name: "[Build] Desktop App (external)"

on:
  workflow_dispatch:
    inputs:
      sha:
        description: the head sha to target the correct check run
        required: false
      ref:
        description: the branch which triggered this workflow
        required: true

concurrency:
  group: ${{ github.workflow }}-${{ github.event.inputs.ref }}
  cancel-in-progress: ${{ github.event.inputs.ref != 'develop' }}

jobs:
  build-desktop-app:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    name: "Build Ledger Live Desktop"
    runs-on: ${{ matrix.os }}
    env:
      NODE_OPTIONS: "--max-old-space-size=7168"
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.sha || github.event.push.head.sha }}
      - name: set git user
        run: |
          git config user.email "team-live@ledger.fr"
          git config user.name "Team Live"
      - uses: actions/setup-python@v4
        with:
          python-version: "3.x"
      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: 3.1.2
          bundler-cache: true
      - uses: pnpm/action-setup@v2
        with:
          version: latest
          dest: ${{ runner.temp }}/setup-pnpm
      - uses: actions/setup-node@v3
        with:
          node-version: 16.x
          cache: pnpm
          cache-dependency-path: "**/pnpm-lock.yaml"
      - name: TurboRepo local caching server
        id: turborepo-cache-server
        uses: ./tools/actions/turborepo-gh-cache
        with:
          server-token: "yolo"
          cleanup-cache-folder: "true"
      - uses: ./tools/actions/composites/build-desktop
        id: build-desktop
        with:
          os: linux
      - name: build the app
        run: pnpm build:lld --api="http://127.0.0.1:${{ steps.turborepo-cache-server.outputs.port }}" --token="yolo" --team="foo"
      - name: upload linux app
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v3
        with:
          name: ${{ steps.build-desktop.outputs.version }}-linux-x86_64.AppImage
          path: ${{ github.workspace }}/apps/ledger-live-desktop/dist/${{ steps.build-desktop.outputs.name }}-${{ steps.build-desktop.outputs.version }}-linux-x86_64.AppImage
      - name: upload macOS app
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v3
        with:
          name: ${{ steps.build-desktop.outputs.version }}-mac.dmg
          path: ${{ github.workspace }}/apps/ledger-live-desktop/dist/${{ steps.build-desktop.outputs.name }}-${{ steps.build-desktop.outputs.version }}-mac.dmg
      - name: upload windows
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v3
        with:
          name: ${{ steps.build-desktop.outputs.version }}-win-x64.exe
          path: ${{ github.workspace }}/apps/ledger-live-desktop/dist/${{ steps.build-desktop.outputs.name }}-${{ steps.build-desktop.outputs.version }}-win-x64.exe
  # report:
  #   needs:
  #     [
  #       build-desktop-app-linux,
  #       build-desktop-app-macos,
  #       build-desktop-app-windows,
  #     ]
  #   runs-on: ubuntu-latest
  #   if: always() && github.event_name == 'workflow_dispatch' && github.event.inputs.check_run_id != '' && github.event.inputs.sha != ''
  #   steps:
  #     - name: generate token
  #       id: generate-token
  #       uses: tibdex/github-app-token@v1
  #       with:
  #         app_id: ${{ secrets.GH_BOT_APP_ID }}
  #         private_key: ${{ secrets.GH_BOT_PRIVATE_KEY }}
  #     - uses: actions/github-script@v6
  #       name: get statuses of runs
  #       id: status
  #       with:
  #         script: |
  #           const fs = require("fs");
  #           const statuses = [
  #             "${{ needs.build-desktop-app-macos.result }}",
  #             "${{ needs.build-desktop-app-linux.result }}",
  #             "${{ needs.build-desktop-app-windows.result }}",
  #           ];
  #           const keys = {
  #             mac: {
  #               symbol: "üçè",
  #               name: "macOS"
  #             },
  #             windows: {
  #               symbol: "ü™ü",
  #               name: "Windows"
  #             },
  #             linux: {
  #               symbol: "üêß",
  #               name: "Linux"
  #             },
  #           };
  #           const report = {
  #             mac: {
  #               pass: ${{ needs.build-desktop-app-macos.result == 'success' }},
  #               status: "${{ needs.build-desktop-app-macos.result }}",
  #             },
  #             linux: {
  #               pass: ${{ needs.build-desktop-app-linux.result == 'success' }},
  #               status: "${{ needs.build-desktop-app-linux.result }}",
  #             },
  #             windows: {
  #               pass: ${{ needs.build-desktop-app-windows.result == 'success' }},
  #               status: "${{ needs.build-desktop-app-windows.result }}",
  #             },
  #           };
  #           const isFailed = statuses.some(e => e === "failure");
  #           const isCancelled = statuses.some(e => e === "cancelled");
  #           let summary = ``
  #           Object.entries(report).map(([os, values]) => {
  #             summary += `### ${keys[os].symbol} ${keys[os].name}
  #           The build for ${keys[os].name} ${values.pass ? 'did' : 'did not'} completely successfully.
  #           The run ended with conclusion => **${values.status}**
  #           `
  #           });
  #           const data = {
  #             isFailed,
  #             isCancelled,
  #             summary,
  #           }
  #           fs.writeFileSync("output.json", JSON.stringify(data), "utf-8");
  #     - uses: actions/upload-artifact@v3
  #       name: upload output
  #       with:
  #         path: ${{ github.workspace }}/output.json
  #         name: output.json
  # - uses: actions/github-script@v6
  #   with:
  #     github-token: ${{ steps.generate-token.outputs.token }}
  #     script: |
  #       const status = ${{ steps.status.outputs.result }};
  #       const title = status.isFailed ? "üî¥ Failed" : status.isCancelled ? "‚ôæ Cancelled" : "üíö Success";
  #       const actions = status.isFailed ? [{
  #         label: "Rerun job",
  #         identifier: "rerun_job",
  #         description: "relaunch failed jobs"
  #       }] : [];
  #       const previous = await github.rest.checks.update({
  #         owner: context.repo.owner,
  #         repo: context.repo.repo,
  #         head_sha: "${{ github.event.inputs.sha }}",
  #         check_run_id: "${{ github.event.inputs.check_run_id }}",
  #       });
  #       await github.rest.checks.update({
  #         owner: context.repo.owner,
  #         repo: context.repo.repo,
  #         name: previous.data.name,
  #         details_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.run_id }}`,
  #         head_sha: "${{ github.event.inputs.sha }}",
  #         check_run_id: "${{ github.event.inputs.check_run_id }}",
  #         completed_at: new Date().toISOString(),
  #         conclusion: status.isFailed ? 'failure' : status.isCancelled ? 'cancelled' : 'success',
  #         output: {
  #           title,
  #           summary: `${status.summary}
  #       ---
  #       [‚öôÔ∏è Summary](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.run_id }})`
  #         },
  #         actions
  #       });

name: "[Test] Desktop App (external)"

on:
  workflow_dispatch:
    inputs:
      sha:
        description: the head sha to target the correct check run
        required: false
      ref:
        description: the branch which triggered this workflow
        required: true

concurrency:
  group: ${{ github.workflow }}-${{ github.event.inputs.ref }}
  cancel-in-progress: ${{ github.event.inputs.ref != 'develop' }}

jobs:
  typecheck:
    name: "Ledger Live Desktop TypeCheck"
    env:
      NODE_OPTIONS: "--max-old-space-size=7168"
      FORCE_COLOR: 3
      CI_OS: ubuntu-latest
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ github.event.inputs.sha || github.event.inputs.ref || github.ref }}
      - uses: ./tools/actions/composites/setup-test-desktop
        id: setup-test-desktop
      - name: TurboRepo local caching server
        id: turborepo-cache-server
        uses: ./tools/actions/turborepo-gh-cache
        with:
          server-token: "yolo"
          cleanup-cache-folder: "true"
      - name: Install dependencies
        run: pnpm i --filter="ledger-live-desktop..." --filter="ledger-live" --frozen-lockfile --unsafe-perm
      - name: Build dependencies
        run: pnpm build:lld:deps --api="http://127.0.0.1:${{ steps.turborepo-cache-server.outputs.port }}" --token="yolo" --team="foo"
      - name: Run code checkers
        run: pnpm desktop test:codecheck

  test-desktop-app:
    name: "Live Desktop Tests"
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    env:
      NODE_OPTIONS: "--max-old-space-size=7168"
      FORCE_COLOR: 3
      CI_OS: "windows-latest"
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
      # DEBUG: "pw:browser*"
      # DEBUG_LOGS: 1
    runs-on: ${{ matrix.os }}
    steps:
      - name: format os name
        id: os
        uses: actions/github-script@v6
        with:
          result-encoding: string
          script: |
            if ("${{ matrix.os }}" === "ubuntu-latest") {
              return "linux"
            } else if ("${{ matrix.os }}" === "macos-latest") {
              return "macos"
            } else if ("${{ matrix.os }}" === "windows-latest") {
              return "windows"
            }
      - uses: actions/checkout@v3
        with:
          ref: ${{ github.event.inputs.sha || github.event.inputs.ref || github.ref }}
      - uses: ./tools/actions/composites/setup-test-desktop
        id: setup-test-desktop
      - name: Install node-gyp globally
        run: |
          pnpm add -g node-gyp
      - name: TurboRepo local caching server
        id: turborepo-cache-server
        uses: ./tools/actions/turborepo-gh-cache
        with:
          server-token: "yolo"
          cleanup-cache-folder: "true"
      - uses: ./tools/actions/composites/test-desktop
        id: test-desktop
        with:
          os: ${{ steps.os.outputs.result }}
          turbo-server-port: ${{ steps.turborepo-cache-server.outputs.port }}
  # report:
  #   needs:
  #     [
  #       typecheck,
  #       test-desktop-app-linux,
  #       test-desktop-app-windows,
  #       test-desktop-app-mac,
  #     ]
  #     # [is-affected, pr-is-fork, test-desktop-app, test-desktop-app-mac-internal]
  #   runs-on: ubuntu-latest
  #   # if: ${{ always() && !cancelled() && needs.is-affected.outputs.is-desktop-affected == 'true' && github.event.pull_request != '' && !fromJSON(needs.pr-is-fork.outputs.pr-is-fork) }}
  #   if: always() && github.event_name == 'workflow_dispatch' && github.event.inputs.check_run_id != '' && github.event.inputs.sha != ''
  #   steps:
  #     - uses: actions/checkout@v3
  #       with:
  #         ref: ${{ github.event.inputs.sha || github.event.inputs.ref || github.ref }}
  #     - name: generate token
  #       id: generate-token
  #       uses: tibdex/github-app-token@v1
  #       with:
  #         app_id: ${{ secrets.GH_BOT_APP_ID }}
  #         private_key: ${{ secrets.GH_BOT_PRIVATE_KEY }}
  #     - name: download images artifacts
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: images
  #     - name: parse images
  #       uses: actions/github-script@v6
  #       with:
  #         script: |
  #           const fs = require("fs");
  #           const files = ["images-linux", "images-windows", "images-macos"];
  #           let result = {};
  #           for (const file of files) {
  #             try {
  #               const raw = JSON.parse(fs.readFileSync("${{github.workspace}}/" + file + ".json"));
  #               const key = file.replace("images-", "").replace("-latest", "").trim()
  #               result[key] = raw;
  #             } catch (err) {
  #               console.log(err);
  #             }
  #           }
  #           fs.writeFileSync("./images.json", JSON.stringify(result, null, 2));
  #     - name: prepare comment with screenshots
  #       id: comment
  #       uses: ./tools/actions/prepare-comment-screenshots
  #       with:
  #         images: images.json
  #         no-actor: true
  #     - uses: actions/github-script@v6
  #       name: prepare status
  #       id: status
  #       with:
  #         script: |
  #           const statuses = [
  #             "${{ needs.typecheck.result }}",
  #             "${{ needs.test-desktop-app-mac.result }}",
  #             "${{ needs.test-desktop-app-linux.result }}",
  #             "${{ needs.test-desktop-app-windows.result }}",
  #           ];
  #           const keys = {
  #             mac: {
  #               symbol: "ðŸ",
  #               name: "macOS"
  #             },
  #             windows: {
  #               symbol: "ðŸªŸ",
  #               name: "Windows"
  #             },
  #             linux: {
  #               symbol: "ðŸ§",
  #               name: "Linux"
  #             },
  #           };
  #           const typecheck = {
  #             pass: ${{ needs.typecheck.result == 'success' }},
  #             status: "${{ needs.typecheck.result }}",
  #           };
  #           const report = {
  #             mac: {
  #               pass: ${{ needs.test-desktop-app-mac.result == 'success' }},
  #               status: "${{ needs.test-desktop-app-mac.result }}",
  #             },
  #             linux: {
  #               pass: ${{ needs.test-desktop-app-linux.result == 'success' }},
  #               status: "${{ needs.test-desktop-app-linux.result }}",
  #             },
  #             windows: {
  #               pass: ${{ needs.test-desktop-app-windows.result == 'success' }},
  #               status: "${{ needs.test-desktop-app-windows.result }}",
  #             },
  #           };
  #           const isFailed = statuses.some(e => e === "failure") || typecheck.status === "failure";
  #           const isCancelled = statuses.some(e => e === "cancelled") || typecheck.status === "cancelled";
  #           let summary = `### TypeCheck
  #           ${typecheck.pass ? "ðŸ’š Everything is fine" : "âŒ Unfortunately type checks did not pass"}
  #           **Type checks** ended with status => ${typecheck.status}
  #           ### Screenshot Tests (Playwright)
  #           `
  #           Object.entries(report).forEach(([os, values]) => {
  #             summary +=`
  #             - ${values.pass
  #                 ? `ðŸ’š Everything went good on ${keys[os].name} Live Desktop Tests`
  #                 : `âŒ Something went wrong on ${keys[os].name} Live Desktop Tests`
  #               }
  #               - final status => **${values.status}**`
  #           });
  #           summary += `
  #           ${{ steps.comment.outputs.body }}
  #           `
  #           return {
  #             isFailed,
  #             isCancelled,
  #             summary,
  #           }
  #     - uses: actions/github-script@v6
  #       name: update checks
  #       with:
  #         github-token: ${{ steps.generate-token.outputs.token }}
  #         script: |
  #           const status = ${{ steps.status.outputs.result }};
  #           const title = status.isFailed ? "ðŸ”´ Failed" : status.isCancelled ? "â™¾ Cancelled" : "ðŸ’š Success";
  #           const actions = status.isFailed ? [{
  #             label: "regen screenshots",
  #             identifier: "regen_screenshots",
  #             description: "Regenerate screenshot for Live Desktop"
  #           }] : [];
  #           const previous = await github.rest.checks.update({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             head_sha: "${{ github.event.inputs.sha }}",
  #             check_run_id: "${{ github.event.inputs.check_run_id }}",
  #           });
  #           await github.rest.checks.update({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             name: previous.data.name,
  #             details_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.run_id }}`,
  #             head_sha: "${{ github.event.inputs.sha }}",
  #             check_run_id: "${{ github.event.inputs.check_run_id }}",
  #             conclusion: status.isFailed ? 'failure' : status.isCancelled ? 'cancelled' : 'success',
  #             completed_at: new Date().toISOString(),
  #             output: {
  #               title,
  #               summary: `${status.summary}
  #           ---
  #           [âš™ï¸ Summary](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.run_id }})`
  #             },
  #             actions
  #           });
  #     # - name: create/update comment
  #     #   uses: actions/github-script@v6
  #     #   with:
  #     #     script: |
  #     #       const body = `${{ env.comment_header }}\n${{ steps.comment.outputs.body }}`;
  #     #       const existingComment = await github.paginate(
  #     #         github.rest.issues.listComments,
  #     #         {
  #     #           owner: context.repo.owner,
  #     #           repo: context.repo.repo,
  #     #           issue_number: context.issue.number,
  #     #         },
  #     #         (response, done) => {
  #     #           const comments = response.data
  #     #           const existingComment = comments
  #     #             .find(comment =>
  #     #               comment.user.login === 'github-actions[bot]' &&
  #     #               comment.body.startsWith(`${{ env.comment_header }}`));
  #     #           if (existingComment) {
  #     #             done()
  #     #             return existingComment;
  #     #           }
  #     #         }
  #     #       ).then(resPerPage => resPerPage.find(res => !!res));
  #     #       if (existingComment) {
  #     #         await github.rest.issues.updateComment({
  #     #           owner: context.repo.owner,
  #     #           repo: context.repo.repo,
  #     #           comment_id: existingComment?.id,
  #     #           body,
  #     #         });
  #     #       } else {
  #     #         await github.rest.issues.createComment({
  #     #           owner: context.repo.owner,
  #     #           repo: context.repo.repo,
  #     #           issue_number: context.issue.number,
  #     #           body,
  #     #         })
  #     #       }

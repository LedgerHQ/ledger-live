/*! For license information please see server.js.LICENSE.txt */
var __webpack_modules__ = {
    "../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/cache.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.saveCache = exports1.restoreCache = exports1.isFeatureAvailable = exports1.ReserveCacheError = exports1.ValidationError = void 0;
        const core = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"));
        const path = __importStar(__webpack_require__("path"));
        const utils = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/cacheUtils.js"));
        const cacheHttpClient = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/cacheHttpClient.js"));
        const tar_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/tar.js");
        class ValidationError extends Error {
            constructor(message){
                super(message);
                this.name = 'ValidationError';
                Object.setPrototypeOf(this, ValidationError.prototype);
            }
        }
        exports1.ValidationError = ValidationError;
        class ReserveCacheError extends Error {
            constructor(message){
                super(message);
                this.name = 'ReserveCacheError';
                Object.setPrototypeOf(this, ReserveCacheError.prototype);
            }
        }
        exports1.ReserveCacheError = ReserveCacheError;
        function checkPaths(paths) {
            if (!paths || 0 === paths.length) throw new ValidationError("Path Validation Error: At least one directory or file path is required");
        }
        function checkKey(key) {
            if (key.length > 512) throw new ValidationError(`Key Validation Error: ${key} cannot be larger than 512 characters.`);
            const regex = /^[^,]*$/;
            if (!regex.test(key)) throw new ValidationError(`Key Validation Error: ${key} cannot contain commas.`);
        }
        function isFeatureAvailable() {
            return !!process.env['ACTIONS_CACHE_URL'];
        }
        exports1.isFeatureAvailable = isFeatureAvailable;
        function restoreCache(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
            return __awaiter(this, void 0, void 0, function*() {
                checkPaths(paths);
                restoreKeys = restoreKeys || [];
                const keys = [
                    primaryKey,
                    ...restoreKeys
                ];
                core.debug('Resolved Keys:');
                core.debug(JSON.stringify(keys));
                if (keys.length > 10) throw new ValidationError("Key Validation Error: Keys are limited to a maximum of 10.");
                for (const key of keys)checkKey(key);
                const compressionMethod = yield utils.getCompressionMethod();
                let archivePath = '';
                try {
                    const cacheEntry = yield cacheHttpClient.getCacheEntry(keys, paths, {
                        compressionMethod,
                        enableCrossOsArchive
                    });
                    if (!(null == cacheEntry ? void 0 : cacheEntry.archiveLocation)) return;
                    if (null == options ? void 0 : options.lookupOnly) {
                        core.info('Lookup only - skipping download');
                        return cacheEntry.cacheKey;
                    }
                    archivePath = path.join((yield utils.createTempDirectory()), utils.getCacheFileName(compressionMethod));
                    core.debug(`Archive Path: ${archivePath}`);
                    yield cacheHttpClient.downloadCache(cacheEntry.archiveLocation, archivePath, options);
                    if (core.isDebug()) yield (0, tar_1.listTar)(archivePath, compressionMethod);
                    const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
                    core.info(`Cache Size: ~${Math.round(archiveFileSize / 1048576)} MB (${archiveFileSize} B)`);
                    yield (0, tar_1.extractTar)(archivePath, compressionMethod);
                    core.info('Cache restored successfully');
                    return cacheEntry.cacheKey;
                } catch (error) {
                    const typedError = error;
                    if (typedError.name === ValidationError.name) throw error;
                    core.warning(`Failed to restore: ${error.message}`);
                } finally{
                    try {
                        yield utils.unlinkFile(archivePath);
                    } catch (error) {
                        core.debug(`Failed to delete archive: ${error}`);
                    }
                }
            });
        }
        exports1.restoreCache = restoreCache;
        function saveCache(paths, key, options, enableCrossOsArchive = false) {
            var _a, _b, _c, _d, _e;
            return __awaiter(this, void 0, void 0, function*() {
                checkPaths(paths);
                checkKey(key);
                const compressionMethod = yield utils.getCompressionMethod();
                let cacheId = -1;
                const cachePaths = yield utils.resolvePaths(paths);
                core.debug('Cache Paths:');
                core.debug(`${JSON.stringify(cachePaths)}`);
                if (0 === cachePaths.length) throw new Error("Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.");
                const archiveFolder = yield utils.createTempDirectory();
                const archivePath = path.join(archiveFolder, utils.getCacheFileName(compressionMethod));
                core.debug(`Archive Path: ${archivePath}`);
                try {
                    yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
                    if (core.isDebug()) yield (0, tar_1.listTar)(archivePath, compressionMethod);
                    const fileSizeLimit = 10737418240;
                    const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
                    core.debug(`File Size: ${archiveFileSize}`);
                    if (archiveFileSize > fileSizeLimit && !utils.isGhes()) throw new Error(`Cache size of ~${Math.round(archiveFileSize / 1048576)} MB (${archiveFileSize} B) is over the 10GB limit, not saving cache.`);
                    core.debug('Reserving Cache');
                    const reserveCacheResponse = yield cacheHttpClient.reserveCache(key, paths, {
                        compressionMethod,
                        enableCrossOsArchive,
                        cacheSize: archiveFileSize
                    });
                    if (null == (_a = null == reserveCacheResponse ? void 0 : reserveCacheResponse.result) ? void 0 : _a.cacheId) cacheId = null == (_b = null == reserveCacheResponse ? void 0 : reserveCacheResponse.result) ? void 0 : _b.cacheId;
                    else if ((null == reserveCacheResponse ? void 0 : reserveCacheResponse.statusCode) === 400) throw new Error(null != (_d = null == (_c = null == reserveCacheResponse ? void 0 : reserveCacheResponse.error) ? void 0 : _c.message) ? _d : `Cache size of ~${Math.round(archiveFileSize / 1048576)} MB (${archiveFileSize} B) is over the data cap limit, not saving cache.`);
                    else throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache. More details: ${null == (_e = null == reserveCacheResponse ? void 0 : reserveCacheResponse.error) ? void 0 : _e.message}`);
                    core.debug(`Saving Cache (ID: ${cacheId})`);
                    yield cacheHttpClient.saveCache(cacheId, archivePath, options);
                } catch (error) {
                    const typedError = error;
                    if (typedError.name === ValidationError.name) throw error;
                    if (typedError.name === ReserveCacheError.name) core.info(`Failed to save: ${typedError.message}`);
                    else core.warning(`Failed to save: ${typedError.message}`);
                } finally{
                    try {
                        yield utils.unlinkFile(archivePath);
                    } catch (error) {
                        core.debug(`Failed to delete archive: ${error}`);
                    }
                }
                return cacheId;
            });
        }
        exports1.saveCache = saveCache;
    },
    "../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/cacheHttpClient.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.saveCache = exports1.reserveCache = exports1.downloadCache = exports1.getCacheEntry = exports1.getCacheVersion = void 0;
        const core = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"));
        const http_client_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/index.js");
        const auth_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/auth.js");
        const crypto = __importStar(__webpack_require__("crypto"));
        const fs = __importStar(__webpack_require__("fs"));
        const url_1 = __webpack_require__("url");
        const utils = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/cacheUtils.js"));
        const downloadUtils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/downloadUtils.js");
        const options_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/options.js");
        const requestUtils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/requestUtils.js");
        const versionSalt = '1.0';
        function getCacheApiUrl(resource) {
            const baseUrl = process.env['ACTIONS_CACHE_URL'] || '';
            if (!baseUrl) throw new Error('Cache Service Url not found, unable to restore cache.');
            const url = `${baseUrl}_apis/artifactcache/${resource}`;
            core.debug(`Resource Url: ${url}`);
            return url;
        }
        function createAcceptHeader(type, apiVersion) {
            return `${type};api-version=${apiVersion}`;
        }
        function getRequestOptions() {
            const requestOptions = {
                headers: {
                    Accept: createAcceptHeader('application/json', '6.0-preview.1')
                }
            };
            return requestOptions;
        }
        function createHttpClient() {
            const token = process.env['ACTIONS_RUNTIME_TOKEN'] || '';
            const bearerCredentialHandler = new auth_1.BearerCredentialHandler(token);
            return new http_client_1.HttpClient('actions/cache', [
                bearerCredentialHandler
            ], getRequestOptions());
        }
        function getCacheVersion(paths, compressionMethod, enableCrossOsArchive = false) {
            const components = paths.slice();
            if (compressionMethod) components.push(compressionMethod);
            if ('win32' === process.platform && !enableCrossOsArchive) components.push('windows-only');
            components.push(versionSalt);
            return crypto.createHash('sha256').update(components.join('|')).digest('hex');
        }
        exports1.getCacheVersion = getCacheVersion;
        function getCacheEntry(keys, paths, options) {
            return __awaiter(this, void 0, void 0, function*() {
                const httpClient = createHttpClient();
                const version = getCacheVersion(paths, null == options ? void 0 : options.compressionMethod, null == options ? void 0 : options.enableCrossOsArchive);
                const resource = `cache?keys=${encodeURIComponent(keys.join(','))}&version=${version}`;
                const response = yield (0, requestUtils_1.retryTypedResponse)('getCacheEntry', ()=>__awaiter(this, void 0, void 0, function*() {
                        return httpClient.getJson(getCacheApiUrl(resource));
                    }));
                if (204 === response.statusCode) {
                    if (core.isDebug()) yield printCachesListForDiagnostics(keys[0], httpClient, version);
                    return null;
                }
                if (!(0, requestUtils_1.isSuccessStatusCode)(response.statusCode)) throw new Error(`Cache service responded with ${response.statusCode}`);
                const cacheResult = response.result;
                const cacheDownloadUrl = null == cacheResult ? void 0 : cacheResult.archiveLocation;
                if (!cacheDownloadUrl) throw new Error('Cache not found.');
                core.setSecret(cacheDownloadUrl);
                core.debug("Cache Result:");
                core.debug(JSON.stringify(cacheResult));
                return cacheResult;
            });
        }
        exports1.getCacheEntry = getCacheEntry;
        function printCachesListForDiagnostics(key, httpClient, version) {
            return __awaiter(this, void 0, void 0, function*() {
                const resource = `caches?key=${encodeURIComponent(key)}`;
                const response = yield (0, requestUtils_1.retryTypedResponse)('listCache', ()=>__awaiter(this, void 0, void 0, function*() {
                        return httpClient.getJson(getCacheApiUrl(resource));
                    }));
                if (200 === response.statusCode) {
                    const cacheListResult = response.result;
                    const totalCount = null == cacheListResult ? void 0 : cacheListResult.totalCount;
                    if (totalCount && totalCount > 0) {
                        core.debug(`No matching cache found for cache key '${key}', version '${version} and scope ${process.env['GITHUB_REF']}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key \nOther caches with similar key:`);
                        for (const cacheEntry of (null == cacheListResult ? void 0 : cacheListResult.artifactCaches) || [])core.debug(`Cache Key: ${null == cacheEntry ? void 0 : cacheEntry.cacheKey}, Cache Version: ${null == cacheEntry ? void 0 : cacheEntry.cacheVersion}, Cache Scope: ${null == cacheEntry ? void 0 : cacheEntry.scope}, Cache Created: ${null == cacheEntry ? void 0 : cacheEntry.creationTime}`);
                    }
                }
            });
        }
        function downloadCache(archiveLocation, archivePath, options) {
            return __awaiter(this, void 0, void 0, function*() {
                const archiveUrl = new url_1.URL(archiveLocation);
                const downloadOptions = (0, options_1.getDownloadOptions)(options);
                if (archiveUrl.hostname.endsWith('.blob.core.windows.net')) if (downloadOptions.useAzureSdk) yield (0, downloadUtils_1.downloadCacheStorageSDK)(archiveLocation, archivePath, downloadOptions);
                else if (downloadOptions.concurrentBlobDownloads) yield (0, downloadUtils_1.downloadCacheHttpClientConcurrent)(archiveLocation, archivePath, downloadOptions);
                else yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
                else yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
            });
        }
        exports1.downloadCache = downloadCache;
        function reserveCache(key, paths, options) {
            return __awaiter(this, void 0, void 0, function*() {
                const httpClient = createHttpClient();
                const version = getCacheVersion(paths, null == options ? void 0 : options.compressionMethod, null == options ? void 0 : options.enableCrossOsArchive);
                const reserveCacheRequest = {
                    key,
                    version,
                    cacheSize: null == options ? void 0 : options.cacheSize
                };
                const response = yield (0, requestUtils_1.retryTypedResponse)('reserveCache', ()=>__awaiter(this, void 0, void 0, function*() {
                        return httpClient.postJson(getCacheApiUrl('caches'), reserveCacheRequest);
                    }));
                return response;
            });
        }
        exports1.reserveCache = reserveCache;
        function getContentRange(start, end) {
            return `bytes ${start}-${end}/*`;
        }
        function uploadChunk(httpClient, resourceUrl, openStream, start, end) {
            return __awaiter(this, void 0, void 0, function*() {
                core.debug(`Uploading chunk of size ${end - start + 1} bytes at offset ${start} with content range: ${getContentRange(start, end)}`);
                const additionalHeaders = {
                    'Content-Type': 'application/octet-stream',
                    'Content-Range': getContentRange(start, end)
                };
                const uploadChunkResponse = yield (0, requestUtils_1.retryHttpClientResponse)(`uploadChunk (start: ${start}, end: ${end})`, ()=>__awaiter(this, void 0, void 0, function*() {
                        return httpClient.sendStream('PATCH', resourceUrl, openStream(), additionalHeaders);
                    }));
                if (!(0, requestUtils_1.isSuccessStatusCode)(uploadChunkResponse.message.statusCode)) throw new Error(`Cache service responded with ${uploadChunkResponse.message.statusCode} during upload chunk.`);
            });
        }
        function uploadFile(httpClient, cacheId, archivePath, options) {
            return __awaiter(this, void 0, void 0, function*() {
                const fileSize = utils.getArchiveFileSizeInBytes(archivePath);
                const resourceUrl = getCacheApiUrl(`caches/${cacheId.toString()}`);
                const fd = fs.openSync(archivePath, 'r');
                const uploadOptions = (0, options_1.getUploadOptions)(options);
                const concurrency = utils.assertDefined('uploadConcurrency', uploadOptions.uploadConcurrency);
                const maxChunkSize = utils.assertDefined('uploadChunkSize', uploadOptions.uploadChunkSize);
                const parallelUploads = [
                    ...new Array(concurrency).keys()
                ];
                core.debug('Awaiting all uploads');
                let offset = 0;
                try {
                    yield Promise.all(parallelUploads.map(()=>__awaiter(this, void 0, void 0, function*() {
                            while(offset < fileSize){
                                const chunkSize = Math.min(fileSize - offset, maxChunkSize);
                                const start = offset;
                                const end = offset + chunkSize - 1;
                                offset += maxChunkSize;
                                yield uploadChunk(httpClient, resourceUrl, ()=>fs.createReadStream(archivePath, {
                                        fd,
                                        start,
                                        end,
                                        autoClose: false
                                    }).on('error', (error)=>{
                                        throw new Error(`Cache upload failed because file read failed with ${error.message}`);
                                    }), start, end);
                            }
                        })));
                } finally{
                    fs.closeSync(fd);
                }
            });
        }
        function commitCache(httpClient, cacheId, filesize) {
            return __awaiter(this, void 0, void 0, function*() {
                const commitCacheRequest = {
                    size: filesize
                };
                return yield (0, requestUtils_1.retryTypedResponse)('commitCache', ()=>__awaiter(this, void 0, void 0, function*() {
                        return httpClient.postJson(getCacheApiUrl(`caches/${cacheId.toString()}`), commitCacheRequest);
                    }));
            });
        }
        function saveCache(cacheId, archivePath, options) {
            return __awaiter(this, void 0, void 0, function*() {
                const httpClient = createHttpClient();
                core.debug('Upload cache');
                yield uploadFile(httpClient, cacheId, archivePath, options);
                core.debug('Commiting cache');
                const cacheSize = utils.getArchiveFileSizeInBytes(archivePath);
                core.info(`Cache Size: ~${Math.round(cacheSize / 1048576)} MB (${cacheSize} B)`);
                const commitCacheResponse = yield commitCache(httpClient, cacheId, cacheSize);
                if (!(0, requestUtils_1.isSuccessStatusCode)(commitCacheResponse.statusCode)) throw new Error(`Cache service responded with ${commitCacheResponse.statusCode} during commit cache.`);
                core.info('Cache saved successfully');
            });
        }
        exports1.saveCache = saveCache;
    },
    "../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/cacheUtils.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        var __asyncValues = this && this.__asyncValues || function(o) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var m = o[Symbol.asyncIterator], i;
            return m ? m.call(o) : (o = "function" == typeof __values ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i);
            function verb(n) {
                i[n] = o[n] && function(v) {
                    return new Promise(function(resolve, reject) {
                        v = o[n](v), settle(resolve, reject, v.done, v.value);
                    });
                };
            }
            function settle(resolve, reject, d, v) {
                Promise.resolve(v).then(function(v) {
                    resolve({
                        value: v,
                        done: d
                    });
                }, reject);
            }
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.isGhes = exports1.assertDefined = exports1.getGnuTarPathOnWindows = exports1.getCacheFileName = exports1.getCompressionMethod = exports1.unlinkFile = exports1.resolvePaths = exports1.getArchiveFileSizeInBytes = exports1.createTempDirectory = void 0;
        const core = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"));
        const exec = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js"));
        const glob = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/glob.js"));
        const io = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js"));
        const fs = __importStar(__webpack_require__("fs"));
        const path = __importStar(__webpack_require__("path"));
        const semver = __importStar(__webpack_require__("../../../node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"));
        const util = __importStar(__webpack_require__("util"));
        const uuid_1 = __webpack_require__("../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/index.js");
        const constants_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/constants.js");
        function createTempDirectory() {
            return __awaiter(this, void 0, void 0, function*() {
                const IS_WINDOWS = 'win32' === process.platform;
                let tempDirectory = process.env['RUNNER_TEMP'] || '';
                if (!tempDirectory) {
                    let baseLocation;
                    baseLocation = IS_WINDOWS ? process.env['USERPROFILE'] || 'C:\\' : 'darwin' === process.platform ? '/Users' : '/home';
                    tempDirectory = path.join(baseLocation, 'actions', 'temp');
                }
                const dest = path.join(tempDirectory, (0, uuid_1.v4)());
                yield io.mkdirP(dest);
                return dest;
            });
        }
        exports1.createTempDirectory = createTempDirectory;
        function getArchiveFileSizeInBytes(filePath) {
            return fs.statSync(filePath).size;
        }
        exports1.getArchiveFileSizeInBytes = getArchiveFileSizeInBytes;
        function resolvePaths(patterns) {
            var _a, e_1, _b, _c;
            var _d;
            return __awaiter(this, void 0, void 0, function*() {
                const paths = [];
                const workspace = null != (_d = process.env['GITHUB_WORKSPACE']) ? _d : process.cwd();
                const globber = yield glob.create(patterns.join('\n'), {
                    implicitDescendants: false
                });
                try {
                    for(var _e = true, _f = __asyncValues(globber.globGenerator()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){
                        _c = _g.value;
                        _e = false;
                        const file = _c;
                        const relativeFile = path.relative(workspace, file).replace(new RegExp(`\\${path.sep}`, 'g'), '/');
                        core.debug(`Matched: ${relativeFile}`);
                        if ('' === relativeFile) paths.push('.');
                        else paths.push(`${relativeFile}`);
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
                return paths;
            });
        }
        exports1.resolvePaths = resolvePaths;
        function unlinkFile(filePath) {
            return __awaiter(this, void 0, void 0, function*() {
                return util.promisify(fs.unlink)(filePath);
            });
        }
        exports1.unlinkFile = unlinkFile;
        function getVersion(app, additionalArgs = []) {
            return __awaiter(this, void 0, void 0, function*() {
                let versionOutput = '';
                additionalArgs.push('--version');
                core.debug(`Checking ${app} ${additionalArgs.join(' ')}`);
                try {
                    yield exec.exec(`${app}`, additionalArgs, {
                        ignoreReturnCode: true,
                        silent: true,
                        listeners: {
                            stdout: (data)=>versionOutput += data.toString(),
                            stderr: (data)=>versionOutput += data.toString()
                        }
                    });
                } catch (err) {
                    core.debug(err.message);
                }
                versionOutput = versionOutput.trim();
                core.debug(versionOutput);
                return versionOutput;
            });
        }
        function getCompressionMethod() {
            return __awaiter(this, void 0, void 0, function*() {
                const versionOutput = yield getVersion('zstd', [
                    '--quiet'
                ]);
                const version = semver.clean(versionOutput);
                core.debug(`zstd version: ${version}`);
                if ('' === versionOutput) return constants_1.CompressionMethod.Gzip;
                return constants_1.CompressionMethod.ZstdWithoutLong;
            });
        }
        exports1.getCompressionMethod = getCompressionMethod;
        function getCacheFileName(compressionMethod) {
            return compressionMethod === constants_1.CompressionMethod.Gzip ? constants_1.CacheFilename.Gzip : constants_1.CacheFilename.Zstd;
        }
        exports1.getCacheFileName = getCacheFileName;
        function getGnuTarPathOnWindows() {
            return __awaiter(this, void 0, void 0, function*() {
                if (fs.existsSync(constants_1.GnuTarPathOnWindows)) return constants_1.GnuTarPathOnWindows;
                const versionOutput = yield getVersion('tar');
                return versionOutput.toLowerCase().includes('gnu tar') ? io.which('tar') : '';
            });
        }
        exports1.getGnuTarPathOnWindows = getGnuTarPathOnWindows;
        function assertDefined(name, value) {
            if (void 0 === value) throw Error(`Expected ${name} but value was undefiend`);
            return value;
        }
        exports1.assertDefined = assertDefined;
        function isGhes() {
            const ghUrl = new URL(process.env['GITHUB_SERVER_URL'] || 'https://github.com');
            const hostname = ghUrl.hostname.trimEnd().toUpperCase();
            const isGitHubHost = 'GITHUB.COM' === hostname;
            const isGheHost = hostname.endsWith('.GHE.COM') || hostname.endsWith('.GHE.LOCALHOST');
            return !isGitHubHost && !isGheHost;
        }
        exports1.isGhes = isGhes;
    },
    "../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/constants.js" (__unused_rspack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.ManifestFilename = exports1.TarFilename = exports1.SystemTarPathOnWindows = exports1.GnuTarPathOnWindows = exports1.SocketTimeout = exports1.DefaultRetryDelay = exports1.DefaultRetryAttempts = exports1.ArchiveToolType = exports1.CompressionMethod = exports1.CacheFilename = void 0;
        var CacheFilename;
        (function(CacheFilename) {
            CacheFilename["Gzip"] = "cache.tgz";
            CacheFilename["Zstd"] = "cache.tzst";
        })(CacheFilename || (exports1.CacheFilename = CacheFilename = {}));
        var CompressionMethod;
        (function(CompressionMethod) {
            CompressionMethod["Gzip"] = "gzip";
            CompressionMethod["ZstdWithoutLong"] = "zstd-without-long";
            CompressionMethod["Zstd"] = "zstd";
        })(CompressionMethod || (exports1.CompressionMethod = CompressionMethod = {}));
        var ArchiveToolType;
        (function(ArchiveToolType) {
            ArchiveToolType["GNU"] = "gnu";
            ArchiveToolType["BSD"] = "bsd";
        })(ArchiveToolType || (exports1.ArchiveToolType = ArchiveToolType = {}));
        exports1.DefaultRetryAttempts = 2;
        exports1.DefaultRetryDelay = 5000;
        exports1.SocketTimeout = 5000;
        exports1.GnuTarPathOnWindows = `${process.env['PROGRAMFILES']}\\Git\\usr\\bin\\tar.exe`;
        exports1.SystemTarPathOnWindows = `${process.env['SYSTEMDRIVE']}\\Windows\\System32\\tar.exe`;
        exports1.TarFilename = 'cache.tar';
        exports1.ManifestFilename = 'manifest.txt';
    },
    "../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/downloadUtils.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.downloadCacheStorageSDK = exports1.downloadCacheHttpClientConcurrent = exports1.downloadCacheHttpClient = exports1.DownloadProgress = void 0;
        const core = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"));
        const http_client_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/index.js");
        const storage_blob_1 = __webpack_require__("../../../node_modules/.pnpm/@azure+storage-blob@12.17.0/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/index.js");
        const buffer = __importStar(__webpack_require__("buffer"));
        const fs = __importStar(__webpack_require__("fs"));
        const stream = __importStar(__webpack_require__("stream"));
        const util = __importStar(__webpack_require__("util"));
        const utils = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/cacheUtils.js"));
        const constants_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/constants.js");
        const requestUtils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/requestUtils.js");
        const abort_controller_1 = __webpack_require__("../../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/index.js");
        function pipeResponseToStream(response, output) {
            return __awaiter(this, void 0, void 0, function*() {
                const pipeline = util.promisify(stream.pipeline);
                yield pipeline(response.message, output);
            });
        }
        class DownloadProgress {
            constructor(contentLength){
                this.contentLength = contentLength;
                this.segmentIndex = 0;
                this.segmentSize = 0;
                this.segmentOffset = 0;
                this.receivedBytes = 0;
                this.displayedComplete = false;
                this.startTime = Date.now();
            }
            nextSegment(segmentSize) {
                this.segmentOffset = this.segmentOffset + this.segmentSize;
                this.segmentIndex = this.segmentIndex + 1;
                this.segmentSize = segmentSize;
                this.receivedBytes = 0;
                core.debug(`Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`);
            }
            setReceivedBytes(receivedBytes) {
                this.receivedBytes = receivedBytes;
            }
            getTransferredBytes() {
                return this.segmentOffset + this.receivedBytes;
            }
            isDone() {
                return this.getTransferredBytes() === this.contentLength;
            }
            display() {
                if (this.displayedComplete) return;
                const transferredBytes = this.segmentOffset + this.receivedBytes;
                const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
                const elapsedTime = Date.now() - this.startTime;
                const downloadSpeed = (transferredBytes / 1048576 / (elapsedTime / 1000)).toFixed(1);
                core.info(`Received ${transferredBytes} of ${this.contentLength} (${percentage}%), ${downloadSpeed} MBs/sec`);
                if (this.isDone()) this.displayedComplete = true;
            }
            onProgress() {
                return (progress)=>{
                    this.setReceivedBytes(progress.loadedBytes);
                };
            }
            startDisplayTimer(delayInMs = 1000) {
                const displayCallback = ()=>{
                    this.display();
                    if (!this.isDone()) this.timeoutHandle = setTimeout(displayCallback, delayInMs);
                };
                this.timeoutHandle = setTimeout(displayCallback, delayInMs);
            }
            stopDisplayTimer() {
                if (this.timeoutHandle) {
                    clearTimeout(this.timeoutHandle);
                    this.timeoutHandle = void 0;
                }
                this.display();
            }
        }
        exports1.DownloadProgress = DownloadProgress;
        function downloadCacheHttpClient(archiveLocation, archivePath) {
            return __awaiter(this, void 0, void 0, function*() {
                const writeStream = fs.createWriteStream(archivePath);
                const httpClient = new http_client_1.HttpClient('actions/cache');
                const downloadResponse = yield (0, requestUtils_1.retryHttpClientResponse)('downloadCache', ()=>__awaiter(this, void 0, void 0, function*() {
                        return httpClient.get(archiveLocation);
                    }));
                downloadResponse.message.socket.setTimeout(constants_1.SocketTimeout, ()=>{
                    downloadResponse.message.destroy();
                    core.debug(`Aborting download, socket timed out after ${constants_1.SocketTimeout} ms`);
                });
                yield pipeResponseToStream(downloadResponse, writeStream);
                const contentLengthHeader = downloadResponse.message.headers['content-length'];
                if (contentLengthHeader) {
                    const expectedLength = parseInt(contentLengthHeader);
                    const actualLength = utils.getArchiveFileSizeInBytes(archivePath);
                    if (actualLength !== expectedLength) throw new Error(`Incomplete download. Expected file size: ${expectedLength}, actual file size: ${actualLength}`);
                } else core.debug('Unable to validate download, no Content-Length header');
            });
        }
        exports1.downloadCacheHttpClient = downloadCacheHttpClient;
        function downloadCacheHttpClientConcurrent(archiveLocation, archivePath, options) {
            var _a;
            return __awaiter(this, void 0, void 0, function*() {
                const archiveDescriptor = yield fs.promises.open(archivePath, 'w');
                const httpClient = new http_client_1.HttpClient('actions/cache', void 0, {
                    socketTimeout: options.timeoutInMs,
                    keepAlive: true
                });
                try {
                    const res = yield (0, requestUtils_1.retryHttpClientResponse)('downloadCacheMetadata', ()=>__awaiter(this, void 0, void 0, function*() {
                            return yield httpClient.request('HEAD', archiveLocation, null, {});
                        }));
                    const lengthHeader = res.message.headers['content-length'];
                    if (null == lengthHeader) throw new Error('Content-Length not found on blob response');
                    const length = parseInt(lengthHeader);
                    if (Number.isNaN(length)) throw new Error(`Could not interpret Content-Length: ${length}`);
                    const downloads = [];
                    const blockSize = 4194304;
                    for(let offset = 0; offset < length; offset += blockSize){
                        const count = Math.min(blockSize, length - offset);
                        downloads.push({
                            offset,
                            promiseGetter: ()=>__awaiter(this, void 0, void 0, function*() {
                                    return yield downloadSegmentRetry(httpClient, archiveLocation, offset, count);
                                })
                        });
                    }
                    downloads.reverse();
                    let actives = 0;
                    let bytesDownloaded = 0;
                    const progress = new DownloadProgress(length);
                    progress.startDisplayTimer();
                    const progressFn = progress.onProgress();
                    const activeDownloads = [];
                    let nextDownload;
                    const waitAndWrite = ()=>__awaiter(this, void 0, void 0, function*() {
                            const segment = yield Promise.race(Object.values(activeDownloads));
                            yield archiveDescriptor.write(segment.buffer, 0, segment.count, segment.offset);
                            actives--;
                            delete activeDownloads[segment.offset];
                            bytesDownloaded += segment.count;
                            progressFn({
                                loadedBytes: bytesDownloaded
                            });
                        });
                    while(nextDownload = downloads.pop()){
                        activeDownloads[nextDownload.offset] = nextDownload.promiseGetter();
                        actives++;
                        if (actives >= (null != (_a = options.downloadConcurrency) ? _a : 10)) yield waitAndWrite();
                    }
                    while(actives > 0)yield waitAndWrite();
                } finally{
                    httpClient.dispose();
                    yield archiveDescriptor.close();
                }
            });
        }
        exports1.downloadCacheHttpClientConcurrent = downloadCacheHttpClientConcurrent;
        function downloadSegmentRetry(httpClient, archiveLocation, offset, count) {
            return __awaiter(this, void 0, void 0, function*() {
                const retries = 5;
                let failures = 0;
                while(true)try {
                    const timeout = 30000;
                    const result = yield promiseWithTimeout(timeout, downloadSegment(httpClient, archiveLocation, offset, count));
                    if ('string' == typeof result) throw new Error('downloadSegmentRetry failed due to timeout');
                    return result;
                } catch (err) {
                    if (failures >= retries) throw err;
                    failures++;
                }
            });
        }
        function downloadSegment(httpClient, archiveLocation, offset, count) {
            return __awaiter(this, void 0, void 0, function*() {
                const partRes = yield (0, requestUtils_1.retryHttpClientResponse)('downloadCachePart', ()=>__awaiter(this, void 0, void 0, function*() {
                        return yield httpClient.get(archiveLocation, {
                            Range: `bytes=${offset}-${offset + count - 1}`
                        });
                    }));
                if (!partRes.readBodyBuffer) throw new Error('Expected HttpClientResponse to implement readBodyBuffer');
                return {
                    offset,
                    count,
                    buffer: yield partRes.readBodyBuffer()
                };
            });
        }
        function downloadCacheStorageSDK(archiveLocation, archivePath, options) {
            var _a;
            return __awaiter(this, void 0, void 0, function*() {
                const client = new storage_blob_1.BlockBlobClient(archiveLocation, void 0, {
                    retryOptions: {
                        tryTimeoutInMs: options.timeoutInMs
                    }
                });
                const properties = yield client.getProperties();
                const contentLength = null != (_a = properties.contentLength) ? _a : -1;
                if (contentLength < 0) {
                    core.debug('Unable to determine content length, downloading file with http-client...');
                    yield downloadCacheHttpClient(archiveLocation, archivePath);
                } else {
                    const maxSegmentSize = Math.min(134217728, buffer.constants.MAX_LENGTH);
                    const downloadProgress = new DownloadProgress(contentLength);
                    const fd = fs.openSync(archivePath, 'w');
                    try {
                        downloadProgress.startDisplayTimer();
                        const controller = new abort_controller_1.AbortController();
                        const abortSignal = controller.signal;
                        while(!downloadProgress.isDone()){
                            const segmentStart = downloadProgress.segmentOffset + downloadProgress.segmentSize;
                            const segmentSize = Math.min(maxSegmentSize, contentLength - segmentStart);
                            downloadProgress.nextSegment(segmentSize);
                            const result = yield promiseWithTimeout(options.segmentTimeoutInMs || 3600000, client.downloadToBuffer(segmentStart, segmentSize, {
                                abortSignal,
                                concurrency: options.downloadConcurrency,
                                onProgress: downloadProgress.onProgress()
                            }));
                            if ('timeout' === result) {
                                controller.abort();
                                throw new Error('Aborting cache download as the download time exceeded the timeout.');
                            }
                            if (Buffer.isBuffer(result)) fs.writeFileSync(fd, result);
                        }
                    } finally{
                        downloadProgress.stopDisplayTimer();
                        fs.closeSync(fd);
                    }
                }
            });
        }
        exports1.downloadCacheStorageSDK = downloadCacheStorageSDK;
        const promiseWithTimeout = (timeoutMs, promise)=>__awaiter(void 0, void 0, void 0, function*() {
                let timeoutHandle;
                const timeoutPromise = new Promise((resolve)=>{
                    timeoutHandle = setTimeout(()=>resolve('timeout'), timeoutMs);
                });
                return Promise.race([
                    promise,
                    timeoutPromise
                ]).then((result)=>{
                    clearTimeout(timeoutHandle);
                    return result;
                });
            });
    },
    "../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/requestUtils.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.retryHttpClientResponse = exports1.retryTypedResponse = exports1.retry = exports1.isRetryableStatusCode = exports1.isServerErrorStatusCode = exports1.isSuccessStatusCode = void 0;
        const core = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"));
        const http_client_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/index.js");
        const constants_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/constants.js");
        function isSuccessStatusCode(statusCode) {
            if (!statusCode) return false;
            return statusCode >= 200 && statusCode < 300;
        }
        exports1.isSuccessStatusCode = isSuccessStatusCode;
        function isServerErrorStatusCode(statusCode) {
            if (!statusCode) return true;
            return statusCode >= 500;
        }
        exports1.isServerErrorStatusCode = isServerErrorStatusCode;
        function isRetryableStatusCode(statusCode) {
            if (!statusCode) return false;
            const retryableStatusCodes = [
                http_client_1.HttpCodes.BadGateway,
                http_client_1.HttpCodes.ServiceUnavailable,
                http_client_1.HttpCodes.GatewayTimeout
            ];
            return retryableStatusCodes.includes(statusCode);
        }
        exports1.isRetryableStatusCode = isRetryableStatusCode;
        function sleep(milliseconds) {
            return __awaiter(this, void 0, void 0, function*() {
                return new Promise((resolve)=>setTimeout(resolve, milliseconds));
            });
        }
        function retry(name, method, getStatusCode, maxAttempts = constants_1.DefaultRetryAttempts, delay = constants_1.DefaultRetryDelay, onError) {
            return __awaiter(this, void 0, void 0, function*() {
                let errorMessage = '';
                let attempt = 1;
                while(attempt <= maxAttempts){
                    let response;
                    let statusCode;
                    let isRetryable = false;
                    try {
                        response = yield method();
                    } catch (error) {
                        if (onError) response = onError(error);
                        isRetryable = true;
                        errorMessage = error.message;
                    }
                    if (response) {
                        statusCode = getStatusCode(response);
                        if (!isServerErrorStatusCode(statusCode)) return response;
                    }
                    if (statusCode) {
                        isRetryable = isRetryableStatusCode(statusCode);
                        errorMessage = `Cache service responded with ${statusCode}`;
                    }
                    core.debug(`${name} - Attempt ${attempt} of ${maxAttempts} failed with error: ${errorMessage}`);
                    if (!isRetryable) {
                        core.debug(`${name} - Error is not retryable`);
                        break;
                    }
                    yield sleep(delay);
                    attempt++;
                }
                throw Error(`${name} failed: ${errorMessage}`);
            });
        }
        exports1.retry = retry;
        function retryTypedResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay = constants_1.DefaultRetryDelay) {
            return __awaiter(this, void 0, void 0, function*() {
                return yield retry(name, method, (response)=>response.statusCode, maxAttempts, delay, (error)=>{
                    if (error instanceof http_client_1.HttpClientError) return {
                        statusCode: error.statusCode,
                        result: null,
                        headers: {},
                        error
                    };
                });
            });
        }
        exports1.retryTypedResponse = retryTypedResponse;
        function retryHttpClientResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay = constants_1.DefaultRetryDelay) {
            return __awaiter(this, void 0, void 0, function*() {
                return yield retry(name, method, (response)=>response.message.statusCode, maxAttempts, delay);
            });
        }
        exports1.retryHttpClientResponse = retryHttpClientResponse;
    },
    "../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/tar.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.createTar = exports1.extractTar = exports1.listTar = void 0;
        const exec_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js");
        const io = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js"));
        const fs_1 = __webpack_require__("fs");
        const path = __importStar(__webpack_require__("path"));
        const utils = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/cacheUtils.js"));
        const constants_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/internal/constants.js");
        const IS_WINDOWS = 'win32' === process.platform;
        function getTarPath() {
            return __awaiter(this, void 0, void 0, function*() {
                switch(process.platform){
                    case 'win32':
                        {
                            const gnuTar = yield utils.getGnuTarPathOnWindows();
                            const systemTar = constants_1.SystemTarPathOnWindows;
                            if (gnuTar) return {
                                path: gnuTar,
                                type: constants_1.ArchiveToolType.GNU
                            };
                            if ((0, fs_1.existsSync)(systemTar)) return {
                                path: systemTar,
                                type: constants_1.ArchiveToolType.BSD
                            };
                            break;
                        }
                    case 'darwin':
                        {
                            const gnuTar = yield io.which('gtar', false);
                            if (gnuTar) return {
                                path: gnuTar,
                                type: constants_1.ArchiveToolType.GNU
                            };
                            return {
                                path: yield io.which('tar', true),
                                type: constants_1.ArchiveToolType.BSD
                            };
                        }
                    default:
                        break;
                }
                return {
                    path: yield io.which('tar', true),
                    type: constants_1.ArchiveToolType.GNU
                };
            });
        }
        function getTarArgs(tarPath, compressionMethod, type, archivePath = '') {
            return __awaiter(this, void 0, void 0, function*() {
                const args = [
                    `"${tarPath.path}"`
                ];
                const cacheFileName = utils.getCacheFileName(compressionMethod);
                const tarFile = 'cache.tar';
                const workingDirectory = getWorkingDirectory();
                const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
                switch(type){
                    case 'create':
                        args.push('--posix', '-cf', BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '--exclude', BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '-P', '-C', workingDirectory.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '--files-from', constants_1.ManifestFilename);
                        break;
                    case 'extract':
                        args.push('-xf', BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '-P', '-C', workingDirectory.replace(new RegExp(`\\${path.sep}`, 'g'), '/'));
                        break;
                    case 'list':
                        args.push('-tf', BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path.sep}`, 'g'), '/'), '-P');
                        break;
                }
                if (tarPath.type === constants_1.ArchiveToolType.GNU) switch(process.platform){
                    case 'win32':
                        args.push('--force-local');
                        break;
                    case 'darwin':
                        args.push('--delay-directory-restore');
                        break;
                }
                return args;
            });
        }
        function getCommands(compressionMethod, type, archivePath = '') {
            return __awaiter(this, void 0, void 0, function*() {
                let args;
                const tarPath = yield getTarPath();
                const tarArgs = yield getTarArgs(tarPath, compressionMethod, type, archivePath);
                const compressionArgs = 'create' !== type ? yield getDecompressionProgram(tarPath, compressionMethod, archivePath) : yield getCompressionProgram(tarPath, compressionMethod);
                const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
                args = BSD_TAR_ZSTD && 'create' !== type ? [
                    [
                        ...compressionArgs
                    ].join(' '),
                    [
                        ...tarArgs
                    ].join(' ')
                ] : [
                    [
                        ...tarArgs
                    ].join(' '),
                    [
                        ...compressionArgs
                    ].join(' ')
                ];
                if (BSD_TAR_ZSTD) return args;
                return [
                    args.join(' ')
                ];
            });
        }
        function getWorkingDirectory() {
            var _a;
            return null != (_a = process.env['GITHUB_WORKSPACE']) ? _a : process.cwd();
        }
        function getDecompressionProgram(tarPath, compressionMethod, archivePath) {
            return __awaiter(this, void 0, void 0, function*() {
                const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
                switch(compressionMethod){
                    case constants_1.CompressionMethod.Zstd:
                        return BSD_TAR_ZSTD ? [
                            'zstd -d --long=30 --force -o',
                            constants_1.TarFilename,
                            archivePath.replace(new RegExp(`\\${path.sep}`, 'g'), '/')
                        ] : [
                            '--use-compress-program',
                            IS_WINDOWS ? '"zstd -d --long=30"' : 'unzstd --long=30'
                        ];
                    case constants_1.CompressionMethod.ZstdWithoutLong:
                        return BSD_TAR_ZSTD ? [
                            'zstd -d --force -o',
                            constants_1.TarFilename,
                            archivePath.replace(new RegExp(`\\${path.sep}`, 'g'), '/')
                        ] : [
                            '--use-compress-program',
                            IS_WINDOWS ? '"zstd -d"' : 'unzstd'
                        ];
                    default:
                        return [
                            '-z'
                        ];
                }
            });
        }
        function getCompressionProgram(tarPath, compressionMethod) {
            return __awaiter(this, void 0, void 0, function*() {
                const cacheFileName = utils.getCacheFileName(compressionMethod);
                const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
                switch(compressionMethod){
                    case constants_1.CompressionMethod.Zstd:
                        return BSD_TAR_ZSTD ? [
                            'zstd -T0 --long=30 --force -o',
                            cacheFileName.replace(new RegExp(`\\${path.sep}`, 'g'), '/'),
                            constants_1.TarFilename
                        ] : [
                            '--use-compress-program',
                            IS_WINDOWS ? '"zstd -T0 --long=30"' : 'zstdmt --long=30'
                        ];
                    case constants_1.CompressionMethod.ZstdWithoutLong:
                        return BSD_TAR_ZSTD ? [
                            'zstd -T0 --force -o',
                            cacheFileName.replace(new RegExp(`\\${path.sep}`, 'g'), '/'),
                            constants_1.TarFilename
                        ] : [
                            '--use-compress-program',
                            IS_WINDOWS ? '"zstd -T0"' : 'zstdmt'
                        ];
                    default:
                        return [
                            '-z'
                        ];
                }
            });
        }
        function execCommands(commands, cwd) {
            return __awaiter(this, void 0, void 0, function*() {
                for (const command of commands)try {
                    yield (0, exec_1.exec)(command, void 0, {
                        cwd,
                        env: Object.assign(Object.assign({}, process.env), {
                            MSYS: 'winsymlinks:nativestrict'
                        })
                    });
                } catch (error) {
                    throw new Error(`${command.split(' ')[0]} failed with error: ${null == error ? void 0 : error.message}`);
                }
            });
        }
        function listTar(archivePath, compressionMethod) {
            return __awaiter(this, void 0, void 0, function*() {
                const commands = yield getCommands(compressionMethod, 'list', archivePath);
                yield execCommands(commands);
            });
        }
        exports1.listTar = listTar;
        function extractTar(archivePath, compressionMethod) {
            return __awaiter(this, void 0, void 0, function*() {
                const workingDirectory = getWorkingDirectory();
                yield io.mkdirP(workingDirectory);
                const commands = yield getCommands(compressionMethod, 'extract', archivePath);
                yield execCommands(commands);
            });
        }
        exports1.extractTar = extractTar;
        function createTar(archiveFolder, sourceDirectories, compressionMethod) {
            return __awaiter(this, void 0, void 0, function*() {
                (0, fs_1.writeFileSync)(path.join(archiveFolder, constants_1.ManifestFilename), sourceDirectories.join('\n'));
                const commands = yield getCommands(compressionMethod, 'create');
                yield execCommands(commands, archiveFolder);
            });
        }
        exports1.createTar = createTar;
    },
    "../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/options.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.getDownloadOptions = exports1.getUploadOptions = void 0;
        const core = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"));
        function getUploadOptions(copy) {
            const result = {
                uploadConcurrency: 4,
                uploadChunkSize: 33554432
            };
            if (copy) {
                if ('number' == typeof copy.uploadConcurrency) result.uploadConcurrency = copy.uploadConcurrency;
                if ('number' == typeof copy.uploadChunkSize) result.uploadChunkSize = copy.uploadChunkSize;
            }
            core.debug(`Upload concurrency: ${result.uploadConcurrency}`);
            core.debug(`Upload chunk size: ${result.uploadChunkSize}`);
            return result;
        }
        exports1.getUploadOptions = getUploadOptions;
        function getDownloadOptions(copy) {
            const result = {
                useAzureSdk: false,
                concurrentBlobDownloads: true,
                downloadConcurrency: 8,
                timeoutInMs: 30000,
                segmentTimeoutInMs: 600000,
                lookupOnly: false
            };
            if (copy) {
                if ('boolean' == typeof copy.useAzureSdk) result.useAzureSdk = copy.useAzureSdk;
                if ('boolean' == typeof copy.concurrentBlobDownloads) result.concurrentBlobDownloads = copy.concurrentBlobDownloads;
                if ('number' == typeof copy.downloadConcurrency) result.downloadConcurrency = copy.downloadConcurrency;
                if ('number' == typeof copy.timeoutInMs) result.timeoutInMs = copy.timeoutInMs;
                if ('number' == typeof copy.segmentTimeoutInMs) result.segmentTimeoutInMs = copy.segmentTimeoutInMs;
                if ('boolean' == typeof copy.lookupOnly) result.lookupOnly = copy.lookupOnly;
            }
            const segmentDownloadTimeoutMins = process.env['SEGMENT_DOWNLOAD_TIMEOUT_MINS'];
            if (segmentDownloadTimeoutMins && !isNaN(Number(segmentDownloadTimeoutMins)) && isFinite(Number(segmentDownloadTimeoutMins))) result.segmentTimeoutInMs = 60 * Number(segmentDownloadTimeoutMins) * 1000;
            core.debug(`Use Azure SDK: ${result.useAzureSdk}`);
            core.debug(`Download concurrency: ${result.downloadConcurrency}`);
            core.debug(`Request timeout (ms): ${result.timeoutInMs}`);
            core.debug(`Cache segment download timeout mins env var: ${process.env['SEGMENT_DOWNLOAD_TIMEOUT_MINS']}`);
            core.debug(`Segment download timeout (ms): ${result.segmentTimeoutInMs}`);
            core.debug(`Lookup only: ${result.lookupOnly}`);
            return result;
        }
        exports1.getDownloadOptions = getDownloadOptions;
    },
    "../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/command.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.issue = exports1.issueCommand = void 0;
        const os = __importStar(__webpack_require__("os"));
        const utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/utils.js");
        function issueCommand(command, properties, message) {
            const cmd = new Command(command, properties, message);
            process.stdout.write(cmd.toString() + os.EOL);
        }
        exports1.issueCommand = issueCommand;
        function issue(name, message = '') {
            issueCommand(name, {}, message);
        }
        exports1.issue = issue;
        const CMD_STRING = '::';
        class Command {
            constructor(command, properties, message){
                if (!command) command = 'missing.command';
                this.command = command;
                this.properties = properties;
                this.message = message;
            }
            toString() {
                let cmdStr = CMD_STRING + this.command;
                if (this.properties && Object.keys(this.properties).length > 0) {
                    cmdStr += ' ';
                    let first = true;
                    for(const key in this.properties)if (this.properties.hasOwnProperty(key)) {
                        const val = this.properties[key];
                        if (val) {
                            if (first) first = false;
                            else cmdStr += ',';
                            cmdStr += `${key}=${escapeProperty(val)}`;
                        }
                    }
                }
                cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
                return cmdStr;
            }
        }
        function escapeData(s) {
            return utils_1.toCommandValue(s).replace(/%/g, '%25').replace(/\r/g, '%0D').replace(/\n/g, '%0A');
        }
        function escapeProperty(s) {
            return utils_1.toCommandValue(s).replace(/%/g, '%25').replace(/\r/g, '%0D').replace(/\n/g, '%0A').replace(/:/g, '%3A').replace(/,/g, '%2C');
        }
    },
    "../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/core.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.getIDToken = exports1.getState = exports1.saveState = exports1.group = exports1.endGroup = exports1.startGroup = exports1.info = exports1.notice = exports1.warning = exports1.error = exports1.debug = exports1.isDebug = exports1.setFailed = exports1.setCommandEcho = exports1.setOutput = exports1.getBooleanInput = exports1.getMultilineInput = exports1.getInput = exports1.addPath = exports1.setSecret = exports1.exportVariable = exports1.ExitCode = void 0;
        const command_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/command.js");
        const file_command_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/file-command.js");
        const utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/utils.js");
        const os = __importStar(__webpack_require__("os"));
        const path = __importStar(__webpack_require__("path"));
        const oidc_utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/oidc-utils.js");
        var ExitCode;
        (function(ExitCode) {
            ExitCode[ExitCode["Success"] = 0] = "Success";
            ExitCode[ExitCode["Failure"] = 1] = "Failure";
        })(ExitCode = exports1.ExitCode || (exports1.ExitCode = {}));
        function exportVariable(name, val) {
            const convertedVal = utils_1.toCommandValue(val);
            process.env[name] = convertedVal;
            const filePath = process.env['GITHUB_ENV'] || '';
            if (filePath) return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
            command_1.issueCommand('set-env', {
                name
            }, convertedVal);
        }
        exports1.exportVariable = exportVariable;
        function setSecret(secret) {
            command_1.issueCommand('add-mask', {}, secret);
        }
        exports1.setSecret = setSecret;
        function addPath(inputPath) {
            const filePath = process.env['GITHUB_PATH'] || '';
            if (filePath) file_command_1.issueFileCommand('PATH', inputPath);
            else command_1.issueCommand('add-path', {}, inputPath);
            process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
        }
        exports1.addPath = addPath;
        function getInput(name, options) {
            const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
            if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);
            if (options && false === options.trimWhitespace) return val;
            return val.trim();
        }
        exports1.getInput = getInput;
        function getMultilineInput(name, options) {
            const inputs = getInput(name, options).split('\n').filter((x)=>'' !== x);
            if (options && false === options.trimWhitespace) return inputs;
            return inputs.map((input)=>input.trim());
        }
        exports1.getMultilineInput = getMultilineInput;
        function getBooleanInput(name, options) {
            const trueValue = [
                'true',
                'True',
                'TRUE'
            ];
            const falseValue = [
                'false',
                'False',
                'FALSE'
            ];
            const val = getInput(name, options);
            if (trueValue.includes(val)) return true;
            if (falseValue.includes(val)) return false;
            throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\nSupport boolean input list: \`true | True | TRUE | false | False | FALSE\``);
        }
        exports1.getBooleanInput = getBooleanInput;
        function setOutput(name, value) {
            const filePath = process.env['GITHUB_OUTPUT'] || '';
            if (filePath) return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
            process.stdout.write(os.EOL);
            command_1.issueCommand('set-output', {
                name
            }, utils_1.toCommandValue(value));
        }
        exports1.setOutput = setOutput;
        function setCommandEcho(enabled) {
            command_1.issue('echo', enabled ? 'on' : 'off');
        }
        exports1.setCommandEcho = setCommandEcho;
        function setFailed(message) {
            process.exitCode = ExitCode.Failure;
            error(message);
        }
        exports1.setFailed = setFailed;
        function isDebug() {
            return '1' === process.env['RUNNER_DEBUG'];
        }
        exports1.isDebug = isDebug;
        function debug(message) {
            command_1.issueCommand('debug', {}, message);
        }
        exports1.debug = debug;
        function error(message, properties = {}) {
            command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
        }
        exports1.error = error;
        function warning(message, properties = {}) {
            command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
        }
        exports1.warning = warning;
        function notice(message, properties = {}) {
            command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
        }
        exports1.notice = notice;
        function info(message) {
            process.stdout.write(message + os.EOL);
        }
        exports1.info = info;
        function startGroup(name) {
            command_1.issue('group', name);
        }
        exports1.startGroup = startGroup;
        function endGroup() {
            command_1.issue('endgroup');
        }
        exports1.endGroup = endGroup;
        function group(name, fn) {
            return __awaiter(this, void 0, void 0, function*() {
                startGroup(name);
                let result;
                try {
                    result = yield fn();
                } finally{
                    endGroup();
                }
                return result;
            });
        }
        exports1.group = group;
        function saveState(name, value) {
            const filePath = process.env['GITHUB_STATE'] || '';
            if (filePath) return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
            command_1.issueCommand('save-state', {
                name
            }, utils_1.toCommandValue(value));
        }
        exports1.saveState = saveState;
        function getState(name) {
            return process.env[`STATE_${name}`] || '';
        }
        exports1.getState = getState;
        function getIDToken(aud) {
            return __awaiter(this, void 0, void 0, function*() {
                return yield oidc_utils_1.OidcClient.getIDToken(aud);
            });
        }
        exports1.getIDToken = getIDToken;
        var summary_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/summary.js");
        Object.defineProperty(exports1, "summary", {
            enumerable: true,
            get: function() {
                return summary_1.summary;
            }
        });
        var summary_2 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/summary.js");
        Object.defineProperty(exports1, "markdownSummary", {
            enumerable: true,
            get: function() {
                return summary_2.markdownSummary;
            }
        });
        var path_utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/path-utils.js");
        Object.defineProperty(exports1, "toPosixPath", {
            enumerable: true,
            get: function() {
                return path_utils_1.toPosixPath;
            }
        });
        Object.defineProperty(exports1, "toWin32Path", {
            enumerable: true,
            get: function() {
                return path_utils_1.toWin32Path;
            }
        });
        Object.defineProperty(exports1, "toPlatformPath", {
            enumerable: true,
            get: function() {
                return path_utils_1.toPlatformPath;
            }
        });
    },
    "../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/file-command.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.prepareKeyValueMessage = exports1.issueFileCommand = void 0;
        const fs = __importStar(__webpack_require__("fs"));
        const os = __importStar(__webpack_require__("os"));
        const uuid_1 = __webpack_require__("../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js");
        const utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/utils.js");
        function issueFileCommand(command, message) {
            const filePath = process.env[`GITHUB_${command}`];
            if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);
            if (!fs.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);
            fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
                encoding: 'utf8'
            });
        }
        exports1.issueFileCommand = issueFileCommand;
        function prepareKeyValueMessage(key, value) {
            const delimiter = `ghadelimiter_${uuid_1.v4()}`;
            const convertedValue = utils_1.toCommandValue(value);
            if (key.includes(delimiter)) throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
            if (convertedValue.includes(delimiter)) throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
            return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
        }
        exports1.prepareKeyValueMessage = prepareKeyValueMessage;
    },
    "../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/oidc-utils.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.OidcClient = void 0;
        const http_client_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/index.js");
        const auth_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/auth.js");
        const core_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/core.js");
        class OidcClient {
            static createHttpClient(allowRetry = true, maxRetry = 10) {
                const requestOptions = {
                    allowRetries: allowRetry,
                    maxRetries: maxRetry
                };
                return new http_client_1.HttpClient('actions/oidc-client', [
                    new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())
                ], requestOptions);
            }
            static getRequestToken() {
                const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
                if (!token) throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
                return token;
            }
            static getIDTokenUrl() {
                const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
                if (!runtimeUrl) throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
                return runtimeUrl;
            }
            static getCall(id_token_url) {
                var _a;
                return __awaiter(this, void 0, void 0, function*() {
                    const httpclient = OidcClient.createHttpClient();
                    const res = yield httpclient.getJson(id_token_url).catch((error)=>{
                        throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`);
                    });
                    const id_token = null == (_a = res.result) ? void 0 : _a.value;
                    if (!id_token) throw new Error('Response json body do not have ID Token field');
                    return id_token;
                });
            }
            static getIDToken(audience) {
                return __awaiter(this, void 0, void 0, function*() {
                    try {
                        let id_token_url = OidcClient.getIDTokenUrl();
                        if (audience) {
                            const encodedAudience = encodeURIComponent(audience);
                            id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                        }
                        core_1.debug(`ID token url is ${id_token_url}`);
                        const id_token = yield OidcClient.getCall(id_token_url);
                        core_1.setSecret(id_token);
                        return id_token;
                    } catch (error) {
                        throw new Error(`Error message: ${error.message}`);
                    }
                });
            }
        }
        exports1.OidcClient = OidcClient;
    },
    "../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/path-utils.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.toPlatformPath = exports1.toWin32Path = exports1.toPosixPath = void 0;
        const path = __importStar(__webpack_require__("path"));
        function toPosixPath(pth) {
            return pth.replace(/[\\]/g, '/');
        }
        exports1.toPosixPath = toPosixPath;
        function toWin32Path(pth) {
            return pth.replace(/[/]/g, '\\');
        }
        exports1.toWin32Path = toWin32Path;
        function toPlatformPath(pth) {
            return pth.replace(/[/\\]/g, path.sep);
        }
        exports1.toPlatformPath = toPlatformPath;
    },
    "../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/summary.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.summary = exports1.markdownSummary = exports1.SUMMARY_DOCS_URL = exports1.SUMMARY_ENV_VAR = void 0;
        const os_1 = __webpack_require__("os");
        const fs_1 = __webpack_require__("fs");
        const { access, appendFile, writeFile } = fs_1.promises;
        exports1.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
        exports1.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
        class Summary {
            constructor(){
                this._buffer = '';
            }
            filePath() {
                return __awaiter(this, void 0, void 0, function*() {
                    if (this._filePath) return this._filePath;
                    const pathFromEnv = process.env[exports1.SUMMARY_ENV_VAR];
                    if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${exports1.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
                    try {
                        yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
                    } catch (_a) {
                        throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
                    }
                    this._filePath = pathFromEnv;
                    return this._filePath;
                });
            }
            wrap(tag, content, attrs = {}) {
                const htmlAttrs = Object.entries(attrs).map(([key, value])=>` ${key}="${value}"`).join('');
                if (!content) return `<${tag}${htmlAttrs}>`;
                return `<${tag}${htmlAttrs}>${content}</${tag}>`;
            }
            write(options) {
                return __awaiter(this, void 0, void 0, function*() {
                    const overwrite = !!(null == options ? void 0 : options.overwrite);
                    const filePath = yield this.filePath();
                    const writeFunc = overwrite ? writeFile : appendFile;
                    yield writeFunc(filePath, this._buffer, {
                        encoding: 'utf8'
                    });
                    return this.emptyBuffer();
                });
            }
            clear() {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.emptyBuffer().write({
                        overwrite: true
                    });
                });
            }
            stringify() {
                return this._buffer;
            }
            isEmptyBuffer() {
                return 0 === this._buffer.length;
            }
            emptyBuffer() {
                this._buffer = '';
                return this;
            }
            addRaw(text, addEOL = false) {
                this._buffer += text;
                return addEOL ? this.addEOL() : this;
            }
            addEOL() {
                return this.addRaw(os_1.EOL);
            }
            addCodeBlock(code, lang) {
                const attrs = Object.assign({}, lang && {
                    lang
                });
                const element = this.wrap('pre', this.wrap('code', code), attrs);
                return this.addRaw(element).addEOL();
            }
            addList(items, ordered = false) {
                const tag = ordered ? 'ol' : 'ul';
                const listItems = items.map((item)=>this.wrap('li', item)).join('');
                const element = this.wrap(tag, listItems);
                return this.addRaw(element).addEOL();
            }
            addTable(rows) {
                const tableBody = rows.map((row)=>{
                    const cells = row.map((cell)=>{
                        if ('string' == typeof cell) return this.wrap('td', cell);
                        const { header, data, colspan, rowspan } = cell;
                        const tag = header ? 'th' : 'td';
                        const attrs = Object.assign(Object.assign({}, colspan && {
                            colspan
                        }), rowspan && {
                            rowspan
                        });
                        return this.wrap(tag, data, attrs);
                    }).join('');
                    return this.wrap('tr', cells);
                }).join('');
                const element = this.wrap('table', tableBody);
                return this.addRaw(element).addEOL();
            }
            addDetails(label, content) {
                const element = this.wrap('details', this.wrap('summary', label) + content);
                return this.addRaw(element).addEOL();
            }
            addImage(src, alt, options) {
                const { width, height } = options || {};
                const attrs = Object.assign(Object.assign({}, width && {
                    width
                }), height && {
                    height
                });
                const element = this.wrap('img', null, Object.assign({
                    src,
                    alt
                }, attrs));
                return this.addRaw(element).addEOL();
            }
            addHeading(text, level) {
                const tag = `h${level}`;
                const allowedTag = [
                    'h1',
                    'h2',
                    'h3',
                    'h4',
                    'h5',
                    'h6'
                ].includes(tag) ? tag : 'h1';
                const element = this.wrap(allowedTag, text);
                return this.addRaw(element).addEOL();
            }
            addSeparator() {
                const element = this.wrap('hr', null);
                return this.addRaw(element).addEOL();
            }
            addBreak() {
                const element = this.wrap('br', null);
                return this.addRaw(element).addEOL();
            }
            addQuote(text, cite) {
                const attrs = Object.assign({}, cite && {
                    cite
                });
                const element = this.wrap('blockquote', text, attrs);
                return this.addRaw(element).addEOL();
            }
            addLink(text, href) {
                const element = this.wrap('a', text, {
                    href
                });
                return this.addRaw(element).addEOL();
            }
        }
        const _summary = new Summary();
        exports1.markdownSummary = _summary;
        exports1.summary = _summary;
    },
    "../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/utils.js" (__unused_rspack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.toCommandProperties = exports1.toCommandValue = void 0;
        function toCommandValue(input) {
            if (null == input) return '';
            if ('string' == typeof input || input instanceof String) return input;
            return JSON.stringify(input);
        }
        exports1.toCommandValue = toCommandValue;
        function toCommandProperties(annotationProperties) {
            if (!Object.keys(annotationProperties).length) return {};
            return {
                title: annotationProperties.title,
                file: annotationProperties.file,
                line: annotationProperties.startLine,
                endLine: annotationProperties.endLine,
                col: annotationProperties.startColumn,
                endColumn: annotationProperties.endColumn
            };
        }
        exports1.toCommandProperties = toCommandProperties;
    },
    "../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/command.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.issue = exports1.issueCommand = void 0;
        const os = __importStar(__webpack_require__("os"));
        const utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js");
        function issueCommand(command, properties, message) {
            const cmd = new Command(command, properties, message);
            process.stdout.write(cmd.toString() + os.EOL);
        }
        exports1.issueCommand = issueCommand;
        function issue(name, message = '') {
            issueCommand(name, {}, message);
        }
        exports1.issue = issue;
        const CMD_STRING = '::';
        class Command {
            constructor(command, properties, message){
                if (!command) command = 'missing.command';
                this.command = command;
                this.properties = properties;
                this.message = message;
            }
            toString() {
                let cmdStr = CMD_STRING + this.command;
                if (this.properties && Object.keys(this.properties).length > 0) {
                    cmdStr += ' ';
                    let first = true;
                    for(const key in this.properties)if (this.properties.hasOwnProperty(key)) {
                        const val = this.properties[key];
                        if (val) {
                            if (first) first = false;
                            else cmdStr += ',';
                            cmdStr += `${key}=${escapeProperty(val)}`;
                        }
                    }
                }
                cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
                return cmdStr;
            }
        }
        function escapeData(s) {
            return (0, utils_1.toCommandValue)(s).replace(/%/g, '%25').replace(/\r/g, '%0D').replace(/\n/g, '%0A');
        }
        function escapeProperty(s) {
            return (0, utils_1.toCommandValue)(s).replace(/%/g, '%25').replace(/\r/g, '%0D').replace(/\n/g, '%0A').replace(/:/g, '%3A').replace(/,/g, '%2C');
        }
    },
    "../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.platform = exports1.toPlatformPath = exports1.toWin32Path = exports1.toPosixPath = exports1.markdownSummary = exports1.summary = exports1.getIDToken = exports1.getState = exports1.saveState = exports1.group = exports1.endGroup = exports1.startGroup = exports1.info = exports1.notice = exports1.warning = exports1.error = exports1.debug = exports1.isDebug = exports1.setFailed = exports1.setCommandEcho = exports1.setOutput = exports1.getBooleanInput = exports1.getMultilineInput = exports1.getInput = exports1.addPath = exports1.setSecret = exports1.exportVariable = exports1.ExitCode = void 0;
        const command_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/command.js");
        const file_command_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/file-command.js");
        const utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js");
        const os = __importStar(__webpack_require__("os"));
        const path = __importStar(__webpack_require__("path"));
        const oidc_utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/oidc-utils.js");
        var ExitCode;
        (function(ExitCode) {
            ExitCode[ExitCode["Success"] = 0] = "Success";
            ExitCode[ExitCode["Failure"] = 1] = "Failure";
        })(ExitCode || (exports1.ExitCode = ExitCode = {}));
        function exportVariable(name, val) {
            const convertedVal = (0, utils_1.toCommandValue)(val);
            process.env[name] = convertedVal;
            const filePath = process.env['GITHUB_ENV'] || '';
            if (filePath) return (0, file_command_1.issueFileCommand)('ENV', (0, file_command_1.prepareKeyValueMessage)(name, val));
            (0, command_1.issueCommand)('set-env', {
                name
            }, convertedVal);
        }
        exports1.exportVariable = exportVariable;
        function setSecret(secret) {
            (0, command_1.issueCommand)('add-mask', {}, secret);
        }
        exports1.setSecret = setSecret;
        function addPath(inputPath) {
            const filePath = process.env['GITHUB_PATH'] || '';
            if (filePath) (0, file_command_1.issueFileCommand)('PATH', inputPath);
            else (0, command_1.issueCommand)('add-path', {}, inputPath);
            process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
        }
        exports1.addPath = addPath;
        function getInput(name, options) {
            const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
            if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);
            if (options && false === options.trimWhitespace) return val;
            return val.trim();
        }
        exports1.getInput = getInput;
        function getMultilineInput(name, options) {
            const inputs = getInput(name, options).split('\n').filter((x)=>'' !== x);
            if (options && false === options.trimWhitespace) return inputs;
            return inputs.map((input)=>input.trim());
        }
        exports1.getMultilineInput = getMultilineInput;
        function getBooleanInput(name, options) {
            const trueValue = [
                'true',
                'True',
                'TRUE'
            ];
            const falseValue = [
                'false',
                'False',
                'FALSE'
            ];
            const val = getInput(name, options);
            if (trueValue.includes(val)) return true;
            if (falseValue.includes(val)) return false;
            throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\nSupport boolean input list: \`true | True | TRUE | false | False | FALSE\``);
        }
        exports1.getBooleanInput = getBooleanInput;
        function setOutput(name, value) {
            const filePath = process.env['GITHUB_OUTPUT'] || '';
            if (filePath) return (0, file_command_1.issueFileCommand)('OUTPUT', (0, file_command_1.prepareKeyValueMessage)(name, value));
            process.stdout.write(os.EOL);
            (0, command_1.issueCommand)('set-output', {
                name
            }, (0, utils_1.toCommandValue)(value));
        }
        exports1.setOutput = setOutput;
        function setCommandEcho(enabled) {
            (0, command_1.issue)('echo', enabled ? 'on' : 'off');
        }
        exports1.setCommandEcho = setCommandEcho;
        function setFailed(message) {
            process.exitCode = ExitCode.Failure;
            error(message);
        }
        exports1.setFailed = setFailed;
        function isDebug() {
            return '1' === process.env['RUNNER_DEBUG'];
        }
        exports1.isDebug = isDebug;
        function debug(message) {
            (0, command_1.issueCommand)('debug', {}, message);
        }
        exports1.debug = debug;
        function error(message, properties = {}) {
            (0, command_1.issueCommand)('error', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
        }
        exports1.error = error;
        function warning(message, properties = {}) {
            (0, command_1.issueCommand)('warning', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
        }
        exports1.warning = warning;
        function notice(message, properties = {}) {
            (0, command_1.issueCommand)('notice', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
        }
        exports1.notice = notice;
        function info(message) {
            process.stdout.write(message + os.EOL);
        }
        exports1.info = info;
        function startGroup(name) {
            (0, command_1.issue)('group', name);
        }
        exports1.startGroup = startGroup;
        function endGroup() {
            (0, command_1.issue)('endgroup');
        }
        exports1.endGroup = endGroup;
        function group(name, fn) {
            return __awaiter(this, void 0, void 0, function*() {
                startGroup(name);
                let result;
                try {
                    result = yield fn();
                } finally{
                    endGroup();
                }
                return result;
            });
        }
        exports1.group = group;
        function saveState(name, value) {
            const filePath = process.env['GITHUB_STATE'] || '';
            if (filePath) return (0, file_command_1.issueFileCommand)('STATE', (0, file_command_1.prepareKeyValueMessage)(name, value));
            (0, command_1.issueCommand)('save-state', {
                name
            }, (0, utils_1.toCommandValue)(value));
        }
        exports1.saveState = saveState;
        function getState(name) {
            return process.env[`STATE_${name}`] || '';
        }
        exports1.getState = getState;
        function getIDToken(aud) {
            return __awaiter(this, void 0, void 0, function*() {
                return yield oidc_utils_1.OidcClient.getIDToken(aud);
            });
        }
        exports1.getIDToken = getIDToken;
        var summary_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/summary.js");
        Object.defineProperty(exports1, "summary", {
            enumerable: true,
            get: function() {
                return summary_1.summary;
            }
        });
        var summary_2 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/summary.js");
        Object.defineProperty(exports1, "markdownSummary", {
            enumerable: true,
            get: function() {
                return summary_2.markdownSummary;
            }
        });
        var path_utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/path-utils.js");
        Object.defineProperty(exports1, "toPosixPath", {
            enumerable: true,
            get: function() {
                return path_utils_1.toPosixPath;
            }
        });
        Object.defineProperty(exports1, "toWin32Path", {
            enumerable: true,
            get: function() {
                return path_utils_1.toWin32Path;
            }
        });
        Object.defineProperty(exports1, "toPlatformPath", {
            enumerable: true,
            get: function() {
                return path_utils_1.toPlatformPath;
            }
        });
        exports1.platform = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/platform.js"));
    },
    "../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/file-command.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.prepareKeyValueMessage = exports1.issueFileCommand = void 0;
        const crypto = __importStar(__webpack_require__("crypto"));
        const fs = __importStar(__webpack_require__("fs"));
        const os = __importStar(__webpack_require__("os"));
        const utils_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js");
        function issueFileCommand(command, message) {
            const filePath = process.env[`GITHUB_${command}`];
            if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);
            if (!fs.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);
            fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
                encoding: 'utf8'
            });
        }
        exports1.issueFileCommand = issueFileCommand;
        function prepareKeyValueMessage(key, value) {
            const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
            const convertedValue = (0, utils_1.toCommandValue)(value);
            if (key.includes(delimiter)) throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
            if (convertedValue.includes(delimiter)) throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
            return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
        }
        exports1.prepareKeyValueMessage = prepareKeyValueMessage;
    },
    "../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/oidc-utils.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.OidcClient = void 0;
        const http_client_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/index.js");
        const auth_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/auth.js");
        const core_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js");
        class OidcClient {
            static createHttpClient(allowRetry = true, maxRetry = 10) {
                const requestOptions = {
                    allowRetries: allowRetry,
                    maxRetries: maxRetry
                };
                return new http_client_1.HttpClient('actions/oidc-client', [
                    new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())
                ], requestOptions);
            }
            static getRequestToken() {
                const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
                if (!token) throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
                return token;
            }
            static getIDTokenUrl() {
                const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
                if (!runtimeUrl) throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
                return runtimeUrl;
            }
            static getCall(id_token_url) {
                var _a;
                return __awaiter(this, void 0, void 0, function*() {
                    const httpclient = OidcClient.createHttpClient();
                    const res = yield httpclient.getJson(id_token_url).catch((error)=>{
                        throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`);
                    });
                    const id_token = null == (_a = res.result) ? void 0 : _a.value;
                    if (!id_token) throw new Error('Response json body do not have ID Token field');
                    return id_token;
                });
            }
            static getIDToken(audience) {
                return __awaiter(this, void 0, void 0, function*() {
                    try {
                        let id_token_url = OidcClient.getIDTokenUrl();
                        if (audience) {
                            const encodedAudience = encodeURIComponent(audience);
                            id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                        }
                        (0, core_1.debug)(`ID token url is ${id_token_url}`);
                        const id_token = yield OidcClient.getCall(id_token_url);
                        (0, core_1.setSecret)(id_token);
                        return id_token;
                    } catch (error) {
                        throw new Error(`Error message: ${error.message}`);
                    }
                });
            }
        }
        exports1.OidcClient = OidcClient;
    },
    "../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/path-utils.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.toPlatformPath = exports1.toWin32Path = exports1.toPosixPath = void 0;
        const path = __importStar(__webpack_require__("path"));
        function toPosixPath(pth) {
            return pth.replace(/[\\]/g, '/');
        }
        exports1.toPosixPath = toPosixPath;
        function toWin32Path(pth) {
            return pth.replace(/[/]/g, '\\');
        }
        exports1.toWin32Path = toWin32Path;
        function toPlatformPath(pth) {
            return pth.replace(/[/\\]/g, path.sep);
        }
        exports1.toPlatformPath = toPlatformPath;
    },
    "../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/platform.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.getDetails = exports1.isLinux = exports1.isMacOS = exports1.isWindows = exports1.arch = exports1.platform = void 0;
        const os_1 = __importDefault(__webpack_require__("os"));
        const exec = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js"));
        const getWindowsInfo = ()=>__awaiter(void 0, void 0, void 0, function*() {
                const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
                    silent: true
                });
                const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
                    silent: true
                });
                return {
                    name: name.trim(),
                    version: version.trim()
                };
            });
        const getMacOsInfo = ()=>__awaiter(void 0, void 0, void 0, function*() {
                var _a, _b, _c, _d;
                const { stdout } = yield exec.getExecOutput('sw_vers', void 0, {
                    silent: true
                });
                const version = null != (_b = null == (_a = stdout.match(/ProductVersion:\s*(.+)/)) ? void 0 : _a[1]) ? _b : '';
                const name = null != (_d = null == (_c = stdout.match(/ProductName:\s*(.+)/)) ? void 0 : _c[1]) ? _d : '';
                return {
                    name,
                    version
                };
            });
        const getLinuxInfo = ()=>__awaiter(void 0, void 0, void 0, function*() {
                const { stdout } = yield exec.getExecOutput('lsb_release', [
                    '-i',
                    '-r',
                    '-s'
                ], {
                    silent: true
                });
                const [name, version] = stdout.trim().split('\n');
                return {
                    name,
                    version
                };
            });
        exports1.platform = os_1.default.platform();
        exports1.arch = os_1.default.arch();
        exports1.isWindows = 'win32' === exports1.platform;
        exports1.isMacOS = 'darwin' === exports1.platform;
        exports1.isLinux = 'linux' === exports1.platform;
        function getDetails() {
            return __awaiter(this, void 0, void 0, function*() {
                return Object.assign(Object.assign({}, (yield exports1.isWindows ? getWindowsInfo() : exports1.isMacOS ? getMacOsInfo() : getLinuxInfo())), {
                    platform: exports1.platform,
                    arch: exports1.arch,
                    isWindows: exports1.isWindows,
                    isMacOS: exports1.isMacOS,
                    isLinux: exports1.isLinux
                });
            });
        }
        exports1.getDetails = getDetails;
    },
    "../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/summary.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.summary = exports1.markdownSummary = exports1.SUMMARY_DOCS_URL = exports1.SUMMARY_ENV_VAR = void 0;
        const os_1 = __webpack_require__("os");
        const fs_1 = __webpack_require__("fs");
        const { access, appendFile, writeFile } = fs_1.promises;
        exports1.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
        exports1.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
        class Summary {
            constructor(){
                this._buffer = '';
            }
            filePath() {
                return __awaiter(this, void 0, void 0, function*() {
                    if (this._filePath) return this._filePath;
                    const pathFromEnv = process.env[exports1.SUMMARY_ENV_VAR];
                    if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${exports1.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
                    try {
                        yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
                    } catch (_a) {
                        throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
                    }
                    this._filePath = pathFromEnv;
                    return this._filePath;
                });
            }
            wrap(tag, content, attrs = {}) {
                const htmlAttrs = Object.entries(attrs).map(([key, value])=>` ${key}="${value}"`).join('');
                if (!content) return `<${tag}${htmlAttrs}>`;
                return `<${tag}${htmlAttrs}>${content}</${tag}>`;
            }
            write(options) {
                return __awaiter(this, void 0, void 0, function*() {
                    const overwrite = !!(null == options ? void 0 : options.overwrite);
                    const filePath = yield this.filePath();
                    const writeFunc = overwrite ? writeFile : appendFile;
                    yield writeFunc(filePath, this._buffer, {
                        encoding: 'utf8'
                    });
                    return this.emptyBuffer();
                });
            }
            clear() {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.emptyBuffer().write({
                        overwrite: true
                    });
                });
            }
            stringify() {
                return this._buffer;
            }
            isEmptyBuffer() {
                return 0 === this._buffer.length;
            }
            emptyBuffer() {
                this._buffer = '';
                return this;
            }
            addRaw(text, addEOL = false) {
                this._buffer += text;
                return addEOL ? this.addEOL() : this;
            }
            addEOL() {
                return this.addRaw(os_1.EOL);
            }
            addCodeBlock(code, lang) {
                const attrs = Object.assign({}, lang && {
                    lang
                });
                const element = this.wrap('pre', this.wrap('code', code), attrs);
                return this.addRaw(element).addEOL();
            }
            addList(items, ordered = false) {
                const tag = ordered ? 'ol' : 'ul';
                const listItems = items.map((item)=>this.wrap('li', item)).join('');
                const element = this.wrap(tag, listItems);
                return this.addRaw(element).addEOL();
            }
            addTable(rows) {
                const tableBody = rows.map((row)=>{
                    const cells = row.map((cell)=>{
                        if ('string' == typeof cell) return this.wrap('td', cell);
                        const { header, data, colspan, rowspan } = cell;
                        const tag = header ? 'th' : 'td';
                        const attrs = Object.assign(Object.assign({}, colspan && {
                            colspan
                        }), rowspan && {
                            rowspan
                        });
                        return this.wrap(tag, data, attrs);
                    }).join('');
                    return this.wrap('tr', cells);
                }).join('');
                const element = this.wrap('table', tableBody);
                return this.addRaw(element).addEOL();
            }
            addDetails(label, content) {
                const element = this.wrap('details', this.wrap('summary', label) + content);
                return this.addRaw(element).addEOL();
            }
            addImage(src, alt, options) {
                const { width, height } = options || {};
                const attrs = Object.assign(Object.assign({}, width && {
                    width
                }), height && {
                    height
                });
                const element = this.wrap('img', null, Object.assign({
                    src,
                    alt
                }, attrs));
                return this.addRaw(element).addEOL();
            }
            addHeading(text, level) {
                const tag = `h${level}`;
                const allowedTag = [
                    'h1',
                    'h2',
                    'h3',
                    'h4',
                    'h5',
                    'h6'
                ].includes(tag) ? tag : 'h1';
                const element = this.wrap(allowedTag, text);
                return this.addRaw(element).addEOL();
            }
            addSeparator() {
                const element = this.wrap('hr', null);
                return this.addRaw(element).addEOL();
            }
            addBreak() {
                const element = this.wrap('br', null);
                return this.addRaw(element).addEOL();
            }
            addQuote(text, cite) {
                const attrs = Object.assign({}, cite && {
                    cite
                });
                const element = this.wrap('blockquote', text, attrs);
                return this.addRaw(element).addEOL();
            }
            addLink(text, href) {
                const element = this.wrap('a', text, {
                    href
                });
                return this.addRaw(element).addEOL();
            }
        }
        const _summary = new Summary();
        exports1.markdownSummary = _summary;
        exports1.summary = _summary;
    },
    "../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js" (__unused_rspack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.toCommandProperties = exports1.toCommandValue = void 0;
        function toCommandValue(input) {
            if (null == input) return '';
            if ('string' == typeof input || input instanceof String) return input;
            return JSON.stringify(input);
        }
        exports1.toCommandValue = toCommandValue;
        function toCommandProperties(annotationProperties) {
            if (!Object.keys(annotationProperties).length) return {};
            return {
                title: annotationProperties.title,
                file: annotationProperties.file,
                line: annotationProperties.startLine,
                endLine: annotationProperties.endLine,
                col: annotationProperties.startColumn,
                endColumn: annotationProperties.endColumn
            };
        }
        exports1.toCommandProperties = toCommandProperties;
    },
    "../../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.getExecOutput = exports1.exec = void 0;
        const string_decoder_1 = __webpack_require__("string_decoder");
        const tr = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js"));
        function exec(commandLine, args, options) {
            return __awaiter(this, void 0, void 0, function*() {
                const commandArgs = tr.argStringToArray(commandLine);
                if (0 === commandArgs.length) throw new Error("Parameter 'commandLine' cannot be null or empty.");
                const toolPath = commandArgs[0];
                args = commandArgs.slice(1).concat(args || []);
                const runner = new tr.ToolRunner(toolPath, args, options);
                return runner.exec();
            });
        }
        exports1.exec = exec;
        function getExecOutput(commandLine, args, options) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function*() {
                let stdout = '';
                let stderr = '';
                const stdoutDecoder = new string_decoder_1.StringDecoder('utf8');
                const stderrDecoder = new string_decoder_1.StringDecoder('utf8');
                const originalStdoutListener = null == (_a = null == options ? void 0 : options.listeners) ? void 0 : _a.stdout;
                const originalStdErrListener = null == (_b = null == options ? void 0 : options.listeners) ? void 0 : _b.stderr;
                const stdErrListener = (data)=>{
                    stderr += stderrDecoder.write(data);
                    if (originalStdErrListener) originalStdErrListener(data);
                };
                const stdOutListener = (data)=>{
                    stdout += stdoutDecoder.write(data);
                    if (originalStdoutListener) originalStdoutListener(data);
                };
                const listeners = Object.assign(Object.assign({}, null == options ? void 0 : options.listeners), {
                    stdout: stdOutListener,
                    stderr: stdErrListener
                });
                const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), {
                    listeners
                }));
                stdout += stdoutDecoder.end();
                stderr += stderrDecoder.end();
                return {
                    exitCode,
                    stdout,
                    stderr
                };
            });
        }
        exports1.getExecOutput = getExecOutput;
    },
    "../../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.argStringToArray = exports1.ToolRunner = void 0;
        const os = __importStar(__webpack_require__("os"));
        const events = __importStar(__webpack_require__("events"));
        const child = __importStar(__webpack_require__("child_process"));
        const path = __importStar(__webpack_require__("path"));
        const io = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js"));
        const ioUtil = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js"));
        const timers_1 = __webpack_require__("timers");
        const IS_WINDOWS = 'win32' === process.platform;
        class ToolRunner extends events.EventEmitter {
            constructor(toolPath, args, options){
                super();
                if (!toolPath) throw new Error("Parameter 'toolPath' cannot be null or empty.");
                this.toolPath = toolPath;
                this.args = args || [];
                this.options = options || {};
            }
            _debug(message) {
                if (this.options.listeners && this.options.listeners.debug) this.options.listeners.debug(message);
            }
            _getCommandString(options, noPrefix) {
                const toolPath = this._getSpawnFileName();
                const args = this._getSpawnArgs(options);
                let cmd = noPrefix ? '' : '[command]';
                if (IS_WINDOWS) if (this._isCmdFile()) {
                    cmd += toolPath;
                    for (const a of args)cmd += ` ${a}`;
                } else if (options.windowsVerbatimArguments) {
                    cmd += `"${toolPath}"`;
                    for (const a of args)cmd += ` ${a}`;
                } else {
                    cmd += this._windowsQuoteCmdArg(toolPath);
                    for (const a of args)cmd += ` ${this._windowsQuoteCmdArg(a)}`;
                }
                else {
                    cmd += toolPath;
                    for (const a of args)cmd += ` ${a}`;
                }
                return cmd;
            }
            _processLineBuffer(data, strBuffer, onLine) {
                try {
                    let s = strBuffer + data.toString();
                    let n = s.indexOf(os.EOL);
                    while(n > -1){
                        const line = s.substring(0, n);
                        onLine(line);
                        s = s.substring(n + os.EOL.length);
                        n = s.indexOf(os.EOL);
                    }
                    return s;
                } catch (err) {
                    this._debug(`error processing line. Failed with error ${err}`);
                    return '';
                }
            }
            _getSpawnFileName() {
                if (IS_WINDOWS) {
                    if (this._isCmdFile()) return process.env['COMSPEC'] || 'cmd.exe';
                }
                return this.toolPath;
            }
            _getSpawnArgs(options) {
                if (IS_WINDOWS) {
                    if (this._isCmdFile()) {
                        let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
                        for (const a of this.args){
                            argline += ' ';
                            argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
                        }
                        argline += '"';
                        return [
                            argline
                        ];
                    }
                }
                return this.args;
            }
            _endsWith(str, end) {
                return str.endsWith(end);
            }
            _isCmdFile() {
                const upperToolPath = this.toolPath.toUpperCase();
                return this._endsWith(upperToolPath, '.CMD') || this._endsWith(upperToolPath, '.BAT');
            }
            _windowsQuoteCmdArg(arg) {
                if (!this._isCmdFile()) return this._uvQuoteCmdArg(arg);
                if (!arg) return '""';
                const cmdSpecialChars = [
                    ' ',
                    '\t',
                    '&',
                    '(',
                    ')',
                    '[',
                    ']',
                    '{',
                    '}',
                    '^',
                    '=',
                    ';',
                    '!',
                    "'",
                    '+',
                    ',',
                    '`',
                    '~',
                    '|',
                    '<',
                    '>',
                    '"'
                ];
                let needsQuotes = false;
                for (const char of arg)if (cmdSpecialChars.some((x)=>x === char)) {
                    needsQuotes = true;
                    break;
                }
                if (!needsQuotes) return arg;
                let reverse = '"';
                let quoteHit = true;
                for(let i = arg.length; i > 0; i--){
                    reverse += arg[i - 1];
                    if (quoteHit && '\\' === arg[i - 1]) reverse += '\\';
                    else if ('"' === arg[i - 1]) {
                        quoteHit = true;
                        reverse += '"';
                    } else quoteHit = false;
                }
                reverse += '"';
                return reverse.split('').reverse().join('');
            }
            _uvQuoteCmdArg(arg) {
                if (!arg) return '""';
                if (!arg.includes(' ') && !arg.includes('\t') && !arg.includes('"')) return arg;
                if (!arg.includes('"') && !arg.includes('\\')) return `"${arg}"`;
                let reverse = '"';
                let quoteHit = true;
                for(let i = arg.length; i > 0; i--){
                    reverse += arg[i - 1];
                    if (quoteHit && '\\' === arg[i - 1]) reverse += '\\';
                    else if ('"' === arg[i - 1]) {
                        quoteHit = true;
                        reverse += '\\';
                    } else quoteHit = false;
                }
                reverse += '"';
                return reverse.split('').reverse().join('');
            }
            _cloneExecOptions(options) {
                options = options || {};
                const result = {
                    cwd: options.cwd || process.cwd(),
                    env: options.env || process.env,
                    silent: options.silent || false,
                    windowsVerbatimArguments: options.windowsVerbatimArguments || false,
                    failOnStdErr: options.failOnStdErr || false,
                    ignoreReturnCode: options.ignoreReturnCode || false,
                    delay: options.delay || 10000
                };
                result.outStream = options.outStream || process.stdout;
                result.errStream = options.errStream || process.stderr;
                return result;
            }
            _getSpawnOptions(options, toolPath) {
                options = options || {};
                const result = {};
                result.cwd = options.cwd;
                result.env = options.env;
                result['windowsVerbatimArguments'] = options.windowsVerbatimArguments || this._isCmdFile();
                if (options.windowsVerbatimArguments) result.argv0 = `"${toolPath}"`;
                return result;
            }
            exec() {
                return __awaiter(this, void 0, void 0, function*() {
                    if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes('/') || IS_WINDOWS && this.toolPath.includes('\\'))) this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
                    this.toolPath = yield io.which(this.toolPath, true);
                    return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                            this._debug(`exec tool: ${this.toolPath}`);
                            this._debug('arguments:');
                            for (const arg of this.args)this._debug(`   ${arg}`);
                            const optionsNonNull = this._cloneExecOptions(this.options);
                            if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
                            const state = new ExecState(optionsNonNull, this.toolPath);
                            state.on('debug', (message)=>{
                                this._debug(message);
                            });
                            if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
                            const fileName = this._getSpawnFileName();
                            const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
                            let stdbuffer = '';
                            if (cp.stdout) cp.stdout.on('data', (data)=>{
                                if (this.options.listeners && this.options.listeners.stdout) this.options.listeners.stdout(data);
                                if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(data);
                                stdbuffer = this._processLineBuffer(data, stdbuffer, (line)=>{
                                    if (this.options.listeners && this.options.listeners.stdline) this.options.listeners.stdline(line);
                                });
                            });
                            let errbuffer = '';
                            if (cp.stderr) cp.stderr.on('data', (data)=>{
                                state.processStderr = true;
                                if (this.options.listeners && this.options.listeners.stderr) this.options.listeners.stderr(data);
                                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                                    const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                                    s.write(data);
                                }
                                errbuffer = this._processLineBuffer(data, errbuffer, (line)=>{
                                    if (this.options.listeners && this.options.listeners.errline) this.options.listeners.errline(line);
                                });
                            });
                            cp.on('error', (err)=>{
                                state.processError = err.message;
                                state.processExited = true;
                                state.processClosed = true;
                                state.CheckComplete();
                            });
                            cp.on('exit', (code)=>{
                                state.processExitCode = code;
                                state.processExited = true;
                                this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
                                state.CheckComplete();
                            });
                            cp.on('close', (code)=>{
                                state.processExitCode = code;
                                state.processExited = true;
                                state.processClosed = true;
                                this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
                                state.CheckComplete();
                            });
                            state.on('done', (error, exitCode)=>{
                                if (stdbuffer.length > 0) this.emit('stdline', stdbuffer);
                                if (errbuffer.length > 0) this.emit('errline', errbuffer);
                                cp.removeAllListeners();
                                if (error) reject(error);
                                else resolve(exitCode);
                            });
                            if (this.options.input) {
                                if (!cp.stdin) throw new Error('child process missing stdin');
                                cp.stdin.end(this.options.input);
                            }
                        }));
                });
            }
        }
        exports1.ToolRunner = ToolRunner;
        function argStringToArray(argString) {
            const args = [];
            let inQuotes = false;
            let escaped = false;
            let arg = '';
            function append(c) {
                if (escaped && '"' !== c) arg += '\\';
                arg += c;
                escaped = false;
            }
            for(let i = 0; i < argString.length; i++){
                const c = argString.charAt(i);
                if ('"' === c) {
                    if (escaped) append(c);
                    else inQuotes = !inQuotes;
                    continue;
                }
                if ('\\' === c && escaped) {
                    append(c);
                    continue;
                }
                if ('\\' === c && inQuotes) {
                    escaped = true;
                    continue;
                }
                if (' ' === c && !inQuotes) {
                    if (arg.length > 0) {
                        args.push(arg);
                        arg = '';
                    }
                    continue;
                }
                append(c);
            }
            if (arg.length > 0) args.push(arg.trim());
            return args;
        }
        exports1.argStringToArray = argStringToArray;
        class ExecState extends events.EventEmitter {
            constructor(options, toolPath){
                super();
                this.processClosed = false;
                this.processError = '';
                this.processExitCode = 0;
                this.processExited = false;
                this.processStderr = false;
                this.delay = 10000;
                this.done = false;
                this.timeout = null;
                if (!toolPath) throw new Error('toolPath must not be empty');
                this.options = options;
                this.toolPath = toolPath;
                if (options.delay) this.delay = options.delay;
            }
            CheckComplete() {
                if (this.done) return;
                if (this.processClosed) this._setResult();
                else if (this.processExited) this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
            }
            _debug(message) {
                this.emit('debug', message);
            }
            _setResult() {
                let error;
                if (this.processExited) if (this.processError) error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
                else if (0 === this.processExitCode || this.options.ignoreReturnCode) {
                    if (this.processStderr && this.options.failOnStdErr) error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
                } else error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this.done = true;
                this.emit('done', error, this.processExitCode);
            }
            static HandleTimeout(state) {
                if (state.done) return;
                if (!state.processClosed && state.processExited) {
                    const message = `The STDIO streams did not close within ${state.delay / 1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
                    state._debug(message);
                }
                state._setResult();
            }
        }
    },
    "../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/glob.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.create = void 0;
        const internal_globber_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-globber.js");
        function create(patterns, options) {
            return __awaiter(this, void 0, void 0, function*() {
                return yield internal_globber_1.DefaultGlobber.create(patterns, options);
            });
        }
        exports1.create = create;
    },
    "../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-glob-options-helper.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.getOptions = void 0;
        const core = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"));
        function getOptions(copy) {
            const result = {
                followSymbolicLinks: true,
                implicitDescendants: true,
                omitBrokenSymbolicLinks: true
            };
            if (copy) {
                if ('boolean' == typeof copy.followSymbolicLinks) {
                    result.followSymbolicLinks = copy.followSymbolicLinks;
                    core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
                }
                if ('boolean' == typeof copy.implicitDescendants) {
                    result.implicitDescendants = copy.implicitDescendants;
                    core.debug(`implicitDescendants '${result.implicitDescendants}'`);
                }
                if ('boolean' == typeof copy.omitBrokenSymbolicLinks) {
                    result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
                    core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
                }
            }
            return result;
        }
        exports1.getOptions = getOptions;
    },
    "../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-globber.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        var __asyncValues = this && this.__asyncValues || function(o) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var m = o[Symbol.asyncIterator], i;
            return m ? m.call(o) : (o = "function" == typeof __values ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i);
            function verb(n) {
                i[n] = o[n] && function(v) {
                    return new Promise(function(resolve, reject) {
                        v = o[n](v), settle(resolve, reject, v.done, v.value);
                    });
                };
            }
            function settle(resolve, reject, d, v) {
                Promise.resolve(v).then(function(v) {
                    resolve({
                        value: v,
                        done: d
                    });
                }, reject);
            }
        };
        var __await = this && this.__await || function(v) {
            return this instanceof __await ? (this.v = v, this) : new __await(v);
        };
        var __asyncGenerator = this && this.__asyncGenerator || function(thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var g = generator.apply(thisArg, _arguments || []), i, q = [];
            return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i;
            function verb(n) {
                if (g[n]) i[n] = function(v) {
                    return new Promise(function(a, b) {
                        q.push([
                            n,
                            v,
                            a,
                            b
                        ]) > 1 || resume(n, v);
                    });
                };
            }
            function resume(n, v) {
                try {
                    step(g[n](v));
                } catch (e) {
                    settle(q[0][3], e);
                }
            }
            function step(r) {
                r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
            }
            function fulfill(value) {
                resume("next", value);
            }
            function reject(value) {
                resume("throw", value);
            }
            function settle(f, v) {
                if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
            }
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.DefaultGlobber = void 0;
        const core = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"));
        const fs = __importStar(__webpack_require__("fs"));
        const globOptionsHelper = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-glob-options-helper.js"));
        const path = __importStar(__webpack_require__("path"));
        const patternHelper = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-pattern-helper.js"));
        const internal_match_kind_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-match-kind.js");
        const internal_pattern_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-pattern.js");
        const internal_search_state_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-search-state.js");
        const IS_WINDOWS = 'win32' === process.platform;
        class DefaultGlobber {
            constructor(options){
                this.patterns = [];
                this.searchPaths = [];
                this.options = globOptionsHelper.getOptions(options);
            }
            getSearchPaths() {
                return this.searchPaths.slice();
            }
            glob() {
                var e_1, _a;
                return __awaiter(this, void 0, void 0, function*() {
                    const result = [];
                    try {
                        for(var _b = __asyncValues(this.globGenerator()), _c; _c = yield _b.next(), !_c.done;){
                            const itemPath = _c.value;
                            result.push(itemPath);
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally{
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                        } finally{
                            if (e_1) throw e_1.error;
                        }
                    }
                    return result;
                });
            }
            globGenerator() {
                return __asyncGenerator(this, arguments, function*() {
                    const options = globOptionsHelper.getOptions(this.options);
                    const patterns = [];
                    for (const pattern of this.patterns){
                        patterns.push(pattern);
                        if (options.implicitDescendants && (pattern.trailingSeparator || '**' !== pattern.segments[pattern.segments.length - 1])) patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat('**')));
                    }
                    const stack = [];
                    for (const searchPath of patternHelper.getSearchPaths(patterns)){
                        core.debug(`Search path '${searchPath}'`);
                        try {
                            yield __await(fs.promises.lstat(searchPath));
                        } catch (err) {
                            if ('ENOENT' === err.code) continue;
                            throw err;
                        }
                        stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
                    }
                    const traversalChain = [];
                    while(stack.length){
                        const item = stack.pop();
                        const match = patternHelper.match(patterns, item.path);
                        const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
                        if (!match && !partialMatch) continue;
                        const stats = yield __await(DefaultGlobber.stat(item, options, traversalChain));
                        if (!stats) continue;
                        if (stats.isDirectory()) {
                            if (match & internal_match_kind_1.MatchKind.Directory) yield yield __await(item.path);
                            else if (!partialMatch) continue;
                            const childLevel = item.level + 1;
                            const childItems = (yield __await(fs.promises.readdir(item.path))).map((x)=>new internal_search_state_1.SearchState(path.join(item.path, x), childLevel));
                            stack.push(...childItems.reverse());
                        } else if (match & internal_match_kind_1.MatchKind.File) yield yield __await(item.path);
                    }
                });
            }
            static create(patterns, options) {
                return __awaiter(this, void 0, void 0, function*() {
                    const result = new DefaultGlobber(options);
                    if (IS_WINDOWS) {
                        patterns = patterns.replace(/\r\n/g, '\n');
                        patterns = patterns.replace(/\r/g, '\n');
                    }
                    const lines = patterns.split('\n').map((x)=>x.trim());
                    for (const line of lines)if (!line || line.startsWith('#')) continue;
                    else result.patterns.push(new internal_pattern_1.Pattern(line));
                    result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
                    return result;
                });
            }
            static stat(item, options, traversalChain) {
                return __awaiter(this, void 0, void 0, function*() {
                    let stats;
                    if (options.followSymbolicLinks) try {
                        stats = yield fs.promises.stat(item.path);
                    } catch (err) {
                        if ('ENOENT' === err.code) {
                            if (options.omitBrokenSymbolicLinks) return void core.debug(`Broken symlink '${item.path}'`);
                            throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
                        }
                        throw err;
                    }
                    else stats = yield fs.promises.lstat(item.path);
                    if (stats.isDirectory() && options.followSymbolicLinks) {
                        const realPath = yield fs.promises.realpath(item.path);
                        while(traversalChain.length >= item.level)traversalChain.pop();
                        if (traversalChain.some((x)=>x === realPath)) return void core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
                        traversalChain.push(realPath);
                    }
                    return stats;
                });
            }
        }
        exports1.DefaultGlobber = DefaultGlobber;
    },
    "../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-match-kind.js" (__unused_rspack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.MatchKind = void 0;
        (function(MatchKind) {
            MatchKind[MatchKind["None"] = 0] = "None";
            MatchKind[MatchKind["Directory"] = 1] = "Directory";
            MatchKind[MatchKind["File"] = 2] = "File";
            MatchKind[MatchKind["All"] = 3] = "All";
        })(exports1.MatchKind || (exports1.MatchKind = {}));
    },
    "../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-path-helper.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.safeTrimTrailingSeparator = exports1.normalizeSeparators = exports1.hasRoot = exports1.hasAbsoluteRoot = exports1.ensureAbsoluteRoot = exports1.dirname = void 0;
        const path = __importStar(__webpack_require__("path"));
        const assert_1 = __importDefault(__webpack_require__("assert"));
        const IS_WINDOWS = 'win32' === process.platform;
        function dirname(p) {
            p = safeTrimTrailingSeparator(p);
            if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) return p;
            let result = path.dirname(p);
            if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) result = safeTrimTrailingSeparator(result);
            return result;
        }
        exports1.dirname = dirname;
        function ensureAbsoluteRoot(root, itemPath) {
            assert_1.default(root, "ensureAbsoluteRoot parameter 'root' must not be empty");
            assert_1.default(itemPath, "ensureAbsoluteRoot parameter 'itemPath' must not be empty");
            if (hasAbsoluteRoot(itemPath)) return itemPath;
            if (IS_WINDOWS) {
                if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
                    let cwd = process.cwd();
                    assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
                    if (itemPath[0].toUpperCase() !== cwd[0].toUpperCase()) return `${itemPath[0]}:\\${itemPath.substr(2)}`;
                    if (2 === itemPath.length) return `${itemPath[0]}:\\${cwd.substr(3)}`;
                    if (!cwd.endsWith('\\')) cwd += '\\';
                    return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
                } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
                    const cwd = process.cwd();
                    assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
                    return `${cwd[0]}:\\${itemPath.substr(1)}`;
                }
            }
            assert_1.default(hasAbsoluteRoot(root), "ensureAbsoluteRoot parameter 'root' must have an absolute root");
            root.endsWith('/') || IS_WINDOWS && root.endsWith('\\') || (root += path.sep);
            return root + itemPath;
        }
        exports1.ensureAbsoluteRoot = ensureAbsoluteRoot;
        function hasAbsoluteRoot(itemPath) {
            assert_1.default(itemPath, "hasAbsoluteRoot parameter 'itemPath' must not be empty");
            itemPath = normalizeSeparators(itemPath);
            if (IS_WINDOWS) return itemPath.startsWith('\\\\') || /^[A-Z]:\\/i.test(itemPath);
            return itemPath.startsWith('/');
        }
        exports1.hasAbsoluteRoot = hasAbsoluteRoot;
        function hasRoot(itemPath) {
            assert_1.default(itemPath, "isRooted parameter 'itemPath' must not be empty");
            itemPath = normalizeSeparators(itemPath);
            if (IS_WINDOWS) return itemPath.startsWith('\\') || /^[A-Z]:/i.test(itemPath);
            return itemPath.startsWith('/');
        }
        exports1.hasRoot = hasRoot;
        function normalizeSeparators(p) {
            p = p || '';
            if (IS_WINDOWS) {
                p = p.replace(/\//g, '\\');
                const isUnc = /^\\\\+[^\\]/.test(p);
                return (isUnc ? '\\' : '') + p.replace(/\\\\+/g, '\\');
            }
            return p.replace(/\/\/+/g, '/');
        }
        exports1.normalizeSeparators = normalizeSeparators;
        function safeTrimTrailingSeparator(p) {
            if (!p) return '';
            p = normalizeSeparators(p);
            if (!p.endsWith(path.sep)) return p;
            if (p === path.sep) return p;
            if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) return p;
            return p.substr(0, p.length - 1);
        }
        exports1.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
    },
    "../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-path.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Path = void 0;
        const path = __importStar(__webpack_require__("path"));
        const pathHelper = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-path-helper.js"));
        const assert_1 = __importDefault(__webpack_require__("assert"));
        const IS_WINDOWS = 'win32' === process.platform;
        class Path {
            constructor(itemPath){
                this.segments = [];
                if ('string' == typeof itemPath) {
                    assert_1.default(itemPath, "Parameter 'itemPath' must not be empty");
                    itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
                    if (pathHelper.hasRoot(itemPath)) {
                        let remaining = itemPath;
                        let dir = pathHelper.dirname(remaining);
                        while(dir !== remaining){
                            const basename = path.basename(remaining);
                            this.segments.unshift(basename);
                            remaining = dir;
                            dir = pathHelper.dirname(remaining);
                        }
                        this.segments.unshift(remaining);
                    } else this.segments = itemPath.split(path.sep);
                } else {
                    assert_1.default(itemPath.length > 0, "Parameter 'itemPath' must not be an empty array");
                    for(let i = 0; i < itemPath.length; i++){
                        let segment = itemPath[i];
                        assert_1.default(segment, "Parameter 'itemPath' must not contain any empty segments");
                        segment = pathHelper.normalizeSeparators(itemPath[i]);
                        if (0 === i && pathHelper.hasRoot(segment)) {
                            segment = pathHelper.safeTrimTrailingSeparator(segment);
                            assert_1.default(segment === pathHelper.dirname(segment), "Parameter 'itemPath' root segment contains information for multiple segments");
                            this.segments.push(segment);
                        } else {
                            assert_1.default(!segment.includes(path.sep), "Parameter 'itemPath' contains unexpected path separators");
                            this.segments.push(segment);
                        }
                    }
                }
            }
            toString() {
                let result = this.segments[0];
                let skipSlash = result.endsWith(path.sep) || IS_WINDOWS && /^[A-Z]:$/i.test(result);
                for(let i = 1; i < this.segments.length; i++){
                    if (skipSlash) skipSlash = false;
                    else result += path.sep;
                    result += this.segments[i];
                }
                return result;
            }
        }
        exports1.Path = Path;
    },
    "../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-pattern-helper.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.partialMatch = exports1.match = exports1.getSearchPaths = void 0;
        const pathHelper = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-path-helper.js"));
        const internal_match_kind_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-match-kind.js");
        const IS_WINDOWS = 'win32' === process.platform;
        function getSearchPaths(patterns) {
            patterns = patterns.filter((x)=>!x.negate);
            const searchPathMap = {};
            for (const pattern of patterns){
                const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
                searchPathMap[key] = 'candidate';
            }
            const result = [];
            for (const pattern of patterns){
                const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
                if ('included' === searchPathMap[key]) continue;
                let foundAncestor = false;
                let tempKey = key;
                let parent = pathHelper.dirname(tempKey);
                while(parent !== tempKey){
                    if (searchPathMap[parent]) {
                        foundAncestor = true;
                        break;
                    }
                    tempKey = parent;
                    parent = pathHelper.dirname(tempKey);
                }
                if (!foundAncestor) {
                    result.push(pattern.searchPath);
                    searchPathMap[key] = 'included';
                }
            }
            return result;
        }
        exports1.getSearchPaths = getSearchPaths;
        function match(patterns, itemPath) {
            let result = internal_match_kind_1.MatchKind.None;
            for (const pattern of patterns)if (pattern.negate) result &= ~pattern.match(itemPath);
            else result |= pattern.match(itemPath);
            return result;
        }
        exports1.match = match;
        function partialMatch(patterns, itemPath) {
            return patterns.some((x)=>!x.negate && x.partialMatch(itemPath));
        }
        exports1.partialMatch = partialMatch;
    },
    "../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-pattern.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Pattern = void 0;
        const os = __importStar(__webpack_require__("os"));
        const path = __importStar(__webpack_require__("path"));
        const pathHelper = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-path-helper.js"));
        const assert_1 = __importDefault(__webpack_require__("assert"));
        const minimatch_1 = __webpack_require__("../../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js");
        const internal_match_kind_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-match-kind.js");
        const internal_path_1 = __webpack_require__("../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-path.js");
        const IS_WINDOWS = 'win32' === process.platform;
        class Pattern {
            constructor(patternOrNegate, isImplicitPattern = false, segments, homedir){
                this.negate = false;
                let pattern;
                if ('string' == typeof patternOrNegate) pattern = patternOrNegate.trim();
                else {
                    segments = segments || [];
                    assert_1.default(segments.length, "Parameter 'segments' must not empty");
                    const root = Pattern.getLiteral(segments[0]);
                    assert_1.default(root && pathHelper.hasAbsoluteRoot(root), "Parameter 'segments' first element must be a root path");
                    pattern = new internal_path_1.Path(segments).toString().trim();
                    if (patternOrNegate) pattern = `!${pattern}`;
                }
                while(pattern.startsWith('!')){
                    this.negate = !this.negate;
                    pattern = pattern.substr(1).trim();
                }
                pattern = Pattern.fixupPattern(pattern, homedir);
                this.segments = new internal_path_1.Path(pattern).segments;
                this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path.sep);
                pattern = pathHelper.safeTrimTrailingSeparator(pattern);
                let foundGlob = false;
                const searchSegments = this.segments.map((x)=>Pattern.getLiteral(x)).filter((x)=>!foundGlob && !(foundGlob = '' === x));
                this.searchPath = new internal_path_1.Path(searchSegments).toString();
                this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? 'i' : '');
                this.isImplicitPattern = isImplicitPattern;
                const minimatchOptions = {
                    dot: true,
                    nobrace: true,
                    nocase: IS_WINDOWS,
                    nocomment: true,
                    noext: true,
                    nonegate: true
                };
                pattern = IS_WINDOWS ? pattern.replace(/\\/g, '/') : pattern;
                this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
            }
            match(itemPath) {
                if ('**' === this.segments[this.segments.length - 1]) {
                    itemPath = pathHelper.normalizeSeparators(itemPath);
                    if (!itemPath.endsWith(path.sep) && false === this.isImplicitPattern) itemPath = `${itemPath}${path.sep}`;
                } else itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
                if (this.minimatch.match(itemPath)) return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
                return internal_match_kind_1.MatchKind.None;
            }
            partialMatch(itemPath) {
                itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
                if (pathHelper.dirname(itemPath) === itemPath) return this.rootRegExp.test(itemPath);
                return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
            }
            static globEscape(s) {
                return (IS_WINDOWS ? s : s.replace(/\\/g, '\\\\')).replace(/(\[)(?=[^/]+\])/g, '[[]').replace(/\?/g, '[?]').replace(/\*/g, '[*]');
            }
            static fixupPattern(pattern, homedir) {
                assert_1.default(pattern, 'pattern cannot be empty');
                const literalSegments = new internal_path_1.Path(pattern).segments.map((x)=>Pattern.getLiteral(x));
                assert_1.default(literalSegments.every((x, i)=>('.' !== x || 0 === i) && '..' !== x), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
                assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
                pattern = pathHelper.normalizeSeparators(pattern);
                if ('.' === pattern || pattern.startsWith(`.${path.sep}`)) pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
                else if ('~' === pattern || pattern.startsWith(`~${path.sep}`)) {
                    homedir = homedir || os.homedir();
                    assert_1.default(homedir, 'Unable to determine HOME directory');
                    assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
                    pattern = Pattern.globEscape(homedir) + pattern.substr(1);
                } else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
                    let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', pattern.substr(0, 2));
                    if (pattern.length > 2 && !root.endsWith('\\')) root += '\\';
                    pattern = Pattern.globEscape(root) + pattern.substr(2);
                } else if (IS_WINDOWS && ('\\' === pattern || pattern.match(/^\\[^\\]/))) {
                    let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', '\\');
                    if (!root.endsWith('\\')) root += '\\';
                    pattern = Pattern.globEscape(root) + pattern.substr(1);
                } else pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
                return pathHelper.normalizeSeparators(pattern);
            }
            static getLiteral(segment) {
                let literal = '';
                for(let i = 0; i < segment.length; i++){
                    const c = segment[i];
                    if ('\\' === c && !IS_WINDOWS && i + 1 < segment.length) {
                        literal += segment[++i];
                        continue;
                    }
                    if ('*' === c || '?' === c) return '';
                    if ('[' === c && i + 1 < segment.length) {
                        let set = '';
                        let closed = -1;
                        for(let i2 = i + 1; i2 < segment.length; i2++){
                            const c2 = segment[i2];
                            if ('\\' === c2 && !IS_WINDOWS && i2 + 1 < segment.length) {
                                set += segment[++i2];
                                continue;
                            }
                            if (']' === c2) {
                                closed = i2;
                                break;
                            }
                            set += c2;
                        }
                        if (closed >= 0) {
                            if (set.length > 1) return '';
                            if (set) {
                                literal += set;
                                i = closed;
                                continue;
                            }
                        }
                    }
                    literal += c;
                }
                return literal;
            }
            static regExpEscape(s) {
                return s.replace(/[[\\^$.|?*+()]/g, '\\$&');
            }
        }
        exports1.Pattern = Pattern;
    },
    "../../../node_modules/.pnpm/@actions+glob@0.1.2/node_modules/@actions/glob/lib/internal-search-state.js" (__unused_rspack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.SearchState = void 0;
        class SearchState {
            constructor(path, level){
                this.path = path;
                this.level = level;
            }
        }
        exports1.SearchState = SearchState;
    },
    "../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/auth.js" (__unused_rspack_module, exports1) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.PersonalAccessTokenCredentialHandler = exports1.BearerCredentialHandler = exports1.BasicCredentialHandler = void 0;
        class BasicCredentialHandler {
            constructor(username, password){
                this.username = username;
                this.password = password;
            }
            prepareRequest(options) {
                if (!options.headers) throw Error('The request has no headers');
                options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
            }
            canHandleAuthentication() {
                return false;
            }
            handleAuthentication() {
                return __awaiter(this, void 0, void 0, function*() {
                    throw new Error('not implemented');
                });
            }
        }
        exports1.BasicCredentialHandler = BasicCredentialHandler;
        class BearerCredentialHandler {
            constructor(token){
                this.token = token;
            }
            prepareRequest(options) {
                if (!options.headers) throw Error('The request has no headers');
                options.headers['Authorization'] = `Bearer ${this.token}`;
            }
            canHandleAuthentication() {
                return false;
            }
            handleAuthentication() {
                return __awaiter(this, void 0, void 0, function*() {
                    throw new Error('not implemented');
                });
            }
        }
        exports1.BearerCredentialHandler = BearerCredentialHandler;
        class PersonalAccessTokenCredentialHandler {
            constructor(token){
                this.token = token;
            }
            prepareRequest(options) {
                if (!options.headers) throw Error('The request has no headers');
                options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
            }
            canHandleAuthentication() {
                return false;
            }
            handleAuthentication() {
                return __awaiter(this, void 0, void 0, function*() {
                    throw new Error('not implemented');
                });
            }
        }
        exports1.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
    },
    "../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/index.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.HttpClient = exports1.isHttps = exports1.HttpClientResponse = exports1.HttpClientError = exports1.getProxyUrl = exports1.MediaTypes = exports1.Headers = exports1.HttpCodes = void 0;
        const http = __importStar(__webpack_require__("http"));
        const https = __importStar(__webpack_require__("https"));
        const pm = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/proxy.js"));
        const tunnel = __importStar(__webpack_require__("../../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js"));
        const undici_1 = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js");
        var HttpCodes;
        (function(HttpCodes) {
            HttpCodes[HttpCodes["OK"] = 200] = "OK";
            HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
            HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
            HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
            HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
            HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
            HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
            HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
            HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
            HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
            HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
            HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
            HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
            HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
            HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
            HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
            HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
            HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
            HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
            HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
            HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
            HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
            HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
            HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
            HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
            HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
            HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
        })(HttpCodes || (exports1.HttpCodes = HttpCodes = {}));
        var Headers;
        (function(Headers) {
            Headers["Accept"] = "accept";
            Headers["ContentType"] = "content-type";
        })(Headers || (exports1.Headers = Headers = {}));
        var MediaTypes;
        (function(MediaTypes) {
            MediaTypes["ApplicationJson"] = "application/json";
        })(MediaTypes || (exports1.MediaTypes = MediaTypes = {}));
        function getProxyUrl(serverUrl) {
            const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
            return proxyUrl ? proxyUrl.href : '';
        }
        exports1.getProxyUrl = getProxyUrl;
        const HttpRedirectCodes = [
            HttpCodes.MovedPermanently,
            HttpCodes.ResourceMoved,
            HttpCodes.SeeOther,
            HttpCodes.TemporaryRedirect,
            HttpCodes.PermanentRedirect
        ];
        const HttpResponseRetryCodes = [
            HttpCodes.BadGateway,
            HttpCodes.ServiceUnavailable,
            HttpCodes.GatewayTimeout
        ];
        const RetryableHttpVerbs = [
            'OPTIONS',
            'GET',
            'DELETE',
            'HEAD'
        ];
        const ExponentialBackoffCeiling = 10;
        const ExponentialBackoffTimeSlice = 5;
        class HttpClientError extends Error {
            constructor(message, statusCode){
                super(message);
                this.name = 'HttpClientError';
                this.statusCode = statusCode;
                Object.setPrototypeOf(this, HttpClientError.prototype);
            }
        }
        exports1.HttpClientError = HttpClientError;
        class HttpClientResponse {
            constructor(message){
                this.message = message;
            }
            readBody() {
                return __awaiter(this, void 0, void 0, function*() {
                    return new Promise((resolve)=>__awaiter(this, void 0, void 0, function*() {
                            let output = Buffer.alloc(0);
                            this.message.on('data', (chunk)=>{
                                output = Buffer.concat([
                                    output,
                                    chunk
                                ]);
                            });
                            this.message.on('end', ()=>{
                                resolve(output.toString());
                            });
                        }));
                });
            }
            readBodyBuffer() {
                return __awaiter(this, void 0, void 0, function*() {
                    return new Promise((resolve)=>__awaiter(this, void 0, void 0, function*() {
                            const chunks = [];
                            this.message.on('data', (chunk)=>{
                                chunks.push(chunk);
                            });
                            this.message.on('end', ()=>{
                                resolve(Buffer.concat(chunks));
                            });
                        }));
                });
            }
        }
        exports1.HttpClientResponse = HttpClientResponse;
        function isHttps(requestUrl) {
            const parsedUrl = new URL(requestUrl);
            return 'https:' === parsedUrl.protocol;
        }
        exports1.isHttps = isHttps;
        class HttpClient {
            constructor(userAgent, handlers, requestOptions){
                this._ignoreSslError = false;
                this._allowRedirects = true;
                this._allowRedirectDowngrade = false;
                this._maxRedirects = 50;
                this._allowRetries = false;
                this._maxRetries = 1;
                this._keepAlive = false;
                this._disposed = false;
                this.userAgent = userAgent;
                this.handlers = handlers || [];
                this.requestOptions = requestOptions;
                if (requestOptions) {
                    if (null != requestOptions.ignoreSslError) this._ignoreSslError = requestOptions.ignoreSslError;
                    this._socketTimeout = requestOptions.socketTimeout;
                    if (null != requestOptions.allowRedirects) this._allowRedirects = requestOptions.allowRedirects;
                    if (null != requestOptions.allowRedirectDowngrade) this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
                    if (null != requestOptions.maxRedirects) this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
                    if (null != requestOptions.keepAlive) this._keepAlive = requestOptions.keepAlive;
                    if (null != requestOptions.allowRetries) this._allowRetries = requestOptions.allowRetries;
                    if (null != requestOptions.maxRetries) this._maxRetries = requestOptions.maxRetries;
                }
            }
            options(requestUrl, additionalHeaders) {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
                });
            }
            get(requestUrl, additionalHeaders) {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.request('GET', requestUrl, null, additionalHeaders || {});
                });
            }
            del(requestUrl, additionalHeaders) {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.request('DELETE', requestUrl, null, additionalHeaders || {});
                });
            }
            post(requestUrl, data, additionalHeaders) {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.request('POST', requestUrl, data, additionalHeaders || {});
                });
            }
            patch(requestUrl, data, additionalHeaders) {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.request('PATCH', requestUrl, data, additionalHeaders || {});
                });
            }
            put(requestUrl, data, additionalHeaders) {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.request('PUT', requestUrl, data, additionalHeaders || {});
                });
            }
            head(requestUrl, additionalHeaders) {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.request('HEAD', requestUrl, null, additionalHeaders || {});
                });
            }
            sendStream(verb, requestUrl, stream, additionalHeaders) {
                return __awaiter(this, void 0, void 0, function*() {
                    return this.request(verb, requestUrl, stream, additionalHeaders);
                });
            }
            getJson(requestUrl, additionalHeaders = {}) {
                return __awaiter(this, void 0, void 0, function*() {
                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                    const res = yield this.get(requestUrl, additionalHeaders);
                    return this._processResponse(res, this.requestOptions);
                });
            }
            postJson(requestUrl, obj, additionalHeaders = {}) {
                return __awaiter(this, void 0, void 0, function*() {
                    const data = JSON.stringify(obj, null, 2);
                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
                    const res = yield this.post(requestUrl, data, additionalHeaders);
                    return this._processResponse(res, this.requestOptions);
                });
            }
            putJson(requestUrl, obj, additionalHeaders = {}) {
                return __awaiter(this, void 0, void 0, function*() {
                    const data = JSON.stringify(obj, null, 2);
                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
                    const res = yield this.put(requestUrl, data, additionalHeaders);
                    return this._processResponse(res, this.requestOptions);
                });
            }
            patchJson(requestUrl, obj, additionalHeaders = {}) {
                return __awaiter(this, void 0, void 0, function*() {
                    const data = JSON.stringify(obj, null, 2);
                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
                    const res = yield this.patch(requestUrl, data, additionalHeaders);
                    return this._processResponse(res, this.requestOptions);
                });
            }
            request(verb, requestUrl, data, headers) {
                return __awaiter(this, void 0, void 0, function*() {
                    if (this._disposed) throw new Error('Client has already been disposed.');
                    const parsedUrl = new URL(requestUrl);
                    let info = this._prepareRequest(verb, parsedUrl, headers);
                    const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
                    let numTries = 0;
                    let response;
                    do {
                        response = yield this.requestRaw(info, data);
                        if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
                            let authenticationHandler;
                            for (const handler of this.handlers)if (handler.canHandleAuthentication(response)) {
                                authenticationHandler = handler;
                                break;
                            }
                            if (authenticationHandler) return authenticationHandler.handleAuthentication(this, info, data);
                            break;
                        }
                        let redirectsRemaining = this._maxRedirects;
                        while(response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0){
                            const redirectUrl = response.message.headers['location'];
                            if (!redirectUrl) break;
                            const parsedRedirectUrl = new URL(redirectUrl);
                            if ('https:' === parsedUrl.protocol && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                            yield response.readBody();
                            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                                for(const header in headers)if ('authorization' === header.toLowerCase()) delete headers[header];
                            }
                            info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                            response = yield this.requestRaw(info, data);
                            redirectsRemaining--;
                        }
                        if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) break;
                        numTries += 1;
                        if (numTries < maxTries) {
                            yield response.readBody();
                            yield this._performExponentialBackoff(numTries);
                        }
                    }while (numTries < maxTries);
                    return response;
                });
            }
            dispose() {
                if (this._agent) this._agent.destroy();
                this._disposed = true;
            }
            requestRaw(info, data) {
                return __awaiter(this, void 0, void 0, function*() {
                    return new Promise((resolve, reject)=>{
                        function callbackForResult(err, res) {
                            if (err) reject(err);
                            else if (res) resolve(res);
                            else reject(new Error('Unknown error'));
                        }
                        this.requestRawWithCallback(info, data, callbackForResult);
                    });
                });
            }
            requestRawWithCallback(info, data, onResult) {
                if ('string' == typeof data) {
                    if (!info.options.headers) info.options.headers = {};
                    info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
                }
                let callbackCalled = false;
                function handleResult(err, res) {
                    if (!callbackCalled) {
                        callbackCalled = true;
                        onResult(err, res);
                    }
                }
                const req = info.httpModule.request(info.options, (msg)=>{
                    const res = new HttpClientResponse(msg);
                    handleResult(void 0, res);
                });
                let socket;
                req.on('socket', (sock)=>{
                    socket = sock;
                });
                req.setTimeout(this._socketTimeout || 180000, ()=>{
                    if (socket) socket.end();
                    handleResult(new Error(`Request timeout: ${info.options.path}`));
                });
                req.on('error', function(err) {
                    handleResult(err);
                });
                if (data && 'string' == typeof data) req.write(data, 'utf8');
                if (data && 'string' != typeof data) {
                    data.on('close', function() {
                        req.end();
                    });
                    data.pipe(req);
                } else req.end();
            }
            getAgent(serverUrl) {
                const parsedUrl = new URL(serverUrl);
                return this._getAgent(parsedUrl);
            }
            getAgentDispatcher(serverUrl) {
                const parsedUrl = new URL(serverUrl);
                const proxyUrl = pm.getProxyUrl(parsedUrl);
                const useProxy = proxyUrl && proxyUrl.hostname;
                if (!useProxy) return;
                return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
            }
            _prepareRequest(method, requestUrl, headers) {
                const info = {};
                info.parsedUrl = requestUrl;
                const usingSsl = 'https:' === info.parsedUrl.protocol;
                info.httpModule = usingSsl ? https : http;
                const defaultPort = usingSsl ? 443 : 80;
                info.options = {};
                info.options.host = info.parsedUrl.hostname;
                info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
                info.options.path = (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
                info.options.method = method;
                info.options.headers = this._mergeHeaders(headers);
                if (null != this.userAgent) info.options.headers['user-agent'] = this.userAgent;
                info.options.agent = this._getAgent(info.parsedUrl);
                if (this.handlers) for (const handler of this.handlers)handler.prepareRequest(info.options);
                return info;
            }
            _mergeHeaders(headers) {
                if (this.requestOptions && this.requestOptions.headers) return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
                return lowercaseKeys(headers || {});
            }
            _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
                let clientHeader;
                if (this.requestOptions && this.requestOptions.headers) clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
                return additionalHeaders[header] || clientHeader || _default;
            }
            _getAgent(parsedUrl) {
                let agent;
                const proxyUrl = pm.getProxyUrl(parsedUrl);
                const useProxy = proxyUrl && proxyUrl.hostname;
                if (this._keepAlive && useProxy) agent = this._proxyAgent;
                if (!useProxy) agent = this._agent;
                if (agent) return agent;
                const usingSsl = 'https:' === parsedUrl.protocol;
                let maxSockets = 100;
                if (this.requestOptions) maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
                if (proxyUrl && proxyUrl.hostname) {
                    const agentOptions = {
                        maxSockets,
                        keepAlive: this._keepAlive,
                        proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
                            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                        }), {
                            host: proxyUrl.hostname,
                            port: proxyUrl.port
                        })
                    };
                    let tunnelAgent;
                    const overHttps = 'https:' === proxyUrl.protocol;
                    tunnelAgent = usingSsl ? overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp : overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
                    agent = tunnelAgent(agentOptions);
                    this._proxyAgent = agent;
                }
                if (!agent) {
                    const options = {
                        keepAlive: this._keepAlive,
                        maxSockets
                    };
                    agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
                    this._agent = agent;
                }
                if (usingSsl && this._ignoreSslError) agent.options = Object.assign(agent.options || {}, {
                    rejectUnauthorized: false
                });
                return agent;
            }
            _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
                let proxyAgent;
                if (this._keepAlive) proxyAgent = this._proxyAgentDispatcher;
                if (proxyAgent) return proxyAgent;
                const usingSsl = 'https:' === parsedUrl.protocol;
                proxyAgent = new undici_1.ProxyAgent(Object.assign({
                    uri: proxyUrl.href,
                    pipelining: this._keepAlive ? 1 : 0
                }, (proxyUrl.username || proxyUrl.password) && {
                    token: `${proxyUrl.username}:${proxyUrl.password}`
                }));
                this._proxyAgentDispatcher = proxyAgent;
                if (usingSsl && this._ignoreSslError) proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
                    rejectUnauthorized: false
                });
                return proxyAgent;
            }
            _performExponentialBackoff(retryNumber) {
                return __awaiter(this, void 0, void 0, function*() {
                    retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
                    const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
                    return new Promise((resolve)=>setTimeout(()=>resolve(), ms));
                });
            }
            _processResponse(res, options) {
                return __awaiter(this, void 0, void 0, function*() {
                    return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                            const statusCode = res.message.statusCode || 0;
                            const response = {
                                statusCode,
                                result: null,
                                headers: {}
                            };
                            if (statusCode === HttpCodes.NotFound) resolve(response);
                            function dateTimeDeserializer(key, value) {
                                if ('string' == typeof value) {
                                    const a = new Date(value);
                                    if (!isNaN(a.valueOf())) return a;
                                }
                                return value;
                            }
                            let obj;
                            let contents;
                            try {
                                contents = yield res.readBody();
                                if (contents && contents.length > 0) {
                                    obj = options && options.deserializeDates ? JSON.parse(contents, dateTimeDeserializer) : JSON.parse(contents);
                                    response.result = obj;
                                }
                                response.headers = res.message.headers;
                            } catch (err) {}
                            if (statusCode > 299) {
                                let msg;
                                msg = obj && obj.message ? obj.message : contents && contents.length > 0 ? contents : `Failed request: (${statusCode})`;
                                const err = new HttpClientError(msg, statusCode);
                                err.result = response.result;
                                reject(err);
                            } else resolve(response);
                        }));
                });
            }
        }
        exports1.HttpClient = HttpClient;
        const lowercaseKeys = (obj)=>Object.keys(obj).reduce((c, k)=>(c[k.toLowerCase()] = obj[k], c), {});
    },
    "../../../node_modules/.pnpm/@actions+http-client@2.2.1/node_modules/@actions/http-client/lib/proxy.js" (__unused_rspack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.checkBypass = exports1.getProxyUrl = void 0;
        function getProxyUrl(reqUrl) {
            const usingSsl = 'https:' === reqUrl.protocol;
            if (checkBypass(reqUrl)) return;
            const proxyVar = (()=>{
                if (usingSsl) return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
                return process.env['http_proxy'] || process.env['HTTP_PROXY'];
            })();
            if (!proxyVar) return;
            try {
                return new URL(proxyVar);
            } catch (_a) {
                if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://')) return new URL(`http://${proxyVar}`);
            }
        }
        exports1.getProxyUrl = getProxyUrl;
        function checkBypass(reqUrl) {
            if (!reqUrl.hostname) return false;
            const reqHost = reqUrl.hostname;
            if (isLoopbackAddress(reqHost)) return true;
            const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
            if (!noProxy) return false;
            let reqPort;
            if (reqUrl.port) reqPort = Number(reqUrl.port);
            else if ('http:' === reqUrl.protocol) reqPort = 80;
            else if ('https:' === reqUrl.protocol) reqPort = 443;
            const upperReqHosts = [
                reqUrl.hostname.toUpperCase()
            ];
            if ('number' == typeof reqPort) upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
            for (const upperNoProxyItem of noProxy.split(',').map((x)=>x.trim().toUpperCase()).filter((x)=>x))if ('*' === upperNoProxyItem || upperReqHosts.some((x)=>x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith('.') && x.endsWith(`${upperNoProxyItem}`))) return true;
            return false;
        }
        exports1.checkBypass = checkBypass;
        function isLoopbackAddress(host) {
            const hostLower = host.toLowerCase();
            return 'localhost' === hostLower || hostLower.startsWith('127.') || hostLower.startsWith('[::1]') || hostLower.startsWith('[0:0:0:0:0:0:0:1]');
        }
    },
    "../../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        var _a;
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.getCmdPath = exports1.tryGetExecutablePath = exports1.isRooted = exports1.isDirectory = exports1.exists = exports1.READONLY = exports1.UV_FS_O_EXLOCK = exports1.IS_WINDOWS = exports1.unlink = exports1.symlink = exports1.stat = exports1.rmdir = exports1.rm = exports1.rename = exports1.readlink = exports1.readdir = exports1.open = exports1.mkdir = exports1.lstat = exports1.copyFile = exports1.chmod = void 0;
        const fs = __importStar(__webpack_require__("fs"));
        const path = __importStar(__webpack_require__("path"));
        _a = fs.promises, exports1.chmod = _a.chmod, exports1.copyFile = _a.copyFile, exports1.lstat = _a.lstat, exports1.mkdir = _a.mkdir, exports1.open = _a.open, exports1.readdir = _a.readdir, exports1.readlink = _a.readlink, exports1.rename = _a.rename, exports1.rm = _a.rm, exports1.rmdir = _a.rmdir, exports1.stat = _a.stat, exports1.symlink = _a.symlink, exports1.unlink = _a.unlink;
        exports1.IS_WINDOWS = 'win32' === process.platform;
        exports1.UV_FS_O_EXLOCK = 0x10000000;
        exports1.READONLY = fs.constants.O_RDONLY;
        function exists(fsPath) {
            return __awaiter(this, void 0, void 0, function*() {
                try {
                    yield exports1.stat(fsPath);
                } catch (err) {
                    if ('ENOENT' === err.code) return false;
                    throw err;
                }
                return true;
            });
        }
        exports1.exists = exists;
        function isDirectory(fsPath, useStat = false) {
            return __awaiter(this, void 0, void 0, function*() {
                const stats = useStat ? yield exports1.stat(fsPath) : yield exports1.lstat(fsPath);
                return stats.isDirectory();
            });
        }
        exports1.isDirectory = isDirectory;
        function isRooted(p) {
            p = normalizeSeparators(p);
            if (!p) throw new Error('isRooted() parameter "p" cannot be empty');
            if (exports1.IS_WINDOWS) return p.startsWith('\\') || /^[A-Z]:/i.test(p);
            return p.startsWith('/');
        }
        exports1.isRooted = isRooted;
        function tryGetExecutablePath(filePath, extensions) {
            return __awaiter(this, void 0, void 0, function*() {
                let stats;
                try {
                    stats = yield exports1.stat(filePath);
                } catch (err) {
                    if ('ENOENT' !== err.code) console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
                }
                if (stats && stats.isFile()) {
                    if (exports1.IS_WINDOWS) {
                        const upperExt = path.extname(filePath).toUpperCase();
                        if (extensions.some((validExt)=>validExt.toUpperCase() === upperExt)) return filePath;
                    } else if (isUnixExecutable(stats)) return filePath;
                }
                const originalFilePath = filePath;
                for (const extension of extensions){
                    filePath = originalFilePath + extension;
                    stats = void 0;
                    try {
                        stats = yield exports1.stat(filePath);
                    } catch (err) {
                        if ('ENOENT' !== err.code) console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
                    }
                    if (stats && stats.isFile()) {
                        if (exports1.IS_WINDOWS) {
                            try {
                                const directory = path.dirname(filePath);
                                const upperName = path.basename(filePath).toUpperCase();
                                for (const actualName of yield exports1.readdir(directory))if (upperName === actualName.toUpperCase()) {
                                    filePath = path.join(directory, actualName);
                                    break;
                                }
                            } catch (err) {
                                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
                            }
                            return filePath;
                        } else if (isUnixExecutable(stats)) return filePath;
                    }
                }
                return '';
            });
        }
        exports1.tryGetExecutablePath = tryGetExecutablePath;
        function normalizeSeparators(p) {
            p = p || '';
            if (exports1.IS_WINDOWS) {
                p = p.replace(/\//g, '\\');
                return p.replace(/\\\\+/g, '\\');
            }
            return p.replace(/\/\/+/g, '/');
        }
        function isUnixExecutable(stats) {
            return (1 & stats.mode) > 0 || (8 & stats.mode) > 0 && stats.gid === process.getgid() || (64 & stats.mode) > 0 && stats.uid === process.getuid();
        }
        function getCmdPath() {
            var _a;
            return null != (_a = process.env['COMSPEC']) ? _a : "cmd.exe";
        }
        exports1.getCmdPath = getCmdPath;
    },
    "../../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.findInPath = exports1.which = exports1.mkdirP = exports1.rmRF = exports1.mv = exports1.cp = void 0;
        const assert_1 = __webpack_require__("assert");
        const path = __importStar(__webpack_require__("path"));
        const ioUtil = __importStar(__webpack_require__("../../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js"));
        function cp(source, dest, options = {}) {
            return __awaiter(this, void 0, void 0, function*() {
                const { force, recursive, copySourceDirectory } = readCopyOptions(options);
                const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
                if (destStat && destStat.isFile() && !force) return;
                const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
                if (!(yield ioUtil.exists(source))) throw new Error(`no such file or directory: ${source}`);
                const sourceStat = yield ioUtil.stat(source);
                if (sourceStat.isDirectory()) if (recursive) yield cpDirRecursive(source, newDest, 0, force);
                else throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
                else {
                    if ('' === path.relative(source, newDest)) throw new Error(`'${newDest}' and '${source}' are the same file`);
                    yield copyFile(source, newDest, force);
                }
            });
        }
        exports1.cp = cp;
        function mv(source, dest, options = {}) {
            return __awaiter(this, void 0, void 0, function*() {
                if (yield ioUtil.exists(dest)) {
                    let destExists = true;
                    if (yield ioUtil.isDirectory(dest)) {
                        dest = path.join(dest, path.basename(source));
                        destExists = yield ioUtil.exists(dest);
                    }
                    if (destExists) if (null == options.force || options.force) yield rmRF(dest);
                    else throw new Error('Destination already exists');
                }
                yield mkdirP(path.dirname(dest));
                yield ioUtil.rename(source, dest);
            });
        }
        exports1.mv = mv;
        function rmRF(inputPath) {
            return __awaiter(this, void 0, void 0, function*() {
                if (ioUtil.IS_WINDOWS) {
                    if (/[*"<>|]/.test(inputPath)) throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
                }
                try {
                    yield ioUtil.rm(inputPath, {
                        force: true,
                        maxRetries: 3,
                        recursive: true,
                        retryDelay: 300
                    });
                } catch (err) {
                    throw new Error(`File was unable to be removed ${err}`);
                }
            });
        }
        exports1.rmRF = rmRF;
        function mkdirP(fsPath) {
            return __awaiter(this, void 0, void 0, function*() {
                assert_1.ok(fsPath, 'a path argument must be provided');
                yield ioUtil.mkdir(fsPath, {
                    recursive: true
                });
            });
        }
        exports1.mkdirP = mkdirP;
        function which(tool, check) {
            return __awaiter(this, void 0, void 0, function*() {
                if (!tool) throw new Error("parameter 'tool' is required");
                if (check) {
                    const result = yield which(tool, false);
                    if (!result) if (ioUtil.IS_WINDOWS) throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
                    else throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
                    return result;
                }
                const matches = yield findInPath(tool);
                if (matches && matches.length > 0) return matches[0];
                return '';
            });
        }
        exports1.which = which;
        function findInPath(tool) {
            return __awaiter(this, void 0, void 0, function*() {
                if (!tool) throw new Error("parameter 'tool' is required");
                const extensions = [];
                if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {
                    for (const extension of process.env['PATHEXT'].split(path.delimiter))if (extension) extensions.push(extension);
                }
                if (ioUtil.isRooted(tool)) {
                    const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
                    if (filePath) return [
                        filePath
                    ];
                    return [];
                }
                if (tool.includes(path.sep)) return [];
                const directories = [];
                if (process.env.PATH) {
                    for (const p of process.env.PATH.split(path.delimiter))if (p) directories.push(p);
                }
                const matches = [];
                for (const directory of directories){
                    const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
                    if (filePath) matches.push(filePath);
                }
                return matches;
            });
        }
        exports1.findInPath = findInPath;
        function readCopyOptions(options) {
            const force = null == options.force ? true : options.force;
            const recursive = Boolean(options.recursive);
            const copySourceDirectory = null == options.copySourceDirectory ? true : Boolean(options.copySourceDirectory);
            return {
                force,
                recursive,
                copySourceDirectory
            };
        }
        function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
            return __awaiter(this, void 0, void 0, function*() {
                if (currentDepth >= 255) return;
                currentDepth++;
                yield mkdirP(destDir);
                const files = yield ioUtil.readdir(sourceDir);
                for (const fileName of files){
                    const srcFile = `${sourceDir}/${fileName}`;
                    const destFile = `${destDir}/${fileName}`;
                    const srcFileStat = yield ioUtil.lstat(srcFile);
                    if (srcFileStat.isDirectory()) yield cpDirRecursive(srcFile, destFile, currentDepth, force);
                    else yield copyFile(srcFile, destFile, force);
                }
                yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
            });
        }
        function copyFile(srcFile, destFile, force) {
            return __awaiter(this, void 0, void 0, function*() {
                if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
                    try {
                        yield ioUtil.lstat(destFile);
                        yield ioUtil.unlink(destFile);
                    } catch (e) {
                        if ('EPERM' === e.code) {
                            yield ioUtil.chmod(destFile, '0666');
                            yield ioUtil.unlink(destFile);
                        }
                    }
                    const symlinkFull = yield ioUtil.readlink(srcFile);
                    yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);
                } else if (!(yield ioUtil.exists(destFile)) || force) yield ioUtil.copyFile(srcFile, destFile);
            });
        }
    },
    "../../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/AbortController.js" (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            l: ()=>AbortError,
            z: ()=>AbortController1
        });
        var _AbortSignal__rspack_import_0 = __webpack_require__("../../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js");
        class AbortError extends Error {
            constructor(message){
                super(message);
                this.name = "AbortError";
            }
        }
        class AbortController1 {
            constructor(parentSignals){
                this._signal = new _AbortSignal__rspack_import_0.h();
                if (!parentSignals) return;
                if (!Array.isArray(parentSignals)) parentSignals = arguments;
                for (const parentSignal of parentSignals)if (parentSignal.aborted) this.abort();
                else parentSignal.addEventListener("abort", ()=>{
                    this.abort();
                });
            }
            get signal() {
                return this._signal;
            }
            abort() {
                (0, _AbortSignal__rspack_import_0.d)(this._signal);
            }
            static timeout(ms) {
                const signal = new _AbortSignal__rspack_import_0.h();
                const timer = setTimeout(_AbortSignal__rspack_import_0.d, ms, signal);
                if ("function" == typeof timer.unref) timer.unref();
                return signal;
            }
        }
    },
    "../../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js" (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            d: ()=>abortSignal,
            h: ()=>AbortSignal1
        });
        const listenersMap = new WeakMap();
        const abortedMap = new WeakMap();
        class AbortSignal1 {
            constructor(){
                this.onabort = null;
                listenersMap.set(this, []);
                abortedMap.set(this, false);
            }
            get aborted() {
                if (!abortedMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
                return abortedMap.get(this);
            }
            static get none() {
                return new AbortSignal1();
            }
            addEventListener(_type, listener) {
                if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
                const listeners = listenersMap.get(this);
                listeners.push(listener);
            }
            removeEventListener(_type, listener) {
                if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
                const listeners = listenersMap.get(this);
                const index = listeners.indexOf(listener);
                if (index > -1) listeners.splice(index, 1);
            }
            dispatchEvent(_event) {
                throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
            }
        }
        function abortSignal(signal) {
            if (signal.aborted) return;
            if (signal.onabort) signal.onabort.call(signal);
            const listeners = listenersMap.get(signal);
            if (listeners) listeners.slice().forEach((listener)=>{
                listener.call(signal, {
                    type: "abort"
                });
            });
            abortedMap.set(signal, true);
        }
    },
    "../../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/index.js" (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            AbortController: ()=>_AbortController__rspack_import_0.z,
            AbortError: ()=>_AbortController__rspack_import_0.l,
            AbortSignal: ()=>_AbortSignal__rspack_import_1.h
        });
        var _AbortController__rspack_import_0 = __webpack_require__("../../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/AbortController.js");
        var _AbortSignal__rspack_import_1 = __webpack_require__("../../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js");
    },
    "../../../node_modules/.pnpm/@azure+storage-blob@12.17.0/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/index.js" (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            BaseRequestPolicy: ()=>BaseRequestPolicy,
            StorageBrowserPolicyFactory: ()=>StorageBrowserPolicyFactory,
            getBlobServiceAccountAudience: ()=>getBlobServiceAccountAudience,
            StorageBrowserPolicy: ()=>StorageBrowserPolicy,
            StorageOAuthScopes: ()=>StorageOAuthScopes,
            generateBlobSASQueryParameters: ()=>generateBlobSASQueryParameters,
            isPipelineLike: ()=>isPipelineLike,
            ContainerSASPermissions: ()=>ContainerSASPermissions,
            SASProtocol: ()=>SASQueryParameters_SASProtocol,
            BlockBlobClient: ()=>BlockBlobClient,
            BlobClient: ()=>BlobClient,
            StorageRetryPolicyType: ()=>StorageRetryPolicy_StorageRetryPolicyType,
            StorageSharedKeyCredentialPolicy: ()=>StorageSharedKeyCredentialPolicy,
            StorageRetryPolicyFactory: ()=>StorageRetryPolicyFactory,
            WebResource: ()=>WebResource,
            logger: ()=>src_log_logger,
            AccountSASPermissions: ()=>AccountSASPermissions,
            AccountSASServices: ()=>AccountSASServices,
            AnonymousCredentialPolicy: ()=>AnonymousCredentialPolicy,
            ContainerClient: ()=>ContainerClient,
            CredentialPolicy: ()=>CredentialPolicy,
            SASQueryParameters: ()=>SASQueryParameters,
            PageBlobClient: ()=>PageBlobClient,
            BlockBlobTier: ()=>models_BlockBlobTier,
            Credential: ()=>Credential,
            StorageBlobAudience: ()=>models_StorageBlobAudience,
            BlobSASPermissions: ()=>BlobSASPermissions,
            PremiumPageBlobTier: ()=>models_PremiumPageBlobTier,
            KnownEncryptionAlgorithmType: ()=>generatedModels_KnownEncryptionAlgorithmType,
            deserializationPolicy: ()=>deserializationPolicy_deserializationPolicy,
            StorageRetryPolicy: ()=>StorageRetryPolicy,
            AccountSASResourceTypes: ()=>AccountSASResourceTypes,
            HttpHeaders: ()=>httpHeaders_HttpHeaders,
            BlobLeaseClient: ()=>BlobLeaseClient,
            AppendBlobClient: ()=>AppendBlobClient,
            newPipeline: ()=>newPipeline,
            StorageSharedKeyCredential: ()=>StorageSharedKeyCredential,
            BlobServiceClient: ()=>BlobServiceClient,
            Pipeline: ()=>Pipeline,
            AnonymousCredential: ()=>AnonymousCredential,
            BlobBatch: ()=>BlobBatch,
            generateAccountSASQueryParameters: ()=>generateAccountSASQueryParameters,
            RequestPolicyOptions: ()=>RequestPolicyOptions,
            RestError: ()=>RestError,
            BlobBatchClient: ()=>BlobBatchClient
        });
        var mappers_namespaceObject = {};
        __webpack_require__.r(mappers_namespaceObject);
        __webpack_require__.d(mappers_namespaceObject, {
            AccessPolicy: ()=>AccessPolicy,
            AppendBlobAppendBlockExceptionHeaders: ()=>AppendBlobAppendBlockExceptionHeaders,
            AppendBlobAppendBlockFromUrlExceptionHeaders: ()=>AppendBlobAppendBlockFromUrlExceptionHeaders,
            AppendBlobAppendBlockFromUrlHeaders: ()=>AppendBlobAppendBlockFromUrlHeaders,
            AppendBlobAppendBlockHeaders: ()=>AppendBlobAppendBlockHeaders,
            AppendBlobCreateExceptionHeaders: ()=>AppendBlobCreateExceptionHeaders,
            AppendBlobCreateHeaders: ()=>AppendBlobCreateHeaders,
            AppendBlobSealExceptionHeaders: ()=>AppendBlobSealExceptionHeaders,
            AppendBlobSealHeaders: ()=>AppendBlobSealHeaders,
            ArrowConfiguration: ()=>ArrowConfiguration,
            ArrowField: ()=>ArrowField,
            BlobAbortCopyFromURLExceptionHeaders: ()=>BlobAbortCopyFromURLExceptionHeaders,
            BlobAbortCopyFromURLHeaders: ()=>BlobAbortCopyFromURLHeaders,
            BlobAcquireLeaseExceptionHeaders: ()=>BlobAcquireLeaseExceptionHeaders,
            BlobAcquireLeaseHeaders: ()=>BlobAcquireLeaseHeaders,
            BlobBreakLeaseExceptionHeaders: ()=>BlobBreakLeaseExceptionHeaders,
            BlobBreakLeaseHeaders: ()=>BlobBreakLeaseHeaders,
            BlobChangeLeaseExceptionHeaders: ()=>BlobChangeLeaseExceptionHeaders,
            BlobChangeLeaseHeaders: ()=>BlobChangeLeaseHeaders,
            BlobCopyFromURLExceptionHeaders: ()=>BlobCopyFromURLExceptionHeaders,
            BlobCopyFromURLHeaders: ()=>BlobCopyFromURLHeaders,
            BlobCreateSnapshotExceptionHeaders: ()=>BlobCreateSnapshotExceptionHeaders,
            BlobCreateSnapshotHeaders: ()=>BlobCreateSnapshotHeaders,
            BlobDeleteExceptionHeaders: ()=>BlobDeleteExceptionHeaders,
            BlobDeleteHeaders: ()=>BlobDeleteHeaders,
            BlobDeleteImmutabilityPolicyExceptionHeaders: ()=>BlobDeleteImmutabilityPolicyExceptionHeaders,
            BlobDeleteImmutabilityPolicyHeaders: ()=>BlobDeleteImmutabilityPolicyHeaders,
            BlobDownloadExceptionHeaders: ()=>BlobDownloadExceptionHeaders,
            BlobDownloadHeaders: ()=>BlobDownloadHeaders,
            BlobFlatListSegment: ()=>BlobFlatListSegment,
            BlobGetAccountInfoExceptionHeaders: ()=>BlobGetAccountInfoExceptionHeaders,
            BlobGetAccountInfoHeaders: ()=>BlobGetAccountInfoHeaders,
            BlobGetPropertiesExceptionHeaders: ()=>BlobGetPropertiesExceptionHeaders,
            BlobGetPropertiesHeaders: ()=>BlobGetPropertiesHeaders,
            BlobGetTagsExceptionHeaders: ()=>BlobGetTagsExceptionHeaders,
            BlobGetTagsHeaders: ()=>BlobGetTagsHeaders,
            BlobHierarchyListSegment: ()=>BlobHierarchyListSegment,
            BlobItemInternal: ()=>BlobItemInternal,
            BlobName: ()=>BlobName,
            BlobPrefix: ()=>BlobPrefix,
            BlobPropertiesInternal: ()=>BlobPropertiesInternal,
            BlobQueryExceptionHeaders: ()=>BlobQueryExceptionHeaders,
            BlobQueryHeaders: ()=>BlobQueryHeaders,
            BlobReleaseLeaseExceptionHeaders: ()=>BlobReleaseLeaseExceptionHeaders,
            BlobReleaseLeaseHeaders: ()=>BlobReleaseLeaseHeaders,
            BlobRenewLeaseExceptionHeaders: ()=>BlobRenewLeaseExceptionHeaders,
            BlobRenewLeaseHeaders: ()=>BlobRenewLeaseHeaders,
            BlobServiceProperties: ()=>BlobServiceProperties,
            BlobServiceStatistics: ()=>BlobServiceStatistics,
            BlobSetExpiryExceptionHeaders: ()=>BlobSetExpiryExceptionHeaders,
            BlobSetExpiryHeaders: ()=>BlobSetExpiryHeaders,
            BlobSetHttpHeadersExceptionHeaders: ()=>BlobSetHttpHeadersExceptionHeaders,
            BlobSetHttpHeadersHeaders: ()=>BlobSetHttpHeadersHeaders,
            BlobSetImmutabilityPolicyExceptionHeaders: ()=>BlobSetImmutabilityPolicyExceptionHeaders,
            BlobSetImmutabilityPolicyHeaders: ()=>BlobSetImmutabilityPolicyHeaders,
            BlobSetLegalHoldExceptionHeaders: ()=>BlobSetLegalHoldExceptionHeaders,
            BlobSetLegalHoldHeaders: ()=>BlobSetLegalHoldHeaders,
            BlobSetMetadataExceptionHeaders: ()=>BlobSetMetadataExceptionHeaders,
            BlobSetMetadataHeaders: ()=>BlobSetMetadataHeaders,
            BlobSetTagsExceptionHeaders: ()=>BlobSetTagsExceptionHeaders,
            BlobSetTagsHeaders: ()=>BlobSetTagsHeaders,
            BlobSetTierExceptionHeaders: ()=>BlobSetTierExceptionHeaders,
            BlobSetTierHeaders: ()=>BlobSetTierHeaders,
            BlobStartCopyFromURLExceptionHeaders: ()=>BlobStartCopyFromURLExceptionHeaders,
            BlobStartCopyFromURLHeaders: ()=>BlobStartCopyFromURLHeaders,
            BlobTag: ()=>BlobTag,
            BlobTags: ()=>BlobTags,
            BlobUndeleteExceptionHeaders: ()=>BlobUndeleteExceptionHeaders,
            BlobUndeleteHeaders: ()=>BlobUndeleteHeaders,
            Block: ()=>Block,
            BlockBlobCommitBlockListExceptionHeaders: ()=>BlockBlobCommitBlockListExceptionHeaders,
            BlockBlobCommitBlockListHeaders: ()=>BlockBlobCommitBlockListHeaders,
            BlockBlobGetBlockListExceptionHeaders: ()=>BlockBlobGetBlockListExceptionHeaders,
            BlockBlobGetBlockListHeaders: ()=>BlockBlobGetBlockListHeaders,
            BlockBlobPutBlobFromUrlExceptionHeaders: ()=>BlockBlobPutBlobFromUrlExceptionHeaders,
            BlockBlobPutBlobFromUrlHeaders: ()=>BlockBlobPutBlobFromUrlHeaders,
            BlockBlobStageBlockExceptionHeaders: ()=>BlockBlobStageBlockExceptionHeaders,
            BlockBlobStageBlockFromURLExceptionHeaders: ()=>BlockBlobStageBlockFromURLExceptionHeaders,
            BlockBlobStageBlockFromURLHeaders: ()=>BlockBlobStageBlockFromURLHeaders,
            BlockBlobStageBlockHeaders: ()=>BlockBlobStageBlockHeaders,
            BlockBlobUploadExceptionHeaders: ()=>BlockBlobUploadExceptionHeaders,
            BlockBlobUploadHeaders: ()=>BlockBlobUploadHeaders,
            BlockList: ()=>BlockList,
            BlockLookupList: ()=>BlockLookupList,
            ClearRange: ()=>ClearRange,
            ContainerAcquireLeaseExceptionHeaders: ()=>ContainerAcquireLeaseExceptionHeaders,
            ContainerAcquireLeaseHeaders: ()=>ContainerAcquireLeaseHeaders,
            ContainerBreakLeaseExceptionHeaders: ()=>ContainerBreakLeaseExceptionHeaders,
            ContainerBreakLeaseHeaders: ()=>ContainerBreakLeaseHeaders,
            ContainerChangeLeaseExceptionHeaders: ()=>ContainerChangeLeaseExceptionHeaders,
            ContainerChangeLeaseHeaders: ()=>ContainerChangeLeaseHeaders,
            ContainerCreateExceptionHeaders: ()=>ContainerCreateExceptionHeaders,
            ContainerCreateHeaders: ()=>ContainerCreateHeaders,
            ContainerDeleteExceptionHeaders: ()=>ContainerDeleteExceptionHeaders,
            ContainerDeleteHeaders: ()=>ContainerDeleteHeaders,
            ContainerFilterBlobsExceptionHeaders: ()=>ContainerFilterBlobsExceptionHeaders,
            ContainerFilterBlobsHeaders: ()=>ContainerFilterBlobsHeaders,
            ContainerGetAccessPolicyExceptionHeaders: ()=>ContainerGetAccessPolicyExceptionHeaders,
            ContainerGetAccessPolicyHeaders: ()=>ContainerGetAccessPolicyHeaders,
            ContainerGetAccountInfoExceptionHeaders: ()=>ContainerGetAccountInfoExceptionHeaders,
            ContainerGetAccountInfoHeaders: ()=>ContainerGetAccountInfoHeaders,
            ContainerGetPropertiesExceptionHeaders: ()=>ContainerGetPropertiesExceptionHeaders,
            ContainerGetPropertiesHeaders: ()=>ContainerGetPropertiesHeaders,
            ContainerItem: ()=>ContainerItem,
            ContainerListBlobFlatSegmentExceptionHeaders: ()=>ContainerListBlobFlatSegmentExceptionHeaders,
            ContainerListBlobFlatSegmentHeaders: ()=>ContainerListBlobFlatSegmentHeaders,
            ContainerListBlobHierarchySegmentExceptionHeaders: ()=>ContainerListBlobHierarchySegmentExceptionHeaders,
            ContainerListBlobHierarchySegmentHeaders: ()=>ContainerListBlobHierarchySegmentHeaders,
            ContainerProperties: ()=>ContainerProperties,
            ContainerReleaseLeaseExceptionHeaders: ()=>ContainerReleaseLeaseExceptionHeaders,
            ContainerReleaseLeaseHeaders: ()=>ContainerReleaseLeaseHeaders,
            ContainerRenameExceptionHeaders: ()=>ContainerRenameExceptionHeaders,
            ContainerRenameHeaders: ()=>ContainerRenameHeaders,
            ContainerRenewLeaseExceptionHeaders: ()=>ContainerRenewLeaseExceptionHeaders,
            ContainerRenewLeaseHeaders: ()=>ContainerRenewLeaseHeaders,
            ContainerRestoreExceptionHeaders: ()=>ContainerRestoreExceptionHeaders,
            ContainerRestoreHeaders: ()=>ContainerRestoreHeaders,
            ContainerSetAccessPolicyExceptionHeaders: ()=>ContainerSetAccessPolicyExceptionHeaders,
            ContainerSetAccessPolicyHeaders: ()=>ContainerSetAccessPolicyHeaders,
            ContainerSetMetadataExceptionHeaders: ()=>ContainerSetMetadataExceptionHeaders,
            ContainerSetMetadataHeaders: ()=>ContainerSetMetadataHeaders,
            ContainerSubmitBatchExceptionHeaders: ()=>ContainerSubmitBatchExceptionHeaders,
            ContainerSubmitBatchHeaders: ()=>ContainerSubmitBatchHeaders,
            CorsRule: ()=>CorsRule,
            DelimitedTextConfiguration: ()=>DelimitedTextConfiguration,
            FilterBlobItem: ()=>FilterBlobItem,
            FilterBlobSegment: ()=>FilterBlobSegment,
            GeoReplication: ()=>GeoReplication,
            JsonTextConfiguration: ()=>JsonTextConfiguration,
            KeyInfo: ()=>KeyInfo,
            ListBlobsFlatSegmentResponse: ()=>ListBlobsFlatSegmentResponse,
            ListBlobsHierarchySegmentResponse: ()=>ListBlobsHierarchySegmentResponse,
            ListContainersSegmentResponse: ()=>ListContainersSegmentResponse,
            Logging: ()=>Logging,
            Metrics: ()=>Metrics,
            PageBlobClearPagesExceptionHeaders: ()=>PageBlobClearPagesExceptionHeaders,
            PageBlobClearPagesHeaders: ()=>PageBlobClearPagesHeaders,
            PageBlobCopyIncrementalExceptionHeaders: ()=>PageBlobCopyIncrementalExceptionHeaders,
            PageBlobCopyIncrementalHeaders: ()=>PageBlobCopyIncrementalHeaders,
            PageBlobCreateExceptionHeaders: ()=>PageBlobCreateExceptionHeaders,
            PageBlobCreateHeaders: ()=>PageBlobCreateHeaders,
            PageBlobGetPageRangesDiffExceptionHeaders: ()=>PageBlobGetPageRangesDiffExceptionHeaders,
            PageBlobGetPageRangesDiffHeaders: ()=>PageBlobGetPageRangesDiffHeaders,
            PageBlobGetPageRangesExceptionHeaders: ()=>PageBlobGetPageRangesExceptionHeaders,
            PageBlobGetPageRangesHeaders: ()=>PageBlobGetPageRangesHeaders,
            PageBlobResizeExceptionHeaders: ()=>PageBlobResizeExceptionHeaders,
            PageBlobResizeHeaders: ()=>PageBlobResizeHeaders,
            PageBlobUpdateSequenceNumberExceptionHeaders: ()=>PageBlobUpdateSequenceNumberExceptionHeaders,
            PageBlobUpdateSequenceNumberHeaders: ()=>PageBlobUpdateSequenceNumberHeaders,
            PageBlobUploadPagesExceptionHeaders: ()=>PageBlobUploadPagesExceptionHeaders,
            PageBlobUploadPagesFromURLExceptionHeaders: ()=>PageBlobUploadPagesFromURLExceptionHeaders,
            PageBlobUploadPagesFromURLHeaders: ()=>PageBlobUploadPagesFromURLHeaders,
            PageBlobUploadPagesHeaders: ()=>PageBlobUploadPagesHeaders,
            PageList: ()=>PageList,
            PageRange: ()=>PageRange,
            QueryFormat: ()=>QueryFormat,
            QueryRequest: ()=>QueryRequest,
            QuerySerialization: ()=>QuerySerialization,
            RetentionPolicy: ()=>RetentionPolicy,
            ServiceFilterBlobsExceptionHeaders: ()=>ServiceFilterBlobsExceptionHeaders,
            ServiceFilterBlobsHeaders: ()=>ServiceFilterBlobsHeaders,
            ServiceGetAccountInfoExceptionHeaders: ()=>ServiceGetAccountInfoExceptionHeaders,
            ServiceGetAccountInfoHeaders: ()=>ServiceGetAccountInfoHeaders,
            ServiceGetPropertiesExceptionHeaders: ()=>ServiceGetPropertiesExceptionHeaders,
            ServiceGetPropertiesHeaders: ()=>ServiceGetPropertiesHeaders,
            ServiceGetStatisticsExceptionHeaders: ()=>ServiceGetStatisticsExceptionHeaders,
            ServiceGetStatisticsHeaders: ()=>ServiceGetStatisticsHeaders,
            ServiceGetUserDelegationKeyExceptionHeaders: ()=>ServiceGetUserDelegationKeyExceptionHeaders,
            ServiceGetUserDelegationKeyHeaders: ()=>ServiceGetUserDelegationKeyHeaders,
            ServiceListContainersSegmentExceptionHeaders: ()=>ServiceListContainersSegmentExceptionHeaders,
            ServiceListContainersSegmentHeaders: ()=>ServiceListContainersSegmentHeaders,
            ServiceSetPropertiesExceptionHeaders: ()=>ServiceSetPropertiesExceptionHeaders,
            ServiceSetPropertiesHeaders: ()=>ServiceSetPropertiesHeaders,
            ServiceSubmitBatchExceptionHeaders: ()=>ServiceSubmitBatchExceptionHeaders,
            ServiceSubmitBatchHeaders: ()=>ServiceSubmitBatchHeaders,
            SignedIdentifier: ()=>SignedIdentifier,
            StaticWebsite: ()=>StaticWebsite,
            StorageError: ()=>StorageError,
            UserDelegationKey: ()=>UserDelegationKey
        });
        var v4 = __webpack_require__("../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v4.js");
        const validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
        function isValidUuid(uuid) {
            return validUuidRegex.test(uuid);
        }
        function generateUuid() {
            return (0, v4.A)();
        }
        function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
            if (!Array.isArray(obj)) obj = [
                obj
            ];
            if (!xmlNamespaceKey || !xmlNamespace) return {
                [elementName]: obj
            };
            const result = {
                [elementName]: obj
            };
            result["$"] = {
                [xmlNamespaceKey]: xmlNamespace
            };
            return result;
        }
        const validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function isDuration(value) {
            return validateISODuration.test(value);
        }
        function replaceAll(value, searchValue, replaceValue) {
            return value && searchValue ? value.split(searchValue).join(replaceValue || "") : value;
        }
        function isPrimitiveType(value) {
            return "object" != typeof value && "function" != typeof value || null === value;
        }
        function getEnvironmentValue(name) {
            if (process.env[name]) return process.env[name];
            if (process.env[name.toLowerCase()]) return process.env[name.toLowerCase()];
        }
        function isObject(input) {
            return "object" == typeof input && null !== input && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
        }
        class URLQuery {
            constructor(){
                this._rawQuery = {};
            }
            any() {
                return Object.keys(this._rawQuery).length > 0;
            }
            keys() {
                return Object.keys(this._rawQuery);
            }
            set(parameterName, parameterValue) {
                const caseParameterValue = parameterValue;
                if (parameterName) if (null != caseParameterValue) {
                    const newValue = Array.isArray(caseParameterValue) ? caseParameterValue : caseParameterValue.toString();
                    this._rawQuery[parameterName] = newValue;
                } else delete this._rawQuery[parameterName];
            }
            get(parameterName) {
                return parameterName ? this._rawQuery[parameterName] : void 0;
            }
            toString() {
                let result = "";
                for(const parameterName in this._rawQuery){
                    if (result) result += "&";
                    const parameterValue = this._rawQuery[parameterName];
                    if (Array.isArray(parameterValue)) {
                        const parameterStrings = [];
                        for (const parameterValueElement of parameterValue)parameterStrings.push(`${parameterName}=${parameterValueElement}`);
                        result += parameterStrings.join("&");
                    } else result += `${parameterName}=${parameterValue}`;
                }
                return result;
            }
            static parse(text) {
                const result = new URLQuery();
                if (text) {
                    if (text.startsWith("?")) text = text.substring(1);
                    let currentState = "ParameterName";
                    let parameterName = "";
                    let parameterValue = "";
                    for(let i = 0; i < text.length; ++i){
                        const currentCharacter = text[i];
                        switch(currentState){
                            case "ParameterName":
                                switch(currentCharacter){
                                    case "=":
                                        currentState = "ParameterValue";
                                        break;
                                    case "&":
                                        parameterName = "";
                                        parameterValue = "";
                                        break;
                                    default:
                                        parameterName += currentCharacter;
                                        break;
                                }
                                break;
                            case "ParameterValue":
                                switch(currentCharacter){
                                    case "&":
                                        result.set(parameterName, parameterValue);
                                        parameterName = "";
                                        parameterValue = "";
                                        currentState = "ParameterName";
                                        break;
                                    default:
                                        parameterValue += currentCharacter;
                                        break;
                                }
                                break;
                            default:
                                throw new Error("Unrecognized URLQuery parse state: " + currentState);
                        }
                    }
                    if ("ParameterValue" === currentState) result.set(parameterName, parameterValue);
                }
                return result;
            }
        }
        class URLBuilder {
            setScheme(scheme) {
                if (scheme) this.set(scheme, "SCHEME");
                else this._scheme = void 0;
            }
            getScheme() {
                return this._scheme;
            }
            setHost(host) {
                if (host) this.set(host, "SCHEME_OR_HOST");
                else this._host = void 0;
            }
            getHost() {
                return this._host;
            }
            setPort(port) {
                if (null == port || "" === port) this._port = void 0;
                else this.set(port.toString(), "PORT");
            }
            getPort() {
                return this._port;
            }
            setPath(path) {
                if (path) {
                    const schemeIndex = path.indexOf("://");
                    if (-1 !== schemeIndex) {
                        const schemeStart = path.lastIndexOf("/", schemeIndex);
                        this.set(-1 === schemeStart ? path : path.substr(schemeStart + 1), "SCHEME");
                    } else this.set(path, "PATH");
                } else this._path = void 0;
            }
            appendPath(path) {
                if (path) {
                    let currentPath = this.getPath();
                    if (currentPath) {
                        if (!currentPath.endsWith("/")) currentPath += "/";
                        if (path.startsWith("/")) path = path.substring(1);
                        path = currentPath + path;
                    }
                    this.set(path, "PATH");
                }
            }
            getPath() {
                return this._path;
            }
            setQuery(query) {
                if (query) this._query = URLQuery.parse(query);
                else this._query = void 0;
            }
            setQueryParameter(queryParameterName, queryParameterValue) {
                if (queryParameterName) {
                    if (!this._query) this._query = new URLQuery();
                    this._query.set(queryParameterName, queryParameterValue);
                }
            }
            getQueryParameterValue(queryParameterName) {
                return this._query ? this._query.get(queryParameterName) : void 0;
            }
            getQuery() {
                return this._query ? this._query.toString() : void 0;
            }
            set(text, startState) {
                const tokenizer = new URLTokenizer(text, startState);
                while(tokenizer.next()){
                    const token = tokenizer.current();
                    let tokenPath;
                    if (token) switch(token.type){
                        case "SCHEME":
                            this._scheme = token.text || void 0;
                            break;
                        case "HOST":
                            this._host = token.text || void 0;
                            break;
                        case "PORT":
                            this._port = token.text || void 0;
                            break;
                        case "PATH":
                            tokenPath = token.text || void 0;
                            if (!this._path || "/" === this._path || "/" !== tokenPath) this._path = tokenPath;
                            break;
                        case "QUERY":
                            this._query = URLQuery.parse(token.text);
                            break;
                        default:
                            throw new Error(`Unrecognized URLTokenType: ${token.type}`);
                    }
                }
            }
            toString() {
                let result = "";
                if (this._scheme) result += `${this._scheme}://`;
                if (this._host) result += this._host;
                if (this._port) result += `:${this._port}`;
                if (this._path) {
                    if (!this._path.startsWith("/")) result += "/";
                    result += this._path;
                }
                if (this._query && this._query.any()) result += `?${this._query.toString()}`;
                return result;
            }
            replaceAll(searchValue, replaceValue) {
                if (searchValue) {
                    this.setScheme(replaceAll(this.getScheme(), searchValue, replaceValue));
                    this.setHost(replaceAll(this.getHost(), searchValue, replaceValue));
                    this.setPort(replaceAll(this.getPort(), searchValue, replaceValue));
                    this.setPath(replaceAll(this.getPath(), searchValue, replaceValue));
                    this.setQuery(replaceAll(this.getQuery(), searchValue, replaceValue));
                }
            }
            static parse(text) {
                const result = new URLBuilder();
                result.set(text, "SCHEME_OR_HOST");
                return result;
            }
        }
        class URLToken {
            constructor(text, type){
                this.text = text;
                this.type = type;
            }
            static scheme(text) {
                return new URLToken(text, "SCHEME");
            }
            static host(text) {
                return new URLToken(text, "HOST");
            }
            static port(text) {
                return new URLToken(text, "PORT");
            }
            static path(text) {
                return new URLToken(text, "PATH");
            }
            static query(text) {
                return new URLToken(text, "QUERY");
            }
        }
        function isAlphaNumericCharacter(character) {
            const characterCode = character.charCodeAt(0);
            return 48 <= characterCode && characterCode <= 57 || 65 <= characterCode && characterCode <= 90 || 97 <= characterCode && characterCode <= 122;
        }
        class URLTokenizer {
            constructor(_text, state){
                this._text = _text;
                this._textLength = _text ? _text.length : 0;
                this._currentState = null != state ? state : "SCHEME_OR_HOST";
                this._currentIndex = 0;
            }
            current() {
                return this._currentToken;
            }
            next() {
                if (hasCurrentCharacter(this)) switch(this._currentState){
                    case "SCHEME":
                        nextScheme(this);
                        break;
                    case "SCHEME_OR_HOST":
                        nextSchemeOrHost(this);
                        break;
                    case "HOST":
                        nextHost(this);
                        break;
                    case "PORT":
                        nextPort(this);
                        break;
                    case "PATH":
                        nextPath(this);
                        break;
                    case "QUERY":
                        nextQuery(this);
                        break;
                    default:
                        throw new Error(`Unrecognized URLTokenizerState: ${this._currentState}`);
                }
                else this._currentToken = void 0;
                return !!this._currentToken;
            }
        }
        function readRemaining(tokenizer) {
            let result = "";
            if (tokenizer._currentIndex < tokenizer._textLength) {
                result = tokenizer._text.substring(tokenizer._currentIndex);
                tokenizer._currentIndex = tokenizer._textLength;
            }
            return result;
        }
        function hasCurrentCharacter(tokenizer) {
            return tokenizer._currentIndex < tokenizer._textLength;
        }
        function getCurrentCharacter(tokenizer) {
            return tokenizer._text[tokenizer._currentIndex];
        }
        function nextCharacter(tokenizer, step) {
            if (hasCurrentCharacter(tokenizer)) {
                if (!step) step = 1;
                tokenizer._currentIndex += step;
            }
        }
        function peekCharacters(tokenizer, charactersToPeek) {
            let endIndex = tokenizer._currentIndex + charactersToPeek;
            if (tokenizer._textLength < endIndex) endIndex = tokenizer._textLength;
            return tokenizer._text.substring(tokenizer._currentIndex, endIndex);
        }
        function readWhile(tokenizer, condition) {
            let result = "";
            while(hasCurrentCharacter(tokenizer)){
                const currentCharacter = getCurrentCharacter(tokenizer);
                if (condition(currentCharacter)) {
                    result += currentCharacter;
                    nextCharacter(tokenizer);
                } else break;
            }
            return result;
        }
        function readWhileLetterOrDigit(tokenizer) {
            return readWhile(tokenizer, (character)=>isAlphaNumericCharacter(character));
        }
        function readUntilCharacter(tokenizer, ...terminatingCharacters) {
            return readWhile(tokenizer, (character)=>-1 === terminatingCharacters.indexOf(character));
        }
        function nextScheme(tokenizer) {
            const scheme = readWhileLetterOrDigit(tokenizer);
            tokenizer._currentToken = URLToken.scheme(scheme);
            if (hasCurrentCharacter(tokenizer)) tokenizer._currentState = "HOST";
            else tokenizer._currentState = "DONE";
        }
        function nextSchemeOrHost(tokenizer) {
            const schemeOrHost = readUntilCharacter(tokenizer, ":", "/", "?");
            if (hasCurrentCharacter(tokenizer)) if (":" === getCurrentCharacter(tokenizer)) if ("://" === peekCharacters(tokenizer, 3)) {
                tokenizer._currentToken = URLToken.scheme(schemeOrHost);
                tokenizer._currentState = "HOST";
            } else {
                tokenizer._currentToken = URLToken.host(schemeOrHost);
                tokenizer._currentState = "PORT";
            }
            else {
                tokenizer._currentToken = URLToken.host(schemeOrHost);
                if ("/" === getCurrentCharacter(tokenizer)) tokenizer._currentState = "PATH";
                else tokenizer._currentState = "QUERY";
            }
            else {
                tokenizer._currentToken = URLToken.host(schemeOrHost);
                tokenizer._currentState = "DONE";
            }
        }
        function nextHost(tokenizer) {
            if ("://" === peekCharacters(tokenizer, 3)) nextCharacter(tokenizer, 3);
            const host = readUntilCharacter(tokenizer, ":", "/", "?");
            tokenizer._currentToken = URLToken.host(host);
            if (hasCurrentCharacter(tokenizer)) if (":" === getCurrentCharacter(tokenizer)) tokenizer._currentState = "PORT";
            else if ("/" === getCurrentCharacter(tokenizer)) tokenizer._currentState = "PATH";
            else tokenizer._currentState = "QUERY";
            else tokenizer._currentState = "DONE";
        }
        function nextPort(tokenizer) {
            if (":" === getCurrentCharacter(tokenizer)) nextCharacter(tokenizer);
            const port = readUntilCharacter(tokenizer, "/", "?");
            tokenizer._currentToken = URLToken.port(port);
            if (hasCurrentCharacter(tokenizer)) if ("/" === getCurrentCharacter(tokenizer)) tokenizer._currentState = "PATH";
            else tokenizer._currentState = "QUERY";
            else tokenizer._currentState = "DONE";
        }
        function nextPath(tokenizer) {
            const path = readUntilCharacter(tokenizer, "?");
            tokenizer._currentToken = URLToken.path(path);
            if (hasCurrentCharacter(tokenizer)) tokenizer._currentState = "QUERY";
            else tokenizer._currentState = "DONE";
        }
        function nextQuery(tokenizer) {
            if ("?" === getCurrentCharacter(tokenizer)) nextCharacter(tokenizer);
            const query = readRemaining(tokenizer);
            tokenizer._currentToken = URLToken.query(query);
            tokenizer._currentState = "DONE";
        }
        const RedactedString = "REDACTED";
        const defaultAllowedHeaderNames = [
            "x-ms-client-request-id",
            "x-ms-return-client-request-id",
            "x-ms-useragent",
            "x-ms-correlation-request-id",
            "x-ms-request-id",
            "client-request-id",
            "ms-cv",
            "return-client-request-id",
            "traceparent",
            "Access-Control-Allow-Credentials",
            "Access-Control-Allow-Headers",
            "Access-Control-Allow-Methods",
            "Access-Control-Allow-Origin",
            "Access-Control-Expose-Headers",
            "Access-Control-Max-Age",
            "Access-Control-Request-Headers",
            "Access-Control-Request-Method",
            "Origin",
            "Accept",
            "Accept-Encoding",
            "Cache-Control",
            "Connection",
            "Content-Length",
            "Content-Type",
            "Date",
            "ETag",
            "Expires",
            "If-Match",
            "If-Modified-Since",
            "If-None-Match",
            "If-Unmodified-Since",
            "Last-Modified",
            "Pragma",
            "Request-Id",
            "Retry-After",
            "Server",
            "Transfer-Encoding",
            "User-Agent",
            "WWW-Authenticate"
        ];
        const defaultAllowedQueryParameters = [
            "api-version"
        ];
        class Sanitizer {
            constructor({ allowedHeaderNames = [], allowedQueryParameters = [] } = {}){
                allowedHeaderNames = Array.isArray(allowedHeaderNames) ? defaultAllowedHeaderNames.concat(allowedHeaderNames) : defaultAllowedHeaderNames;
                allowedQueryParameters = Array.isArray(allowedQueryParameters) ? defaultAllowedQueryParameters.concat(allowedQueryParameters) : defaultAllowedQueryParameters;
                this.allowedHeaderNames = new Set(allowedHeaderNames.map((n)=>n.toLowerCase()));
                this.allowedQueryParameters = new Set(allowedQueryParameters.map((p)=>p.toLowerCase()));
            }
            sanitize(obj) {
                const seen = new Set();
                return JSON.stringify(obj, (key, value)=>{
                    if (value instanceof Error) return Object.assign(Object.assign({}, value), {
                        name: value.name,
                        message: value.message
                    });
                    if ("_headersMap" === key) return this.sanitizeHeaders(value);
                    if ("url" === key) return this.sanitizeUrl(value);
                    if ("query" === key) return this.sanitizeQuery(value);
                    if ("body" === key) return;
                    if ("response" === key) return;
                    else if ("operationSpec" === key) return;
                    else if (Array.isArray(value) || isObject(value)) {
                        if (seen.has(value)) return "[Circular]";
                        seen.add(value);
                    }
                    return value;
                }, 2);
            }
            sanitizeHeaders(value) {
                return this.sanitizeObject(value, this.allowedHeaderNames, (v, k)=>v[k].value);
            }
            sanitizeQuery(value) {
                return this.sanitizeObject(value, this.allowedQueryParameters, (v, k)=>v[k]);
            }
            sanitizeObject(value, allowedKeys, accessor) {
                if ("object" != typeof value || null === value) return value;
                const sanitized = {};
                for (const k of Object.keys(value))if (allowedKeys.has(k.toLowerCase())) sanitized[k] = accessor(value, k);
                else sanitized[k] = RedactedString;
                return sanitized;
            }
            sanitizeUrl(value) {
                if ("string" != typeof value || null === value) return value;
                const urlBuilder = URLBuilder.parse(value);
                const queryString = urlBuilder.getQuery();
                if (!queryString) return value;
                const query = URLQuery.parse(queryString);
                for (const k of query.keys())if (!this.allowedQueryParameters.has(k.toLowerCase())) query.set(k, RedactedString);
                urlBuilder.setQuery(query.toString());
                return urlBuilder.toString();
            }
        }
        var external_util_ = __webpack_require__("util");
        const custom = external_util_.inspect.custom;
        const errorSanitizer = new Sanitizer();
        class RestError extends Error {
            constructor(message, code, statusCode, request, response){
                super(message);
                this.name = "RestError";
                this.code = code;
                this.statusCode = statusCode;
                this.request = request;
                this.response = response;
                Object.setPrototypeOf(this, RestError.prototype);
            }
            [custom]() {
                return `RestError: ${this.message} \n ${errorSanitizer.sanitize(this)}`;
            }
        }
        RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
        RestError.PARSE_ERROR = "PARSE_ERROR";
        function __rest(s, e) {
            var t = {};
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
            if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
            }
            return t;
        }
        function __values1(o) {
            var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
            if (m) return m.call(o);
            if (o && "number" == typeof o.length) return {
                next: function() {
                    if (o && i >= o.length) o = void 0;
                    return {
                        value: o && o[i++],
                        done: !o
                    };
                }
            };
            throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function __await(v) {
            return this instanceof __await ? (this.v = v, this) : new __await(v);
        }
        function __asyncGenerator(thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var g = generator.apply(thisArg, _arguments || []), i, q = [];
            return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i;
            function verb(n) {
                if (g[n]) i[n] = function(v) {
                    return new Promise(function(a, b) {
                        q.push([
                            n,
                            v,
                            a,
                            b
                        ]) > 1 || resume(n, v);
                    });
                };
            }
            function resume(n, v) {
                try {
                    step(g[n](v));
                } catch (e) {
                    settle(q[0][3], e);
                }
            }
            function step(r) {
                r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
            }
            function fulfill(value) {
                resume("next", value);
            }
            function reject(value) {
                resume("throw", value);
            }
            function settle(f, v) {
                if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
            }
        }
        function __asyncDelegator(o) {
            var i, p;
            return i = {}, verb("next"), verb("throw", function(e) {
                throw e;
            }), verb("return"), i[Symbol.iterator] = function() {
                return this;
            }, i;
            function verb(n, f) {
                i[n] = o[n] ? function(v) {
                    return (p = !p) ? {
                        value: __await(o[n](v)),
                        done: false
                    } : f ? f(v) : v;
                } : f;
            }
        }
        function __asyncValues(o) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var m = o[Symbol.asyncIterator], i;
            return m ? m.call(o) : (o = "function" == typeof __values1 ? __values1(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i);
            function verb(n) {
                i[n] = o[n] && function(v) {
                    return new Promise(function(resolve, reject) {
                        v = o[n](v), settle(resolve, reject, v.done, v.value);
                    });
                };
            }
            function settle(resolve, reject, d, v) {
                Promise.resolve(v).then(function(v) {
                    resolve({
                        value: v,
                        done: d
                    });
                }, reject);
            }
        }
        class AbortError extends Error {
            constructor(message){
                super(message);
                this.name = "AbortError";
            }
        }
        function createAbortablePromise(buildPromise, options) {
            const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options ?? {};
            return new Promise((resolve, reject)=>{
                function rejectOnAbort() {
                    reject(new AbortError(abortErrorMsg ?? "The operation was aborted."));
                }
                function removeListeners() {
                    abortSignal?.removeEventListener("abort", onAbort);
                }
                function onAbort() {
                    cleanupBeforeAbort?.();
                    removeListeners();
                    rejectOnAbort();
                }
                if (abortSignal?.aborted) return rejectOnAbort();
                try {
                    buildPromise((x)=>{
                        removeListeners();
                        resolve(x);
                    }, (x)=>{
                        removeListeners();
                        reject(x);
                    });
                } catch (err) {
                    reject(err);
                }
                abortSignal?.addEventListener("abort", onAbort);
            });
        }
        const StandardAbortMessage = "The delay was aborted.";
        function delay_delay(timeInMs, options) {
            let token;
            const { abortSignal, abortErrorMsg } = options ?? {};
            return createAbortablePromise((resolve)=>{
                token = setTimeout(resolve, timeInMs);
            }, {
                cleanupBeforeAbort: ()=>clearTimeout(token),
                abortSignal,
                abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
            });
        }
        var external_crypto_ = __webpack_require__("crypto");
        "function" == typeof globalThis?.crypto?.randomUUID ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : external_crypto_.randomUUID;
        "u" > typeof window && window.document;
        "object" == typeof self && "function" == typeof self?.importScripts && (self.constructor?.name === "DedicatedWorkerGlobalScope" || self.constructor?.name === "ServiceWorkerGlobalScope" || self.constructor?.name);
        const isDeno = "u" > typeof Deno && void 0 !== Deno.version && void 0 !== Deno.version.deno;
        const isBun = "u" > typeof Bun && void 0 !== Bun.version;
        const checkEnvironment_isNode = void 0 !== globalThis.process && Boolean(globalThis.process.version) && Boolean(globalThis.process.versions?.node) && !isDeno && !isBun;
        "u" > typeof navigator && navigator?.product;
        function isTokenCredential(credential) {
            const castCredential = credential;
            return castCredential && "function" == typeof castCredential.getToken && (void 0 === castCredential.signRequest || castCredential.getToken.length > 0);
        }
        var httpPipelineLogLevel_HttpPipelineLogLevel;
        (function(HttpPipelineLogLevel) {
            HttpPipelineLogLevel[HttpPipelineLogLevel["OFF"] = 0] = "OFF";
            HttpPipelineLogLevel[HttpPipelineLogLevel["ERROR"] = 1] = "ERROR";
            HttpPipelineLogLevel[HttpPipelineLogLevel["WARNING"] = 2] = "WARNING";
            HttpPipelineLogLevel[HttpPipelineLogLevel["INFO"] = 3] = "INFO";
        })(httpPipelineLogLevel_HttpPipelineLogLevel || (httpPipelineLogLevel_HttpPipelineLogLevel = {}));
        class BaseRequestPolicy {
            constructor(_nextPolicy, _options){
                this._nextPolicy = _nextPolicy;
                this._options = _options;
            }
            shouldLog(logLevel) {
                return this._options.shouldLog(logLevel);
            }
            log(logLevel, message) {
                this._options.log(logLevel, message);
            }
        }
        class RequestPolicyOptions {
            constructor(_logger){
                this._logger = _logger;
            }
            shouldLog(logLevel) {
                return !!this._logger && logLevel !== httpPipelineLogLevel_HttpPipelineLogLevel.OFF && logLevel <= this._logger.minimumLogLevel;
            }
            log(logLevel, message) {
                if (this._logger && this.shouldLog(logLevel)) this._logger.log(logLevel, message);
            }
        }
        const constants_Constants = {
            coreHttpVersion: "3.0.4",
            HTTP: "http:",
            HTTPS: "https:",
            HTTP_PROXY: "HTTP_PROXY",
            HTTPS_PROXY: "HTTPS_PROXY",
            NO_PROXY: "NO_PROXY",
            ALL_PROXY: "ALL_PROXY",
            HttpConstants: {
                HttpVerbs: {
                    PUT: "PUT",
                    GET: "GET",
                    DELETE: "DELETE",
                    POST: "POST",
                    MERGE: "MERGE",
                    HEAD: "HEAD",
                    PATCH: "PATCH"
                },
                StatusCodes: {
                    TooManyRequests: 429,
                    ServiceUnavailable: 503
                }
            },
            HeaderConstants: {
                AUTHORIZATION: "authorization",
                AUTHORIZATION_SCHEME: "Bearer",
                RETRY_AFTER: "Retry-After",
                USER_AGENT: "User-Agent"
            }
        };
        const globalNoProxyList = [];
        let noProxyListLoaded = false;
        const globalBypassedMap = new Map();
        function loadEnvironmentProxyValue() {
            if (!process) return;
            const httpsProxy = getEnvironmentValue(constants_Constants.HTTPS_PROXY);
            const allProxy = getEnvironmentValue(constants_Constants.ALL_PROXY);
            const httpProxy = getEnvironmentValue(constants_Constants.HTTP_PROXY);
            return httpsProxy || allProxy || httpProxy;
        }
        function isBypassed(uri, noProxyList, bypassedMap) {
            if (0 === noProxyList.length) return false;
            const host = URLBuilder.parse(uri).getHost();
            if (null == bypassedMap ? void 0 : bypassedMap.has(host)) return bypassedMap.get(host);
            let isBypassedFlag = false;
            for (const pattern of noProxyList)if ("." === pattern[0]) {
                if (host.endsWith(pattern)) isBypassedFlag = true;
                else if (host.length === pattern.length - 1 && host === pattern.slice(1)) isBypassedFlag = true;
            } else if (host === pattern) isBypassedFlag = true;
            null == bypassedMap || bypassedMap.set(host, isBypassedFlag);
            return isBypassedFlag;
        }
        function loadNoProxy() {
            const noProxy = getEnvironmentValue(constants_Constants.NO_PROXY);
            noProxyListLoaded = true;
            if (noProxy) return noProxy.split(",").map((item)=>item.trim()).filter((item)=>item.length);
            return [];
        }
        function getDefaultProxySettings(proxyUrl) {
            if (!proxyUrl) {
                proxyUrl = loadEnvironmentProxyValue();
                if (!proxyUrl) return;
            }
            const { username, password, urlWithoutAuth } = extractAuthFromUrl(proxyUrl);
            const parsedUrl = URLBuilder.parse(urlWithoutAuth);
            const schema = parsedUrl.getScheme() ? parsedUrl.getScheme() + "://" : "";
            return {
                host: schema + parsedUrl.getHost(),
                port: Number.parseInt(parsedUrl.getPort() || "80"),
                username,
                password
            };
        }
        function proxyPolicy_proxyPolicy(proxySettings, options) {
            if (!proxySettings) proxySettings = getDefaultProxySettings();
            if (!noProxyListLoaded) globalNoProxyList.push(...loadNoProxy());
            return {
                create: (nextPolicy, requestPolicyOptions)=>new ProxyPolicy(nextPolicy, requestPolicyOptions, proxySettings, null == options ? void 0 : options.customNoProxyList)
            };
        }
        function extractAuthFromUrl(url) {
            const atIndex = url.indexOf("@");
            if (-1 === atIndex) return {
                urlWithoutAuth: url
            };
            const schemeIndex = url.indexOf("://");
            const authStart = -1 !== schemeIndex ? schemeIndex + 3 : 0;
            const auth = url.substring(authStart, atIndex);
            const colonIndex = auth.indexOf(":");
            const hasPassword = -1 !== colonIndex;
            const username = hasPassword ? auth.substring(0, colonIndex) : auth;
            const password = hasPassword ? auth.substring(colonIndex + 1) : void 0;
            const urlWithoutAuth = url.substring(0, authStart) + url.substring(atIndex + 1);
            return {
                username,
                password,
                urlWithoutAuth
            };
        }
        class ProxyPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, proxySettings, customNoProxyList){
                super(nextPolicy, options);
                this.proxySettings = proxySettings;
                this.customNoProxyList = customNoProxyList;
            }
            sendRequest(request) {
                var _a;
                if (!request.proxySettings && !isBypassed(request.url, null != (_a = this.customNoProxyList) ? _a : globalNoProxyList, this.customNoProxyList ? void 0 : globalBypassedMap)) request.proxySettings = this.proxySettings;
                return this._nextPolicy.sendRequest(request);
            }
        }
        var _globalThis = 'object' == typeof globalThis ? globalThis : global;
        var VERSION = '1.9.0';
        var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
        function _makeCompatibilityCheck(ownVersion) {
            var acceptedVersions = new Set([
                ownVersion
            ]);
            var rejectedVersions = new Set();
            var myVersionMatch = ownVersion.match(re);
            if (!myVersionMatch) return function() {
                return false;
            };
            var ownVersionParsed = {
                major: +myVersionMatch[1],
                minor: +myVersionMatch[2],
                patch: +myVersionMatch[3],
                prerelease: myVersionMatch[4]
            };
            if (null != ownVersionParsed.prerelease) return function(globalVersion) {
                return globalVersion === ownVersion;
            };
            function _reject(v) {
                rejectedVersions.add(v);
                return false;
            }
            function _accept(v) {
                acceptedVersions.add(v);
                return true;
            }
            return function(globalVersion) {
                if (acceptedVersions.has(globalVersion)) return true;
                if (rejectedVersions.has(globalVersion)) return false;
                var globalVersionMatch = globalVersion.match(re);
                if (!globalVersionMatch) return _reject(globalVersion);
                var globalVersionParsed = {
                    major: +globalVersionMatch[1],
                    minor: +globalVersionMatch[2],
                    patch: +globalVersionMatch[3],
                    prerelease: globalVersionMatch[4]
                };
                if (null != globalVersionParsed.prerelease) return _reject(globalVersion);
                if (ownVersionParsed.major !== globalVersionParsed.major) return _reject(globalVersion);
                if (0 === ownVersionParsed.major) {
                    if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) return _accept(globalVersion);
                    return _reject(globalVersion);
                }
                if (ownVersionParsed.minor <= globalVersionParsed.minor) return _accept(globalVersion);
                return _reject(globalVersion);
            };
        }
        var semver_isCompatible = _makeCompatibilityCheck(VERSION);
        var major = VERSION.split('.')[0];
        var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
        var _global = _globalThis;
        function registerGlobal(type, instance, diag, allowOverride) {
            var _a;
            if (void 0 === allowOverride) allowOverride = false;
            var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = null != (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) ? _a : {
                version: VERSION
            };
            if (!allowOverride && api[type]) {
                var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
                diag.error(err.stack || err.message);
                return false;
            }
            if (api.version !== VERSION) {
                var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
                diag.error(err.stack || err.message);
                return false;
            }
            api[type] = instance;
            diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
            return true;
        }
        function getGlobal(type) {
            var _a, _b;
            var globalVersion = null == (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) ? void 0 : _a.version;
            if (!globalVersion || !semver_isCompatible(globalVersion)) return;
            return null == (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) ? void 0 : _b[type];
        }
        function unregisterGlobal(type, diag) {
            diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
            var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
            if (api) delete api[type];
        }
        function createContextKey(description) {
            return Symbol.for(description);
        }
        var context_BaseContext = function() {
            function BaseContext(parentContext) {
                var self1 = this;
                self1._currentContext = parentContext ? new Map(parentContext) : new Map();
                self1.getValue = function(key) {
                    return self1._currentContext.get(key);
                };
                self1.setValue = function(key, value) {
                    var context = new BaseContext(self1._currentContext);
                    context._currentContext.set(key, value);
                    return context;
                };
                self1.deleteValue = function(key) {
                    var context = new BaseContext(self1._currentContext);
                    context._currentContext.delete(key);
                    return context;
                };
            }
            return BaseContext;
        }();
        var ROOT_CONTEXT = new context_BaseContext();
        var NoopContextManager_read = function(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var i = m.call(o), r, ar = [], e;
            try {
                while((void 0 === n || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally{
                try {
                    if (r && !r.done && (m = i["return"])) m.call(i);
                } finally{
                    if (e) throw e.error;
                }
            }
            return ar;
        };
        var NoopContextManager_spreadArray = function(to, from, pack) {
            if (pack || 2 === arguments.length) {
                for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
                    if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
            return to.concat(ar || Array.prototype.slice.call(from));
        };
        var NoopContextManager_NoopContextManager = function() {
            function NoopContextManager() {}
            NoopContextManager.prototype.active = function() {
                return ROOT_CONTEXT;
            };
            NoopContextManager.prototype.with = function(_context, fn, thisArg) {
                var args = [];
                for(var _i = 3; _i < arguments.length; _i++)args[_i - 3] = arguments[_i];
                return fn.call.apply(fn, NoopContextManager_spreadArray([
                    thisArg
                ], NoopContextManager_read(args), false));
            };
            NoopContextManager.prototype.bind = function(_context, target) {
                return target;
            };
            NoopContextManager.prototype.enable = function() {
                return this;
            };
            NoopContextManager.prototype.disable = function() {
                return this;
            };
            return NoopContextManager;
        }();
        var ComponentLogger_read = function(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var i = m.call(o), r, ar = [], e;
            try {
                while((void 0 === n || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally{
                try {
                    if (r && !r.done && (m = i["return"])) m.call(i);
                } finally{
                    if (e) throw e.error;
                }
            }
            return ar;
        };
        var ComponentLogger_spreadArray = function(to, from, pack) {
            if (pack || 2 === arguments.length) {
                for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
                    if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
            return to.concat(ar || Array.prototype.slice.call(from));
        };
        var ComponentLogger_DiagComponentLogger = function() {
            function DiagComponentLogger(props) {
                this._namespace = props.namespace || 'DiagComponentLogger';
            }
            DiagComponentLogger.prototype.debug = function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                return logProxy('debug', this._namespace, args);
            };
            DiagComponentLogger.prototype.error = function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                return logProxy('error', this._namespace, args);
            };
            DiagComponentLogger.prototype.info = function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                return logProxy('info', this._namespace, args);
            };
            DiagComponentLogger.prototype.warn = function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                return logProxy('warn', this._namespace, args);
            };
            DiagComponentLogger.prototype.verbose = function() {
                var args = [];
                for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                return logProxy('verbose', this._namespace, args);
            };
            return DiagComponentLogger;
        }();
        function logProxy(funcName, namespace, args) {
            var logger = getGlobal('diag');
            if (!logger) return;
            args.unshift(namespace);
            return logger[funcName].apply(logger, ComponentLogger_spreadArray([], ComponentLogger_read(args), false));
        }
        var types_DiagLogLevel;
        (function(DiagLogLevel) {
            DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
            DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
            DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
            DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
            DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
            DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
            DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
        })(types_DiagLogLevel || (types_DiagLogLevel = {}));
        function createLogLevelDiagLogger(maxLevel, logger) {
            if (maxLevel < types_DiagLogLevel.NONE) maxLevel = types_DiagLogLevel.NONE;
            else if (maxLevel > types_DiagLogLevel.ALL) maxLevel = types_DiagLogLevel.ALL;
            logger = logger || {};
            function _filterFunc(funcName, theLevel) {
                var theFunc = logger[funcName];
                if ('function' == typeof theFunc && maxLevel >= theLevel) return theFunc.bind(logger);
                return function() {};
            }
            return {
                error: _filterFunc('error', types_DiagLogLevel.ERROR),
                warn: _filterFunc('warn', types_DiagLogLevel.WARN),
                info: _filterFunc('info', types_DiagLogLevel.INFO),
                debug: _filterFunc('debug', types_DiagLogLevel.DEBUG),
                verbose: _filterFunc('verbose', types_DiagLogLevel.VERBOSE)
            };
        }
        var diag_read = function(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var i = m.call(o), r, ar = [], e;
            try {
                while((void 0 === n || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally{
                try {
                    if (r && !r.done && (m = i["return"])) m.call(i);
                } finally{
                    if (e) throw e.error;
                }
            }
            return ar;
        };
        var diag_spreadArray = function(to, from, pack) {
            if (pack || 2 === arguments.length) {
                for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
                    if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
            return to.concat(ar || Array.prototype.slice.call(from));
        };
        var API_NAME = 'diag';
        var diag_DiagAPI = function() {
            function DiagAPI() {
                function _logProxy(funcName) {
                    return function() {
                        var args = [];
                        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                        var logger = getGlobal('diag');
                        if (!logger) return;
                        return logger[funcName].apply(logger, diag_spreadArray([], diag_read(args), false));
                    };
                }
                var self1 = this;
                var setLogger = function(logger, optionsOrLogLevel) {
                    var _a, _b, _c;
                    if (void 0 === optionsOrLogLevel) optionsOrLogLevel = {
                        logLevel: types_DiagLogLevel.INFO
                    };
                    if (logger === self1) {
                        var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                        self1.error(null != (_a = err.stack) ? _a : err.message);
                        return false;
                    }
                    if ('number' == typeof optionsOrLogLevel) optionsOrLogLevel = {
                        logLevel: optionsOrLogLevel
                    };
                    var oldLogger = getGlobal('diag');
                    var newLogger = createLogLevelDiagLogger(null != (_b = optionsOrLogLevel.logLevel) ? _b : types_DiagLogLevel.INFO, logger);
                    if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                        var stack = null != (_c = new Error().stack) ? _c : '<failed to generate stacktrace>';
                        oldLogger.warn("Current logger will be overwritten from " + stack);
                        newLogger.warn("Current logger will overwrite one already registered from " + stack);
                    }
                    return registerGlobal('diag', newLogger, self1, true);
                };
                self1.setLogger = setLogger;
                self1.disable = function() {
                    unregisterGlobal(API_NAME, self1);
                };
                self1.createComponentLogger = function(options) {
                    return new ComponentLogger_DiagComponentLogger(options);
                };
                self1.verbose = _logProxy('verbose');
                self1.debug = _logProxy('debug');
                self1.info = _logProxy('info');
                self1.warn = _logProxy('warn');
                self1.error = _logProxy('error');
            }
            DiagAPI.instance = function() {
                if (!this._instance) this._instance = new DiagAPI();
                return this._instance;
            };
            return DiagAPI;
        }();
        var context_read = function(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var i = m.call(o), r, ar = [], e;
            try {
                while((void 0 === n || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally{
                try {
                    if (r && !r.done && (m = i["return"])) m.call(i);
                } finally{
                    if (e) throw e.error;
                }
            }
            return ar;
        };
        var context_spreadArray = function(to, from, pack) {
            if (pack || 2 === arguments.length) {
                for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
                    if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
            return to.concat(ar || Array.prototype.slice.call(from));
        };
        var context_API_NAME = 'context';
        var NOOP_CONTEXT_MANAGER = new NoopContextManager_NoopContextManager();
        var context_ContextAPI = function() {
            function ContextAPI() {}
            ContextAPI.getInstance = function() {
                if (!this._instance) this._instance = new ContextAPI();
                return this._instance;
            };
            ContextAPI.prototype.setGlobalContextManager = function(contextManager) {
                return registerGlobal(context_API_NAME, contextManager, diag_DiagAPI.instance());
            };
            ContextAPI.prototype.active = function() {
                return this._getContextManager().active();
            };
            ContextAPI.prototype.with = function(context, fn, thisArg) {
                var _a;
                var args = [];
                for(var _i = 3; _i < arguments.length; _i++)args[_i - 3] = arguments[_i];
                return (_a = this._getContextManager()).with.apply(_a, context_spreadArray([
                    context,
                    fn,
                    thisArg
                ], context_read(args), false));
            };
            ContextAPI.prototype.bind = function(context, target) {
                return this._getContextManager().bind(context, target);
            };
            ContextAPI.prototype._getContextManager = function() {
                return getGlobal(context_API_NAME) || NOOP_CONTEXT_MANAGER;
            };
            ContextAPI.prototype.disable = function() {
                this._getContextManager().disable();
                unregisterGlobal(context_API_NAME, diag_DiagAPI.instance());
            };
            return ContextAPI;
        }();
        var trace_flags_TraceFlags;
        (function(TraceFlags) {
            TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
            TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
        })(trace_flags_TraceFlags || (trace_flags_TraceFlags = {}));
        var INVALID_SPANID = '0000000000000000';
        var INVALID_TRACEID = '00000000000000000000000000000000';
        var INVALID_SPAN_CONTEXT = {
            traceId: INVALID_TRACEID,
            spanId: INVALID_SPANID,
            traceFlags: trace_flags_TraceFlags.NONE
        };
        var NonRecordingSpan_NonRecordingSpan = function() {
            function NonRecordingSpan(_spanContext) {
                if (void 0 === _spanContext) _spanContext = INVALID_SPAN_CONTEXT;
                this._spanContext = _spanContext;
            }
            NonRecordingSpan.prototype.spanContext = function() {
                return this._spanContext;
            };
            NonRecordingSpan.prototype.setAttribute = function(_key, _value) {
                return this;
            };
            NonRecordingSpan.prototype.setAttributes = function(_attributes) {
                return this;
            };
            NonRecordingSpan.prototype.addEvent = function(_name, _attributes) {
                return this;
            };
            NonRecordingSpan.prototype.addLink = function(_link) {
                return this;
            };
            NonRecordingSpan.prototype.addLinks = function(_links) {
                return this;
            };
            NonRecordingSpan.prototype.setStatus = function(_status) {
                return this;
            };
            NonRecordingSpan.prototype.updateName = function(_name) {
                return this;
            };
            NonRecordingSpan.prototype.end = function(_endTime) {};
            NonRecordingSpan.prototype.isRecording = function() {
                return false;
            };
            NonRecordingSpan.prototype.recordException = function(_exception, _time) {};
            return NonRecordingSpan;
        }();
        var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
        function getSpan(context) {
            return context.getValue(SPAN_KEY) || void 0;
        }
        function getActiveSpan() {
            return getSpan(context_ContextAPI.getInstance().active());
        }
        function setSpan(context, span) {
            return context.setValue(SPAN_KEY, span);
        }
        function deleteSpan(context) {
            return context.deleteValue(SPAN_KEY);
        }
        function setSpanContext(context, spanContext) {
            return setSpan(context, new NonRecordingSpan_NonRecordingSpan(spanContext));
        }
        function getSpanContext(context) {
            var _a;
            return null == (_a = getSpan(context)) ? void 0 : _a.spanContext();
        }
        var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
        var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
        function isValidTraceId(traceId) {
            return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
        }
        function isValidSpanId(spanId) {
            return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
        }
        function isSpanContextValid(spanContext) {
            return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
        }
        function wrapSpanContext(spanContext) {
            return new NonRecordingSpan_NonRecordingSpan(spanContext);
        }
        var contextApi = context_ContextAPI.getInstance();
        var NoopTracer_NoopTracer = function() {
            function NoopTracer() {}
            NoopTracer.prototype.startSpan = function(name, options, context) {
                if (void 0 === context) context = contextApi.active();
                var root = Boolean(null == options ? void 0 : options.root);
                if (root) return new NonRecordingSpan_NonRecordingSpan();
                var parentFromContext = context && getSpanContext(context);
                if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) return new NonRecordingSpan_NonRecordingSpan(parentFromContext);
                return new NonRecordingSpan_NonRecordingSpan();
            };
            NoopTracer.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
                var opts;
                var ctx;
                var fn;
                if (arguments.length < 2) return;
                if (2 === arguments.length) fn = arg2;
                else if (3 === arguments.length) {
                    opts = arg2;
                    fn = arg3;
                } else {
                    opts = arg2;
                    ctx = arg3;
                    fn = arg4;
                }
                var parentContext = null != ctx ? ctx : contextApi.active();
                var span = this.startSpan(name, opts, parentContext);
                var contextWithSpanSet = setSpan(parentContext, span);
                return contextApi.with(contextWithSpanSet, fn, void 0, span);
            };
            return NoopTracer;
        }();
        function isSpanContext(spanContext) {
            return 'object' == typeof spanContext && 'string' == typeof spanContext['spanId'] && 'string' == typeof spanContext['traceId'] && 'number' == typeof spanContext['traceFlags'];
        }
        var NOOP_TRACER = new NoopTracer_NoopTracer();
        var ProxyTracer_ProxyTracer = function() {
            function ProxyTracer(_provider, name, version, options) {
                this._provider = _provider;
                this.name = name;
                this.version = version;
                this.options = options;
            }
            ProxyTracer.prototype.startSpan = function(name, options, context) {
                return this._getTracer().startSpan(name, options, context);
            };
            ProxyTracer.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
                var tracer = this._getTracer();
                return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
            };
            ProxyTracer.prototype._getTracer = function() {
                if (this._delegate) return this._delegate;
                var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
                if (!tracer) return NOOP_TRACER;
                this._delegate = tracer;
                return this._delegate;
            };
            return ProxyTracer;
        }();
        var NoopTracerProvider_NoopTracerProvider = function() {
            function NoopTracerProvider() {}
            NoopTracerProvider.prototype.getTracer = function(_name, _version, _options) {
                return new NoopTracer_NoopTracer();
            };
            return NoopTracerProvider;
        }();
        var NOOP_TRACER_PROVIDER = new NoopTracerProvider_NoopTracerProvider();
        var ProxyTracerProvider_ProxyTracerProvider = function() {
            function ProxyTracerProvider() {}
            ProxyTracerProvider.prototype.getTracer = function(name, version, options) {
                var _a;
                return null != (_a = this.getDelegateTracer(name, version, options)) ? _a : new ProxyTracer_ProxyTracer(this, name, version, options);
            };
            ProxyTracerProvider.prototype.getDelegate = function() {
                var _a;
                return null != (_a = this._delegate) ? _a : NOOP_TRACER_PROVIDER;
            };
            ProxyTracerProvider.prototype.setDelegate = function(delegate) {
                this._delegate = delegate;
            };
            ProxyTracerProvider.prototype.getDelegateTracer = function(name, version, options) {
                var _a;
                return null == (_a = this._delegate) ? void 0 : _a.getTracer(name, version, options);
            };
            return ProxyTracerProvider;
        }();
        var trace_API_NAME = 'trace';
        var trace_TraceAPI = function() {
            function TraceAPI() {
                this._proxyTracerProvider = new ProxyTracerProvider_ProxyTracerProvider();
                this.wrapSpanContext = wrapSpanContext;
                this.isSpanContextValid = isSpanContextValid;
                this.deleteSpan = deleteSpan;
                this.getSpan = getSpan;
                this.getActiveSpan = getActiveSpan;
                this.getSpanContext = getSpanContext;
                this.setSpan = setSpan;
                this.setSpanContext = setSpanContext;
            }
            TraceAPI.getInstance = function() {
                if (!this._instance) this._instance = new TraceAPI();
                return this._instance;
            };
            TraceAPI.prototype.setGlobalTracerProvider = function(provider) {
                var success = registerGlobal(trace_API_NAME, this._proxyTracerProvider, diag_DiagAPI.instance());
                if (success) this._proxyTracerProvider.setDelegate(provider);
                return success;
            };
            TraceAPI.prototype.getTracerProvider = function() {
                return getGlobal(trace_API_NAME) || this._proxyTracerProvider;
            };
            TraceAPI.prototype.getTracer = function(name, version) {
                return this.getTracerProvider().getTracer(name, version);
            };
            TraceAPI.prototype.disable = function() {
                unregisterGlobal(trace_API_NAME, diag_DiagAPI.instance());
                this._proxyTracerProvider = new ProxyTracerProvider_ProxyTracerProvider();
            };
            return TraceAPI;
        }();
        var trace = trace_TraceAPI.getInstance();
        var context_api_context = context_ContextAPI.getInstance();
        var interfaces_SpanKind;
        (function(SpanKind) {
            SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
            SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
            SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
            SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
            SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
        })(interfaces_SpanKind || (interfaces_SpanKind = {}));
        function interfaces_setSpan(context, span) {
            return trace.setSpan(context, span);
        }
        function interfaces_isSpanContextValid(context) {
            return trace.isSpanContextValid(context);
        }
        function getTracer(name, version) {
            return trace.getTracer(name || "azure/core-tracing", version);
        }
        const interfaces_context = context_api_context;
        var interfaces_SpanStatusCode;
        (function(SpanStatusCode) {
            SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
            SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
            SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
        })(interfaces_SpanStatusCode || (interfaces_SpanStatusCode = {}));
        function operationOptionsToRequestOptionsBase(opts) {
            const { requestOptions, tracingOptions } = opts, additionalOptions = __rest(opts, [
                "requestOptions",
                "tracingOptions"
            ]);
            let result = additionalOptions;
            if (requestOptions) result = Object.assign(Object.assign({}, result), requestOptions);
            if (tracingOptions) {
                result.tracingContext = tracingOptions.tracingContext;
                result.spanOptions = null == tracingOptions ? void 0 : tracingOptions.spanOptions;
            }
            return result;
        }
        function encodeByteArray(value) {
            const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
            return bufferValue.toString("base64");
        }
        function decodeString(value) {
            return Buffer.from(value, "base64");
        }
        class Serializer {
            constructor(modelMappers = {}, isXML){
                this.modelMappers = modelMappers;
                this.isXML = isXML;
            }
            validateConstraints(mapper, value, objectName) {
                const failValidation = (constraintName, constraintValue)=>{
                    throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
                };
                if (mapper.constraints && void 0 != value) {
                    const valueAsNumber = value;
                    const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
                    if (void 0 != ExclusiveMaximum && valueAsNumber >= ExclusiveMaximum) failValidation("ExclusiveMaximum", ExclusiveMaximum);
                    if (void 0 != ExclusiveMinimum && valueAsNumber <= ExclusiveMinimum) failValidation("ExclusiveMinimum", ExclusiveMinimum);
                    if (void 0 != InclusiveMaximum && valueAsNumber > InclusiveMaximum) failValidation("InclusiveMaximum", InclusiveMaximum);
                    if (void 0 != InclusiveMinimum && valueAsNumber < InclusiveMinimum) failValidation("InclusiveMinimum", InclusiveMinimum);
                    const valueAsArray = value;
                    if (void 0 != MaxItems && valueAsArray.length > MaxItems) failValidation("MaxItems", MaxItems);
                    if (void 0 != MaxLength && valueAsArray.length > MaxLength) failValidation("MaxLength", MaxLength);
                    if (void 0 != MinItems && valueAsArray.length < MinItems) failValidation("MinItems", MinItems);
                    if (void 0 != MinLength && valueAsArray.length < MinLength) failValidation("MinLength", MinLength);
                    if (void 0 != MultipleOf && valueAsNumber % MultipleOf !== 0) failValidation("MultipleOf", MultipleOf);
                    if (Pattern) {
                        const pattern = "string" == typeof Pattern ? new RegExp(Pattern) : Pattern;
                        if ("string" != typeof value || null === value.match(pattern)) failValidation("Pattern", Pattern);
                    }
                    if (UniqueItems && valueAsArray.some((item, i, ar)=>ar.indexOf(item) !== i)) failValidation("UniqueItems", UniqueItems);
                }
            }
            serialize(mapper, object, objectName, options = {}) {
                var _a, _b, _c;
                const updatedOptions = {
                    rootName: null != (_a = options.rootName) ? _a : "",
                    includeRoot: null != (_b = options.includeRoot) ? _b : false,
                    xmlCharKey: null != (_c = options.xmlCharKey) ? _c : "_"
                };
                let payload = {};
                const mapperType = mapper.type.name;
                if (!objectName) objectName = mapper.serializedName;
                if (null !== mapperType.match(/^Sequence$/i)) payload = [];
                if (mapper.isConstant) object = mapper.defaultValue;
                const { required, nullable } = mapper;
                if (required && nullable && void 0 === object) throw new Error(`${objectName} cannot be undefined.`);
                if (required && !nullable && void 0 == object) throw new Error(`${objectName} cannot be null or undefined.`);
                if (!required && false === nullable && null === object) throw new Error(`${objectName} cannot be null.`);
                if (void 0 == object) payload = object;
                else if (null !== mapperType.match(/^any$/i)) payload = object;
                else if (null !== mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i)) payload = serializeBasicTypes(mapperType, objectName, object);
                else if (null !== mapperType.match(/^Enum$/i)) {
                    const enumMapper = mapper;
                    payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
                } else if (null !== mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i)) payload = serializeDateTypes(mapperType, object, objectName);
                else if (null !== mapperType.match(/^ByteArray$/i)) payload = serializeByteArrayType(objectName, object);
                else if (null !== mapperType.match(/^Base64Url$/i)) payload = serializeBase64UrlType(objectName, object);
                else if (null !== mapperType.match(/^Sequence$/i)) payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
                else if (null !== mapperType.match(/^Dictionary$/i)) payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
                else if (null !== mapperType.match(/^Composite$/i)) payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
                return payload;
            }
            deserialize(mapper, responseBody, objectName, options = {}) {
                var _a, _b, _c;
                const updatedOptions = {
                    rootName: null != (_a = options.rootName) ? _a : "",
                    includeRoot: null != (_b = options.includeRoot) ? _b : false,
                    xmlCharKey: null != (_c = options.xmlCharKey) ? _c : "_"
                };
                if (void 0 == responseBody) {
                    if (this.isXML && "Sequence" === mapper.type.name && !mapper.xmlIsWrapped) responseBody = [];
                    if (void 0 !== mapper.defaultValue) responseBody = mapper.defaultValue;
                    return responseBody;
                }
                let payload;
                const mapperType = mapper.type.name;
                if (!objectName) objectName = mapper.serializedName;
                if (null !== mapperType.match(/^Composite$/i)) payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
                else {
                    if (this.isXML) {
                        const xmlCharKey = updatedOptions.xmlCharKey;
                        const castResponseBody = responseBody;
                        if (void 0 != castResponseBody["$"] && void 0 != castResponseBody[xmlCharKey]) responseBody = castResponseBody[xmlCharKey];
                    }
                    if (null !== mapperType.match(/^Number$/i)) {
                        payload = parseFloat(responseBody);
                        if (isNaN(payload)) payload = responseBody;
                    } else if (null !== mapperType.match(/^Boolean$/i)) payload = "true" === responseBody ? true : "false" === responseBody ? false : responseBody;
                    else if (null !== mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i)) payload = responseBody;
                    else if (null !== mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i)) payload = new Date(responseBody);
                    else if (null !== mapperType.match(/^UnixTime$/i)) payload = unixTimeToDate(responseBody);
                    else if (null !== mapperType.match(/^ByteArray$/i)) payload = decodeString(responseBody);
                    else if (null !== mapperType.match(/^Base64Url$/i)) payload = base64UrlToByteArray(responseBody);
                    else if (null !== mapperType.match(/^Sequence$/i)) payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
                    else if (null !== mapperType.match(/^Dictionary$/i)) payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
                }
                if (mapper.isConstant) payload = mapper.defaultValue;
                return payload;
            }
        }
        function trimEnd(str, ch) {
            let len = str.length;
            while(len - 1 >= 0 && str[len - 1] === ch)--len;
            return str.substr(0, len);
        }
        function bufferToBase64Url(buffer) {
            if (!buffer) return;
            if (!(buffer instanceof Uint8Array)) throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
            const str = encodeByteArray(buffer);
            return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
        }
        function base64UrlToByteArray(str) {
            if (!str) return;
            if (str && "string" != typeof str.valueOf()) throw new Error("Please provide an input of type string for converting to Uint8Array");
            str = str.replace(/-/g, "+").replace(/_/g, "/");
            return decodeString(str);
        }
        function splitSerializeName(prop) {
            const classes = [];
            let partialclass = "";
            if (prop) {
                const subwords = prop.split(".");
                for (const item of subwords)if ("\\" === item.charAt(item.length - 1)) partialclass += item.substr(0, item.length - 1) + ".";
                else {
                    partialclass += item;
                    classes.push(partialclass);
                    partialclass = "";
                }
            }
            return classes;
        }
        function dateToUnixTime(d) {
            if (!d) return;
            if ("string" == typeof d.valueOf()) d = new Date(d);
            return Math.floor(d.getTime() / 1000);
        }
        function unixTimeToDate(n) {
            if (!n) return;
            return new Date(1000 * n);
        }
        function serializeBasicTypes(typeName, objectName, value) {
            if (null != value) {
                if (null !== typeName.match(/^Number$/i)) {
                    if ("number" != typeof value) throw new Error(`${objectName} with value ${value} must be of type number.`);
                } else if (null !== typeName.match(/^String$/i)) {
                    if ("string" != typeof value.valueOf()) throw new Error(`${objectName} with value "${value}" must be of type string.`);
                } else if (null !== typeName.match(/^Uuid$/i)) {
                    if (!("string" == typeof value.valueOf() && isValidUuid(value))) throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
                } else if (null !== typeName.match(/^Boolean$/i)) {
                    if ("boolean" != typeof value) throw new Error(`${objectName} with value ${value} must be of type boolean.`);
                } else if (null !== typeName.match(/^Stream$/i)) {
                    const objectType = typeof value;
                    if ("string" !== objectType && "function" !== objectType && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !(("function" == typeof Blob || "object" == typeof Blob) && value instanceof Blob)) throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`);
                }
            }
            return value;
        }
        function serializeEnumType(objectName, allowedValues, value) {
            if (!allowedValues) throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
            const isPresent = allowedValues.some((item)=>{
                if ("string" == typeof item.valueOf()) return item.toLowerCase() === value.toLowerCase();
                return item === value;
            });
            if (!isPresent) throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
            return value;
        }
        function serializeByteArrayType(objectName, value) {
            let returnValue = "";
            if (void 0 != value) {
                if (!(value instanceof Uint8Array)) throw new Error(`${objectName} must be of type Uint8Array.`);
                returnValue = encodeByteArray(value);
            }
            return returnValue;
        }
        function serializeBase64UrlType(objectName, value) {
            let returnValue = "";
            if (void 0 != value) {
                if (!(value instanceof Uint8Array)) throw new Error(`${objectName} must be of type Uint8Array.`);
                returnValue = bufferToBase64Url(value) || "";
            }
            return returnValue;
        }
        function serializeDateTypes(typeName, value, objectName) {
            if (void 0 != value) {
                if (null !== typeName.match(/^Date$/i)) {
                    if (!(value instanceof Date || "string" == typeof value.valueOf() && !isNaN(Date.parse(value)))) throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
                    value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
                } else if (null !== typeName.match(/^DateTime$/i)) {
                    if (!(value instanceof Date || "string" == typeof value.valueOf() && !isNaN(Date.parse(value)))) throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
                    value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
                } else if (null !== typeName.match(/^DateTimeRfc1123$/i)) {
                    if (!(value instanceof Date || "string" == typeof value.valueOf() && !isNaN(Date.parse(value)))) throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
                    value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
                } else if (null !== typeName.match(/^UnixTime$/i)) {
                    if (!(value instanceof Date || "string" == typeof value.valueOf() && !isNaN(Date.parse(value)))) throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
                    value = dateToUnixTime(value);
                } else if (null !== typeName.match(/^TimeSpan$/i)) {
                    if (!isDuration(value)) throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
                }
            }
            return value;
        }
        function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
            if (!Array.isArray(object)) throw new Error(`${objectName} must be of type Array.`);
            const elementType = mapper.type.element;
            if (!elementType || "object" != typeof elementType) throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
            const tempArray = [];
            for(let i = 0; i < object.length; i++){
                const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
                if (isXml && elementType.xmlNamespace) {
                    const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
                    if ("Composite" === elementType.type.name) {
                        tempArray[i] = Object.assign({}, serializedValue);
                        tempArray[i]["$"] = {
                            [xmlnsKey]: elementType.xmlNamespace
                        };
                    } else {
                        tempArray[i] = {};
                        tempArray[i][options.xmlCharKey] = serializedValue;
                        tempArray[i]["$"] = {
                            [xmlnsKey]: elementType.xmlNamespace
                        };
                    }
                } else tempArray[i] = serializedValue;
            }
            return tempArray;
        }
        function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
            if ("object" != typeof object) throw new Error(`${objectName} must be of type object.`);
            const valueType = mapper.type.value;
            if (!valueType || "object" != typeof valueType) throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
            const tempDictionary = {};
            for (const key of Object.keys(object)){
                const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
                tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
            }
            if (isXml && mapper.xmlNamespace) {
                const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
                const result = tempDictionary;
                result["$"] = {
                    [xmlnsKey]: mapper.xmlNamespace
                };
                return result;
            }
            return tempDictionary;
        }
        function resolveAdditionalProperties(serializer, mapper, objectName) {
            const additionalProperties = mapper.type.additionalProperties;
            if (!additionalProperties && mapper.type.className) {
                const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
                return null == modelMapper ? void 0 : modelMapper.type.additionalProperties;
            }
            return additionalProperties;
        }
        function resolveReferencedMapper(serializer, mapper, objectName) {
            const className = mapper.type.className;
            if (!className) throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
            return serializer.modelMappers[className];
        }
        function resolveModelProperties(serializer, mapper, objectName) {
            let modelProps = mapper.type.modelProperties;
            if (!modelProps) {
                const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
                if (!modelMapper) throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
                modelProps = null == modelMapper ? void 0 : modelMapper.type.modelProperties;
                if (!modelProps) throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
            }
            return modelProps;
        }
        function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
            if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
            if (void 0 != object) {
                const payload = {};
                const modelProps = resolveModelProperties(serializer, mapper, objectName);
                for (const key of Object.keys(modelProps)){
                    const propertyMapper = modelProps[key];
                    if (propertyMapper.readOnly) continue;
                    let propName;
                    let parentObject = payload;
                    if (serializer.isXML) propName = propertyMapper.xmlIsWrapped ? propertyMapper.xmlName : propertyMapper.xmlElementName || propertyMapper.xmlName;
                    else {
                        const paths = splitSerializeName(propertyMapper.serializedName);
                        propName = paths.pop();
                        for (const pathName of paths){
                            const childObject = parentObject[pathName];
                            if (void 0 == childObject && (void 0 != object[key] || void 0 !== propertyMapper.defaultValue)) parentObject[pathName] = {};
                            parentObject = parentObject[pathName];
                        }
                    }
                    if (void 0 != parentObject) {
                        if (isXml && mapper.xmlNamespace) {
                            const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
                            parentObject["$"] = Object.assign(Object.assign({}, parentObject["$"]), {
                                [xmlnsKey]: mapper.xmlNamespace
                            });
                        }
                        const propertyObjectName = "" !== propertyMapper.serializedName ? objectName + "." + propertyMapper.serializedName : objectName;
                        let toSerialize = object[key];
                        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
                        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && void 0 == toSerialize) toSerialize = mapper.serializedName;
                        const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
                        if (void 0 !== serializedValue && void 0 != propName) {
                            const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
                            if (isXml && propertyMapper.xmlIsAttribute) {
                                parentObject["$"] = parentObject["$"] || {};
                                parentObject["$"][propName] = serializedValue;
                            } else if (isXml && propertyMapper.xmlIsWrapped) parentObject[propName] = {
                                [propertyMapper.xmlElementName]: value
                            };
                            else parentObject[propName] = value;
                        }
                    }
                }
                const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
                if (additionalPropertiesMapper) {
                    const propNames = Object.keys(modelProps);
                    for(const clientPropName in object){
                        const isAdditionalProperty = propNames.every((pn)=>pn !== clientPropName);
                        if (isAdditionalProperty) payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
                    }
                }
                return payload;
            }
            return object;
        }
        function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
            if (!isXml || !propertyMapper.xmlNamespace) return serializedValue;
            const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
            const xmlNamespace = {
                [xmlnsKey]: propertyMapper.xmlNamespace
            };
            if ([
                "Composite"
            ].includes(propertyMapper.type.name)) if (serializedValue["$"]) return serializedValue;
            else {
                const result = Object.assign({}, serializedValue);
                result["$"] = xmlNamespace;
                return result;
            }
            const result = {};
            result[options.xmlCharKey] = serializedValue;
            result["$"] = xmlNamespace;
            return result;
        }
        function isSpecialXmlProperty(propertyName, options) {
            return [
                "$",
                options.xmlCharKey
            ].includes(propertyName);
        }
        function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
            var _a, _b;
            const xmlCharKey = null != (_a = options.xmlCharKey) ? _a : "_";
            if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
            const modelProps = resolveModelProperties(serializer, mapper, objectName);
            let instance = {};
            const handledPropertyNames = [];
            for (const key of Object.keys(modelProps)){
                const propertyMapper = modelProps[key];
                const paths = splitSerializeName(modelProps[key].serializedName);
                handledPropertyNames.push(paths[0]);
                const { serializedName, xmlName, xmlElementName } = propertyMapper;
                let propertyObjectName = objectName;
                if ("" !== serializedName && void 0 !== serializedName) propertyObjectName = objectName + "." + serializedName;
                const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
                if (headerCollectionPrefix) {
                    const dictionary = {};
                    for (const headerKey of Object.keys(responseBody)){
                        if (headerKey.startsWith(headerCollectionPrefix)) dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
                        handledPropertyNames.push(headerKey);
                    }
                    instance[key] = dictionary;
                } else if (serializer.isXML) if (propertyMapper.xmlIsAttribute && responseBody["$"]) instance[key] = serializer.deserialize(propertyMapper, responseBody["$"][xmlName], propertyObjectName, options);
                else if (propertyMapper.xmlIsMsText) {
                    if (void 0 !== responseBody[xmlCharKey]) instance[key] = responseBody[xmlCharKey];
                    else if ("string" == typeof responseBody) instance[key] = responseBody;
                } else {
                    const propertyName = xmlElementName || xmlName || serializedName;
                    if (propertyMapper.xmlIsWrapped) {
                        const wrapped = responseBody[xmlName];
                        const elementList = null != (_b = null == wrapped ? void 0 : wrapped[xmlElementName]) ? _b : [];
                        instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
                        handledPropertyNames.push(xmlName);
                    } else {
                        const property = responseBody[propertyName];
                        instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
                        handledPropertyNames.push(propertyName);
                    }
                }
                else {
                    let propertyInstance;
                    let res = responseBody;
                    for (const item of paths){
                        if (!res) break;
                        res = res[item];
                    }
                    propertyInstance = res;
                    const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
                    if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && void 0 == propertyInstance) propertyInstance = mapper.serializedName;
                    let serializedValue;
                    if (Array.isArray(responseBody[key]) && "" === modelProps[key].serializedName) {
                        propertyInstance = responseBody[key];
                        const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                        for (const [k, v] of Object.entries(instance))if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) arrayInstance[k] = v;
                        instance = arrayInstance;
                    } else if (void 0 !== propertyInstance || void 0 !== propertyMapper.defaultValue) {
                        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                        instance[key] = serializedValue;
                    }
                }
            }
            const additionalPropertiesMapper = mapper.type.additionalProperties;
            if (additionalPropertiesMapper) {
                const isAdditionalProperty = (responsePropName)=>{
                    for(const clientPropName in modelProps){
                        const paths = splitSerializeName(modelProps[clientPropName].serializedName);
                        if (paths[0] === responsePropName) return false;
                    }
                    return true;
                };
                for(const responsePropName in responseBody)if (isAdditionalProperty(responsePropName)) instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
            } else if (responseBody) {
                for (const key of Object.keys(responseBody))if (void 0 === instance[key] && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) instance[key] = responseBody[key];
            }
            return instance;
        }
        function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
            const value = mapper.type.value;
            if (!value || "object" != typeof value) throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
            if (responseBody) {
                const tempDictionary = {};
                for (const key of Object.keys(responseBody))tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
                return tempDictionary;
            }
            return responseBody;
        }
        function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
            const element = mapper.type.element;
            if (!element || "object" != typeof element) throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
            if (responseBody) {
                if (!Array.isArray(responseBody)) responseBody = [
                    responseBody
                ];
                const tempArray = [];
                for(let i = 0; i < responseBody.length; i++)tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
                return tempArray;
            }
            return responseBody;
        }
        function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
            const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
            if (polymorphicDiscriminator) {
                const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
                if (void 0 != discriminatorName) {
                    const discriminatorValue = object[discriminatorName];
                    if (void 0 != discriminatorValue) {
                        const typeName = mapper.type.uberParent || mapper.type.className;
                        const indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + "." + discriminatorValue;
                        const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];
                        if (polymorphicMapper) mapper = polymorphicMapper;
                    }
                }
            }
            return mapper;
        }
        function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
            return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
        }
        function getPolymorphicDiscriminatorSafely(serializer, typeName) {
            return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
        }
        function strEnum(o) {
            const result = {};
            for (const key of o)result[key] = key;
            return result;
        }
        const MapperType = strEnum([
            "Base64Url",
            "Boolean",
            "ByteArray",
            "Composite",
            "Date",
            "DateTime",
            "DateTimeRfc1123",
            "Dictionary",
            "Enum",
            "Number",
            "Object",
            "Sequence",
            "String",
            "Stream",
            "TimeSpan",
            "UnixTime"
        ]);
        const BlobServiceProperties = {
            serializedName: "BlobServiceProperties",
            xmlName: "StorageServiceProperties",
            type: {
                name: "Composite",
                className: "BlobServiceProperties",
                modelProperties: {
                    blobAnalyticsLogging: {
                        serializedName: "Logging",
                        xmlName: "Logging",
                        type: {
                            name: "Composite",
                            className: "Logging"
                        }
                    },
                    hourMetrics: {
                        serializedName: "HourMetrics",
                        xmlName: "HourMetrics",
                        type: {
                            name: "Composite",
                            className: "Metrics"
                        }
                    },
                    minuteMetrics: {
                        serializedName: "MinuteMetrics",
                        xmlName: "MinuteMetrics",
                        type: {
                            name: "Composite",
                            className: "Metrics"
                        }
                    },
                    cors: {
                        serializedName: "Cors",
                        xmlName: "Cors",
                        xmlIsWrapped: true,
                        xmlElementName: "CorsRule",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "CorsRule"
                                }
                            }
                        }
                    },
                    defaultServiceVersion: {
                        serializedName: "DefaultServiceVersion",
                        xmlName: "DefaultServiceVersion",
                        type: {
                            name: "String"
                        }
                    },
                    deleteRetentionPolicy: {
                        serializedName: "DeleteRetentionPolicy",
                        xmlName: "DeleteRetentionPolicy",
                        type: {
                            name: "Composite",
                            className: "RetentionPolicy"
                        }
                    },
                    staticWebsite: {
                        serializedName: "StaticWebsite",
                        xmlName: "StaticWebsite",
                        type: {
                            name: "Composite",
                            className: "StaticWebsite"
                        }
                    }
                }
            }
        };
        const Logging = {
            serializedName: "Logging",
            type: {
                name: "Composite",
                className: "Logging",
                modelProperties: {
                    version: {
                        serializedName: "Version",
                        required: true,
                        xmlName: "Version",
                        type: {
                            name: "String"
                        }
                    },
                    deleteProperty: {
                        serializedName: "Delete",
                        required: true,
                        xmlName: "Delete",
                        type: {
                            name: "Boolean"
                        }
                    },
                    read: {
                        serializedName: "Read",
                        required: true,
                        xmlName: "Read",
                        type: {
                            name: "Boolean"
                        }
                    },
                    write: {
                        serializedName: "Write",
                        required: true,
                        xmlName: "Write",
                        type: {
                            name: "Boolean"
                        }
                    },
                    retentionPolicy: {
                        serializedName: "RetentionPolicy",
                        xmlName: "RetentionPolicy",
                        type: {
                            name: "Composite",
                            className: "RetentionPolicy"
                        }
                    }
                }
            }
        };
        const RetentionPolicy = {
            serializedName: "RetentionPolicy",
            type: {
                name: "Composite",
                className: "RetentionPolicy",
                modelProperties: {
                    enabled: {
                        serializedName: "Enabled",
                        required: true,
                        xmlName: "Enabled",
                        type: {
                            name: "Boolean"
                        }
                    },
                    days: {
                        constraints: {
                            InclusiveMinimum: 1
                        },
                        serializedName: "Days",
                        xmlName: "Days",
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        };
        const Metrics = {
            serializedName: "Metrics",
            type: {
                name: "Composite",
                className: "Metrics",
                modelProperties: {
                    version: {
                        serializedName: "Version",
                        xmlName: "Version",
                        type: {
                            name: "String"
                        }
                    },
                    enabled: {
                        serializedName: "Enabled",
                        required: true,
                        xmlName: "Enabled",
                        type: {
                            name: "Boolean"
                        }
                    },
                    includeAPIs: {
                        serializedName: "IncludeAPIs",
                        xmlName: "IncludeAPIs",
                        type: {
                            name: "Boolean"
                        }
                    },
                    retentionPolicy: {
                        serializedName: "RetentionPolicy",
                        xmlName: "RetentionPolicy",
                        type: {
                            name: "Composite",
                            className: "RetentionPolicy"
                        }
                    }
                }
            }
        };
        const CorsRule = {
            serializedName: "CorsRule",
            type: {
                name: "Composite",
                className: "CorsRule",
                modelProperties: {
                    allowedOrigins: {
                        serializedName: "AllowedOrigins",
                        required: true,
                        xmlName: "AllowedOrigins",
                        type: {
                            name: "String"
                        }
                    },
                    allowedMethods: {
                        serializedName: "AllowedMethods",
                        required: true,
                        xmlName: "AllowedMethods",
                        type: {
                            name: "String"
                        }
                    },
                    allowedHeaders: {
                        serializedName: "AllowedHeaders",
                        required: true,
                        xmlName: "AllowedHeaders",
                        type: {
                            name: "String"
                        }
                    },
                    exposedHeaders: {
                        serializedName: "ExposedHeaders",
                        required: true,
                        xmlName: "ExposedHeaders",
                        type: {
                            name: "String"
                        }
                    },
                    maxAgeInSeconds: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        serializedName: "MaxAgeInSeconds",
                        required: true,
                        xmlName: "MaxAgeInSeconds",
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        };
        const StaticWebsite = {
            serializedName: "StaticWebsite",
            type: {
                name: "Composite",
                className: "StaticWebsite",
                modelProperties: {
                    enabled: {
                        serializedName: "Enabled",
                        required: true,
                        xmlName: "Enabled",
                        type: {
                            name: "Boolean"
                        }
                    },
                    indexDocument: {
                        serializedName: "IndexDocument",
                        xmlName: "IndexDocument",
                        type: {
                            name: "String"
                        }
                    },
                    errorDocument404Path: {
                        serializedName: "ErrorDocument404Path",
                        xmlName: "ErrorDocument404Path",
                        type: {
                            name: "String"
                        }
                    },
                    defaultIndexDocumentPath: {
                        serializedName: "DefaultIndexDocumentPath",
                        xmlName: "DefaultIndexDocumentPath",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const StorageError = {
            serializedName: "StorageError",
            type: {
                name: "Composite",
                className: "StorageError",
                modelProperties: {
                    message: {
                        serializedName: "Message",
                        xmlName: "Message",
                        type: {
                            name: "String"
                        }
                    },
                    code: {
                        serializedName: "Code",
                        xmlName: "Code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobServiceStatistics = {
            serializedName: "BlobServiceStatistics",
            xmlName: "StorageServiceStats",
            type: {
                name: "Composite",
                className: "BlobServiceStatistics",
                modelProperties: {
                    geoReplication: {
                        serializedName: "GeoReplication",
                        xmlName: "GeoReplication",
                        type: {
                            name: "Composite",
                            className: "GeoReplication"
                        }
                    }
                }
            }
        };
        const GeoReplication = {
            serializedName: "GeoReplication",
            type: {
                name: "Composite",
                className: "GeoReplication",
                modelProperties: {
                    status: {
                        serializedName: "Status",
                        required: true,
                        xmlName: "Status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "live",
                                "bootstrap",
                                "unavailable"
                            ]
                        }
                    },
                    lastSyncOn: {
                        serializedName: "LastSyncTime",
                        required: true,
                        xmlName: "LastSyncTime",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const ListContainersSegmentResponse = {
            serializedName: "ListContainersSegmentResponse",
            xmlName: "EnumerationResults",
            type: {
                name: "Composite",
                className: "ListContainersSegmentResponse",
                modelProperties: {
                    serviceEndpoint: {
                        serializedName: "ServiceEndpoint",
                        required: true,
                        xmlName: "ServiceEndpoint",
                        xmlIsAttribute: true,
                        type: {
                            name: "String"
                        }
                    },
                    prefix: {
                        serializedName: "Prefix",
                        xmlName: "Prefix",
                        type: {
                            name: "String"
                        }
                    },
                    marker: {
                        serializedName: "Marker",
                        xmlName: "Marker",
                        type: {
                            name: "String"
                        }
                    },
                    maxPageSize: {
                        serializedName: "MaxResults",
                        xmlName: "MaxResults",
                        type: {
                            name: "Number"
                        }
                    },
                    containerItems: {
                        serializedName: "ContainerItems",
                        required: true,
                        xmlName: "Containers",
                        xmlIsWrapped: true,
                        xmlElementName: "Container",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "ContainerItem"
                                }
                            }
                        }
                    },
                    continuationToken: {
                        serializedName: "NextMarker",
                        xmlName: "NextMarker",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerItem = {
            serializedName: "ContainerItem",
            xmlName: "Container",
            type: {
                name: "Composite",
                className: "ContainerItem",
                modelProperties: {
                    name: {
                        serializedName: "Name",
                        required: true,
                        xmlName: "Name",
                        type: {
                            name: "String"
                        }
                    },
                    deleted: {
                        serializedName: "Deleted",
                        xmlName: "Deleted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    version: {
                        serializedName: "Version",
                        xmlName: "Version",
                        type: {
                            name: "String"
                        }
                    },
                    properties: {
                        serializedName: "Properties",
                        xmlName: "Properties",
                        type: {
                            name: "Composite",
                            className: "ContainerProperties"
                        }
                    },
                    metadata: {
                        serializedName: "Metadata",
                        xmlName: "Metadata",
                        type: {
                            name: "Dictionary",
                            value: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            }
        };
        const ContainerProperties = {
            serializedName: "ContainerProperties",
            type: {
                name: "Composite",
                className: "ContainerProperties",
                modelProperties: {
                    lastModified: {
                        serializedName: "Last-Modified",
                        required: true,
                        xmlName: "Last-Modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    etag: {
                        serializedName: "Etag",
                        required: true,
                        xmlName: "Etag",
                        type: {
                            name: "String"
                        }
                    },
                    leaseStatus: {
                        serializedName: "LeaseStatus",
                        xmlName: "LeaseStatus",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "locked",
                                "unlocked"
                            ]
                        }
                    },
                    leaseState: {
                        serializedName: "LeaseState",
                        xmlName: "LeaseState",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "available",
                                "leased",
                                "expired",
                                "breaking",
                                "broken"
                            ]
                        }
                    },
                    leaseDuration: {
                        serializedName: "LeaseDuration",
                        xmlName: "LeaseDuration",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "infinite",
                                "fixed"
                            ]
                        }
                    },
                    publicAccess: {
                        serializedName: "PublicAccess",
                        xmlName: "PublicAccess",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "container",
                                "blob"
                            ]
                        }
                    },
                    hasImmutabilityPolicy: {
                        serializedName: "HasImmutabilityPolicy",
                        xmlName: "HasImmutabilityPolicy",
                        type: {
                            name: "Boolean"
                        }
                    },
                    hasLegalHold: {
                        serializedName: "HasLegalHold",
                        xmlName: "HasLegalHold",
                        type: {
                            name: "Boolean"
                        }
                    },
                    defaultEncryptionScope: {
                        serializedName: "DefaultEncryptionScope",
                        xmlName: "DefaultEncryptionScope",
                        type: {
                            name: "String"
                        }
                    },
                    preventEncryptionScopeOverride: {
                        serializedName: "DenyEncryptionScopeOverride",
                        xmlName: "DenyEncryptionScopeOverride",
                        type: {
                            name: "Boolean"
                        }
                    },
                    deletedOn: {
                        serializedName: "DeletedTime",
                        xmlName: "DeletedTime",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    remainingRetentionDays: {
                        serializedName: "RemainingRetentionDays",
                        xmlName: "RemainingRetentionDays",
                        type: {
                            name: "Number"
                        }
                    },
                    isImmutableStorageWithVersioningEnabled: {
                        serializedName: "ImmutableStorageWithVersioningEnabled",
                        xmlName: "ImmutableStorageWithVersioningEnabled",
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            }
        };
        const KeyInfo = {
            serializedName: "KeyInfo",
            type: {
                name: "Composite",
                className: "KeyInfo",
                modelProperties: {
                    startsOn: {
                        serializedName: "Start",
                        required: true,
                        xmlName: "Start",
                        type: {
                            name: "String"
                        }
                    },
                    expiresOn: {
                        serializedName: "Expiry",
                        required: true,
                        xmlName: "Expiry",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const UserDelegationKey = {
            serializedName: "UserDelegationKey",
            type: {
                name: "Composite",
                className: "UserDelegationKey",
                modelProperties: {
                    signedObjectId: {
                        serializedName: "SignedOid",
                        required: true,
                        xmlName: "SignedOid",
                        type: {
                            name: "String"
                        }
                    },
                    signedTenantId: {
                        serializedName: "SignedTid",
                        required: true,
                        xmlName: "SignedTid",
                        type: {
                            name: "String"
                        }
                    },
                    signedStartsOn: {
                        serializedName: "SignedStart",
                        required: true,
                        xmlName: "SignedStart",
                        type: {
                            name: "String"
                        }
                    },
                    signedExpiresOn: {
                        serializedName: "SignedExpiry",
                        required: true,
                        xmlName: "SignedExpiry",
                        type: {
                            name: "String"
                        }
                    },
                    signedService: {
                        serializedName: "SignedService",
                        required: true,
                        xmlName: "SignedService",
                        type: {
                            name: "String"
                        }
                    },
                    signedVersion: {
                        serializedName: "SignedVersion",
                        required: true,
                        xmlName: "SignedVersion",
                        type: {
                            name: "String"
                        }
                    },
                    value: {
                        serializedName: "Value",
                        required: true,
                        xmlName: "Value",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const FilterBlobSegment = {
            serializedName: "FilterBlobSegment",
            xmlName: "EnumerationResults",
            type: {
                name: "Composite",
                className: "FilterBlobSegment",
                modelProperties: {
                    serviceEndpoint: {
                        serializedName: "ServiceEndpoint",
                        required: true,
                        xmlName: "ServiceEndpoint",
                        xmlIsAttribute: true,
                        type: {
                            name: "String"
                        }
                    },
                    where: {
                        serializedName: "Where",
                        required: true,
                        xmlName: "Where",
                        type: {
                            name: "String"
                        }
                    },
                    blobs: {
                        serializedName: "Blobs",
                        required: true,
                        xmlName: "Blobs",
                        xmlIsWrapped: true,
                        xmlElementName: "Blob",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "FilterBlobItem"
                                }
                            }
                        }
                    },
                    continuationToken: {
                        serializedName: "NextMarker",
                        xmlName: "NextMarker",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const FilterBlobItem = {
            serializedName: "FilterBlobItem",
            xmlName: "Blob",
            type: {
                name: "Composite",
                className: "FilterBlobItem",
                modelProperties: {
                    name: {
                        serializedName: "Name",
                        required: true,
                        xmlName: "Name",
                        type: {
                            name: "String"
                        }
                    },
                    containerName: {
                        serializedName: "ContainerName",
                        required: true,
                        xmlName: "ContainerName",
                        type: {
                            name: "String"
                        }
                    },
                    tags: {
                        serializedName: "Tags",
                        xmlName: "Tags",
                        type: {
                            name: "Composite",
                            className: "BlobTags"
                        }
                    }
                }
            }
        };
        const BlobTags = {
            serializedName: "BlobTags",
            xmlName: "Tags",
            type: {
                name: "Composite",
                className: "BlobTags",
                modelProperties: {
                    blobTagSet: {
                        serializedName: "BlobTagSet",
                        required: true,
                        xmlName: "TagSet",
                        xmlIsWrapped: true,
                        xmlElementName: "Tag",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "BlobTag"
                                }
                            }
                        }
                    }
                }
            }
        };
        const BlobTag = {
            serializedName: "BlobTag",
            xmlName: "Tag",
            type: {
                name: "Composite",
                className: "BlobTag",
                modelProperties: {
                    key: {
                        serializedName: "Key",
                        required: true,
                        xmlName: "Key",
                        type: {
                            name: "String"
                        }
                    },
                    value: {
                        serializedName: "Value",
                        required: true,
                        xmlName: "Value",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const SignedIdentifier = {
            serializedName: "SignedIdentifier",
            xmlName: "SignedIdentifier",
            type: {
                name: "Composite",
                className: "SignedIdentifier",
                modelProperties: {
                    id: {
                        serializedName: "Id",
                        required: true,
                        xmlName: "Id",
                        type: {
                            name: "String"
                        }
                    },
                    accessPolicy: {
                        serializedName: "AccessPolicy",
                        xmlName: "AccessPolicy",
                        type: {
                            name: "Composite",
                            className: "AccessPolicy"
                        }
                    }
                }
            }
        };
        const AccessPolicy = {
            serializedName: "AccessPolicy",
            type: {
                name: "Composite",
                className: "AccessPolicy",
                modelProperties: {
                    startsOn: {
                        serializedName: "Start",
                        xmlName: "Start",
                        type: {
                            name: "String"
                        }
                    },
                    expiresOn: {
                        serializedName: "Expiry",
                        xmlName: "Expiry",
                        type: {
                            name: "String"
                        }
                    },
                    permissions: {
                        serializedName: "Permission",
                        xmlName: "Permission",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ListBlobsFlatSegmentResponse = {
            serializedName: "ListBlobsFlatSegmentResponse",
            xmlName: "EnumerationResults",
            type: {
                name: "Composite",
                className: "ListBlobsFlatSegmentResponse",
                modelProperties: {
                    serviceEndpoint: {
                        serializedName: "ServiceEndpoint",
                        required: true,
                        xmlName: "ServiceEndpoint",
                        xmlIsAttribute: true,
                        type: {
                            name: "String"
                        }
                    },
                    containerName: {
                        serializedName: "ContainerName",
                        required: true,
                        xmlName: "ContainerName",
                        xmlIsAttribute: true,
                        type: {
                            name: "String"
                        }
                    },
                    prefix: {
                        serializedName: "Prefix",
                        xmlName: "Prefix",
                        type: {
                            name: "String"
                        }
                    },
                    marker: {
                        serializedName: "Marker",
                        xmlName: "Marker",
                        type: {
                            name: "String"
                        }
                    },
                    maxPageSize: {
                        serializedName: "MaxResults",
                        xmlName: "MaxResults",
                        type: {
                            name: "Number"
                        }
                    },
                    segment: {
                        serializedName: "Segment",
                        xmlName: "Blobs",
                        type: {
                            name: "Composite",
                            className: "BlobFlatListSegment"
                        }
                    },
                    continuationToken: {
                        serializedName: "NextMarker",
                        xmlName: "NextMarker",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobFlatListSegment = {
            serializedName: "BlobFlatListSegment",
            xmlName: "Blobs",
            type: {
                name: "Composite",
                className: "BlobFlatListSegment",
                modelProperties: {
                    blobItems: {
                        serializedName: "BlobItems",
                        required: true,
                        xmlName: "BlobItems",
                        xmlElementName: "Blob",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "BlobItemInternal"
                                }
                            }
                        }
                    }
                }
            }
        };
        const BlobItemInternal = {
            serializedName: "BlobItemInternal",
            xmlName: "Blob",
            type: {
                name: "Composite",
                className: "BlobItemInternal",
                modelProperties: {
                    name: {
                        serializedName: "Name",
                        xmlName: "Name",
                        type: {
                            name: "Composite",
                            className: "BlobName"
                        }
                    },
                    deleted: {
                        serializedName: "Deleted",
                        required: true,
                        xmlName: "Deleted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    snapshot: {
                        serializedName: "Snapshot",
                        required: true,
                        xmlName: "Snapshot",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "VersionId",
                        xmlName: "VersionId",
                        type: {
                            name: "String"
                        }
                    },
                    isCurrentVersion: {
                        serializedName: "IsCurrentVersion",
                        xmlName: "IsCurrentVersion",
                        type: {
                            name: "Boolean"
                        }
                    },
                    properties: {
                        serializedName: "Properties",
                        xmlName: "Properties",
                        type: {
                            name: "Composite",
                            className: "BlobPropertiesInternal"
                        }
                    },
                    metadata: {
                        serializedName: "Metadata",
                        xmlName: "Metadata",
                        type: {
                            name: "Dictionary",
                            value: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    },
                    blobTags: {
                        serializedName: "BlobTags",
                        xmlName: "Tags",
                        type: {
                            name: "Composite",
                            className: "BlobTags"
                        }
                    },
                    objectReplicationMetadata: {
                        serializedName: "ObjectReplicationMetadata",
                        xmlName: "OrMetadata",
                        type: {
                            name: "Dictionary",
                            value: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    },
                    hasVersionsOnly: {
                        serializedName: "HasVersionsOnly",
                        xmlName: "HasVersionsOnly",
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            }
        };
        const BlobName = {
            serializedName: "BlobName",
            type: {
                name: "Composite",
                className: "BlobName",
                modelProperties: {
                    encoded: {
                        serializedName: "Encoded",
                        xmlName: "Encoded",
                        xmlIsAttribute: true,
                        type: {
                            name: "Boolean"
                        }
                    },
                    content: {
                        serializedName: "content",
                        xmlName: "content",
                        xmlIsMsText: true,
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobPropertiesInternal = {
            serializedName: "BlobPropertiesInternal",
            xmlName: "Properties",
            type: {
                name: "Composite",
                className: "BlobPropertiesInternal",
                modelProperties: {
                    createdOn: {
                        serializedName: "Creation-Time",
                        xmlName: "Creation-Time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    lastModified: {
                        serializedName: "Last-Modified",
                        required: true,
                        xmlName: "Last-Modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    etag: {
                        serializedName: "Etag",
                        required: true,
                        xmlName: "Etag",
                        type: {
                            name: "String"
                        }
                    },
                    contentLength: {
                        serializedName: "Content-Length",
                        xmlName: "Content-Length",
                        type: {
                            name: "Number"
                        }
                    },
                    contentType: {
                        serializedName: "Content-Type",
                        xmlName: "Content-Type",
                        type: {
                            name: "String"
                        }
                    },
                    contentEncoding: {
                        serializedName: "Content-Encoding",
                        xmlName: "Content-Encoding",
                        type: {
                            name: "String"
                        }
                    },
                    contentLanguage: {
                        serializedName: "Content-Language",
                        xmlName: "Content-Language",
                        type: {
                            name: "String"
                        }
                    },
                    contentMD5: {
                        serializedName: "Content-MD5",
                        xmlName: "Content-MD5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    contentDisposition: {
                        serializedName: "Content-Disposition",
                        xmlName: "Content-Disposition",
                        type: {
                            name: "String"
                        }
                    },
                    cacheControl: {
                        serializedName: "Cache-Control",
                        xmlName: "Cache-Control",
                        type: {
                            name: "String"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    blobType: {
                        serializedName: "BlobType",
                        xmlName: "BlobType",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "BlockBlob",
                                "PageBlob",
                                "AppendBlob"
                            ]
                        }
                    },
                    leaseStatus: {
                        serializedName: "LeaseStatus",
                        xmlName: "LeaseStatus",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "locked",
                                "unlocked"
                            ]
                        }
                    },
                    leaseState: {
                        serializedName: "LeaseState",
                        xmlName: "LeaseState",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "available",
                                "leased",
                                "expired",
                                "breaking",
                                "broken"
                            ]
                        }
                    },
                    leaseDuration: {
                        serializedName: "LeaseDuration",
                        xmlName: "LeaseDuration",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "infinite",
                                "fixed"
                            ]
                        }
                    },
                    copyId: {
                        serializedName: "CopyId",
                        xmlName: "CopyId",
                        type: {
                            name: "String"
                        }
                    },
                    copyStatus: {
                        serializedName: "CopyStatus",
                        xmlName: "CopyStatus",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "pending",
                                "success",
                                "aborted",
                                "failed"
                            ]
                        }
                    },
                    copySource: {
                        serializedName: "CopySource",
                        xmlName: "CopySource",
                        type: {
                            name: "String"
                        }
                    },
                    copyProgress: {
                        serializedName: "CopyProgress",
                        xmlName: "CopyProgress",
                        type: {
                            name: "String"
                        }
                    },
                    copyCompletedOn: {
                        serializedName: "CopyCompletionTime",
                        xmlName: "CopyCompletionTime",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    copyStatusDescription: {
                        serializedName: "CopyStatusDescription",
                        xmlName: "CopyStatusDescription",
                        type: {
                            name: "String"
                        }
                    },
                    serverEncrypted: {
                        serializedName: "ServerEncrypted",
                        xmlName: "ServerEncrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    incrementalCopy: {
                        serializedName: "IncrementalCopy",
                        xmlName: "IncrementalCopy",
                        type: {
                            name: "Boolean"
                        }
                    },
                    destinationSnapshot: {
                        serializedName: "DestinationSnapshot",
                        xmlName: "DestinationSnapshot",
                        type: {
                            name: "String"
                        }
                    },
                    deletedOn: {
                        serializedName: "DeletedTime",
                        xmlName: "DeletedTime",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    remainingRetentionDays: {
                        serializedName: "RemainingRetentionDays",
                        xmlName: "RemainingRetentionDays",
                        type: {
                            name: "Number"
                        }
                    },
                    accessTier: {
                        serializedName: "AccessTier",
                        xmlName: "AccessTier",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "P4",
                                "P6",
                                "P10",
                                "P15",
                                "P20",
                                "P30",
                                "P40",
                                "P50",
                                "P60",
                                "P70",
                                "P80",
                                "Hot",
                                "Cool",
                                "Archive",
                                "Cold"
                            ]
                        }
                    },
                    accessTierInferred: {
                        serializedName: "AccessTierInferred",
                        xmlName: "AccessTierInferred",
                        type: {
                            name: "Boolean"
                        }
                    },
                    archiveStatus: {
                        serializedName: "ArchiveStatus",
                        xmlName: "ArchiveStatus",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "rehydrate-pending-to-hot",
                                "rehydrate-pending-to-cool",
                                "rehydrate-pending-to-cold"
                            ]
                        }
                    },
                    customerProvidedKeySha256: {
                        serializedName: "CustomerProvidedKeySha256",
                        xmlName: "CustomerProvidedKeySha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "EncryptionScope",
                        xmlName: "EncryptionScope",
                        type: {
                            name: "String"
                        }
                    },
                    accessTierChangedOn: {
                        serializedName: "AccessTierChangeTime",
                        xmlName: "AccessTierChangeTime",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    tagCount: {
                        serializedName: "TagCount",
                        xmlName: "TagCount",
                        type: {
                            name: "Number"
                        }
                    },
                    expiresOn: {
                        serializedName: "Expiry-Time",
                        xmlName: "Expiry-Time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isSealed: {
                        serializedName: "Sealed",
                        xmlName: "Sealed",
                        type: {
                            name: "Boolean"
                        }
                    },
                    rehydratePriority: {
                        serializedName: "RehydratePriority",
                        xmlName: "RehydratePriority",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "High",
                                "Standard"
                            ]
                        }
                    },
                    lastAccessedOn: {
                        serializedName: "LastAccessTime",
                        xmlName: "LastAccessTime",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    immutabilityPolicyExpiresOn: {
                        serializedName: "ImmutabilityPolicyUntilDate",
                        xmlName: "ImmutabilityPolicyUntilDate",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    immutabilityPolicyMode: {
                        serializedName: "ImmutabilityPolicyMode",
                        xmlName: "ImmutabilityPolicyMode",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Mutable",
                                "Unlocked",
                                "Locked"
                            ]
                        }
                    },
                    legalHold: {
                        serializedName: "LegalHold",
                        xmlName: "LegalHold",
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            }
        };
        const ListBlobsHierarchySegmentResponse = {
            serializedName: "ListBlobsHierarchySegmentResponse",
            xmlName: "EnumerationResults",
            type: {
                name: "Composite",
                className: "ListBlobsHierarchySegmentResponse",
                modelProperties: {
                    serviceEndpoint: {
                        serializedName: "ServiceEndpoint",
                        required: true,
                        xmlName: "ServiceEndpoint",
                        xmlIsAttribute: true,
                        type: {
                            name: "String"
                        }
                    },
                    containerName: {
                        serializedName: "ContainerName",
                        required: true,
                        xmlName: "ContainerName",
                        xmlIsAttribute: true,
                        type: {
                            name: "String"
                        }
                    },
                    prefix: {
                        serializedName: "Prefix",
                        xmlName: "Prefix",
                        type: {
                            name: "String"
                        }
                    },
                    marker: {
                        serializedName: "Marker",
                        xmlName: "Marker",
                        type: {
                            name: "String"
                        }
                    },
                    maxPageSize: {
                        serializedName: "MaxResults",
                        xmlName: "MaxResults",
                        type: {
                            name: "Number"
                        }
                    },
                    delimiter: {
                        serializedName: "Delimiter",
                        xmlName: "Delimiter",
                        type: {
                            name: "String"
                        }
                    },
                    segment: {
                        serializedName: "Segment",
                        xmlName: "Blobs",
                        type: {
                            name: "Composite",
                            className: "BlobHierarchyListSegment"
                        }
                    },
                    continuationToken: {
                        serializedName: "NextMarker",
                        xmlName: "NextMarker",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobHierarchyListSegment = {
            serializedName: "BlobHierarchyListSegment",
            xmlName: "Blobs",
            type: {
                name: "Composite",
                className: "BlobHierarchyListSegment",
                modelProperties: {
                    blobPrefixes: {
                        serializedName: "BlobPrefixes",
                        xmlName: "BlobPrefixes",
                        xmlElementName: "BlobPrefix",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "BlobPrefix"
                                }
                            }
                        }
                    },
                    blobItems: {
                        serializedName: "BlobItems",
                        required: true,
                        xmlName: "BlobItems",
                        xmlElementName: "Blob",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "BlobItemInternal"
                                }
                            }
                        }
                    }
                }
            }
        };
        const BlobPrefix = {
            serializedName: "BlobPrefix",
            type: {
                name: "Composite",
                className: "BlobPrefix",
                modelProperties: {
                    name: {
                        serializedName: "Name",
                        xmlName: "Name",
                        type: {
                            name: "Composite",
                            className: "BlobName"
                        }
                    }
                }
            }
        };
        const BlockLookupList = {
            serializedName: "BlockLookupList",
            xmlName: "BlockList",
            type: {
                name: "Composite",
                className: "BlockLookupList",
                modelProperties: {
                    committed: {
                        serializedName: "Committed",
                        xmlName: "Committed",
                        xmlElementName: "Committed",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    },
                    uncommitted: {
                        serializedName: "Uncommitted",
                        xmlName: "Uncommitted",
                        xmlElementName: "Uncommitted",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    },
                    latest: {
                        serializedName: "Latest",
                        xmlName: "Latest",
                        xmlElementName: "Latest",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            }
        };
        const BlockList = {
            serializedName: "BlockList",
            type: {
                name: "Composite",
                className: "BlockList",
                modelProperties: {
                    committedBlocks: {
                        serializedName: "CommittedBlocks",
                        xmlName: "CommittedBlocks",
                        xmlIsWrapped: true,
                        xmlElementName: "Block",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "Block"
                                }
                            }
                        }
                    },
                    uncommittedBlocks: {
                        serializedName: "UncommittedBlocks",
                        xmlName: "UncommittedBlocks",
                        xmlIsWrapped: true,
                        xmlElementName: "Block",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "Block"
                                }
                            }
                        }
                    }
                }
            }
        };
        const Block = {
            serializedName: "Block",
            type: {
                name: "Composite",
                className: "Block",
                modelProperties: {
                    name: {
                        serializedName: "Name",
                        required: true,
                        xmlName: "Name",
                        type: {
                            name: "String"
                        }
                    },
                    size: {
                        serializedName: "Size",
                        required: true,
                        xmlName: "Size",
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        };
        const PageList = {
            serializedName: "PageList",
            type: {
                name: "Composite",
                className: "PageList",
                modelProperties: {
                    pageRange: {
                        serializedName: "PageRange",
                        xmlName: "PageRange",
                        xmlElementName: "PageRange",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "PageRange"
                                }
                            }
                        }
                    },
                    clearRange: {
                        serializedName: "ClearRange",
                        xmlName: "ClearRange",
                        xmlElementName: "ClearRange",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "ClearRange"
                                }
                            }
                        }
                    },
                    continuationToken: {
                        serializedName: "NextMarker",
                        xmlName: "NextMarker",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageRange = {
            serializedName: "PageRange",
            xmlName: "PageRange",
            type: {
                name: "Composite",
                className: "PageRange",
                modelProperties: {
                    start: {
                        serializedName: "Start",
                        required: true,
                        xmlName: "Start",
                        type: {
                            name: "Number"
                        }
                    },
                    end: {
                        serializedName: "End",
                        required: true,
                        xmlName: "End",
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        };
        const ClearRange = {
            serializedName: "ClearRange",
            xmlName: "ClearRange",
            type: {
                name: "Composite",
                className: "ClearRange",
                modelProperties: {
                    start: {
                        serializedName: "Start",
                        required: true,
                        xmlName: "Start",
                        type: {
                            name: "Number"
                        }
                    },
                    end: {
                        serializedName: "End",
                        required: true,
                        xmlName: "End",
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        };
        const QueryRequest = {
            serializedName: "QueryRequest",
            xmlName: "QueryRequest",
            type: {
                name: "Composite",
                className: "QueryRequest",
                modelProperties: {
                    queryType: {
                        serializedName: "QueryType",
                        required: true,
                        xmlName: "QueryType",
                        type: {
                            name: "String"
                        }
                    },
                    expression: {
                        serializedName: "Expression",
                        required: true,
                        xmlName: "Expression",
                        type: {
                            name: "String"
                        }
                    },
                    inputSerialization: {
                        serializedName: "InputSerialization",
                        xmlName: "InputSerialization",
                        type: {
                            name: "Composite",
                            className: "QuerySerialization"
                        }
                    },
                    outputSerialization: {
                        serializedName: "OutputSerialization",
                        xmlName: "OutputSerialization",
                        type: {
                            name: "Composite",
                            className: "QuerySerialization"
                        }
                    }
                }
            }
        };
        const QuerySerialization = {
            serializedName: "QuerySerialization",
            type: {
                name: "Composite",
                className: "QuerySerialization",
                modelProperties: {
                    format: {
                        serializedName: "Format",
                        xmlName: "Format",
                        type: {
                            name: "Composite",
                            className: "QueryFormat"
                        }
                    }
                }
            }
        };
        const QueryFormat = {
            serializedName: "QueryFormat",
            type: {
                name: "Composite",
                className: "QueryFormat",
                modelProperties: {
                    type: {
                        serializedName: "Type",
                        required: true,
                        xmlName: "Type",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "delimited",
                                "json",
                                "arrow",
                                "parquet"
                            ]
                        }
                    },
                    delimitedTextConfiguration: {
                        serializedName: "DelimitedTextConfiguration",
                        xmlName: "DelimitedTextConfiguration",
                        type: {
                            name: "Composite",
                            className: "DelimitedTextConfiguration"
                        }
                    },
                    jsonTextConfiguration: {
                        serializedName: "JsonTextConfiguration",
                        xmlName: "JsonTextConfiguration",
                        type: {
                            name: "Composite",
                            className: "JsonTextConfiguration"
                        }
                    },
                    arrowConfiguration: {
                        serializedName: "ArrowConfiguration",
                        xmlName: "ArrowConfiguration",
                        type: {
                            name: "Composite",
                            className: "ArrowConfiguration"
                        }
                    },
                    parquetTextConfiguration: {
                        serializedName: "ParquetTextConfiguration",
                        xmlName: "ParquetTextConfiguration",
                        type: {
                            name: "any"
                        }
                    }
                }
            }
        };
        const DelimitedTextConfiguration = {
            serializedName: "DelimitedTextConfiguration",
            xmlName: "DelimitedTextConfiguration",
            type: {
                name: "Composite",
                className: "DelimitedTextConfiguration",
                modelProperties: {
                    columnSeparator: {
                        serializedName: "ColumnSeparator",
                        xmlName: "ColumnSeparator",
                        type: {
                            name: "String"
                        }
                    },
                    fieldQuote: {
                        serializedName: "FieldQuote",
                        xmlName: "FieldQuote",
                        type: {
                            name: "String"
                        }
                    },
                    recordSeparator: {
                        serializedName: "RecordSeparator",
                        xmlName: "RecordSeparator",
                        type: {
                            name: "String"
                        }
                    },
                    escapeChar: {
                        serializedName: "EscapeChar",
                        xmlName: "EscapeChar",
                        type: {
                            name: "String"
                        }
                    },
                    headersPresent: {
                        serializedName: "HeadersPresent",
                        xmlName: "HasHeaders",
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            }
        };
        const JsonTextConfiguration = {
            serializedName: "JsonTextConfiguration",
            xmlName: "JsonTextConfiguration",
            type: {
                name: "Composite",
                className: "JsonTextConfiguration",
                modelProperties: {
                    recordSeparator: {
                        serializedName: "RecordSeparator",
                        xmlName: "RecordSeparator",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ArrowConfiguration = {
            serializedName: "ArrowConfiguration",
            xmlName: "ArrowConfiguration",
            type: {
                name: "Composite",
                className: "ArrowConfiguration",
                modelProperties: {
                    schema: {
                        serializedName: "Schema",
                        required: true,
                        xmlName: "Schema",
                        xmlIsWrapped: true,
                        xmlElementName: "Field",
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "ArrowField"
                                }
                            }
                        }
                    }
                }
            }
        };
        const ArrowField = {
            serializedName: "ArrowField",
            xmlName: "Field",
            type: {
                name: "Composite",
                className: "ArrowField",
                modelProperties: {
                    type: {
                        serializedName: "Type",
                        required: true,
                        xmlName: "Type",
                        type: {
                            name: "String"
                        }
                    },
                    name: {
                        serializedName: "Name",
                        xmlName: "Name",
                        type: {
                            name: "String"
                        }
                    },
                    precision: {
                        serializedName: "Precision",
                        xmlName: "Precision",
                        type: {
                            name: "Number"
                        }
                    },
                    scale: {
                        serializedName: "Scale",
                        xmlName: "Scale",
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        };
        const ServiceSetPropertiesHeaders = {
            serializedName: "Service_setPropertiesHeaders",
            type: {
                name: "Composite",
                className: "ServiceSetPropertiesHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceSetPropertiesExceptionHeaders = {
            serializedName: "Service_setPropertiesExceptionHeaders",
            type: {
                name: "Composite",
                className: "ServiceSetPropertiesExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceGetPropertiesHeaders = {
            serializedName: "Service_getPropertiesHeaders",
            type: {
                name: "Composite",
                className: "ServiceGetPropertiesHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceGetPropertiesExceptionHeaders = {
            serializedName: "Service_getPropertiesExceptionHeaders",
            type: {
                name: "Composite",
                className: "ServiceGetPropertiesExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceGetStatisticsHeaders = {
            serializedName: "Service_getStatisticsHeaders",
            type: {
                name: "Composite",
                className: "ServiceGetStatisticsHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceGetStatisticsExceptionHeaders = {
            serializedName: "Service_getStatisticsExceptionHeaders",
            type: {
                name: "Composite",
                className: "ServiceGetStatisticsExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceListContainersSegmentHeaders = {
            serializedName: "Service_listContainersSegmentHeaders",
            type: {
                name: "Composite",
                className: "ServiceListContainersSegmentHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceListContainersSegmentExceptionHeaders = {
            serializedName: "Service_listContainersSegmentExceptionHeaders",
            type: {
                name: "Composite",
                className: "ServiceListContainersSegmentExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceGetUserDelegationKeyHeaders = {
            serializedName: "Service_getUserDelegationKeyHeaders",
            type: {
                name: "Composite",
                className: "ServiceGetUserDelegationKeyHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceGetUserDelegationKeyExceptionHeaders = {
            serializedName: "Service_getUserDelegationKeyExceptionHeaders",
            type: {
                name: "Composite",
                className: "ServiceGetUserDelegationKeyExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceGetAccountInfoHeaders = {
            serializedName: "Service_getAccountInfoHeaders",
            type: {
                name: "Composite",
                className: "ServiceGetAccountInfoHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    skuName: {
                        serializedName: "x-ms-sku-name",
                        xmlName: "x-ms-sku-name",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Standard_LRS",
                                "Standard_GRS",
                                "Standard_RAGRS",
                                "Standard_ZRS",
                                "Premium_LRS"
                            ]
                        }
                    },
                    accountKind: {
                        serializedName: "x-ms-account-kind",
                        xmlName: "x-ms-account-kind",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Storage",
                                "BlobStorage",
                                "StorageV2",
                                "FileStorage",
                                "BlockBlobStorage"
                            ]
                        }
                    },
                    isHierarchicalNamespaceEnabled: {
                        serializedName: "x-ms-is-hns-enabled",
                        xmlName: "x-ms-is-hns-enabled",
                        type: {
                            name: "Boolean"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceGetAccountInfoExceptionHeaders = {
            serializedName: "Service_getAccountInfoExceptionHeaders",
            type: {
                name: "Composite",
                className: "ServiceGetAccountInfoExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceSubmitBatchHeaders = {
            serializedName: "Service_submitBatchHeaders",
            type: {
                name: "Composite",
                className: "ServiceSubmitBatchHeaders",
                modelProperties: {
                    contentType: {
                        serializedName: "content-type",
                        xmlName: "content-type",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceSubmitBatchExceptionHeaders = {
            serializedName: "Service_submitBatchExceptionHeaders",
            type: {
                name: "Composite",
                className: "ServiceSubmitBatchExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceFilterBlobsHeaders = {
            serializedName: "Service_filterBlobsHeaders",
            type: {
                name: "Composite",
                className: "ServiceFilterBlobsHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ServiceFilterBlobsExceptionHeaders = {
            serializedName: "Service_filterBlobsExceptionHeaders",
            type: {
                name: "Composite",
                className: "ServiceFilterBlobsExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerCreateHeaders = {
            serializedName: "Container_createHeaders",
            type: {
                name: "Composite",
                className: "ContainerCreateHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerCreateExceptionHeaders = {
            serializedName: "Container_createExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerCreateExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerGetPropertiesHeaders = {
            serializedName: "Container_getPropertiesHeaders",
            type: {
                name: "Composite",
                className: "ContainerGetPropertiesHeaders",
                modelProperties: {
                    metadata: {
                        serializedName: "x-ms-meta",
                        xmlName: "x-ms-meta",
                        type: {
                            name: "Dictionary",
                            value: {
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        headerCollectionPrefix: "x-ms-meta-"
                    },
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    leaseDuration: {
                        serializedName: "x-ms-lease-duration",
                        xmlName: "x-ms-lease-duration",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "infinite",
                                "fixed"
                            ]
                        }
                    },
                    leaseState: {
                        serializedName: "x-ms-lease-state",
                        xmlName: "x-ms-lease-state",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "available",
                                "leased",
                                "expired",
                                "breaking",
                                "broken"
                            ]
                        }
                    },
                    leaseStatus: {
                        serializedName: "x-ms-lease-status",
                        xmlName: "x-ms-lease-status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "locked",
                                "unlocked"
                            ]
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    blobPublicAccess: {
                        serializedName: "x-ms-blob-public-access",
                        xmlName: "x-ms-blob-public-access",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "container",
                                "blob"
                            ]
                        }
                    },
                    hasImmutabilityPolicy: {
                        serializedName: "x-ms-has-immutability-policy",
                        xmlName: "x-ms-has-immutability-policy",
                        type: {
                            name: "Boolean"
                        }
                    },
                    hasLegalHold: {
                        serializedName: "x-ms-has-legal-hold",
                        xmlName: "x-ms-has-legal-hold",
                        type: {
                            name: "Boolean"
                        }
                    },
                    defaultEncryptionScope: {
                        serializedName: "x-ms-default-encryption-scope",
                        xmlName: "x-ms-default-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    denyEncryptionScopeOverride: {
                        serializedName: "x-ms-deny-encryption-scope-override",
                        xmlName: "x-ms-deny-encryption-scope-override",
                        type: {
                            name: "Boolean"
                        }
                    },
                    isImmutableStorageWithVersioningEnabled: {
                        serializedName: "x-ms-immutable-storage-with-versioning-enabled",
                        xmlName: "x-ms-immutable-storage-with-versioning-enabled",
                        type: {
                            name: "Boolean"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerGetPropertiesExceptionHeaders = {
            serializedName: "Container_getPropertiesExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerGetPropertiesExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerDeleteHeaders = {
            serializedName: "Container_deleteHeaders",
            type: {
                name: "Composite",
                className: "ContainerDeleteHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerDeleteExceptionHeaders = {
            serializedName: "Container_deleteExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerDeleteExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerSetMetadataHeaders = {
            serializedName: "Container_setMetadataHeaders",
            type: {
                name: "Composite",
                className: "ContainerSetMetadataHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerSetMetadataExceptionHeaders = {
            serializedName: "Container_setMetadataExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerSetMetadataExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerGetAccessPolicyHeaders = {
            serializedName: "Container_getAccessPolicyHeaders",
            type: {
                name: "Composite",
                className: "ContainerGetAccessPolicyHeaders",
                modelProperties: {
                    blobPublicAccess: {
                        serializedName: "x-ms-blob-public-access",
                        xmlName: "x-ms-blob-public-access",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "container",
                                "blob"
                            ]
                        }
                    },
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerGetAccessPolicyExceptionHeaders = {
            serializedName: "Container_getAccessPolicyExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerGetAccessPolicyExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerSetAccessPolicyHeaders = {
            serializedName: "Container_setAccessPolicyHeaders",
            type: {
                name: "Composite",
                className: "ContainerSetAccessPolicyHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerSetAccessPolicyExceptionHeaders = {
            serializedName: "Container_setAccessPolicyExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerSetAccessPolicyExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerRestoreHeaders = {
            serializedName: "Container_restoreHeaders",
            type: {
                name: "Composite",
                className: "ContainerRestoreHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerRestoreExceptionHeaders = {
            serializedName: "Container_restoreExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerRestoreExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerRenameHeaders = {
            serializedName: "Container_renameHeaders",
            type: {
                name: "Composite",
                className: "ContainerRenameHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerRenameExceptionHeaders = {
            serializedName: "Container_renameExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerRenameExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerSubmitBatchHeaders = {
            serializedName: "Container_submitBatchHeaders",
            type: {
                name: "Composite",
                className: "ContainerSubmitBatchHeaders",
                modelProperties: {
                    contentType: {
                        serializedName: "content-type",
                        xmlName: "content-type",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerSubmitBatchExceptionHeaders = {
            serializedName: "Container_submitBatchExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerSubmitBatchExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerFilterBlobsHeaders = {
            serializedName: "Container_filterBlobsHeaders",
            type: {
                name: "Composite",
                className: "ContainerFilterBlobsHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const ContainerFilterBlobsExceptionHeaders = {
            serializedName: "Container_filterBlobsExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerFilterBlobsExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerAcquireLeaseHeaders = {
            serializedName: "Container_acquireLeaseHeaders",
            type: {
                name: "Composite",
                className: "ContainerAcquireLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    leaseId: {
                        serializedName: "x-ms-lease-id",
                        xmlName: "x-ms-lease-id",
                        type: {
                            name: "String"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const ContainerAcquireLeaseExceptionHeaders = {
            serializedName: "Container_acquireLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerAcquireLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerReleaseLeaseHeaders = {
            serializedName: "Container_releaseLeaseHeaders",
            type: {
                name: "Composite",
                className: "ContainerReleaseLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const ContainerReleaseLeaseExceptionHeaders = {
            serializedName: "Container_releaseLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerReleaseLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerRenewLeaseHeaders = {
            serializedName: "Container_renewLeaseHeaders",
            type: {
                name: "Composite",
                className: "ContainerRenewLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    leaseId: {
                        serializedName: "x-ms-lease-id",
                        xmlName: "x-ms-lease-id",
                        type: {
                            name: "String"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const ContainerRenewLeaseExceptionHeaders = {
            serializedName: "Container_renewLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerRenewLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerBreakLeaseHeaders = {
            serializedName: "Container_breakLeaseHeaders",
            type: {
                name: "Composite",
                className: "ContainerBreakLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    leaseTime: {
                        serializedName: "x-ms-lease-time",
                        xmlName: "x-ms-lease-time",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const ContainerBreakLeaseExceptionHeaders = {
            serializedName: "Container_breakLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerBreakLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerChangeLeaseHeaders = {
            serializedName: "Container_changeLeaseHeaders",
            type: {
                name: "Composite",
                className: "ContainerChangeLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    leaseId: {
                        serializedName: "x-ms-lease-id",
                        xmlName: "x-ms-lease-id",
                        type: {
                            name: "String"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const ContainerChangeLeaseExceptionHeaders = {
            serializedName: "Container_changeLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerChangeLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerListBlobFlatSegmentHeaders = {
            serializedName: "Container_listBlobFlatSegmentHeaders",
            type: {
                name: "Composite",
                className: "ContainerListBlobFlatSegmentHeaders",
                modelProperties: {
                    contentType: {
                        serializedName: "content-type",
                        xmlName: "content-type",
                        type: {
                            name: "String"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerListBlobFlatSegmentExceptionHeaders = {
            serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerListBlobFlatSegmentExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerListBlobHierarchySegmentHeaders = {
            serializedName: "Container_listBlobHierarchySegmentHeaders",
            type: {
                name: "Composite",
                className: "ContainerListBlobHierarchySegmentHeaders",
                modelProperties: {
                    contentType: {
                        serializedName: "content-type",
                        xmlName: "content-type",
                        type: {
                            name: "String"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerListBlobHierarchySegmentExceptionHeaders = {
            serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerListBlobHierarchySegmentExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const ContainerGetAccountInfoHeaders = {
            serializedName: "Container_getAccountInfoHeaders",
            type: {
                name: "Composite",
                className: "ContainerGetAccountInfoHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    skuName: {
                        serializedName: "x-ms-sku-name",
                        xmlName: "x-ms-sku-name",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Standard_LRS",
                                "Standard_GRS",
                                "Standard_RAGRS",
                                "Standard_ZRS",
                                "Premium_LRS"
                            ]
                        }
                    },
                    accountKind: {
                        serializedName: "x-ms-account-kind",
                        xmlName: "x-ms-account-kind",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Storage",
                                "BlobStorage",
                                "StorageV2",
                                "FileStorage",
                                "BlockBlobStorage"
                            ]
                        }
                    }
                }
            }
        };
        const ContainerGetAccountInfoExceptionHeaders = {
            serializedName: "Container_getAccountInfoExceptionHeaders",
            type: {
                name: "Composite",
                className: "ContainerGetAccountInfoExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobDownloadHeaders = {
            serializedName: "Blob_downloadHeaders",
            type: {
                name: "Composite",
                className: "BlobDownloadHeaders",
                modelProperties: {
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    createdOn: {
                        serializedName: "x-ms-creation-time",
                        xmlName: "x-ms-creation-time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    metadata: {
                        serializedName: "x-ms-meta",
                        xmlName: "x-ms-meta",
                        type: {
                            name: "Dictionary",
                            value: {
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        headerCollectionPrefix: "x-ms-meta-"
                    },
                    objectReplicationPolicyId: {
                        serializedName: "x-ms-or-policy-id",
                        xmlName: "x-ms-or-policy-id",
                        type: {
                            name: "String"
                        }
                    },
                    objectReplicationRules: {
                        serializedName: "x-ms-or",
                        xmlName: "x-ms-or",
                        type: {
                            name: "Dictionary",
                            value: {
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        headerCollectionPrefix: "x-ms-or-"
                    },
                    contentLength: {
                        serializedName: "content-length",
                        xmlName: "content-length",
                        type: {
                            name: "Number"
                        }
                    },
                    contentType: {
                        serializedName: "content-type",
                        xmlName: "content-type",
                        type: {
                            name: "String"
                        }
                    },
                    contentRange: {
                        serializedName: "content-range",
                        xmlName: "content-range",
                        type: {
                            name: "String"
                        }
                    },
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    contentEncoding: {
                        serializedName: "content-encoding",
                        xmlName: "content-encoding",
                        type: {
                            name: "String"
                        }
                    },
                    cacheControl: {
                        serializedName: "cache-control",
                        xmlName: "cache-control",
                        type: {
                            name: "String"
                        }
                    },
                    contentDisposition: {
                        serializedName: "content-disposition",
                        xmlName: "content-disposition",
                        type: {
                            name: "String"
                        }
                    },
                    contentLanguage: {
                        serializedName: "content-language",
                        xmlName: "content-language",
                        type: {
                            name: "String"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    blobType: {
                        serializedName: "x-ms-blob-type",
                        xmlName: "x-ms-blob-type",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "BlockBlob",
                                "PageBlob",
                                "AppendBlob"
                            ]
                        }
                    },
                    copyCompletedOn: {
                        serializedName: "x-ms-copy-completion-time",
                        xmlName: "x-ms-copy-completion-time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    copyStatusDescription: {
                        serializedName: "x-ms-copy-status-description",
                        xmlName: "x-ms-copy-status-description",
                        type: {
                            name: "String"
                        }
                    },
                    copyId: {
                        serializedName: "x-ms-copy-id",
                        xmlName: "x-ms-copy-id",
                        type: {
                            name: "String"
                        }
                    },
                    copyProgress: {
                        serializedName: "x-ms-copy-progress",
                        xmlName: "x-ms-copy-progress",
                        type: {
                            name: "String"
                        }
                    },
                    copySource: {
                        serializedName: "x-ms-copy-source",
                        xmlName: "x-ms-copy-source",
                        type: {
                            name: "String"
                        }
                    },
                    copyStatus: {
                        serializedName: "x-ms-copy-status",
                        xmlName: "x-ms-copy-status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "pending",
                                "success",
                                "aborted",
                                "failed"
                            ]
                        }
                    },
                    leaseDuration: {
                        serializedName: "x-ms-lease-duration",
                        xmlName: "x-ms-lease-duration",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "infinite",
                                "fixed"
                            ]
                        }
                    },
                    leaseState: {
                        serializedName: "x-ms-lease-state",
                        xmlName: "x-ms-lease-state",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "available",
                                "leased",
                                "expired",
                                "breaking",
                                "broken"
                            ]
                        }
                    },
                    leaseStatus: {
                        serializedName: "x-ms-lease-status",
                        xmlName: "x-ms-lease-status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "locked",
                                "unlocked"
                            ]
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    isCurrentVersion: {
                        serializedName: "x-ms-is-current-version",
                        xmlName: "x-ms-is-current-version",
                        type: {
                            name: "Boolean"
                        }
                    },
                    acceptRanges: {
                        serializedName: "accept-ranges",
                        xmlName: "accept-ranges",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    blobCommittedBlockCount: {
                        serializedName: "x-ms-blob-committed-block-count",
                        xmlName: "x-ms-blob-committed-block-count",
                        type: {
                            name: "Number"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-server-encrypted",
                        xmlName: "x-ms-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    blobContentMD5: {
                        serializedName: "x-ms-blob-content-md5",
                        xmlName: "x-ms-blob-content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    tagCount: {
                        serializedName: "x-ms-tag-count",
                        xmlName: "x-ms-tag-count",
                        type: {
                            name: "Number"
                        }
                    },
                    isSealed: {
                        serializedName: "x-ms-blob-sealed",
                        xmlName: "x-ms-blob-sealed",
                        type: {
                            name: "Boolean"
                        }
                    },
                    lastAccessed: {
                        serializedName: "x-ms-last-access-time",
                        xmlName: "x-ms-last-access-time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    immutabilityPolicyExpiresOn: {
                        serializedName: "x-ms-immutability-policy-until-date",
                        xmlName: "x-ms-immutability-policy-until-date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    immutabilityPolicyMode: {
                        serializedName: "x-ms-immutability-policy-mode",
                        xmlName: "x-ms-immutability-policy-mode",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Mutable",
                                "Unlocked",
                                "Locked"
                            ]
                        }
                    },
                    legalHold: {
                        serializedName: "x-ms-legal-hold",
                        xmlName: "x-ms-legal-hold",
                        type: {
                            name: "Boolean"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    },
                    contentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    }
                }
            }
        };
        const BlobDownloadExceptionHeaders = {
            serializedName: "Blob_downloadExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobDownloadExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobGetPropertiesHeaders = {
            serializedName: "Blob_getPropertiesHeaders",
            type: {
                name: "Composite",
                className: "BlobGetPropertiesHeaders",
                modelProperties: {
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    createdOn: {
                        serializedName: "x-ms-creation-time",
                        xmlName: "x-ms-creation-time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    metadata: {
                        serializedName: "x-ms-meta",
                        xmlName: "x-ms-meta",
                        type: {
                            name: "Dictionary",
                            value: {
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        headerCollectionPrefix: "x-ms-meta-"
                    },
                    objectReplicationPolicyId: {
                        serializedName: "x-ms-or-policy-id",
                        xmlName: "x-ms-or-policy-id",
                        type: {
                            name: "String"
                        }
                    },
                    objectReplicationRules: {
                        serializedName: "x-ms-or",
                        xmlName: "x-ms-or",
                        type: {
                            name: "Dictionary",
                            value: {
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        headerCollectionPrefix: "x-ms-or-"
                    },
                    blobType: {
                        serializedName: "x-ms-blob-type",
                        xmlName: "x-ms-blob-type",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "BlockBlob",
                                "PageBlob",
                                "AppendBlob"
                            ]
                        }
                    },
                    copyCompletedOn: {
                        serializedName: "x-ms-copy-completion-time",
                        xmlName: "x-ms-copy-completion-time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    copyStatusDescription: {
                        serializedName: "x-ms-copy-status-description",
                        xmlName: "x-ms-copy-status-description",
                        type: {
                            name: "String"
                        }
                    },
                    copyId: {
                        serializedName: "x-ms-copy-id",
                        xmlName: "x-ms-copy-id",
                        type: {
                            name: "String"
                        }
                    },
                    copyProgress: {
                        serializedName: "x-ms-copy-progress",
                        xmlName: "x-ms-copy-progress",
                        type: {
                            name: "String"
                        }
                    },
                    copySource: {
                        serializedName: "x-ms-copy-source",
                        xmlName: "x-ms-copy-source",
                        type: {
                            name: "String"
                        }
                    },
                    copyStatus: {
                        serializedName: "x-ms-copy-status",
                        xmlName: "x-ms-copy-status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "pending",
                                "success",
                                "aborted",
                                "failed"
                            ]
                        }
                    },
                    isIncrementalCopy: {
                        serializedName: "x-ms-incremental-copy",
                        xmlName: "x-ms-incremental-copy",
                        type: {
                            name: "Boolean"
                        }
                    },
                    destinationSnapshot: {
                        serializedName: "x-ms-copy-destination-snapshot",
                        xmlName: "x-ms-copy-destination-snapshot",
                        type: {
                            name: "String"
                        }
                    },
                    leaseDuration: {
                        serializedName: "x-ms-lease-duration",
                        xmlName: "x-ms-lease-duration",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "infinite",
                                "fixed"
                            ]
                        }
                    },
                    leaseState: {
                        serializedName: "x-ms-lease-state",
                        xmlName: "x-ms-lease-state",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "available",
                                "leased",
                                "expired",
                                "breaking",
                                "broken"
                            ]
                        }
                    },
                    leaseStatus: {
                        serializedName: "x-ms-lease-status",
                        xmlName: "x-ms-lease-status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "locked",
                                "unlocked"
                            ]
                        }
                    },
                    contentLength: {
                        serializedName: "content-length",
                        xmlName: "content-length",
                        type: {
                            name: "Number"
                        }
                    },
                    contentType: {
                        serializedName: "content-type",
                        xmlName: "content-type",
                        type: {
                            name: "String"
                        }
                    },
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    contentEncoding: {
                        serializedName: "content-encoding",
                        xmlName: "content-encoding",
                        type: {
                            name: "String"
                        }
                    },
                    contentDisposition: {
                        serializedName: "content-disposition",
                        xmlName: "content-disposition",
                        type: {
                            name: "String"
                        }
                    },
                    contentLanguage: {
                        serializedName: "content-language",
                        xmlName: "content-language",
                        type: {
                            name: "String"
                        }
                    },
                    cacheControl: {
                        serializedName: "cache-control",
                        xmlName: "cache-control",
                        type: {
                            name: "String"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    acceptRanges: {
                        serializedName: "accept-ranges",
                        xmlName: "accept-ranges",
                        type: {
                            name: "String"
                        }
                    },
                    blobCommittedBlockCount: {
                        serializedName: "x-ms-blob-committed-block-count",
                        xmlName: "x-ms-blob-committed-block-count",
                        type: {
                            name: "Number"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-server-encrypted",
                        xmlName: "x-ms-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    accessTier: {
                        serializedName: "x-ms-access-tier",
                        xmlName: "x-ms-access-tier",
                        type: {
                            name: "String"
                        }
                    },
                    accessTierInferred: {
                        serializedName: "x-ms-access-tier-inferred",
                        xmlName: "x-ms-access-tier-inferred",
                        type: {
                            name: "Boolean"
                        }
                    },
                    archiveStatus: {
                        serializedName: "x-ms-archive-status",
                        xmlName: "x-ms-archive-status",
                        type: {
                            name: "String"
                        }
                    },
                    accessTierChangedOn: {
                        serializedName: "x-ms-access-tier-change-time",
                        xmlName: "x-ms-access-tier-change-time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    isCurrentVersion: {
                        serializedName: "x-ms-is-current-version",
                        xmlName: "x-ms-is-current-version",
                        type: {
                            name: "Boolean"
                        }
                    },
                    tagCount: {
                        serializedName: "x-ms-tag-count",
                        xmlName: "x-ms-tag-count",
                        type: {
                            name: "Number"
                        }
                    },
                    expiresOn: {
                        serializedName: "x-ms-expiry-time",
                        xmlName: "x-ms-expiry-time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isSealed: {
                        serializedName: "x-ms-blob-sealed",
                        xmlName: "x-ms-blob-sealed",
                        type: {
                            name: "Boolean"
                        }
                    },
                    rehydratePriority: {
                        serializedName: "x-ms-rehydrate-priority",
                        xmlName: "x-ms-rehydrate-priority",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "High",
                                "Standard"
                            ]
                        }
                    },
                    lastAccessed: {
                        serializedName: "x-ms-last-access-time",
                        xmlName: "x-ms-last-access-time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    immutabilityPolicyExpiresOn: {
                        serializedName: "x-ms-immutability-policy-until-date",
                        xmlName: "x-ms-immutability-policy-until-date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    immutabilityPolicyMode: {
                        serializedName: "x-ms-immutability-policy-mode",
                        xmlName: "x-ms-immutability-policy-mode",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Mutable",
                                "Unlocked",
                                "Locked"
                            ]
                        }
                    },
                    legalHold: {
                        serializedName: "x-ms-legal-hold",
                        xmlName: "x-ms-legal-hold",
                        type: {
                            name: "Boolean"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobGetPropertiesExceptionHeaders = {
            serializedName: "Blob_getPropertiesExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobGetPropertiesExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobDeleteHeaders = {
            serializedName: "Blob_deleteHeaders",
            type: {
                name: "Composite",
                className: "BlobDeleteHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobDeleteExceptionHeaders = {
            serializedName: "Blob_deleteExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobDeleteExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobUndeleteHeaders = {
            serializedName: "Blob_undeleteHeaders",
            type: {
                name: "Composite",
                className: "BlobUndeleteHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobUndeleteExceptionHeaders = {
            serializedName: "Blob_undeleteExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobUndeleteExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetExpiryHeaders = {
            serializedName: "Blob_setExpiryHeaders",
            type: {
                name: "Composite",
                className: "BlobSetExpiryHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const BlobSetExpiryExceptionHeaders = {
            serializedName: "Blob_setExpiryExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobSetExpiryExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetHttpHeadersHeaders = {
            serializedName: "Blob_setHttpHeadersHeaders",
            type: {
                name: "Composite",
                className: "BlobSetHttpHeadersHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetHttpHeadersExceptionHeaders = {
            serializedName: "Blob_setHttpHeadersExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobSetHttpHeadersExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetImmutabilityPolicyHeaders = {
            serializedName: "Blob_setImmutabilityPolicyHeaders",
            type: {
                name: "Composite",
                className: "BlobSetImmutabilityPolicyHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    immutabilityPolicyExpiry: {
                        serializedName: "x-ms-immutability-policy-until-date",
                        xmlName: "x-ms-immutability-policy-until-date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    immutabilityPolicyMode: {
                        serializedName: "x-ms-immutability-policy-mode",
                        xmlName: "x-ms-immutability-policy-mode",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Mutable",
                                "Unlocked",
                                "Locked"
                            ]
                        }
                    }
                }
            }
        };
        const BlobSetImmutabilityPolicyExceptionHeaders = {
            serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobSetImmutabilityPolicyExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobDeleteImmutabilityPolicyHeaders = {
            serializedName: "Blob_deleteImmutabilityPolicyHeaders",
            type: {
                name: "Composite",
                className: "BlobDeleteImmutabilityPolicyHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const BlobDeleteImmutabilityPolicyExceptionHeaders = {
            serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetLegalHoldHeaders = {
            serializedName: "Blob_setLegalHoldHeaders",
            type: {
                name: "Composite",
                className: "BlobSetLegalHoldHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    legalHold: {
                        serializedName: "x-ms-legal-hold",
                        xmlName: "x-ms-legal-hold",
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            }
        };
        const BlobSetLegalHoldExceptionHeaders = {
            serializedName: "Blob_setLegalHoldExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobSetLegalHoldExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetMetadataHeaders = {
            serializedName: "Blob_setMetadataHeaders",
            type: {
                name: "Composite",
                className: "BlobSetMetadataHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetMetadataExceptionHeaders = {
            serializedName: "Blob_setMetadataExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobSetMetadataExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobAcquireLeaseHeaders = {
            serializedName: "Blob_acquireLeaseHeaders",
            type: {
                name: "Composite",
                className: "BlobAcquireLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    leaseId: {
                        serializedName: "x-ms-lease-id",
                        xmlName: "x-ms-lease-id",
                        type: {
                            name: "String"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const BlobAcquireLeaseExceptionHeaders = {
            serializedName: "Blob_acquireLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobAcquireLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobReleaseLeaseHeaders = {
            serializedName: "Blob_releaseLeaseHeaders",
            type: {
                name: "Composite",
                className: "BlobReleaseLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const BlobReleaseLeaseExceptionHeaders = {
            serializedName: "Blob_releaseLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobReleaseLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobRenewLeaseHeaders = {
            serializedName: "Blob_renewLeaseHeaders",
            type: {
                name: "Composite",
                className: "BlobRenewLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    leaseId: {
                        serializedName: "x-ms-lease-id",
                        xmlName: "x-ms-lease-id",
                        type: {
                            name: "String"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const BlobRenewLeaseExceptionHeaders = {
            serializedName: "Blob_renewLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobRenewLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobChangeLeaseHeaders = {
            serializedName: "Blob_changeLeaseHeaders",
            type: {
                name: "Composite",
                className: "BlobChangeLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    leaseId: {
                        serializedName: "x-ms-lease-id",
                        xmlName: "x-ms-lease-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const BlobChangeLeaseExceptionHeaders = {
            serializedName: "Blob_changeLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobChangeLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobBreakLeaseHeaders = {
            serializedName: "Blob_breakLeaseHeaders",
            type: {
                name: "Composite",
                className: "BlobBreakLeaseHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    leaseTime: {
                        serializedName: "x-ms-lease-time",
                        xmlName: "x-ms-lease-time",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    }
                }
            }
        };
        const BlobBreakLeaseExceptionHeaders = {
            serializedName: "Blob_breakLeaseExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobBreakLeaseExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobCreateSnapshotHeaders = {
            serializedName: "Blob_createSnapshotHeaders",
            type: {
                name: "Composite",
                className: "BlobCreateSnapshotHeaders",
                modelProperties: {
                    snapshot: {
                        serializedName: "x-ms-snapshot",
                        xmlName: "x-ms-snapshot",
                        type: {
                            name: "String"
                        }
                    },
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobCreateSnapshotExceptionHeaders = {
            serializedName: "Blob_createSnapshotExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobCreateSnapshotExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobStartCopyFromURLHeaders = {
            serializedName: "Blob_startCopyFromURLHeaders",
            type: {
                name: "Composite",
                className: "BlobStartCopyFromURLHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    copyId: {
                        serializedName: "x-ms-copy-id",
                        xmlName: "x-ms-copy-id",
                        type: {
                            name: "String"
                        }
                    },
                    copyStatus: {
                        serializedName: "x-ms-copy-status",
                        xmlName: "x-ms-copy-status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "pending",
                                "success",
                                "aborted",
                                "failed"
                            ]
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobStartCopyFromURLExceptionHeaders = {
            serializedName: "Blob_startCopyFromURLExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobStartCopyFromURLExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobCopyFromURLHeaders = {
            serializedName: "Blob_copyFromURLHeaders",
            type: {
                name: "Composite",
                className: "BlobCopyFromURLHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    copyId: {
                        serializedName: "x-ms-copy-id",
                        xmlName: "x-ms-copy-id",
                        type: {
                            name: "String"
                        }
                    },
                    copyStatus: {
                        defaultValue: "success",
                        isConstant: true,
                        serializedName: "x-ms-copy-status",
                        type: {
                            name: "String"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    xMsContentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobCopyFromURLExceptionHeaders = {
            serializedName: "Blob_copyFromURLExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobCopyFromURLExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobAbortCopyFromURLHeaders = {
            serializedName: "Blob_abortCopyFromURLHeaders",
            type: {
                name: "Composite",
                className: "BlobAbortCopyFromURLHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobAbortCopyFromURLExceptionHeaders = {
            serializedName: "Blob_abortCopyFromURLExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobAbortCopyFromURLExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetTierHeaders = {
            serializedName: "Blob_setTierHeaders",
            type: {
                name: "Composite",
                className: "BlobSetTierHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetTierExceptionHeaders = {
            serializedName: "Blob_setTierExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobSetTierExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobGetAccountInfoHeaders = {
            serializedName: "Blob_getAccountInfoHeaders",
            type: {
                name: "Composite",
                className: "BlobGetAccountInfoHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    skuName: {
                        serializedName: "x-ms-sku-name",
                        xmlName: "x-ms-sku-name",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Standard_LRS",
                                "Standard_GRS",
                                "Standard_RAGRS",
                                "Standard_ZRS",
                                "Premium_LRS"
                            ]
                        }
                    },
                    accountKind: {
                        serializedName: "x-ms-account-kind",
                        xmlName: "x-ms-account-kind",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Storage",
                                "BlobStorage",
                                "StorageV2",
                                "FileStorage",
                                "BlockBlobStorage"
                            ]
                        }
                    }
                }
            }
        };
        const BlobGetAccountInfoExceptionHeaders = {
            serializedName: "Blob_getAccountInfoExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobGetAccountInfoExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobQueryHeaders = {
            serializedName: "Blob_queryHeaders",
            type: {
                name: "Composite",
                className: "BlobQueryHeaders",
                modelProperties: {
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    metadata: {
                        serializedName: "x-ms-meta",
                        xmlName: "x-ms-meta",
                        type: {
                            name: "Dictionary",
                            value: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    },
                    contentLength: {
                        serializedName: "content-length",
                        xmlName: "content-length",
                        type: {
                            name: "Number"
                        }
                    },
                    contentType: {
                        serializedName: "content-type",
                        xmlName: "content-type",
                        type: {
                            name: "String"
                        }
                    },
                    contentRange: {
                        serializedName: "content-range",
                        xmlName: "content-range",
                        type: {
                            name: "String"
                        }
                    },
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    contentEncoding: {
                        serializedName: "content-encoding",
                        xmlName: "content-encoding",
                        type: {
                            name: "String"
                        }
                    },
                    cacheControl: {
                        serializedName: "cache-control",
                        xmlName: "cache-control",
                        type: {
                            name: "String"
                        }
                    },
                    contentDisposition: {
                        serializedName: "content-disposition",
                        xmlName: "content-disposition",
                        type: {
                            name: "String"
                        }
                    },
                    contentLanguage: {
                        serializedName: "content-language",
                        xmlName: "content-language",
                        type: {
                            name: "String"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    blobType: {
                        serializedName: "x-ms-blob-type",
                        xmlName: "x-ms-blob-type",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "BlockBlob",
                                "PageBlob",
                                "AppendBlob"
                            ]
                        }
                    },
                    copyCompletionTime: {
                        serializedName: "x-ms-copy-completion-time",
                        xmlName: "x-ms-copy-completion-time",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    copyStatusDescription: {
                        serializedName: "x-ms-copy-status-description",
                        xmlName: "x-ms-copy-status-description",
                        type: {
                            name: "String"
                        }
                    },
                    copyId: {
                        serializedName: "x-ms-copy-id",
                        xmlName: "x-ms-copy-id",
                        type: {
                            name: "String"
                        }
                    },
                    copyProgress: {
                        serializedName: "x-ms-copy-progress",
                        xmlName: "x-ms-copy-progress",
                        type: {
                            name: "String"
                        }
                    },
                    copySource: {
                        serializedName: "x-ms-copy-source",
                        xmlName: "x-ms-copy-source",
                        type: {
                            name: "String"
                        }
                    },
                    copyStatus: {
                        serializedName: "x-ms-copy-status",
                        xmlName: "x-ms-copy-status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "pending",
                                "success",
                                "aborted",
                                "failed"
                            ]
                        }
                    },
                    leaseDuration: {
                        serializedName: "x-ms-lease-duration",
                        xmlName: "x-ms-lease-duration",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "infinite",
                                "fixed"
                            ]
                        }
                    },
                    leaseState: {
                        serializedName: "x-ms-lease-state",
                        xmlName: "x-ms-lease-state",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "available",
                                "leased",
                                "expired",
                                "breaking",
                                "broken"
                            ]
                        }
                    },
                    leaseStatus: {
                        serializedName: "x-ms-lease-status",
                        xmlName: "x-ms-lease-status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "locked",
                                "unlocked"
                            ]
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    acceptRanges: {
                        serializedName: "accept-ranges",
                        xmlName: "accept-ranges",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    blobCommittedBlockCount: {
                        serializedName: "x-ms-blob-committed-block-count",
                        xmlName: "x-ms-blob-committed-block-count",
                        type: {
                            name: "Number"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-server-encrypted",
                        xmlName: "x-ms-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    blobContentMD5: {
                        serializedName: "x-ms-blob-content-md5",
                        xmlName: "x-ms-blob-content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    },
                    contentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    }
                }
            }
        };
        const BlobQueryExceptionHeaders = {
            serializedName: "Blob_queryExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobQueryExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobGetTagsHeaders = {
            serializedName: "Blob_getTagsHeaders",
            type: {
                name: "Composite",
                className: "BlobGetTagsHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobGetTagsExceptionHeaders = {
            serializedName: "Blob_getTagsExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobGetTagsExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetTagsHeaders = {
            serializedName: "Blob_setTagsHeaders",
            type: {
                name: "Composite",
                className: "BlobSetTagsHeaders",
                modelProperties: {
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlobSetTagsExceptionHeaders = {
            serializedName: "Blob_setTagsExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlobSetTagsExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobCreateHeaders = {
            serializedName: "PageBlob_createHeaders",
            type: {
                name: "Composite",
                className: "PageBlobCreateHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobCreateExceptionHeaders = {
            serializedName: "PageBlob_createExceptionHeaders",
            type: {
                name: "Composite",
                className: "PageBlobCreateExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobUploadPagesHeaders = {
            serializedName: "PageBlob_uploadPagesHeaders",
            type: {
                name: "Composite",
                className: "PageBlobUploadPagesHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    xMsContentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobUploadPagesExceptionHeaders = {
            serializedName: "PageBlob_uploadPagesExceptionHeaders",
            type: {
                name: "Composite",
                className: "PageBlobUploadPagesExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobClearPagesHeaders = {
            serializedName: "PageBlob_clearPagesHeaders",
            type: {
                name: "Composite",
                className: "PageBlobClearPagesHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    xMsContentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobClearPagesExceptionHeaders = {
            serializedName: "PageBlob_clearPagesExceptionHeaders",
            type: {
                name: "Composite",
                className: "PageBlobClearPagesExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobUploadPagesFromURLHeaders = {
            serializedName: "PageBlob_uploadPagesFromURLHeaders",
            type: {
                name: "Composite",
                className: "PageBlobUploadPagesFromURLHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    xMsContentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobUploadPagesFromURLExceptionHeaders = {
            serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
            type: {
                name: "Composite",
                className: "PageBlobUploadPagesFromURLExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobGetPageRangesHeaders = {
            serializedName: "PageBlob_getPageRangesHeaders",
            type: {
                name: "Composite",
                className: "PageBlobGetPageRangesHeaders",
                modelProperties: {
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    blobContentLength: {
                        serializedName: "x-ms-blob-content-length",
                        xmlName: "x-ms-blob-content-length",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobGetPageRangesExceptionHeaders = {
            serializedName: "PageBlob_getPageRangesExceptionHeaders",
            type: {
                name: "Composite",
                className: "PageBlobGetPageRangesExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobGetPageRangesDiffHeaders = {
            serializedName: "PageBlob_getPageRangesDiffHeaders",
            type: {
                name: "Composite",
                className: "PageBlobGetPageRangesDiffHeaders",
                modelProperties: {
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    blobContentLength: {
                        serializedName: "x-ms-blob-content-length",
                        xmlName: "x-ms-blob-content-length",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobGetPageRangesDiffExceptionHeaders = {
            serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
            type: {
                name: "Composite",
                className: "PageBlobGetPageRangesDiffExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobResizeHeaders = {
            serializedName: "PageBlob_resizeHeaders",
            type: {
                name: "Composite",
                className: "PageBlobResizeHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobResizeExceptionHeaders = {
            serializedName: "PageBlob_resizeExceptionHeaders",
            type: {
                name: "Composite",
                className: "PageBlobResizeExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobUpdateSequenceNumberHeaders = {
            serializedName: "PageBlob_updateSequenceNumberHeaders",
            type: {
                name: "Composite",
                className: "PageBlobUpdateSequenceNumberHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    blobSequenceNumber: {
                        serializedName: "x-ms-blob-sequence-number",
                        xmlName: "x-ms-blob-sequence-number",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobUpdateSequenceNumberExceptionHeaders = {
            serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
            type: {
                name: "Composite",
                className: "PageBlobUpdateSequenceNumberExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobCopyIncrementalHeaders = {
            serializedName: "PageBlob_copyIncrementalHeaders",
            type: {
                name: "Composite",
                className: "PageBlobCopyIncrementalHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    copyId: {
                        serializedName: "x-ms-copy-id",
                        xmlName: "x-ms-copy-id",
                        type: {
                            name: "String"
                        }
                    },
                    copyStatus: {
                        serializedName: "x-ms-copy-status",
                        xmlName: "x-ms-copy-status",
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "pending",
                                "success",
                                "aborted",
                                "failed"
                            ]
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const PageBlobCopyIncrementalExceptionHeaders = {
            serializedName: "PageBlob_copyIncrementalExceptionHeaders",
            type: {
                name: "Composite",
                className: "PageBlobCopyIncrementalExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const AppendBlobCreateHeaders = {
            serializedName: "AppendBlob_createHeaders",
            type: {
                name: "Composite",
                className: "AppendBlobCreateHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const AppendBlobCreateExceptionHeaders = {
            serializedName: "AppendBlob_createExceptionHeaders",
            type: {
                name: "Composite",
                className: "AppendBlobCreateExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const AppendBlobAppendBlockHeaders = {
            serializedName: "AppendBlob_appendBlockHeaders",
            type: {
                name: "Composite",
                className: "AppendBlobAppendBlockHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    xMsContentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    blobAppendOffset: {
                        serializedName: "x-ms-blob-append-offset",
                        xmlName: "x-ms-blob-append-offset",
                        type: {
                            name: "String"
                        }
                    },
                    blobCommittedBlockCount: {
                        serializedName: "x-ms-blob-committed-block-count",
                        xmlName: "x-ms-blob-committed-block-count",
                        type: {
                            name: "Number"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const AppendBlobAppendBlockExceptionHeaders = {
            serializedName: "AppendBlob_appendBlockExceptionHeaders",
            type: {
                name: "Composite",
                className: "AppendBlobAppendBlockExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const AppendBlobAppendBlockFromUrlHeaders = {
            serializedName: "AppendBlob_appendBlockFromUrlHeaders",
            type: {
                name: "Composite",
                className: "AppendBlobAppendBlockFromUrlHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    xMsContentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    blobAppendOffset: {
                        serializedName: "x-ms-blob-append-offset",
                        xmlName: "x-ms-blob-append-offset",
                        type: {
                            name: "String"
                        }
                    },
                    blobCommittedBlockCount: {
                        serializedName: "x-ms-blob-committed-block-count",
                        xmlName: "x-ms-blob-committed-block-count",
                        type: {
                            name: "Number"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const AppendBlobAppendBlockFromUrlExceptionHeaders = {
            serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
            type: {
                name: "Composite",
                className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const AppendBlobSealHeaders = {
            serializedName: "AppendBlob_sealHeaders",
            type: {
                name: "Composite",
                className: "AppendBlobSealHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isSealed: {
                        serializedName: "x-ms-blob-sealed",
                        xmlName: "x-ms-blob-sealed",
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            }
        };
        const AppendBlobSealExceptionHeaders = {
            serializedName: "AppendBlob_sealExceptionHeaders",
            type: {
                name: "Composite",
                className: "AppendBlobSealExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobUploadHeaders = {
            serializedName: "BlockBlob_uploadHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobUploadHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobUploadExceptionHeaders = {
            serializedName: "BlockBlob_uploadExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobUploadExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobPutBlobFromUrlHeaders = {
            serializedName: "BlockBlob_putBlobFromUrlHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobPutBlobFromUrlHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobPutBlobFromUrlExceptionHeaders = {
            serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobPutBlobFromUrlExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobStageBlockHeaders = {
            serializedName: "BlockBlob_stageBlockHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobStageBlockHeaders",
                modelProperties: {
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    xMsContentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobStageBlockExceptionHeaders = {
            serializedName: "BlockBlob_stageBlockExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobStageBlockExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobStageBlockFromURLHeaders = {
            serializedName: "BlockBlob_stageBlockFromURLHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobStageBlockFromURLHeaders",
                modelProperties: {
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    xMsContentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobStageBlockFromURLExceptionHeaders = {
            serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobStageBlockFromURLExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobCommitBlockListHeaders = {
            serializedName: "BlockBlob_commitBlockListHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobCommitBlockListHeaders",
                modelProperties: {
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    contentMD5: {
                        serializedName: "content-md5",
                        xmlName: "content-md5",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    xMsContentCrc64: {
                        serializedName: "x-ms-content-crc64",
                        xmlName: "x-ms-content-crc64",
                        type: {
                            name: "ByteArray"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    versionId: {
                        serializedName: "x-ms-version-id",
                        xmlName: "x-ms-version-id",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    isServerEncrypted: {
                        serializedName: "x-ms-request-server-encrypted",
                        xmlName: "x-ms-request-server-encrypted",
                        type: {
                            name: "Boolean"
                        }
                    },
                    encryptionKeySha256: {
                        serializedName: "x-ms-encryption-key-sha256",
                        xmlName: "x-ms-encryption-key-sha256",
                        type: {
                            name: "String"
                        }
                    },
                    encryptionScope: {
                        serializedName: "x-ms-encryption-scope",
                        xmlName: "x-ms-encryption-scope",
                        type: {
                            name: "String"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobCommitBlockListExceptionHeaders = {
            serializedName: "BlockBlob_commitBlockListExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobCommitBlockListExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobGetBlockListHeaders = {
            serializedName: "BlockBlob_getBlockListHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobGetBlockListHeaders",
                modelProperties: {
                    lastModified: {
                        serializedName: "last-modified",
                        xmlName: "last-modified",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    etag: {
                        serializedName: "etag",
                        xmlName: "etag",
                        type: {
                            name: "String"
                        }
                    },
                    contentType: {
                        serializedName: "content-type",
                        xmlName: "content-type",
                        type: {
                            name: "String"
                        }
                    },
                    blobContentLength: {
                        serializedName: "x-ms-blob-content-length",
                        xmlName: "x-ms-blob-content-length",
                        type: {
                            name: "Number"
                        }
                    },
                    clientRequestId: {
                        serializedName: "x-ms-client-request-id",
                        xmlName: "x-ms-client-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    requestId: {
                        serializedName: "x-ms-request-id",
                        xmlName: "x-ms-request-id",
                        type: {
                            name: "String"
                        }
                    },
                    version: {
                        serializedName: "x-ms-version",
                        xmlName: "x-ms-version",
                        type: {
                            name: "String"
                        }
                    },
                    date: {
                        serializedName: "date",
                        xmlName: "date",
                        type: {
                            name: "DateTimeRfc1123"
                        }
                    },
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        const BlockBlobGetBlockListExceptionHeaders = {
            serializedName: "BlockBlob_getBlockListExceptionHeaders",
            type: {
                name: "Composite",
                className: "BlockBlobGetBlockListExceptionHeaders",
                modelProperties: {
                    errorCode: {
                        serializedName: "x-ms-error-code",
                        xmlName: "x-ms-error-code",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        };
        var queryCollectionFormat_QueryCollectionFormat;
        (function(QueryCollectionFormat) {
            QueryCollectionFormat["Csv"] = ",";
            QueryCollectionFormat["Ssv"] = " ";
            QueryCollectionFormat["Tsv"] = "\t";
            QueryCollectionFormat["Pipes"] = "|";
            QueryCollectionFormat["Multi"] = "Multi";
        })(queryCollectionFormat_QueryCollectionFormat || (queryCollectionFormat_QueryCollectionFormat = {}));
        const parameters_contentType = {
            parameterPath: [
                "options",
                "contentType"
            ],
            mapper: {
                defaultValue: "application/xml",
                isConstant: true,
                serializedName: "Content-Type",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_blobServiceProperties = {
            parameterPath: "blobServiceProperties",
            mapper: BlobServiceProperties
        };
        const parameters_accept = {
            parameterPath: "accept",
            mapper: {
                defaultValue: "application/xml",
                isConstant: true,
                serializedName: "Accept",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_url = {
            parameterPath: "url",
            mapper: {
                serializedName: "url",
                required: true,
                xmlName: "url",
                type: {
                    name: "String"
                }
            },
            skipEncoding: true
        };
        const restype = {
            parameterPath: "restype",
            mapper: {
                defaultValue: "service",
                isConstant: true,
                serializedName: "restype",
                type: {
                    name: "String"
                }
            }
        };
        const comp = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "properties",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const timeoutInSeconds = {
            parameterPath: [
                "options",
                "timeoutInSeconds"
            ],
            mapper: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "timeout",
                xmlName: "timeout",
                type: {
                    name: "Number"
                }
            }
        };
        const parameters_version = {
            parameterPath: "version",
            mapper: {
                defaultValue: "2023-11-03",
                isConstant: true,
                serializedName: "x-ms-version",
                type: {
                    name: "String"
                }
            }
        };
        const requestId = {
            parameterPath: [
                "options",
                "requestId"
            ],
            mapper: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            }
        };
        const accept1 = {
            parameterPath: "accept",
            mapper: {
                defaultValue: "application/xml",
                isConstant: true,
                serializedName: "Accept",
                type: {
                    name: "String"
                }
            }
        };
        const comp1 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "stats",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const comp2 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "list",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_prefix = {
            parameterPath: [
                "options",
                "prefix"
            ],
            mapper: {
                serializedName: "prefix",
                xmlName: "prefix",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_marker = {
            parameterPath: [
                "options",
                "marker"
            ],
            mapper: {
                serializedName: "marker",
                xmlName: "marker",
                type: {
                    name: "String"
                }
            }
        };
        const maxPageSize = {
            parameterPath: [
                "options",
                "maxPageSize"
            ],
            mapper: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "maxresults",
                xmlName: "maxresults",
                type: {
                    name: "Number"
                }
            }
        };
        const parameters_include = {
            parameterPath: [
                "options",
                "include"
            ],
            mapper: {
                serializedName: "include",
                xmlName: "include",
                xmlElementName: "ListContainersIncludeType",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "metadata",
                                "deleted",
                                "system"
                            ]
                        }
                    }
                }
            },
            collectionFormat: queryCollectionFormat_QueryCollectionFormat.Csv
        };
        const parameters_keyInfo = {
            parameterPath: "keyInfo",
            mapper: KeyInfo
        };
        const comp3 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "userdelegationkey",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const restype1 = {
            parameterPath: "restype",
            mapper: {
                defaultValue: "account",
                isConstant: true,
                serializedName: "restype",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_body = {
            parameterPath: "body",
            mapper: {
                serializedName: "body",
                required: true,
                xmlName: "body",
                type: {
                    name: "Stream"
                }
            }
        };
        const comp4 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "batch",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_contentLength = {
            parameterPath: "contentLength",
            mapper: {
                serializedName: "Content-Length",
                required: true,
                xmlName: "Content-Length",
                type: {
                    name: "Number"
                }
            }
        };
        const parameters_multipartContentType = {
            parameterPath: "multipartContentType",
            mapper: {
                serializedName: "Content-Type",
                required: true,
                xmlName: "Content-Type",
                type: {
                    name: "String"
                }
            }
        };
        const comp5 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "blobs",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const where = {
            parameterPath: [
                "options",
                "where"
            ],
            mapper: {
                serializedName: "where",
                xmlName: "where",
                type: {
                    name: "String"
                }
            }
        };
        const restype2 = {
            parameterPath: "restype",
            mapper: {
                defaultValue: "container",
                isConstant: true,
                serializedName: "restype",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_metadata = {
            parameterPath: [
                "options",
                "metadata"
            ],
            mapper: {
                serializedName: "x-ms-meta",
                xmlName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                },
                headerCollectionPrefix: "x-ms-meta-"
            }
        };
        const parameters_access = {
            parameterPath: [
                "options",
                "access"
            ],
            mapper: {
                serializedName: "x-ms-blob-public-access",
                xmlName: "x-ms-blob-public-access",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "container",
                        "blob"
                    ]
                }
            }
        };
        const defaultEncryptionScope = {
            parameterPath: [
                "options",
                "containerEncryptionScope",
                "defaultEncryptionScope"
            ],
            mapper: {
                serializedName: "x-ms-default-encryption-scope",
                xmlName: "x-ms-default-encryption-scope",
                type: {
                    name: "String"
                }
            }
        };
        const preventEncryptionScopeOverride = {
            parameterPath: [
                "options",
                "containerEncryptionScope",
                "preventEncryptionScopeOverride"
            ],
            mapper: {
                serializedName: "x-ms-deny-encryption-scope-override",
                xmlName: "x-ms-deny-encryption-scope-override",
                type: {
                    name: "Boolean"
                }
            }
        };
        const parameters_leaseId = {
            parameterPath: [
                "options",
                "leaseAccessConditions",
                "leaseId"
            ],
            mapper: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            }
        };
        const ifModifiedSince = {
            parameterPath: [
                "options",
                "modifiedAccessConditions",
                "ifModifiedSince"
            ],
            mapper: {
                serializedName: "If-Modified-Since",
                xmlName: "If-Modified-Since",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        };
        const ifUnmodifiedSince = {
            parameterPath: [
                "options",
                "modifiedAccessConditions",
                "ifUnmodifiedSince"
            ],
            mapper: {
                serializedName: "If-Unmodified-Since",
                xmlName: "If-Unmodified-Since",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        };
        const comp6 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "metadata",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const comp7 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "acl",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_containerAcl = {
            parameterPath: [
                "options",
                "containerAcl"
            ],
            mapper: {
                serializedName: "containerAcl",
                xmlName: "SignedIdentifiers",
                xmlIsWrapped: true,
                xmlElementName: "SignedIdentifier",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SignedIdentifier"
                        }
                    }
                }
            }
        };
        const comp8 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "undelete",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_deletedContainerName = {
            parameterPath: [
                "options",
                "deletedContainerName"
            ],
            mapper: {
                serializedName: "x-ms-deleted-container-name",
                xmlName: "x-ms-deleted-container-name",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_deletedContainerVersion = {
            parameterPath: [
                "options",
                "deletedContainerVersion"
            ],
            mapper: {
                serializedName: "x-ms-deleted-container-version",
                xmlName: "x-ms-deleted-container-version",
                type: {
                    name: "String"
                }
            }
        };
        const comp9 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "rename",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_sourceContainerName = {
            parameterPath: "sourceContainerName",
            mapper: {
                serializedName: "x-ms-source-container-name",
                required: true,
                xmlName: "x-ms-source-container-name",
                type: {
                    name: "String"
                }
            }
        };
        const sourceLeaseId = {
            parameterPath: [
                "options",
                "sourceLeaseId"
            ],
            mapper: {
                serializedName: "x-ms-source-lease-id",
                xmlName: "x-ms-source-lease-id",
                type: {
                    name: "String"
                }
            }
        };
        const comp10 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "lease",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const action = {
            parameterPath: "action",
            mapper: {
                defaultValue: "acquire",
                isConstant: true,
                serializedName: "x-ms-lease-action",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_duration = {
            parameterPath: [
                "options",
                "duration"
            ],
            mapper: {
                serializedName: "x-ms-lease-duration",
                xmlName: "x-ms-lease-duration",
                type: {
                    name: "Number"
                }
            }
        };
        const parameters_proposedLeaseId = {
            parameterPath: [
                "options",
                "proposedLeaseId"
            ],
            mapper: {
                serializedName: "x-ms-proposed-lease-id",
                xmlName: "x-ms-proposed-lease-id",
                type: {
                    name: "String"
                }
            }
        };
        const action1 = {
            parameterPath: "action",
            mapper: {
                defaultValue: "release",
                isConstant: true,
                serializedName: "x-ms-lease-action",
                type: {
                    name: "String"
                }
            }
        };
        const leaseId1 = {
            parameterPath: "leaseId",
            mapper: {
                serializedName: "x-ms-lease-id",
                required: true,
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            }
        };
        const action2 = {
            parameterPath: "action",
            mapper: {
                defaultValue: "renew",
                isConstant: true,
                serializedName: "x-ms-lease-action",
                type: {
                    name: "String"
                }
            }
        };
        const action3 = {
            parameterPath: "action",
            mapper: {
                defaultValue: "break",
                isConstant: true,
                serializedName: "x-ms-lease-action",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_breakPeriod = {
            parameterPath: [
                "options",
                "breakPeriod"
            ],
            mapper: {
                serializedName: "x-ms-lease-break-period",
                xmlName: "x-ms-lease-break-period",
                type: {
                    name: "Number"
                }
            }
        };
        const action4 = {
            parameterPath: "action",
            mapper: {
                defaultValue: "change",
                isConstant: true,
                serializedName: "x-ms-lease-action",
                type: {
                    name: "String"
                }
            }
        };
        const proposedLeaseId1 = {
            parameterPath: "proposedLeaseId",
            mapper: {
                serializedName: "x-ms-proposed-lease-id",
                required: true,
                xmlName: "x-ms-proposed-lease-id",
                type: {
                    name: "String"
                }
            }
        };
        const include1 = {
            parameterPath: [
                "options",
                "include"
            ],
            mapper: {
                serializedName: "include",
                xmlName: "include",
                xmlElementName: "ListBlobsIncludeItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "copy",
                                "deleted",
                                "metadata",
                                "snapshots",
                                "uncommittedblobs",
                                "versions",
                                "tags",
                                "immutabilitypolicy",
                                "legalhold",
                                "deletedwithversions"
                            ]
                        }
                    }
                }
            },
            collectionFormat: queryCollectionFormat_QueryCollectionFormat.Csv
        };
        const parameters_delimiter = {
            parameterPath: "delimiter",
            mapper: {
                serializedName: "delimiter",
                required: true,
                xmlName: "delimiter",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_snapshot = {
            parameterPath: [
                "options",
                "snapshot"
            ],
            mapper: {
                serializedName: "snapshot",
                xmlName: "snapshot",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_versionId = {
            parameterPath: [
                "options",
                "versionId"
            ],
            mapper: {
                serializedName: "versionid",
                xmlName: "versionid",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_range = {
            parameterPath: [
                "options",
                "range"
            ],
            mapper: {
                serializedName: "x-ms-range",
                xmlName: "x-ms-range",
                type: {
                    name: "String"
                }
            }
        };
        const rangeGetContentMD5 = {
            parameterPath: [
                "options",
                "rangeGetContentMD5"
            ],
            mapper: {
                serializedName: "x-ms-range-get-content-md5",
                xmlName: "x-ms-range-get-content-md5",
                type: {
                    name: "Boolean"
                }
            }
        };
        const rangeGetContentCRC64 = {
            parameterPath: [
                "options",
                "rangeGetContentCRC64"
            ],
            mapper: {
                serializedName: "x-ms-range-get-content-crc64",
                xmlName: "x-ms-range-get-content-crc64",
                type: {
                    name: "Boolean"
                }
            }
        };
        const encryptionKey = {
            parameterPath: [
                "options",
                "cpkInfo",
                "encryptionKey"
            ],
            mapper: {
                serializedName: "x-ms-encryption-key",
                xmlName: "x-ms-encryption-key",
                type: {
                    name: "String"
                }
            }
        };
        const encryptionKeySha256 = {
            parameterPath: [
                "options",
                "cpkInfo",
                "encryptionKeySha256"
            ],
            mapper: {
                serializedName: "x-ms-encryption-key-sha256",
                xmlName: "x-ms-encryption-key-sha256",
                type: {
                    name: "String"
                }
            }
        };
        const encryptionAlgorithm = {
            parameterPath: [
                "options",
                "cpkInfo",
                "encryptionAlgorithm"
            ],
            mapper: {
                serializedName: "x-ms-encryption-algorithm",
                xmlName: "x-ms-encryption-algorithm",
                type: {
                    name: "String"
                }
            }
        };
        const ifMatch = {
            parameterPath: [
                "options",
                "modifiedAccessConditions",
                "ifMatch"
            ],
            mapper: {
                serializedName: "If-Match",
                xmlName: "If-Match",
                type: {
                    name: "String"
                }
            }
        };
        const ifNoneMatch = {
            parameterPath: [
                "options",
                "modifiedAccessConditions",
                "ifNoneMatch"
            ],
            mapper: {
                serializedName: "If-None-Match",
                xmlName: "If-None-Match",
                type: {
                    name: "String"
                }
            }
        };
        const ifTags = {
            parameterPath: [
                "options",
                "modifiedAccessConditions",
                "ifTags"
            ],
            mapper: {
                serializedName: "x-ms-if-tags",
                xmlName: "x-ms-if-tags",
                type: {
                    name: "String"
                }
            }
        };
        const deleteSnapshots = {
            parameterPath: [
                "options",
                "deleteSnapshots"
            ],
            mapper: {
                serializedName: "x-ms-delete-snapshots",
                xmlName: "x-ms-delete-snapshots",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "include",
                        "only"
                    ]
                }
            }
        };
        const blobDeleteType = {
            parameterPath: [
                "options",
                "blobDeleteType"
            ],
            mapper: {
                serializedName: "deletetype",
                xmlName: "deletetype",
                type: {
                    name: "String"
                }
            }
        };
        const comp11 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "expiry",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_expiryOptions = {
            parameterPath: "expiryOptions",
            mapper: {
                serializedName: "x-ms-expiry-option",
                required: true,
                xmlName: "x-ms-expiry-option",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_expiresOn = {
            parameterPath: [
                "options",
                "expiresOn"
            ],
            mapper: {
                serializedName: "x-ms-expiry-time",
                xmlName: "x-ms-expiry-time",
                type: {
                    name: "String"
                }
            }
        };
        const blobCacheControl = {
            parameterPath: [
                "options",
                "blobHttpHeaders",
                "blobCacheControl"
            ],
            mapper: {
                serializedName: "x-ms-blob-cache-control",
                xmlName: "x-ms-blob-cache-control",
                type: {
                    name: "String"
                }
            }
        };
        const blobContentType = {
            parameterPath: [
                "options",
                "blobHttpHeaders",
                "blobContentType"
            ],
            mapper: {
                serializedName: "x-ms-blob-content-type",
                xmlName: "x-ms-blob-content-type",
                type: {
                    name: "String"
                }
            }
        };
        const blobContentMD5 = {
            parameterPath: [
                "options",
                "blobHttpHeaders",
                "blobContentMD5"
            ],
            mapper: {
                serializedName: "x-ms-blob-content-md5",
                xmlName: "x-ms-blob-content-md5",
                type: {
                    name: "ByteArray"
                }
            }
        };
        const blobContentEncoding = {
            parameterPath: [
                "options",
                "blobHttpHeaders",
                "blobContentEncoding"
            ],
            mapper: {
                serializedName: "x-ms-blob-content-encoding",
                xmlName: "x-ms-blob-content-encoding",
                type: {
                    name: "String"
                }
            }
        };
        const blobContentLanguage = {
            parameterPath: [
                "options",
                "blobHttpHeaders",
                "blobContentLanguage"
            ],
            mapper: {
                serializedName: "x-ms-blob-content-language",
                xmlName: "x-ms-blob-content-language",
                type: {
                    name: "String"
                }
            }
        };
        const blobContentDisposition = {
            parameterPath: [
                "options",
                "blobHttpHeaders",
                "blobContentDisposition"
            ],
            mapper: {
                serializedName: "x-ms-blob-content-disposition",
                xmlName: "x-ms-blob-content-disposition",
                type: {
                    name: "String"
                }
            }
        };
        const comp12 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "immutabilityPolicies",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const immutabilityPolicyExpiry = {
            parameterPath: [
                "options",
                "immutabilityPolicyExpiry"
            ],
            mapper: {
                serializedName: "x-ms-immutability-policy-until-date",
                xmlName: "x-ms-immutability-policy-until-date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        };
        const immutabilityPolicyMode = {
            parameterPath: [
                "options",
                "immutabilityPolicyMode"
            ],
            mapper: {
                serializedName: "x-ms-immutability-policy-mode",
                xmlName: "x-ms-immutability-policy-mode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Mutable",
                        "Unlocked",
                        "Locked"
                    ]
                }
            }
        };
        const comp13 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "legalhold",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_legalHold = {
            parameterPath: "legalHold",
            mapper: {
                serializedName: "x-ms-legal-hold",
                required: true,
                xmlName: "x-ms-legal-hold",
                type: {
                    name: "Boolean"
                }
            }
        };
        const parameters_encryptionScope = {
            parameterPath: [
                "options",
                "encryptionScope"
            ],
            mapper: {
                serializedName: "x-ms-encryption-scope",
                xmlName: "x-ms-encryption-scope",
                type: {
                    name: "String"
                }
            }
        };
        const comp14 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "snapshot",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_tier = {
            parameterPath: [
                "options",
                "tier"
            ],
            mapper: {
                serializedName: "x-ms-access-tier",
                xmlName: "x-ms-access-tier",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "P4",
                        "P6",
                        "P10",
                        "P15",
                        "P20",
                        "P30",
                        "P40",
                        "P50",
                        "P60",
                        "P70",
                        "P80",
                        "Hot",
                        "Cool",
                        "Archive",
                        "Cold"
                    ]
                }
            }
        };
        const rehydratePriority = {
            parameterPath: [
                "options",
                "rehydratePriority"
            ],
            mapper: {
                serializedName: "x-ms-rehydrate-priority",
                xmlName: "x-ms-rehydrate-priority",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "High",
                        "Standard"
                    ]
                }
            }
        };
        const sourceIfModifiedSince = {
            parameterPath: [
                "options",
                "sourceModifiedAccessConditions",
                "sourceIfModifiedSince"
            ],
            mapper: {
                serializedName: "x-ms-source-if-modified-since",
                xmlName: "x-ms-source-if-modified-since",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        };
        const sourceIfUnmodifiedSince = {
            parameterPath: [
                "options",
                "sourceModifiedAccessConditions",
                "sourceIfUnmodifiedSince"
            ],
            mapper: {
                serializedName: "x-ms-source-if-unmodified-since",
                xmlName: "x-ms-source-if-unmodified-since",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        };
        const sourceIfMatch = {
            parameterPath: [
                "options",
                "sourceModifiedAccessConditions",
                "sourceIfMatch"
            ],
            mapper: {
                serializedName: "x-ms-source-if-match",
                xmlName: "x-ms-source-if-match",
                type: {
                    name: "String"
                }
            }
        };
        const sourceIfNoneMatch = {
            parameterPath: [
                "options",
                "sourceModifiedAccessConditions",
                "sourceIfNoneMatch"
            ],
            mapper: {
                serializedName: "x-ms-source-if-none-match",
                xmlName: "x-ms-source-if-none-match",
                type: {
                    name: "String"
                }
            }
        };
        const sourceIfTags = {
            parameterPath: [
                "options",
                "sourceModifiedAccessConditions",
                "sourceIfTags"
            ],
            mapper: {
                serializedName: "x-ms-source-if-tags",
                xmlName: "x-ms-source-if-tags",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_copySource = {
            parameterPath: "copySource",
            mapper: {
                serializedName: "x-ms-copy-source",
                required: true,
                xmlName: "x-ms-copy-source",
                type: {
                    name: "String"
                }
            }
        };
        const blobTagsString = {
            parameterPath: [
                "options",
                "blobTagsString"
            ],
            mapper: {
                serializedName: "x-ms-tags",
                xmlName: "x-ms-tags",
                type: {
                    name: "String"
                }
            }
        };
        const sealBlob = {
            parameterPath: [
                "options",
                "sealBlob"
            ],
            mapper: {
                serializedName: "x-ms-seal-blob",
                xmlName: "x-ms-seal-blob",
                type: {
                    name: "Boolean"
                }
            }
        };
        const legalHold1 = {
            parameterPath: [
                "options",
                "legalHold"
            ],
            mapper: {
                serializedName: "x-ms-legal-hold",
                xmlName: "x-ms-legal-hold",
                type: {
                    name: "Boolean"
                }
            }
        };
        const xMsRequiresSync = {
            parameterPath: "xMsRequiresSync",
            mapper: {
                defaultValue: "true",
                isConstant: true,
                serializedName: "x-ms-requires-sync",
                type: {
                    name: "String"
                }
            }
        };
        const sourceContentMD5 = {
            parameterPath: [
                "options",
                "sourceContentMD5"
            ],
            mapper: {
                serializedName: "x-ms-source-content-md5",
                xmlName: "x-ms-source-content-md5",
                type: {
                    name: "ByteArray"
                }
            }
        };
        const copySourceAuthorization = {
            parameterPath: [
                "options",
                "copySourceAuthorization"
            ],
            mapper: {
                serializedName: "x-ms-copy-source-authorization",
                xmlName: "x-ms-copy-source-authorization",
                type: {
                    name: "String"
                }
            }
        };
        const copySourceTags = {
            parameterPath: [
                "options",
                "copySourceTags"
            ],
            mapper: {
                serializedName: "x-ms-copy-source-tag-option",
                xmlName: "x-ms-copy-source-tag-option",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "REPLACE",
                        "COPY"
                    ]
                }
            }
        };
        const comp15 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "copy",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const copyActionAbortConstant = {
            parameterPath: "copyActionAbortConstant",
            mapper: {
                defaultValue: "abort",
                isConstant: true,
                serializedName: "x-ms-copy-action",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_copyId = {
            parameterPath: "copyId",
            mapper: {
                serializedName: "copyid",
                required: true,
                xmlName: "copyid",
                type: {
                    name: "String"
                }
            }
        };
        const comp16 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "tier",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const tier1 = {
            parameterPath: "tier",
            mapper: {
                serializedName: "x-ms-access-tier",
                required: true,
                xmlName: "x-ms-access-tier",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "P4",
                        "P6",
                        "P10",
                        "P15",
                        "P20",
                        "P30",
                        "P40",
                        "P50",
                        "P60",
                        "P70",
                        "P80",
                        "Hot",
                        "Cool",
                        "Archive",
                        "Cold"
                    ]
                }
            }
        };
        const queryRequest = {
            parameterPath: [
                "options",
                "queryRequest"
            ],
            mapper: QueryRequest
        };
        const comp17 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "query",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const comp18 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "tags",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_tags = {
            parameterPath: [
                "options",
                "tags"
            ],
            mapper: BlobTags
        };
        const transactionalContentMD5 = {
            parameterPath: [
                "options",
                "transactionalContentMD5"
            ],
            mapper: {
                serializedName: "Content-MD5",
                xmlName: "Content-MD5",
                type: {
                    name: "ByteArray"
                }
            }
        };
        const transactionalContentCrc64 = {
            parameterPath: [
                "options",
                "transactionalContentCrc64"
            ],
            mapper: {
                serializedName: "x-ms-content-crc64",
                xmlName: "x-ms-content-crc64",
                type: {
                    name: "ByteArray"
                }
            }
        };
        const blobType = {
            parameterPath: "blobType",
            mapper: {
                defaultValue: "PageBlob",
                isConstant: true,
                serializedName: "x-ms-blob-type",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_blobContentLength = {
            parameterPath: "blobContentLength",
            mapper: {
                serializedName: "x-ms-blob-content-length",
                required: true,
                xmlName: "x-ms-blob-content-length",
                type: {
                    name: "Number"
                }
            }
        };
        const blobSequenceNumber = {
            parameterPath: [
                "options",
                "blobSequenceNumber"
            ],
            mapper: {
                serializedName: "x-ms-blob-sequence-number",
                xmlName: "x-ms-blob-sequence-number",
                type: {
                    name: "Number"
                }
            }
        };
        const contentType1 = {
            parameterPath: [
                "options",
                "contentType"
            ],
            mapper: {
                defaultValue: "application/octet-stream",
                isConstant: true,
                serializedName: "Content-Type",
                type: {
                    name: "String"
                }
            }
        };
        const body1 = {
            parameterPath: "body",
            mapper: {
                serializedName: "body",
                required: true,
                xmlName: "body",
                type: {
                    name: "Stream"
                }
            }
        };
        const accept2 = {
            parameterPath: "accept",
            mapper: {
                defaultValue: "application/xml",
                isConstant: true,
                serializedName: "Accept",
                type: {
                    name: "String"
                }
            }
        };
        const comp19 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "page",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const pageWrite = {
            parameterPath: "pageWrite",
            mapper: {
                defaultValue: "update",
                isConstant: true,
                serializedName: "x-ms-page-write",
                type: {
                    name: "String"
                }
            }
        };
        const ifSequenceNumberLessThanOrEqualTo = {
            parameterPath: [
                "options",
                "sequenceNumberAccessConditions",
                "ifSequenceNumberLessThanOrEqualTo"
            ],
            mapper: {
                serializedName: "x-ms-if-sequence-number-le",
                xmlName: "x-ms-if-sequence-number-le",
                type: {
                    name: "Number"
                }
            }
        };
        const ifSequenceNumberLessThan = {
            parameterPath: [
                "options",
                "sequenceNumberAccessConditions",
                "ifSequenceNumberLessThan"
            ],
            mapper: {
                serializedName: "x-ms-if-sequence-number-lt",
                xmlName: "x-ms-if-sequence-number-lt",
                type: {
                    name: "Number"
                }
            }
        };
        const ifSequenceNumberEqualTo = {
            parameterPath: [
                "options",
                "sequenceNumberAccessConditions",
                "ifSequenceNumberEqualTo"
            ],
            mapper: {
                serializedName: "x-ms-if-sequence-number-eq",
                xmlName: "x-ms-if-sequence-number-eq",
                type: {
                    name: "Number"
                }
            }
        };
        const pageWrite1 = {
            parameterPath: "pageWrite",
            mapper: {
                defaultValue: "clear",
                isConstant: true,
                serializedName: "x-ms-page-write",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_sourceUrl = {
            parameterPath: "sourceUrl",
            mapper: {
                serializedName: "x-ms-copy-source",
                required: true,
                xmlName: "x-ms-copy-source",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_sourceRange = {
            parameterPath: "sourceRange",
            mapper: {
                serializedName: "x-ms-source-range",
                required: true,
                xmlName: "x-ms-source-range",
                type: {
                    name: "String"
                }
            }
        };
        const sourceContentCrc64 = {
            parameterPath: [
                "options",
                "sourceContentCrc64"
            ],
            mapper: {
                serializedName: "x-ms-source-content-crc64",
                xmlName: "x-ms-source-content-crc64",
                type: {
                    name: "ByteArray"
                }
            }
        };
        const range1 = {
            parameterPath: "range",
            mapper: {
                serializedName: "x-ms-range",
                required: true,
                xmlName: "x-ms-range",
                type: {
                    name: "String"
                }
            }
        };
        const comp20 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "pagelist",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const prevsnapshot = {
            parameterPath: [
                "options",
                "prevsnapshot"
            ],
            mapper: {
                serializedName: "prevsnapshot",
                xmlName: "prevsnapshot",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_prevSnapshotUrl = {
            parameterPath: [
                "options",
                "prevSnapshotUrl"
            ],
            mapper: {
                serializedName: "x-ms-previous-snapshot-url",
                xmlName: "x-ms-previous-snapshot-url",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_sequenceNumberAction = {
            parameterPath: "sequenceNumberAction",
            mapper: {
                serializedName: "x-ms-sequence-number-action",
                required: true,
                xmlName: "x-ms-sequence-number-action",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "max",
                        "update",
                        "increment"
                    ]
                }
            }
        };
        const comp21 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "incrementalcopy",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const blobType1 = {
            parameterPath: "blobType",
            mapper: {
                defaultValue: "AppendBlob",
                isConstant: true,
                serializedName: "x-ms-blob-type",
                type: {
                    name: "String"
                }
            }
        };
        const comp22 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "appendblock",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const maxSize = {
            parameterPath: [
                "options",
                "appendPositionAccessConditions",
                "maxSize"
            ],
            mapper: {
                serializedName: "x-ms-blob-condition-maxsize",
                xmlName: "x-ms-blob-condition-maxsize",
                type: {
                    name: "Number"
                }
            }
        };
        const appendPosition = {
            parameterPath: [
                "options",
                "appendPositionAccessConditions",
                "appendPosition"
            ],
            mapper: {
                serializedName: "x-ms-blob-condition-appendpos",
                xmlName: "x-ms-blob-condition-appendpos",
                type: {
                    name: "Number"
                }
            }
        };
        const sourceRange1 = {
            parameterPath: [
                "options",
                "sourceRange"
            ],
            mapper: {
                serializedName: "x-ms-source-range",
                xmlName: "x-ms-source-range",
                type: {
                    name: "String"
                }
            }
        };
        const comp23 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "seal",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const blobType2 = {
            parameterPath: "blobType",
            mapper: {
                defaultValue: "BlockBlob",
                isConstant: true,
                serializedName: "x-ms-blob-type",
                type: {
                    name: "String"
                }
            }
        };
        const copySourceBlobProperties = {
            parameterPath: [
                "options",
                "copySourceBlobProperties"
            ],
            mapper: {
                serializedName: "x-ms-copy-source-blob-properties",
                xmlName: "x-ms-copy-source-blob-properties",
                type: {
                    name: "Boolean"
                }
            }
        };
        const comp24 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "block",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_blockId = {
            parameterPath: "blockId",
            mapper: {
                serializedName: "blockid",
                required: true,
                xmlName: "blockid",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_blocks = {
            parameterPath: "blocks",
            mapper: BlockLookupList
        };
        const comp25 = {
            parameterPath: "comp",
            mapper: {
                defaultValue: "blocklist",
                isConstant: true,
                serializedName: "comp",
                type: {
                    name: "String"
                }
            }
        };
        const parameters_listType = {
            parameterPath: "listType",
            mapper: {
                defaultValue: "committed",
                serializedName: "blocklisttype",
                required: true,
                xmlName: "blocklisttype",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "committed",
                        "uncommitted",
                        "all"
                    ]
                }
            }
        };
        class Service {
            constructor(client){
                this.client = client;
            }
            setProperties(blobServiceProperties, options) {
                const operationArguments = {
                    blobServiceProperties,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, setPropertiesOperationSpec);
            }
            getProperties(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec);
            }
            getStatistics(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, getStatisticsOperationSpec);
            }
            listContainersSegment(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, listContainersSegmentOperationSpec);
            }
            getUserDelegationKey(keyInfo, options) {
                const operationArguments = {
                    keyInfo,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, getUserDelegationKeyOperationSpec);
            }
            getAccountInfo(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, getAccountInfoOperationSpec);
            }
            submitBatch(contentLength, multipartContentType, body, options) {
                const operationArguments = {
                    contentLength,
                    multipartContentType,
                    body,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, submitBatchOperationSpec);
            }
            filterBlobs(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, filterBlobsOperationSpec);
            }
        }
        const xmlSerializer = new Serializer(mappers_namespaceObject, true);
        const setPropertiesOperationSpec = {
            path: "/",
            httpMethod: "PUT",
            responses: {
                202: {
                    headersMapper: ServiceSetPropertiesHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ServiceSetPropertiesExceptionHeaders
                }
            },
            requestBody: parameters_blobServiceProperties,
            queryParameters: [
                restype,
                comp,
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_contentType,
                parameters_accept,
                parameters_version,
                requestId
            ],
            isXML: true,
            contentType: "application/xml; charset=utf-8",
            mediaType: "xml",
            serializer: xmlSerializer
        };
        const getPropertiesOperationSpec = {
            path: "/",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: BlobServiceProperties,
                    headersMapper: ServiceGetPropertiesHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ServiceGetPropertiesExceptionHeaders
                }
            },
            queryParameters: [
                restype,
                comp,
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1
            ],
            isXML: true,
            serializer: xmlSerializer
        };
        const getStatisticsOperationSpec = {
            path: "/",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: BlobServiceStatistics,
                    headersMapper: ServiceGetStatisticsHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ServiceGetStatisticsExceptionHeaders
                }
            },
            queryParameters: [
                restype,
                timeoutInSeconds,
                comp1
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1
            ],
            isXML: true,
            serializer: xmlSerializer
        };
        const listContainersSegmentOperationSpec = {
            path: "/",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: ListContainersSegmentResponse,
                    headersMapper: ServiceListContainersSegmentHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ServiceListContainersSegmentExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp2,
                parameters_prefix,
                parameters_marker,
                maxPageSize,
                parameters_include
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1
            ],
            isXML: true,
            serializer: xmlSerializer
        };
        const getUserDelegationKeyOperationSpec = {
            path: "/",
            httpMethod: "POST",
            responses: {
                200: {
                    bodyMapper: UserDelegationKey,
                    headersMapper: ServiceGetUserDelegationKeyHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ServiceGetUserDelegationKeyExceptionHeaders
                }
            },
            requestBody: parameters_keyInfo,
            queryParameters: [
                restype,
                timeoutInSeconds,
                comp3
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_contentType,
                parameters_accept,
                parameters_version,
                requestId
            ],
            isXML: true,
            contentType: "application/xml; charset=utf-8",
            mediaType: "xml",
            serializer: xmlSerializer
        };
        const getAccountInfoOperationSpec = {
            path: "/",
            httpMethod: "GET",
            responses: {
                200: {
                    headersMapper: ServiceGetAccountInfoHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ServiceGetAccountInfoExceptionHeaders
                }
            },
            queryParameters: [
                comp,
                restype1
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                accept1
            ],
            isXML: true,
            serializer: xmlSerializer
        };
        const submitBatchOperationSpec = {
            path: "/",
            httpMethod: "POST",
            responses: {
                202: {
                    bodyMapper: {
                        type: {
                            name: "Stream"
                        },
                        serializedName: "parsedResponse"
                    },
                    headersMapper: ServiceSubmitBatchHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ServiceSubmitBatchExceptionHeaders
                }
            },
            requestBody: parameters_body,
            queryParameters: [
                timeoutInSeconds,
                comp4
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_contentType,
                parameters_accept,
                parameters_version,
                requestId,
                parameters_contentLength,
                parameters_multipartContentType
            ],
            isXML: true,
            contentType: "application/xml; charset=utf-8",
            mediaType: "xml",
            serializer: xmlSerializer
        };
        const filterBlobsOperationSpec = {
            path: "/",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: FilterBlobSegment,
                    headersMapper: ServiceFilterBlobsHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ServiceFilterBlobsExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_marker,
                maxPageSize,
                comp5,
                where
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1
            ],
            isXML: true,
            serializer: xmlSerializer
        };
        class Container {
            constructor(client){
                this.client = client;
            }
            create(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, createOperationSpec);
            }
            getProperties(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, container_getPropertiesOperationSpec);
            }
            delete(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, deleteOperationSpec);
            }
            setMetadata(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, setMetadataOperationSpec);
            }
            getAccessPolicy(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, getAccessPolicyOperationSpec);
            }
            setAccessPolicy(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, setAccessPolicyOperationSpec);
            }
            restore(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, restoreOperationSpec);
            }
            rename(sourceContainerName, options) {
                const operationArguments = {
                    sourceContainerName,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, renameOperationSpec);
            }
            submitBatch(contentLength, multipartContentType, body, options) {
                const operationArguments = {
                    contentLength,
                    multipartContentType,
                    body,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, container_submitBatchOperationSpec);
            }
            filterBlobs(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, container_filterBlobsOperationSpec);
            }
            acquireLease(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, acquireLeaseOperationSpec);
            }
            releaseLease(leaseId, options) {
                const operationArguments = {
                    leaseId,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, releaseLeaseOperationSpec);
            }
            renewLease(leaseId, options) {
                const operationArguments = {
                    leaseId,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, renewLeaseOperationSpec);
            }
            breakLease(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, breakLeaseOperationSpec);
            }
            changeLease(leaseId, proposedLeaseId, options) {
                const operationArguments = {
                    leaseId,
                    proposedLeaseId,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, changeLeaseOperationSpec);
            }
            listBlobFlatSegment(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, listBlobFlatSegmentOperationSpec);
            }
            listBlobHierarchySegment(delimiter, options) {
                const operationArguments = {
                    delimiter,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, listBlobHierarchySegmentOperationSpec);
            }
            getAccountInfo(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, container_getAccountInfoOperationSpec);
            }
        }
        const container_xmlSerializer = new Serializer(mappers_namespaceObject, true);
        const createOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: ContainerCreateHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerCreateExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_metadata,
                parameters_access,
                defaultEncryptionScope,
                preventEncryptionScopeOverride
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const container_getPropertiesOperationSpec = {
            path: "/{containerName}",
            httpMethod: "GET",
            responses: {
                200: {
                    headersMapper: ContainerGetPropertiesHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerGetPropertiesExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const deleteOperationSpec = {
            path: "/{containerName}",
            httpMethod: "DELETE",
            responses: {
                202: {
                    headersMapper: ContainerDeleteHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerDeleteExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const setMetadataOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: ContainerSetMetadataHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerSetMetadataExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp6
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const getAccessPolicyOperationSpec = {
            path: "/{containerName}",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "SignedIdentifier"
                                }
                            }
                        },
                        serializedName: "SignedIdentifiers",
                        xmlName: "SignedIdentifiers",
                        xmlIsWrapped: true,
                        xmlElementName: "SignedIdentifier"
                    },
                    headersMapper: ContainerGetAccessPolicyHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerGetAccessPolicyExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp7
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const setAccessPolicyOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: ContainerSetAccessPolicyHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerSetAccessPolicyExceptionHeaders
                }
            },
            requestBody: parameters_containerAcl,
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp7
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_contentType,
                parameters_accept,
                parameters_version,
                requestId,
                parameters_access,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince
            ],
            isXML: true,
            contentType: "application/xml; charset=utf-8",
            mediaType: "xml",
            serializer: container_xmlSerializer
        };
        const restoreOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: ContainerRestoreHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerRestoreExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp8
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_deletedContainerName,
                parameters_deletedContainerVersion
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const renameOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: ContainerRenameHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerRenameExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp9
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_sourceContainerName,
                sourceLeaseId
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const container_submitBatchOperationSpec = {
            path: "/{containerName}",
            httpMethod: "POST",
            responses: {
                202: {
                    bodyMapper: {
                        type: {
                            name: "Stream"
                        },
                        serializedName: "parsedResponse"
                    },
                    headersMapper: ContainerSubmitBatchHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerSubmitBatchExceptionHeaders
                }
            },
            requestBody: parameters_body,
            queryParameters: [
                timeoutInSeconds,
                comp4,
                restype2
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_contentType,
                parameters_accept,
                parameters_version,
                requestId,
                parameters_contentLength,
                parameters_multipartContentType
            ],
            isXML: true,
            contentType: "application/xml; charset=utf-8",
            mediaType: "xml",
            serializer: container_xmlSerializer
        };
        const container_filterBlobsOperationSpec = {
            path: "/{containerName}",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: FilterBlobSegment,
                    headersMapper: ContainerFilterBlobsHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerFilterBlobsExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_marker,
                maxPageSize,
                comp5,
                where,
                restype2
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const acquireLeaseOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: ContainerAcquireLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerAcquireLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                action,
                parameters_duration,
                parameters_proposedLeaseId
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const releaseLeaseOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: ContainerReleaseLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerReleaseLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                action1,
                leaseId1
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const renewLeaseOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: ContainerRenewLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerRenewLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                leaseId1,
                action2
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const breakLeaseOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                202: {
                    headersMapper: ContainerBreakLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerBreakLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                action3,
                parameters_breakPeriod
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const changeLeaseOperationSpec = {
            path: "/{containerName}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: ContainerChangeLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerChangeLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                restype2,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                leaseId1,
                action4,
                proposedLeaseId1
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const listBlobFlatSegmentOperationSpec = {
            path: "/{containerName}",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: ListBlobsFlatSegmentResponse,
                    headersMapper: ContainerListBlobFlatSegmentHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerListBlobFlatSegmentExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp2,
                parameters_prefix,
                parameters_marker,
                maxPageSize,
                restype2,
                include1
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const listBlobHierarchySegmentOperationSpec = {
            path: "/{containerName}",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: ListBlobsHierarchySegmentResponse,
                    headersMapper: ContainerListBlobHierarchySegmentHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerListBlobHierarchySegmentExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp2,
                parameters_prefix,
                parameters_marker,
                maxPageSize,
                restype2,
                include1,
                parameters_delimiter
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        const container_getAccountInfoOperationSpec = {
            path: "/{containerName}",
            httpMethod: "GET",
            responses: {
                200: {
                    headersMapper: ContainerGetAccountInfoHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: ContainerGetAccountInfoExceptionHeaders
                }
            },
            queryParameters: [
                comp,
                restype1
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                accept1
            ],
            isXML: true,
            serializer: container_xmlSerializer
        };
        var xml2js = __webpack_require__("../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/xml2js.js");
        const xml2jsDefaultOptionsV2 = {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: void 0,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: "$$",
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: void 0,
            attrValueProcessors: void 0,
            tagNameProcessors: void 0,
            valueProcessors: void 0,
            rootName: "root",
            xmldec: {
                version: "1.0",
                encoding: "UTF-8",
                standalone: true
            },
            doctype: void 0,
            renderOpts: {
                pretty: true,
                indent: "  ",
                newline: "\n"
            },
            headless: false,
            chunkSize: 10000,
            emptyTag: "",
            cdata: false
        };
        const xml2jsParserSettings = Object.assign({}, xml2jsDefaultOptionsV2);
        xml2jsParserSettings.explicitArray = false;
        const xml2jsBuilderSettings = Object.assign({}, xml2jsDefaultOptionsV2);
        xml2jsBuilderSettings.explicitArray = false;
        xml2jsBuilderSettings.renderOpts = {
            pretty: false
        };
        function stringifyXML(obj, opts = {}) {
            var _a;
            xml2jsBuilderSettings.rootName = opts.rootName;
            xml2jsBuilderSettings.charkey = null != (_a = opts.xmlCharKey) ? _a : "_";
            const builder = new xml2js.Builder(xml2jsBuilderSettings);
            return builder.buildObject(obj);
        }
        function parseXML(str, opts = {}) {
            var _a;
            xml2jsParserSettings.explicitRoot = !!opts.includeRoot;
            xml2jsParserSettings.charkey = null != (_a = opts.xmlCharKey) ? _a : "_";
            const xmlParser = new xml2js.Parser(xml2jsParserSettings);
            return new Promise((resolve, reject)=>{
                if (str) xmlParser.parseString(str, (err, res)=>{
                    if (err) reject(err);
                    else resolve(res);
                });
                else reject(new Error("Document is empty"));
            });
        }
        function deserializationPolicy_deserializationPolicy(deserializationContentTypes, parsingOptions) {
            return {
                create: (nextPolicy, options)=>new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions)
            };
        }
        const defaultJsonContentTypes = [
            "application/json",
            "text/json"
        ];
        const defaultXmlContentTypes = [
            "application/xml",
            "application/atom+xml"
        ];
        class DeserializationPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions = {}){
                var _a;
                super(nextPolicy, requestPolicyOptions);
                this.jsonContentTypes = deserializationContentTypes && deserializationContentTypes.json || defaultJsonContentTypes;
                this.xmlContentTypes = deserializationContentTypes && deserializationContentTypes.xml || defaultXmlContentTypes;
                this.xmlCharKey = null != (_a = parsingOptions.xmlCharKey) ? _a : "_";
            }
            async sendRequest(request) {
                return this._nextPolicy.sendRequest(request).then((response)=>deserializeResponseBody(this.jsonContentTypes, this.xmlContentTypes, response, {
                        xmlCharKey: this.xmlCharKey
                    }));
            }
        }
        function getOperationResponse(parsedResponse) {
            let result;
            const request = parsedResponse.request;
            const operationSpec = request.operationSpec;
            if (operationSpec) {
                const operationResponseGetter = request.operationResponseGetter;
                result = operationResponseGetter ? operationResponseGetter(operationSpec, parsedResponse) : operationSpec.responses[parsedResponse.status];
            }
            return result;
        }
        function shouldDeserializeResponse(parsedResponse) {
            const shouldDeserialize = parsedResponse.request.shouldDeserialize;
            let result;
            result = void 0 === shouldDeserialize ? true : "boolean" == typeof shouldDeserialize ? shouldDeserialize : shouldDeserialize(parsedResponse);
            return result;
        }
        function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options = {}) {
            var _a, _b, _c;
            const updatedOptions = {
                rootName: null != (_a = options.rootName) ? _a : "",
                includeRoot: null != (_b = options.includeRoot) ? _b : false,
                xmlCharKey: null != (_c = options.xmlCharKey) ? _c : "_"
            };
            return parse(jsonContentTypes, xmlContentTypes, response, updatedOptions).then((parsedResponse)=>{
                if (!shouldDeserializeResponse(parsedResponse)) return parsedResponse;
                const operationSpec = parsedResponse.request.operationSpec;
                if (!operationSpec || !operationSpec.responses) return parsedResponse;
                const responseSpec = getOperationResponse(parsedResponse);
                const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);
                if (error) throw error;
                if (shouldReturnResponse) return parsedResponse;
                if (responseSpec) {
                    if (responseSpec.bodyMapper) {
                        let valueToDeserialize = parsedResponse.parsedBody;
                        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) valueToDeserialize = "object" == typeof valueToDeserialize ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
                        try {
                            parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
                        } catch (innerError) {
                            const restError = new RestError(`Error ${innerError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, void 0, parsedResponse.status, parsedResponse.request, parsedResponse);
                            throw restError;
                        }
                    } else if ("HEAD" === operationSpec.httpMethod) parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
                    if (responseSpec.headersMapper) parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJson(), "operationRes.parsedHeaders", options);
                }
                return parsedResponse;
            });
        }
        function isOperationSpecEmpty(operationSpec) {
            const expectedStatusCodes = Object.keys(operationSpec.responses);
            return 0 === expectedStatusCodes.length || 1 === expectedStatusCodes.length && "default" === expectedStatusCodes[0];
        }
        function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
            var _a;
            const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
            const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
            if (isExpectedStatusCode) {
                if (!responseSpec) return {
                    error: null,
                    shouldReturnResponse: false
                };
                else if (!responseSpec.isError) return {
                    error: null,
                    shouldReturnResponse: false
                };
            }
            const errorResponseSpec = null != responseSpec ? responseSpec : operationSpec.responses.default;
            const streaming = (null == (_a = parsedResponse.request.streamResponseStatusCodes) ? void 0 : _a.has(parsedResponse.status)) || parsedResponse.request.streamResponseBody;
            const initialErrorMessage = streaming ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
            const error = new RestError(initialErrorMessage, void 0, parsedResponse.status, parsedResponse.request, parsedResponse);
            if (!errorResponseSpec) throw error;
            const defaultBodyMapper = errorResponseSpec.bodyMapper;
            const defaultHeadersMapper = errorResponseSpec.headersMapper;
            try {
                if (parsedResponse.parsedBody) {
                    const parsedBody = parsedResponse.parsedBody;
                    let parsedError;
                    if (defaultBodyMapper) {
                        let valueToDeserialize = parsedBody;
                        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperType.Sequence) valueToDeserialize = "object" == typeof parsedBody ? parsedBody[defaultBodyMapper.xmlElementName] : [];
                        parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
                    }
                    const internalError = parsedBody.error || parsedError || parsedBody;
                    error.code = internalError.code;
                    if (internalError.message) error.message = internalError.message;
                    if (defaultBodyMapper) error.response.parsedBody = parsedError;
                }
                if (parsedResponse.headers && defaultHeadersMapper) error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJson(), "operationRes.parsedHeaders");
            } catch (defaultError) {
                error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
            }
            return {
                error,
                shouldReturnResponse: false
            };
        }
        function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts) {
            var _a;
            const errorHandler = (err)=>{
                const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
                const errCode = err.code || RestError.PARSE_ERROR;
                const e = new RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);
                return Promise.reject(e);
            };
            const streaming = (null == (_a = operationResponse.request.streamResponseStatusCodes) ? void 0 : _a.has(operationResponse.status)) || operationResponse.request.streamResponseBody;
            if (!streaming && operationResponse.bodyAsText) {
                const text = operationResponse.bodyAsText;
                const contentType = operationResponse.headers.get("Content-Type") || "";
                const contentComponents = contentType ? contentType.split(";").map((component)=>component.toLowerCase()) : [];
                if (0 === contentComponents.length || contentComponents.some((component)=>-1 !== jsonContentTypes.indexOf(component))) return new Promise((resolve)=>{
                    operationResponse.parsedBody = JSON.parse(text);
                    resolve(operationResponse);
                }).catch(errorHandler);
                if (contentComponents.some((component)=>-1 !== xmlContentTypes.indexOf(component))) return parseXML(text, opts).then((body)=>{
                    operationResponse.parsedBody = body;
                    return operationResponse;
                }).catch(errorHandler);
            }
            return Promise.resolve(operationResponse);
        }
        function getHeaderKey(headerName) {
            return headerName.toLowerCase();
        }
        function isHttpHeadersLike(object) {
            if (object && "object" == typeof object) {
                const castObject = object;
                if ("function" == typeof castObject.rawHeaders && "function" == typeof castObject.clone && "function" == typeof castObject.get && "function" == typeof castObject.set && "function" == typeof castObject.contains && "function" == typeof castObject.remove && "function" == typeof castObject.headersArray && "function" == typeof castObject.headerValues && "function" == typeof castObject.headerNames && "function" == typeof castObject.toJson) return true;
            }
            return false;
        }
        class httpHeaders_HttpHeaders {
            constructor(rawHeaders){
                this._headersMap = {};
                if (rawHeaders) for(const headerName in rawHeaders)this.set(headerName, rawHeaders[headerName]);
            }
            set(headerName, headerValue) {
                this._headersMap[getHeaderKey(headerName)] = {
                    name: headerName,
                    value: headerValue.toString().trim()
                };
            }
            get(headerName) {
                const header = this._headersMap[getHeaderKey(headerName)];
                return header ? header.value : void 0;
            }
            contains(headerName) {
                return !!this._headersMap[getHeaderKey(headerName)];
            }
            remove(headerName) {
                const result = this.contains(headerName);
                delete this._headersMap[getHeaderKey(headerName)];
                return result;
            }
            rawHeaders() {
                return this.toJson({
                    preserveCase: true
                });
            }
            headersArray() {
                const headers = [];
                for(const headerKey in this._headersMap)headers.push(this._headersMap[headerKey]);
                return headers;
            }
            headerNames() {
                const headerNames = [];
                const headers = this.headersArray();
                for(let i = 0; i < headers.length; ++i)headerNames.push(headers[i].name);
                return headerNames;
            }
            headerValues() {
                const headerValues = [];
                const headers = this.headersArray();
                for(let i = 0; i < headers.length; ++i)headerValues.push(headers[i].value);
                return headerValues;
            }
            toJson(options = {}) {
                const result = {};
                if (options.preserveCase) for(const headerKey in this._headersMap){
                    const header = this._headersMap[headerKey];
                    result[header.name] = header.value;
                }
                else for(const headerKey in this._headersMap){
                    const header = this._headersMap[headerKey];
                    result[getHeaderKey(header.name)] = header.value;
                }
                return result;
            }
            toString() {
                return JSON.stringify(this.toJson({
                    preserveCase: true
                }));
            }
            clone() {
                const resultPreservingCasing = {};
                for(const headerKey in this._headersMap){
                    const header = this._headersMap[headerKey];
                    resultPreservingCasing[header.name] = header.value;
                }
                return new httpHeaders_HttpHeaders(resultPreservingCasing);
            }
        }
        function isWebResourceLike(object) {
            if (object && "object" == typeof object) {
                const castObject = object;
                if ("string" == typeof castObject.url && "string" == typeof castObject.method && "object" == typeof castObject.headers && isHttpHeadersLike(castObject.headers) && "function" == typeof castObject.validateRequestProperties && "function" == typeof castObject.prepare && "function" == typeof castObject.clone) return true;
            }
            return false;
        }
        class WebResource {
            constructor(url, method, body, query, headers, streamResponseBody, withCredentials, abortSignal, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive, decompressResponse, streamResponseStatusCodes){
                this.streamResponseBody = streamResponseBody;
                this.streamResponseStatusCodes = streamResponseStatusCodes;
                this.url = url || "";
                this.method = method || "GET";
                this.headers = isHttpHeadersLike(headers) ? headers : new httpHeaders_HttpHeaders(headers);
                this.body = body;
                this.query = query;
                this.formData = void 0;
                this.withCredentials = withCredentials || false;
                this.abortSignal = abortSignal;
                this.timeout = timeout || 0;
                this.onUploadProgress = onUploadProgress;
                this.onDownloadProgress = onDownloadProgress;
                this.proxySettings = proxySettings;
                this.keepAlive = keepAlive;
                this.decompressResponse = decompressResponse;
                this.requestId = this.headers.get("x-ms-client-request-id") || generateUuid();
            }
            validateRequestProperties() {
                if (!this.method) throw new Error("WebResource.method is required.");
                if (!this.url) throw new Error("WebResource.url is required.");
            }
            prepare(options) {
                if (!options) throw new Error("options object is required");
                if (void 0 === options.method || null === options.method || "string" != typeof options.method.valueOf()) throw new Error("options.method must be a string.");
                if (options.url && options.pathTemplate) throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
                if ((void 0 === options.pathTemplate || null === options.pathTemplate || "string" != typeof options.pathTemplate.valueOf()) && (void 0 === options.url || null === options.url || "string" != typeof options.url.valueOf())) throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
                if (options.url) {
                    if ("string" != typeof options.url) throw new Error('options.url must be of type "string".');
                    this.url = options.url;
                }
                if (options.method) {
                    const validMethods = [
                        "GET",
                        "PUT",
                        "HEAD",
                        "DELETE",
                        "OPTIONS",
                        "POST",
                        "PATCH",
                        "TRACE"
                    ];
                    if (-1 === validMethods.indexOf(options.method.toUpperCase())) throw new Error('The provided method "' + options.method + '" is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));
                }
                this.method = options.method.toUpperCase();
                if (options.pathTemplate) {
                    const { pathTemplate, pathParameters } = options;
                    if ("string" != typeof pathTemplate) throw new Error('options.pathTemplate must be of type "string".');
                    if (!options.baseUrl) options.baseUrl = "https://management.azure.com";
                    const baseUrl = options.baseUrl;
                    let url = baseUrl + (baseUrl.endsWith("/") ? "" : "/") + (pathTemplate.startsWith("/") ? pathTemplate.slice(1) : pathTemplate);
                    const segments = url.match(/({[\w-]*\s*[\w-]*})/gi);
                    if (segments && segments.length) {
                        if (!pathParameters) throw new Error(`pathTemplate: ${pathTemplate} has been provided. Hence, options.pathParameters must also be provided.`);
                        segments.forEach(function(item) {
                            const pathParamName = item.slice(1, -1);
                            const pathParam = pathParameters[pathParamName];
                            if (null == pathParam || !("string" == typeof pathParam || "object" == typeof pathParam)) {
                                const stringifiedPathParameters = JSON.stringify(pathParameters, void 0, 2);
                                throw new Error(`pathTemplate: ${pathTemplate} contains the path parameter ${pathParamName} however, it is not present in parameters: ${stringifiedPathParameters}.The value of the path parameter can either be a "string" of the form { ${pathParamName}: "some sample value" } or it can be an "object" of the form { "${pathParamName}": { value: "some sample value", skipUrlEncoding: true } }.`);
                            }
                            if ("string" == typeof pathParam.valueOf()) url = url.replace(item, encodeURIComponent(pathParam));
                            if ("object" == typeof pathParam.valueOf()) {
                                if (!pathParam.value) throw new Error(`options.pathParameters[${pathParamName}] is of type "object" but it does not contain a "value" property.`);
                                url = pathParam.skipUrlEncoding ? url.replace(item, pathParam.value) : url.replace(item, encodeURIComponent(pathParam.value));
                            }
                        });
                    }
                    this.url = url;
                }
                if (options.queryParameters) {
                    const queryParameters = options.queryParameters;
                    if ("object" != typeof queryParameters) throw new Error('options.queryParameters must be of type object. It should be a JSON object of "query-parameter-name" as the key and the "query-parameter-value" as the value. The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.');
                    if (this.url && -1 === this.url.indexOf("?")) this.url += "?";
                    const queryParams = [];
                    this.query = {};
                    for(const queryParamName in queryParameters){
                        const queryParam = queryParameters[queryParamName];
                        if (queryParam) {
                            if ("string" == typeof queryParam) {
                                queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam));
                                this.query[queryParamName] = encodeURIComponent(queryParam);
                            } else if ("object" == typeof queryParam) {
                                if (!queryParam.value) throw new Error(`options.queryParameters[${queryParamName}] is of type "object" but it does not contain a "value" property.`);
                                if (queryParam.skipUrlEncoding) {
                                    queryParams.push(queryParamName + "=" + queryParam.value);
                                    this.query[queryParamName] = queryParam.value;
                                } else {
                                    queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam.value));
                                    this.query[queryParamName] = encodeURIComponent(queryParam.value);
                                }
                            }
                        }
                    }
                    this.url += queryParams.join("&");
                }
                if (options.headers) {
                    const headers = options.headers;
                    for (const headerName of Object.keys(options.headers))this.headers.set(headerName, headers[headerName]);
                }
                if (!this.headers.get("accept-language")) this.headers.set("accept-language", "en-US");
                if (!this.headers.get("x-ms-client-request-id") && !options.disableClientRequestId) this.headers.set("x-ms-client-request-id", this.requestId);
                if (!this.headers.get("Content-Type")) this.headers.set("Content-Type", "application/json; charset=utf-8");
                this.body = options.body;
                if (void 0 !== options.body && null !== options.body) if (options.bodyIsStream) {
                    if (!this.headers.get("Transfer-Encoding")) this.headers.set("Transfer-Encoding", "chunked");
                    if ("application/octet-stream" !== this.headers.get("Content-Type")) this.headers.set("Content-Type", "application/octet-stream");
                } else {
                    if (options.serializationMapper) this.body = new Serializer(options.mappers).serialize(options.serializationMapper, options.body, "requestBody");
                    if (!options.disableJsonStringifyOnBody) this.body = JSON.stringify(options.body);
                }
                if (options.spanOptions) this.spanOptions = options.spanOptions;
                if (options.tracingContext) this.tracingContext = options.tracingContext;
                this.abortSignal = options.abortSignal;
                this.onDownloadProgress = options.onDownloadProgress;
                this.onUploadProgress = options.onUploadProgress;
                return this;
            }
            clone() {
                const result = new WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse, this.streamResponseStatusCodes);
                if (this.formData) result.formData = this.formData;
                if (this.operationSpec) result.operationSpec = this.operationSpec;
                if (this.shouldDeserialize) result.shouldDeserialize = this.shouldDeserialize;
                if (this.operationResponseGetter) result.operationResponseGetter = this.operationResponseGetter;
                return result;
            }
        }
        function isTracingDisabled() {
            var _a;
            if ("u" < typeof process) return false;
            const azureTracingDisabledValue = null == (_a = process.env.AZURE_TRACING_DISABLED) ? void 0 : _a.toLowerCase();
            if ("false" === azureTracingDisabledValue || "0" === azureTracingDisabledValue) return false;
            return Boolean(azureTracingDisabledValue);
        }
        function createSpanFunction(args) {
            return function(operationName, operationOptions) {
                const tracer = getTracer();
                const tracingOptions = (null == operationOptions ? void 0 : operationOptions.tracingOptions) || {};
                const spanOptions = Object.assign({
                    kind: interfaces_SpanKind.INTERNAL
                }, tracingOptions.spanOptions);
                const spanName = args.packagePrefix ? `${args.packagePrefix}.${operationName}` : operationName;
                let span;
                span = isTracingDisabled() ? trace.wrapSpanContext(INVALID_SPAN_CONTEXT) : tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);
                if (args.namespace) span.setAttribute("az.namespace", args.namespace);
                let newSpanOptions = tracingOptions.spanOptions || {};
                if (span.isRecording() && args.namespace) newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), {
                    attributes: Object.assign(Object.assign({}, spanOptions.attributes), {
                        "az.namespace": args.namespace
                    })
                });
                const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), {
                    spanOptions: newSpanOptions,
                    tracingContext: interfaces_setSpan(tracingOptions.tracingContext || interfaces_context.active(), span)
                });
                const newOperationOptions = Object.assign(Object.assign({}, operationOptions), {
                    tracingOptions: newTracingOptions
                });
                return {
                    span,
                    updatedOptions: newOperationOptions
                };
            };
        }
        const traceParentHeader_VERSION = "00";
        function getTraceParentHeader(spanContext) {
            const missingFields = [];
            if (!spanContext.traceId) missingFields.push("traceId");
            if (!spanContext.spanId) missingFields.push("spanId");
            if (missingFields.length) return;
            const flags = spanContext.traceFlags || 0;
            const hexFlags = flags.toString(16);
            const traceFlags = 1 === hexFlags.length ? `0${hexFlags}` : hexFlags;
            return `${traceParentHeader_VERSION}-${spanContext.traceId}-${spanContext.spanId}-${traceFlags}`;
        }
        const external_node_os_namespaceObject = require("node:os");
        var external_node_util_ = __webpack_require__("node:util");
        const external_node_process_namespaceObject = require("node:process");
        function log(message, ...args) {
            external_node_process_namespaceObject.stderr.write(`${external_node_util_.format(message, ...args)}${external_node_os_namespaceObject.EOL}`);
        }
        const debugEnvVariable = "u" > typeof process && process.env && process.env.DEBUG || void 0;
        let enabledString;
        let debug_enabledNamespaces = [];
        let skippedNamespaces = [];
        const debuggers = [];
        if (debugEnvVariable) enable(debugEnvVariable);
        const debugObj = Object.assign((namespace)=>createDebugger(namespace), {
            enable,
            enabled,
            disable,
            log: log
        });
        function enable(namespaces) {
            enabledString = namespaces;
            debug_enabledNamespaces = [];
            skippedNamespaces = [];
            const wildcard = /\*/g;
            const namespaceList = namespaces.split(",").map((ns)=>ns.trim().replace(wildcard, ".*?"));
            for (const ns of namespaceList)if (ns.startsWith("-")) skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
            else debug_enabledNamespaces.push(new RegExp(`^${ns}$`));
            for (const instance of debuggers)instance.enabled = enabled(instance.namespace);
        }
        function enabled(namespace) {
            if (namespace.endsWith("*")) return true;
            for (const skipped of skippedNamespaces)if (skipped.test(namespace)) return false;
            for (const enabledNamespace of debug_enabledNamespaces)if (enabledNamespace.test(namespace)) return true;
            return false;
        }
        function disable() {
            const result = enabledString || "";
            enable("");
            return result;
        }
        function createDebugger(namespace) {
            const newDebugger = Object.assign(debug, {
                enabled: enabled(namespace),
                destroy,
                log: debugObj.log,
                namespace,
                extend
            });
            function debug(...args) {
                if (!newDebugger.enabled) return;
                if (args.length > 0) args[0] = `${namespace} ${args[0]}`;
                newDebugger.log(...args);
            }
            debuggers.push(newDebugger);
            return newDebugger;
        }
        function destroy() {
            const index = debuggers.indexOf(this);
            if (index >= 0) {
                debuggers.splice(index, 1);
                return true;
            }
            return false;
        }
        function extend(namespace) {
            const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
            newDebugger.log = this.log;
            return newDebugger;
        }
        const esm_debug = debugObj;
        const registeredLoggers = new Set();
        const logLevelFromEnv = "u" > typeof process && process.env && process.env.AZURE_LOG_LEVEL || void 0;
        let azureLogLevel;
        const AzureLogger = esm_debug("azure");
        AzureLogger.log = (...args)=>{
            esm_debug.log(...args);
        };
        const AZURE_LOG_LEVELS = [
            "verbose",
            "info",
            "warning",
            "error"
        ];
        if (logLevelFromEnv) if (isAzureLogLevel(logLevelFromEnv)) setLogLevel(logLevelFromEnv);
        else console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
        function setLogLevel(level) {
            if (level && !isAzureLogLevel(level)) throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
            azureLogLevel = level;
            const enabledNamespaces = [];
            for (const logger of registeredLoggers)if (shouldEnable(logger)) enabledNamespaces.push(logger.namespace);
            esm_debug.enable(enabledNamespaces.join(","));
        }
        const levelMap = {
            verbose: 400,
            info: 300,
            warning: 200,
            error: 100
        };
        function createClientLogger(namespace) {
            const clientRootLogger = AzureLogger.extend(namespace);
            patchLogMethod(AzureLogger, clientRootLogger);
            return {
                error: createLogger(clientRootLogger, "error"),
                warning: createLogger(clientRootLogger, "warning"),
                info: createLogger(clientRootLogger, "info"),
                verbose: createLogger(clientRootLogger, "verbose")
            };
        }
        function patchLogMethod(parent, child) {
            child.log = (...args)=>{
                parent.log(...args);
            };
        }
        function createLogger(parent, level) {
            const logger = Object.assign(parent.extend(level), {
                level
            });
            patchLogMethod(parent, logger);
            if (shouldEnable(logger)) {
                const enabledNamespaces = esm_debug.disable();
                esm_debug.enable(enabledNamespaces + "," + logger.namespace);
            }
            registeredLoggers.add(logger);
            return logger;
        }
        function shouldEnable(logger) {
            return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);
        }
        function isAzureLogLevel(logLevel) {
            return AZURE_LOG_LEVELS.includes(logLevel);
        }
        const log_logger = createClientLogger("core-http");
        const createSpan = createSpanFunction({
            packagePrefix: "",
            namespace: ""
        });
        function tracingPolicy_tracingPolicy(tracingOptions = {}) {
            return {
                create (nextPolicy, options) {
                    return new TracingPolicy(nextPolicy, options, tracingOptions);
                }
            };
        }
        class TracingPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, tracingOptions){
                super(nextPolicy, options);
                this.userAgent = tracingOptions.userAgent;
            }
            async sendRequest(request) {
                if (!request.tracingContext) return this._nextPolicy.sendRequest(request);
                const span = this.tryCreateSpan(request);
                if (!span) return this._nextPolicy.sendRequest(request);
                try {
                    const response = await this._nextPolicy.sendRequest(request);
                    this.tryProcessResponse(span, response);
                    return response;
                } catch (err) {
                    this.tryProcessError(span, err);
                    throw err;
                }
            }
            tryCreateSpan(request) {
                var _a;
                try {
                    const { span } = createSpan(`HTTP ${request.method}`, {
                        tracingOptions: {
                            spanOptions: Object.assign(Object.assign({}, request.spanOptions), {
                                kind: interfaces_SpanKind.CLIENT
                            }),
                            tracingContext: request.tracingContext
                        }
                    });
                    if (!span.isRecording()) return void span.end();
                    const namespaceFromContext = null == (_a = request.tracingContext) ? void 0 : _a.getValue(Symbol.for("az.namespace"));
                    if ("string" == typeof namespaceFromContext) span.setAttribute("az.namespace", namespaceFromContext);
                    span.setAttributes({
                        "http.method": request.method,
                        "http.url": request.url,
                        requestId: request.requestId
                    });
                    if (this.userAgent) span.setAttribute("http.user_agent", this.userAgent);
                    const spanContext = span.spanContext();
                    const traceParentHeader = getTraceParentHeader(spanContext);
                    if (traceParentHeader && interfaces_isSpanContextValid(spanContext)) {
                        request.headers.set("traceparent", traceParentHeader);
                        const traceState = spanContext.traceState && spanContext.traceState.serialize();
                        if (traceState) request.headers.set("tracestate", traceState);
                    }
                    return span;
                } catch (error) {
                    log_logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);
                    return;
                }
            }
            tryProcessError(span, err) {
                try {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: err.message
                    });
                    if (err.statusCode) span.setAttribute("http.status_code", err.statusCode);
                    span.end();
                } catch (error) {
                    log_logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);
                }
            }
            tryProcessResponse(span, response) {
                try {
                    span.setAttribute("http.status_code", response.status);
                    const serviceRequestId = response.headers.get("x-ms-request-id");
                    if (serviceRequestId) span.setAttribute("serviceRequestId", serviceRequestId);
                    span.setStatus({
                        code: interfaces_SpanStatusCode.OK
                    });
                    span.end();
                } catch (error) {
                    log_logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);
                }
            }
        }
        const keepAlivePolicy_DefaultKeepAliveOptions = {
            enable: true
        };
        function keepAlivePolicy_keepAlivePolicy(keepAliveOptions) {
            return {
                create: (nextPolicy, options)=>new KeepAlivePolicy(nextPolicy, options, keepAliveOptions || keepAlivePolicy_DefaultKeepAliveOptions)
            };
        }
        class KeepAlivePolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, keepAliveOptions){
                super(nextPolicy, options);
                this.keepAliveOptions = keepAliveOptions;
            }
            async sendRequest(request) {
                request.keepAlive = this.keepAliveOptions.enable;
                return this._nextPolicy.sendRequest(request);
            }
        }
        function generateClientRequestIdPolicy_generateClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
            return {
                create: (nextPolicy, options)=>new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName)
            };
        }
        class GenerateClientRequestIdPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, _requestIdHeaderName){
                super(nextPolicy, options);
                this._requestIdHeaderName = _requestIdHeaderName;
            }
            sendRequest(request) {
                if (!request.headers.contains(this._requestIdHeaderName)) request.headers.set(this._requestIdHeaderName, request.requestId);
                return this._nextPolicy.sendRequest(request);
            }
        }
        function logPolicy_logPolicy(loggingOptions = {}) {
            return {
                create: (nextPolicy, options)=>new LogPolicy(nextPolicy, options, loggingOptions)
            };
        }
        class LogPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, { logger = log_logger.info, allowedHeaderNames = [], allowedQueryParameters = [] } = {}){
                super(nextPolicy, options);
                this.logger = logger;
                this.sanitizer = new Sanitizer({
                    allowedHeaderNames,
                    allowedQueryParameters
                });
            }
            get allowedHeaderNames() {
                return this.sanitizer.allowedHeaderNames;
            }
            set allowedHeaderNames(allowedHeaderNames) {
                this.sanitizer.allowedHeaderNames = allowedHeaderNames;
            }
            get allowedQueryParameters() {
                return this.sanitizer.allowedQueryParameters;
            }
            set allowedQueryParameters(allowedQueryParameters) {
                this.sanitizer.allowedQueryParameters = allowedQueryParameters;
            }
            sendRequest(request) {
                if (!this.logger.enabled) return this._nextPolicy.sendRequest(request);
                this.logRequest(request);
                return this._nextPolicy.sendRequest(request).then((response)=>this.logResponse(response));
            }
            logRequest(request) {
                this.logger(`Request: ${this.sanitizer.sanitize(request)}`);
            }
            logResponse(response) {
                this.logger(`Response status code: ${response.status}`);
                this.logger(`Headers: ${this.sanitizer.sanitize(response.headers)}`);
                return response;
            }
        }
        function disableResponseDecompressionPolicy_disableResponseDecompressionPolicy() {
            return {
                create: (nextPolicy, options)=>new DisableResponseDecompressionPolicy(nextPolicy, options)
            };
        }
        class DisableResponseDecompressionPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options){
                super(nextPolicy, options);
            }
            async sendRequest(request) {
                request.decompressResponse = false;
                return this._nextPolicy.sendRequest(request);
            }
        }
        const src_log_logger = createClientLogger("storage-blob");
        const SDK_VERSION = "12.17.0";
        const SERVICE_VERSION = "2023-11-03";
        const BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 268435456;
        const BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4194304000;
        const DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8388608;
        const DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4194304;
        const StorageOAuthScopes = "https://storage.azure.com/.default";
        const constants_URLConstants = {
            Parameters: {
                FORCE_BROWSER_NO_CACHE: "_",
                SIGNATURE: "sig",
                SNAPSHOT: "snapshot",
                VERSIONID: "versionid",
                TIMEOUT: "timeout"
            }
        };
        const HTTPURLConnection = {
            HTTP_ACCEPTED: 202,
            HTTP_CONFLICT: 409,
            HTTP_NOT_FOUND: 404,
            HTTP_PRECON_FAILED: 412,
            HTTP_RANGE_NOT_SATISFIABLE: 416
        };
        const constants_HeaderConstants = {
            AUTHORIZATION: "Authorization",
            AUTHORIZATION_SCHEME: "Bearer",
            CONTENT_ENCODING: "Content-Encoding",
            CONTENT_ID: "Content-ID",
            CONTENT_LANGUAGE: "Content-Language",
            CONTENT_LENGTH: "Content-Length",
            CONTENT_MD5: "Content-Md5",
            CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
            CONTENT_TYPE: "Content-Type",
            COOKIE: "Cookie",
            DATE: "date",
            IF_MATCH: "if-match",
            IF_MODIFIED_SINCE: "if-modified-since",
            IF_NONE_MATCH: "if-none-match",
            IF_UNMODIFIED_SINCE: "if-unmodified-since",
            PREFIX_FOR_STORAGE: "x-ms-",
            RANGE: "Range",
            USER_AGENT: "User-Agent",
            X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
            X_MS_COPY_SOURCE: "x-ms-copy-source",
            X_MS_DATE: "x-ms-date",
            X_MS_ERROR_CODE: "x-ms-error-code",
            X_MS_VERSION: "x-ms-version"
        };
        const SIZE_1_MB = 1048576;
        const BATCH_MAX_PAYLOAD_IN_BYTES = 4 * SIZE_1_MB;
        const HTTP_VERSION_1_1 = "HTTP/1.1";
        const DevelopmentConnectionString = "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;";
        const StorageBlobLoggingAllowedHeaderNames = [
            "Access-Control-Allow-Origin",
            "Cache-Control",
            "Content-Length",
            "Content-Type",
            "Date",
            "Request-Id",
            "traceparent",
            "Transfer-Encoding",
            "User-Agent",
            "x-ms-client-request-id",
            "x-ms-date",
            "x-ms-error-code",
            "x-ms-request-id",
            "x-ms-return-client-request-id",
            "x-ms-version",
            "Accept-Ranges",
            "Content-Disposition",
            "Content-Encoding",
            "Content-Language",
            "Content-MD5",
            "Content-Range",
            "ETag",
            "Last-Modified",
            "Server",
            "Vary",
            "x-ms-content-crc64",
            "x-ms-copy-action",
            "x-ms-copy-completion-time",
            "x-ms-copy-id",
            "x-ms-copy-progress",
            "x-ms-copy-status",
            "x-ms-has-immutability-policy",
            "x-ms-has-legal-hold",
            "x-ms-lease-state",
            "x-ms-lease-status",
            "x-ms-range",
            "x-ms-request-server-encrypted",
            "x-ms-server-encrypted",
            "x-ms-snapshot",
            "x-ms-source-range",
            "If-Match",
            "If-Modified-Since",
            "If-None-Match",
            "If-Unmodified-Since",
            "x-ms-access-tier",
            "x-ms-access-tier-change-time",
            "x-ms-access-tier-inferred",
            "x-ms-account-kind",
            "x-ms-archive-status",
            "x-ms-blob-append-offset",
            "x-ms-blob-cache-control",
            "x-ms-blob-committed-block-count",
            "x-ms-blob-condition-appendpos",
            "x-ms-blob-condition-maxsize",
            "x-ms-blob-content-disposition",
            "x-ms-blob-content-encoding",
            "x-ms-blob-content-language",
            "x-ms-blob-content-length",
            "x-ms-blob-content-md5",
            "x-ms-blob-content-type",
            "x-ms-blob-public-access",
            "x-ms-blob-sequence-number",
            "x-ms-blob-type",
            "x-ms-copy-destination-snapshot",
            "x-ms-creation-time",
            "x-ms-default-encryption-scope",
            "x-ms-delete-snapshots",
            "x-ms-delete-type-permanent",
            "x-ms-deny-encryption-scope-override",
            "x-ms-encryption-algorithm",
            "x-ms-if-sequence-number-eq",
            "x-ms-if-sequence-number-le",
            "x-ms-if-sequence-number-lt",
            "x-ms-incremental-copy",
            "x-ms-lease-action",
            "x-ms-lease-break-period",
            "x-ms-lease-duration",
            "x-ms-lease-id",
            "x-ms-lease-time",
            "x-ms-page-write",
            "x-ms-proposed-lease-id",
            "x-ms-range-get-content-md5",
            "x-ms-rehydrate-priority",
            "x-ms-sequence-number-action",
            "x-ms-sku-name",
            "x-ms-source-content-md5",
            "x-ms-source-if-match",
            "x-ms-source-if-modified-since",
            "x-ms-source-if-none-match",
            "x-ms-source-if-unmodified-since",
            "x-ms-tag-count",
            "x-ms-encryption-key-sha256",
            "x-ms-if-tags",
            "x-ms-source-if-tags"
        ];
        const StorageBlobLoggingAllowedQueryParameters = [
            "comp",
            "maxresults",
            "rscc",
            "rscd",
            "rsce",
            "rscl",
            "rsct",
            "se",
            "si",
            "sip",
            "sp",
            "spr",
            "sr",
            "srt",
            "ss",
            "st",
            "sv",
            "include",
            "marker",
            "prefix",
            "copyid",
            "restype",
            "blockid",
            "blocklisttype",
            "delimiter",
            "prevsnapshot",
            "ske",
            "skoid",
            "sks",
            "skt",
            "sktid",
            "skv",
            "snapshot"
        ];
        const BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
        const BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
        const PathStylePorts = [
            "10000",
            "10001",
            "10002",
            "10003",
            "10004",
            "10100",
            "10101",
            "10102",
            "10103",
            "10104",
            "11000",
            "11001",
            "11002",
            "11003",
            "11004",
            "11100",
            "11101",
            "11102",
            "11103",
            "11104"
        ];
        function escapeURLPath(url) {
            const urlParsed = URLBuilder.parse(url);
            let path = urlParsed.getPath();
            path = path || "/";
            path = utils_common_escape(path);
            urlParsed.setPath(path);
            return urlParsed.toString();
        }
        function getProxyUriFromDevConnString(connectionString) {
            let proxyUri = "";
            if (-1 !== connectionString.search("DevelopmentStorageProxyUri=")) {
                const matchCredentials = connectionString.split(";");
                for (const element of matchCredentials)if (element.trim().startsWith("DevelopmentStorageProxyUri=")) proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
            }
            return proxyUri;
        }
        function getValueInConnString(connectionString, argument) {
            const elements = connectionString.split(";");
            for (const element of elements)if (element.trim().startsWith(argument)) return element.trim().match(argument + "=(.*)")[1];
            return "";
        }
        function extractConnectionStringParts(connectionString) {
            let proxyUri = "";
            if (connectionString.startsWith("UseDevelopmentStorage=true")) {
                proxyUri = getProxyUriFromDevConnString(connectionString);
                connectionString = DevelopmentConnectionString;
            }
            let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
            blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
            if (-1 !== connectionString.search("DefaultEndpointsProtocol=") && -1 !== connectionString.search("AccountKey=")) {
                let defaultEndpointsProtocol = "";
                let accountName = "";
                let accountKey = Buffer.from("accountKey", "base64");
                let endpointSuffix = "";
                accountName = getValueInConnString(connectionString, "AccountName");
                accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
                if (!blobEndpoint) {
                    defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
                    const protocol = defaultEndpointsProtocol.toLowerCase();
                    if ("https" !== protocol && "http" !== protocol) throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
                    endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
                    if (!endpointSuffix) throw new Error("Invalid EndpointSuffix in the provided Connection String");
                    blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
                }
                if (accountName) {
                    if (0 === accountKey.length) throw new Error("Invalid AccountKey in the provided Connection String");
                } else throw new Error("Invalid AccountName in the provided Connection String");
                return {
                    kind: "AccountConnString",
                    url: blobEndpoint,
                    accountName,
                    accountKey,
                    proxyUri
                };
            }
            {
                const accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
                let accountName = getValueInConnString(connectionString, "AccountName");
                if (!accountName) accountName = getAccountNameFromUrl(blobEndpoint);
                if (blobEndpoint) {
                    if (!accountSas) throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
                } else throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
                return {
                    kind: "SASConnString",
                    url: blobEndpoint,
                    accountName,
                    accountSas
                };
            }
        }
        function utils_common_escape(text) {
            return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
        }
        function appendToURLPath(url, name) {
            const urlParsed = URLBuilder.parse(url);
            let path = urlParsed.getPath();
            path = path ? path.endsWith("/") ? `${path}${name}` : `${path}/${name}` : name;
            urlParsed.setPath(path);
            const normalizedUrl = new URL(urlParsed.toString());
            return normalizedUrl.toString();
        }
        function setURLParameter(url, name, value) {
            const urlParsed = URLBuilder.parse(url);
            urlParsed.setQueryParameter(name, value);
            return urlParsed.toString();
        }
        function getURLParameter(url, name) {
            const urlParsed = URLBuilder.parse(url);
            return urlParsed.getQueryParameterValue(name);
        }
        function setURLHost(url, host) {
            const urlParsed = URLBuilder.parse(url);
            urlParsed.setHost(host);
            return urlParsed.toString();
        }
        function getURLPath(url) {
            const urlParsed = URLBuilder.parse(url);
            return urlParsed.getPath();
        }
        function getURLScheme(url) {
            const urlParsed = URLBuilder.parse(url);
            return urlParsed.getScheme();
        }
        function getURLPathAndQuery(url) {
            const urlParsed = URLBuilder.parse(url);
            const pathString = urlParsed.getPath();
            if (!pathString) throw new RangeError("Invalid url without valid path.");
            let queryString = urlParsed.getQuery() || "";
            queryString = queryString.trim();
            if ("" !== queryString) queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
            return `${pathString}${queryString}`;
        }
        function getURLQueries(url) {
            let queryString = URLBuilder.parse(url).getQuery();
            if (!queryString) return {};
            queryString = queryString.trim();
            queryString = queryString.startsWith("?") ? queryString.substr(1) : queryString;
            let querySubStrings = queryString.split("&");
            querySubStrings = querySubStrings.filter((value)=>{
                const indexOfEqual = value.indexOf("=");
                const lastIndexOfEqual = value.lastIndexOf("=");
                return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
            });
            const queries = {};
            for (const querySubString of querySubStrings){
                const splitResults = querySubString.split("=");
                const key = splitResults[0];
                const value = splitResults[1];
                queries[key] = value;
            }
            return queries;
        }
        function appendToURLQuery(url, queryParts) {
            const urlParsed = URLBuilder.parse(url);
            let query = urlParsed.getQuery();
            if (query) query += "&" + queryParts;
            else query = queryParts;
            urlParsed.setQuery(query);
            return urlParsed.toString();
        }
        function truncatedISO8061Date(date, withMilliseconds = true) {
            const dateString = date.toISOString();
            return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
        }
        function base64encode(content) {
            return checkEnvironment_isNode ? Buffer.from(content).toString("base64") : btoa(content);
        }
        function generateBlockID(blockIDPrefix, blockIndex) {
            const maxSourceStringLength = 48;
            const maxBlockIndexLength = 6;
            const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
            if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
            const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
            return base64encode(res);
        }
        async function utils_common_delay(timeInMs, aborter, abortError) {
            return new Promise((resolve, reject)=>{
                let timeout;
                const abortHandler = ()=>{
                    if (void 0 !== timeout) clearTimeout(timeout);
                    reject(abortError);
                };
                const resolveHandler = ()=>{
                    if (void 0 !== aborter) aborter.removeEventListener("abort", abortHandler);
                    resolve();
                };
                timeout = setTimeout(resolveHandler, timeInMs);
                if (void 0 !== aborter) aborter.addEventListener("abort", abortHandler);
            });
        }
        function padStart(currentString, targetLength, padString = " ") {
            if (String.prototype.padStart) return currentString.padStart(targetLength, padString);
            padString = padString || " ";
            if (currentString.length > targetLength) return currentString;
            targetLength -= currentString.length;
            if (targetLength > padString.length) padString += padString.repeat(targetLength / padString.length);
            return padString.slice(0, targetLength) + currentString;
        }
        function iEqual(str1, str2) {
            return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
        }
        function getAccountNameFromUrl(url) {
            const parsedUrl = URLBuilder.parse(url);
            let accountName;
            try {
                accountName = "blob" === parsedUrl.getHost().split(".")[1] ? parsedUrl.getHost().split(".")[0] : isIpEndpointStyle(parsedUrl) ? parsedUrl.getPath().split("/")[1] : "";
                return accountName;
            } catch (error) {
                throw new Error("Unable to extract accountName with provided information.");
            }
        }
        function isIpEndpointStyle(parsedUrl) {
            if (void 0 === parsedUrl.getHost()) return false;
            const host = parsedUrl.getHost() + (void 0 === parsedUrl.getPort() ? "" : ":" + parsedUrl.getPort());
            return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || void 0 !== parsedUrl.getPort() && PathStylePorts.includes(parsedUrl.getPort());
        }
        function toBlobTagsString(tags) {
            if (void 0 === tags) return;
            const tagPairs = [];
            for(const key in tags)if (Object.prototype.hasOwnProperty.call(tags, key)) {
                const value = tags[key];
                tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
            }
            return tagPairs.join("&");
        }
        function toBlobTags(tags) {
            if (void 0 === tags) return;
            const res = {
                blobTagSet: []
            };
            for(const key in tags)if (Object.prototype.hasOwnProperty.call(tags, key)) {
                const value = tags[key];
                res.blobTagSet.push({
                    key,
                    value
                });
            }
            return res;
        }
        function toTags(tags) {
            if (void 0 === tags) return;
            const res = {};
            for (const blobTag of tags.blobTagSet)res[blobTag.key] = blobTag.value;
            return res;
        }
        function toQuerySerialization(textConfiguration) {
            if (void 0 === textConfiguration) return;
            switch(textConfiguration.kind){
                case "csv":
                    return {
                        format: {
                            type: "delimited",
                            delimitedTextConfiguration: {
                                columnSeparator: textConfiguration.columnSeparator || ",",
                                fieldQuote: textConfiguration.fieldQuote || "",
                                recordSeparator: textConfiguration.recordSeparator,
                                escapeChar: textConfiguration.escapeCharacter || "",
                                headersPresent: textConfiguration.hasHeaders || false
                            }
                        }
                    };
                case "json":
                    return {
                        format: {
                            type: "json",
                            jsonTextConfiguration: {
                                recordSeparator: textConfiguration.recordSeparator
                            }
                        }
                    };
                case "arrow":
                    return {
                        format: {
                            type: "arrow",
                            arrowConfiguration: {
                                schema: textConfiguration.schema
                            }
                        }
                    };
                case "parquet":
                    return {
                        format: {
                            type: "parquet"
                        }
                    };
                default:
                    throw Error("Invalid BlobQueryTextConfiguration.");
            }
        }
        function parseObjectReplicationRecord(objectReplicationRecord) {
            if (!objectReplicationRecord) return;
            if ("policy-id" in objectReplicationRecord) return;
            const orProperties = [];
            for(const key in objectReplicationRecord){
                const ids = key.split("_");
                const policyPrefix = "or-";
                if (ids[0].startsWith(policyPrefix)) ids[0] = ids[0].substring(policyPrefix.length);
                const rule = {
                    ruleId: ids[1],
                    replicationStatus: objectReplicationRecord[key]
                };
                const policyIndex = orProperties.findIndex((policy)=>policy.policyId === ids[0]);
                if (policyIndex > -1) orProperties[policyIndex].rules.push(rule);
                else orProperties.push({
                    policyId: ids[0],
                    rules: [
                        rule
                    ]
                });
            }
            return orProperties;
        }
        function attachCredential(thing, credential) {
            thing.credential = credential;
            return thing;
        }
        function httpAuthorizationToString(httpAuthorization) {
            return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : void 0;
        }
        function BlobNameToString(name) {
            if (name.encoded) return decodeURIComponent(name.content);
            return name.content;
        }
        function ConvertInternalResponseOfListBlobFlat(internalResponse) {
            return Object.assign(Object.assign({}, internalResponse), {
                segment: {
                    blobItems: internalResponse.segment.blobItems.map((blobItemInteral)=>{
                        const blobItem = Object.assign(Object.assign({}, blobItemInteral), {
                            name: BlobNameToString(blobItemInteral.name)
                        });
                        return blobItem;
                    })
                }
            });
        }
        function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
            var _a;
            return Object.assign(Object.assign({}, internalResponse), {
                segment: {
                    blobPrefixes: null == (_a = internalResponse.segment.blobPrefixes) ? void 0 : _a.map((blobPrefixInternal)=>{
                        const blobPrefix = Object.assign(Object.assign({}, blobPrefixInternal), {
                            name: BlobNameToString(blobPrefixInternal.name)
                        });
                        return blobPrefix;
                    }),
                    blobItems: internalResponse.segment.blobItems.map((blobItemInteral)=>{
                        const blobItem = Object.assign(Object.assign({}, blobItemInteral), {
                            name: BlobNameToString(blobItemInteral.name)
                        });
                        return blobItem;
                    })
                }
            });
        }
        function* ExtractPageRangeInfoItems(getPageRangesSegment) {
            let pageRange = [];
            let clearRange = [];
            if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;
            if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;
            let pageRangeIndex = 0;
            let clearRangeIndex = 0;
            while(pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length)if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {
                yield {
                    start: pageRange[pageRangeIndex].start,
                    end: pageRange[pageRangeIndex].end,
                    isClear: false
                };
                ++pageRangeIndex;
            } else {
                yield {
                    start: clearRange[clearRangeIndex].start,
                    end: clearRange[clearRangeIndex].end,
                    isClear: true
                };
                ++clearRangeIndex;
            }
            for(; pageRangeIndex < pageRange.length; ++pageRangeIndex)yield {
                start: pageRange[pageRangeIndex].start,
                end: pageRange[pageRangeIndex].end,
                isClear: false
            };
            for(; clearRangeIndex < clearRange.length; ++clearRangeIndex)yield {
                start: clearRange[clearRangeIndex].start,
                end: clearRange[clearRangeIndex].end,
                isClear: true
            };
        }
        function EscapePath(blobName) {
            const split = blobName.split("/");
            for(let i = 0; i < split.length; i++)split[i] = encodeURIComponent(split[i]);
            return split.join("/");
        }
        class StorageBrowserPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options){
                super(nextPolicy, options);
            }
            async sendRequest(request) {
                if (checkEnvironment_isNode) return this._nextPolicy.sendRequest(request);
                if ("GET" === request.method.toUpperCase() || "HEAD" === request.method.toUpperCase()) request.url = setURLParameter(request.url, constants_URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
                request.headers.remove(constants_HeaderConstants.COOKIE);
                request.headers.remove(constants_HeaderConstants.CONTENT_LENGTH);
                return this._nextPolicy.sendRequest(request);
            }
        }
        class StorageBrowserPolicyFactory {
            create(nextPolicy, options) {
                return new StorageBrowserPolicy(nextPolicy, options);
            }
        }
        var src_AbortController = __webpack_require__("../../../node_modules/.pnpm/@azure+abort-controller@1.1.0/node_modules/@azure/abort-controller/dist-esm/src/AbortController.js");
        var StorageRetryPolicy_StorageRetryPolicyType;
        (function(StorageRetryPolicyType) {
            StorageRetryPolicyType[StorageRetryPolicyType["EXPONENTIAL"] = 0] = "EXPONENTIAL";
            StorageRetryPolicyType[StorageRetryPolicyType["FIXED"] = 1] = "FIXED";
        })(StorageRetryPolicy_StorageRetryPolicyType || (StorageRetryPolicy_StorageRetryPolicyType = {}));
        const DEFAULT_RETRY_OPTIONS = {
            maxRetryDelayInMs: 120000,
            maxTries: 4,
            retryDelayInMs: 4000,
            retryPolicyType: StorageRetryPolicy_StorageRetryPolicyType.EXPONENTIAL,
            secondaryHost: "",
            tryTimeoutInMs: void 0
        };
        const RETRY_ABORT_ERROR = new src_AbortController.l("The operation was aborted.");
        class StorageRetryPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS){
                super(nextPolicy, options);
                this.retryOptions = {
                    retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
                    maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
                    tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
                    retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
                    maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
                    secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
                };
            }
            async sendRequest(request) {
                return this.attemptSendRequest(request, false, 1);
            }
            async attemptSendRequest(request, secondaryHas404, attempt) {
                const newRequest = request.clone();
                const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !("GET" === request.method || "HEAD" === request.method || "OPTIONS" === request.method) || attempt % 2 === 1;
                if (!isPrimaryRetry) newRequest.url = setURLHost(newRequest.url, this.retryOptions.secondaryHost);
                if (this.retryOptions.tryTimeoutInMs) newRequest.url = setURLParameter(newRequest.url, constants_URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
                let response;
                try {
                    src_log_logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
                    response = await this._nextPolicy.sendRequest(newRequest);
                    if (!this.shouldRetry(isPrimaryRetry, attempt, response)) return response;
                    secondaryHas404 = secondaryHas404 || !isPrimaryRetry && 404 === response.status;
                } catch (err) {
                    src_log_logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
                    if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) throw err;
                }
                await this.delay(isPrimaryRetry, attempt, request.abortSignal);
                return this.attemptSendRequest(request, secondaryHas404, ++attempt);
            }
            shouldRetry(isPrimaryRetry, attempt, response, err) {
                if (attempt >= this.retryOptions.maxTries) {
                    src_log_logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
                    return false;
                }
                const retriableErrors = [
                    "ETIMEDOUT",
                    "ESOCKETTIMEDOUT",
                    "ECONNREFUSED",
                    "ECONNRESET",
                    "ENOENT",
                    "ENOTFOUND",
                    "TIMEOUT",
                    "EPIPE",
                    "REQUEST_SEND_ERROR"
                ];
                if (err) {
                    for (const retriableError of retriableErrors)if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
                        src_log_logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
                        return true;
                    }
                }
                if (response || err) {
                    const statusCode = response ? response.status : err ? err.statusCode : 0;
                    if (!isPrimaryRetry && 404 === statusCode) {
                        src_log_logger.info("RetryPolicy: Secondary access with 404, will retry.");
                        return true;
                    }
                    if (503 === statusCode || 500 === statusCode) {
                        src_log_logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
                        return true;
                    }
                }
                if ((null == err ? void 0 : err.code) === "PARSE_ERROR" && (null == err ? void 0 : err.message.startsWith('Error "Error: Unclosed root tag'))) {
                    src_log_logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
                    return true;
                }
                return false;
            }
            async delay(isPrimaryRetry, attempt, abortSignal) {
                let delayTimeInMs = 0;
                if (isPrimaryRetry) switch(this.retryOptions.retryPolicyType){
                    case StorageRetryPolicy_StorageRetryPolicyType.EXPONENTIAL:
                        delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
                        break;
                    case StorageRetryPolicy_StorageRetryPolicyType.FIXED:
                        delayTimeInMs = this.retryOptions.retryDelayInMs;
                        break;
                }
                else delayTimeInMs = 1000 * Math.random();
                src_log_logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
                return utils_common_delay(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR);
            }
        }
        class StorageRetryPolicyFactory {
            constructor(retryOptions){
                this.retryOptions = retryOptions;
            }
            create(nextPolicy, options) {
                return new StorageRetryPolicy(nextPolicy, options, this.retryOptions);
            }
        }
        class CredentialPolicy extends BaseRequestPolicy {
            sendRequest(request) {
                return this._nextPolicy.sendRequest(this.signRequest(request));
            }
            signRequest(request) {
                return request;
            }
        }
        class AnonymousCredentialPolicy extends CredentialPolicy {
            constructor(nextPolicy, options){
                super(nextPolicy, options);
            }
        }
        class Credential {
            create(_nextPolicy, _options) {
                throw new Error("Method should be implemented in children classes.");
            }
        }
        class AnonymousCredential extends Credential {
            create(nextPolicy, options) {
                return new AnonymousCredentialPolicy(nextPolicy, options);
            }
        }
        var external_os_ = __webpack_require__("os");
        class TelemetryPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, telemetry){
                super(nextPolicy, options);
                this.telemetry = telemetry;
            }
            async sendRequest(request) {
                if (checkEnvironment_isNode) {
                    if (!request.headers) request.headers = new httpHeaders_HttpHeaders();
                    if (!request.headers.get(constants_HeaderConstants.USER_AGENT)) request.headers.set(constants_HeaderConstants.USER_AGENT, this.telemetry);
                }
                return this._nextPolicy.sendRequest(request);
            }
        }
        class TelemetryPolicyFactory {
            constructor(telemetry){
                const userAgentInfo = [];
                if (checkEnvironment_isNode) {
                    if (telemetry) {
                        const telemetryString = telemetry.userAgentPrefix || "";
                        if (telemetryString.length > 0 && -1 === userAgentInfo.indexOf(telemetryString)) userAgentInfo.push(telemetryString);
                    }
                    const libInfo = `azsdk-js-storageblob/${SDK_VERSION}`;
                    if (-1 === userAgentInfo.indexOf(libInfo)) userAgentInfo.push(libInfo);
                    let runtimeInfo = `(NODE-VERSION ${process.version})`;
                    if (external_os_) runtimeInfo = `(NODE-VERSION ${process.version}; ${external_os_.type()} ${external_os_.release()})`;
                    if (-1 === userAgentInfo.indexOf(runtimeInfo)) userAgentInfo.push(runtimeInfo);
                }
                this.telemetryString = userAgentInfo.join(" ");
            }
            create(nextPolicy, options) {
                return new TelemetryPolicy(nextPolicy, options, this.telemetryString);
            }
        }
        var external_http_ = __webpack_require__("http");
        var external_https_ = __webpack_require__("https");
        var node_modules_tunnel = __webpack_require__("../../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js");
        function createProxyAgent(requestUrl, proxySettings, headers) {
            const host = URLBuilder.parse(proxySettings.host).getHost();
            if (!host) throw new Error("Expecting a non-empty host in proxy settings.");
            if (!isValidPort(proxySettings.port)) throw new Error("Expecting a valid port number in the range of [0, 65535] in proxy settings.");
            const tunnelOptions = {
                proxy: {
                    host: host,
                    port: proxySettings.port,
                    headers: headers && headers.rawHeaders() || {}
                }
            };
            if (proxySettings.username && proxySettings.password) tunnelOptions.proxy.proxyAuth = `${proxySettings.username}:${proxySettings.password}`;
            else if (proxySettings.username) tunnelOptions.proxy.proxyAuth = `${proxySettings.username}`;
            const isRequestHttps = isUrlHttps(requestUrl);
            const isProxyHttps = isUrlHttps(proxySettings.host);
            const proxyAgent = {
                isHttps: isRequestHttps,
                agent: createTunnel(isRequestHttps, isProxyHttps, tunnelOptions)
            };
            return proxyAgent;
        }
        function isUrlHttps(url) {
            const urlScheme = URLBuilder.parse(url).getScheme() || "";
            return "https" === urlScheme.toLowerCase();
        }
        function createTunnel(isRequestHttps, isProxyHttps, tunnelOptions) {
            if (isRequestHttps && isProxyHttps) return node_modules_tunnel.httpsOverHttps(tunnelOptions);
            if (isRequestHttps && !isProxyHttps) return node_modules_tunnel.httpsOverHttp(tunnelOptions);
            if (!isRequestHttps && isProxyHttps) return node_modules_tunnel.httpOverHttps(tunnelOptions);
            return node_modules_tunnel.httpOverHttp(tunnelOptions);
        }
        function isValidPort(port) {
            return 0 <= port && port <= 65535;
        }
        var external_stream_ = __webpack_require__("stream");
        var form_data = __webpack_require__("../../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/form_data.js");
        var form_data_default = /*#__PURE__*/ __webpack_require__.n(form_data);
        var external_url_ = __webpack_require__("url");
        var public_api = __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js");
        var external_zlib_ = __webpack_require__("zlib");
        const Readable = external_stream_.Readable;
        const BUFFER = Symbol('buffer');
        const TYPE = Symbol('type');
        class lib_Blob {
            constructor(){
                this[TYPE] = '';
                const blobParts = arguments[0];
                const options = arguments[1];
                const buffers = [];
                if (blobParts) {
                    const a = blobParts;
                    const length = Number(a.length);
                    for(let i = 0; i < length; i++){
                        const element = a[i];
                        let buffer;
                        buffer = element instanceof Buffer ? element : ArrayBuffer.isView(element) ? Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? Buffer.from(element) : element instanceof lib_Blob ? element[BUFFER] : Buffer.from('string' == typeof element ? element : String(element));
                        buffer.length;
                        buffers.push(buffer);
                    }
                }
                this[BUFFER] = Buffer.concat(buffers);
                let type = options && void 0 !== options.type && String(options.type).toLowerCase();
                if (type && !/[^\u0020-\u007E]/.test(type)) this[TYPE] = type;
            }
            get size() {
                return this[BUFFER].length;
            }
            get type() {
                return this[TYPE];
            }
            text() {
                return Promise.resolve(this[BUFFER].toString());
            }
            arrayBuffer() {
                const buf = this[BUFFER];
                const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                return Promise.resolve(ab);
            }
            stream() {
                const readable = new Readable();
                readable._read = function() {};
                readable.push(this[BUFFER]);
                readable.push(null);
                return readable;
            }
            toString() {
                return '[object Blob]';
            }
            slice() {
                const size = this.size;
                const start = arguments[0];
                const end = arguments[1];
                let relativeStart, relativeEnd;
                relativeStart = void 0 === start ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
                relativeEnd = void 0 === end ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
                const span = Math.max(relativeEnd - relativeStart, 0);
                const buffer = this[BUFFER];
                const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
                const blob = new lib_Blob([], {
                    type: arguments[2]
                });
                blob[BUFFER] = slicedBuffer;
                return blob;
            }
        }
        Object.defineProperties(lib_Blob.prototype, {
            size: {
                enumerable: true
            },
            type: {
                enumerable: true
            },
            slice: {
                enumerable: true
            }
        });
        Object.defineProperty(lib_Blob.prototype, Symbol.toStringTag, {
            value: 'Blob',
            writable: false,
            enumerable: false,
            configurable: true
        });
        function FetchError(message, type, systemError) {
            Error.call(this, message);
            this.message = message;
            this.type = type;
            if (systemError) this.code = this.errno = systemError.code;
            Error.captureStackTrace(this, this.constructor);
        }
        FetchError.prototype = Object.create(Error.prototype);
        FetchError.prototype.constructor = FetchError;
        FetchError.prototype.name = 'FetchError';
        let convert;
        try {
            convert = require('encoding').convert;
        } catch (e) {}
        const INTERNALS = Symbol('Body internals');
        const PassThrough = external_stream_.PassThrough;
        function Body(body) {
            var _this = this;
            var _ref = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref$size = _ref.size;
            let size = void 0 === _ref$size ? 0 : _ref$size;
            var _ref$timeout = _ref.timeout;
            let timeout = void 0 === _ref$timeout ? 0 : _ref$timeout;
            if (null == body) body = null;
            else if (isURLSearchParams(body)) body = Buffer.from(body.toString());
            else if (isBlob(body)) ;
            else if (Buffer.isBuffer(body)) ;
            else if ('[object ArrayBuffer]' === Object.prototype.toString.call(body)) body = Buffer.from(body);
            else if (ArrayBuffer.isView(body)) body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
            else body instanceof external_stream_ || (body = Buffer.from(String(body)));
            this[INTERNALS] = {
                body,
                disturbed: false,
                error: null
            };
            this.size = size;
            this.timeout = timeout;
            if (body instanceof external_stream_) body.on('error', function(err) {
                const error = 'AbortError' === err.name ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
                _this[INTERNALS].error = error;
            });
        }
        Body.prototype = {
            get body () {
                return this[INTERNALS].body;
            },
            get bodyUsed () {
                return this[INTERNALS].disturbed;
            },
            arrayBuffer () {
                return consumeBody.call(this).then(function(buf) {
                    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                });
            },
            blob () {
                let ct = this.headers && this.headers.get('content-type') || '';
                return consumeBody.call(this).then(function(buf) {
                    return Object.assign(new lib_Blob([], {
                        type: ct.toLowerCase()
                    }), {
                        [BUFFER]: buf
                    });
                });
            },
            json () {
                var _this2 = this;
                return consumeBody.call(this).then(function(buffer) {
                    try {
                        return JSON.parse(buffer.toString());
                    } catch (err) {
                        return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
                    }
                });
            },
            text () {
                return consumeBody.call(this).then(function(buffer) {
                    return buffer.toString();
                });
            },
            buffer () {
                return consumeBody.call(this);
            },
            textConverted () {
                var _this3 = this;
                return consumeBody.call(this).then(function(buffer) {
                    return convertBody(buffer, _this3.headers);
                });
            }
        };
        Object.defineProperties(Body.prototype, {
            body: {
                enumerable: true
            },
            bodyUsed: {
                enumerable: true
            },
            arrayBuffer: {
                enumerable: true
            },
            blob: {
                enumerable: true
            },
            json: {
                enumerable: true
            },
            text: {
                enumerable: true
            }
        });
        Body.mixIn = function(proto) {
            for (const name of Object.getOwnPropertyNames(Body.prototype))if (!(name in proto)) {
                const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
                Object.defineProperty(proto, name, desc);
            }
        };
        function consumeBody() {
            var _this4 = this;
            if (this[INTERNALS].disturbed) return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
            this[INTERNALS].disturbed = true;
            if (this[INTERNALS].error) return Body.Promise.reject(this[INTERNALS].error);
            let body = this.body;
            if (null === body) return Body.Promise.resolve(Buffer.alloc(0));
            if (isBlob(body)) body = body.stream();
            if (Buffer.isBuffer(body)) return Body.Promise.resolve(body);
            if (!(body instanceof external_stream_)) return Body.Promise.resolve(Buffer.alloc(0));
            let accum = [];
            let accumBytes = 0;
            let abort = false;
            return new Body.Promise(function(resolve, reject) {
                let resTimeout;
                if (_this4.timeout) resTimeout = setTimeout(function() {
                    abort = true;
                    reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
                }, _this4.timeout);
                body.on('error', function(err) {
                    if ('AbortError' === err.name) {
                        abort = true;
                        reject(err);
                    } else reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
                });
                body.on('data', function(chunk) {
                    if (abort || null === chunk) return;
                    if (_this4.size && accumBytes + chunk.length > _this4.size) {
                        abort = true;
                        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
                        return;
                    }
                    accumBytes += chunk.length;
                    accum.push(chunk);
                });
                body.on('end', function() {
                    if (abort) return;
                    clearTimeout(resTimeout);
                    try {
                        resolve(Buffer.concat(accum, accumBytes));
                    } catch (err) {
                        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
                    }
                });
            });
        }
        function convertBody(buffer, headers) {
            if ('function' != typeof convert) throw new Error('The package `encoding` must be installed to use the textConverted() function');
            const ct = headers.get('content-type');
            let charset = 'utf-8';
            let res, str;
            if (ct) res = /charset=([^;]*)/i.exec(ct);
            str = buffer.slice(0, 1024).toString();
            if (!res && str) res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
            if (!res && str) {
                res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
                if (!res) {
                    res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
                    if (res) res.pop();
                }
                if (res) res = /charset=(.*)/i.exec(res.pop());
            }
            if (!res && str) res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
            if (res) {
                charset = res.pop();
                if ('gb2312' === charset || 'gbk' === charset) charset = 'gb18030';
            }
            return convert(buffer, 'UTF-8', charset).toString();
        }
        function isURLSearchParams(obj) {
            if ('object' != typeof obj || 'function' != typeof obj.append || 'function' != typeof obj.delete || 'function' != typeof obj.get || 'function' != typeof obj.getAll || 'function' != typeof obj.has || 'function' != typeof obj.set) return false;
            return 'URLSearchParams' === obj.constructor.name || '[object URLSearchParams]' === Object.prototype.toString.call(obj) || 'function' == typeof obj.sort;
        }
        function isBlob(obj) {
            return 'object' == typeof obj && 'function' == typeof obj.arrayBuffer && 'string' == typeof obj.type && 'function' == typeof obj.stream && 'function' == typeof obj.constructor && 'string' == typeof obj.constructor.name && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
        }
        function clone(instance) {
            let p1, p2;
            let body = instance.body;
            if (instance.bodyUsed) throw new Error('cannot clone body after it is used');
            if (body instanceof external_stream_ && 'function' != typeof body.getBoundary) {
                p1 = new PassThrough();
                p2 = new PassThrough();
                body.pipe(p1);
                body.pipe(p2);
                instance[INTERNALS].body = p1;
                body = p2;
            }
            return body;
        }
        function extractContentType(body) {
            if (null === body) return null;
            if ('string' == typeof body) return 'text/plain;charset=UTF-8';
            if (isURLSearchParams(body)) return 'application/x-www-form-urlencoded;charset=UTF-8';
            if (isBlob(body)) return body.type || null;
            if (Buffer.isBuffer(body)) return null;
            else if ('[object ArrayBuffer]' === Object.prototype.toString.call(body)) return null;
            else if (ArrayBuffer.isView(body)) return null;
            else if ('function' == typeof body.getBoundary) return `multipart/form-data;boundary=${body.getBoundary()}`;
            else if (body instanceof external_stream_) return null;
            else return 'text/plain;charset=UTF-8';
        }
        function getTotalBytes(instance) {
            const body = instance.body;
            if (null === body) return 0;
            if (isBlob(body)) return body.size;
            if (Buffer.isBuffer(body)) return body.length;
            if (!body || 'function' != typeof body.getLengthSync) return null;
            if (body._lengthRetrievers && 0 == body._lengthRetrievers.length || body.hasKnownLength && body.hasKnownLength()) return body.getLengthSync();
            return null;
        }
        function writeToStream(dest, instance) {
            const body = instance.body;
            if (null === body) dest.end();
            else if (isBlob(body)) body.stream().pipe(dest);
            else if (Buffer.isBuffer(body)) {
                dest.write(body);
                dest.end();
            } else body.pipe(dest);
        }
        Body.Promise = global.Promise;
        const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
        const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
        function validateName(name) {
            name = `${name}`;
            if (invalidTokenRegex.test(name) || '' === name) throw new TypeError(`${name} is not a legal HTTP header name`);
        }
        function validateValue(value) {
            value = `${value}`;
            if (invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);
        }
        function find(map, name) {
            name = name.toLowerCase();
            for(const key in map)if (key.toLowerCase() === name) return key;
        }
        const MAP = Symbol('map');
        class Headers {
            constructor(){
                let init = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
                this[MAP] = Object.create(null);
                if (init instanceof Headers) {
                    const rawHeaders = init.raw();
                    const headerNames = Object.keys(rawHeaders);
                    for (const headerName of headerNames)for (const value of rawHeaders[headerName])this.append(headerName, value);
                    return;
                }
                if (null == init) ;
                else if ('object' == typeof init) {
                    const method = init[Symbol.iterator];
                    if (null != method) {
                        if ('function' != typeof method) throw new TypeError('Header pairs must be iterable');
                        const pairs = [];
                        for (const pair of init){
                            if ('object' != typeof pair || 'function' != typeof pair[Symbol.iterator]) throw new TypeError('Each header pair must be iterable');
                            pairs.push(Array.from(pair));
                        }
                        for (const pair of pairs){
                            if (2 !== pair.length) throw new TypeError('Each header pair must be a name/value tuple');
                            this.append(pair[0], pair[1]);
                        }
                    } else for (const key of Object.keys(init)){
                        const value = init[key];
                        this.append(key, value);
                    }
                } else throw new TypeError('Provided initializer must be an object');
            }
            get(name) {
                name = `${name}`;
                validateName(name);
                const key = find(this[MAP], name);
                if (void 0 === key) return null;
                return this[MAP][key].join(', ');
            }
            forEach(callback) {
                let thisArg = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
                let pairs = getHeaders(this);
                let i = 0;
                while(i < pairs.length){
                    var _pairs$i = pairs[i];
                    const name = _pairs$i[0], value = _pairs$i[1];
                    callback.call(thisArg, value, name, this);
                    pairs = getHeaders(this);
                    i++;
                }
            }
            set(name, value) {
                name = `${name}`;
                value = `${value}`;
                validateName(name);
                validateValue(value);
                const key = find(this[MAP], name);
                this[MAP][void 0 !== key ? key : name] = [
                    value
                ];
            }
            append(name, value) {
                name = `${name}`;
                value = `${value}`;
                validateName(name);
                validateValue(value);
                const key = find(this[MAP], name);
                if (void 0 !== key) this[MAP][key].push(value);
                else this[MAP][name] = [
                    value
                ];
            }
            has(name) {
                name = `${name}`;
                validateName(name);
                return void 0 !== find(this[MAP], name);
            }
            delete(name) {
                name = `${name}`;
                validateName(name);
                const key = find(this[MAP], name);
                if (void 0 !== key) delete this[MAP][key];
            }
            raw() {
                return this[MAP];
            }
            keys() {
                return createHeadersIterator(this, 'key');
            }
            values() {
                return createHeadersIterator(this, 'value');
            }
            [Symbol.iterator]() {
                return createHeadersIterator(this, 'key+value');
            }
        }
        Headers.prototype.entries = Headers.prototype[Symbol.iterator];
        Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
            value: 'Headers',
            writable: false,
            enumerable: false,
            configurable: true
        });
        Object.defineProperties(Headers.prototype, {
            get: {
                enumerable: true
            },
            forEach: {
                enumerable: true
            },
            set: {
                enumerable: true
            },
            append: {
                enumerable: true
            },
            has: {
                enumerable: true
            },
            delete: {
                enumerable: true
            },
            keys: {
                enumerable: true
            },
            values: {
                enumerable: true
            },
            entries: {
                enumerable: true
            }
        });
        function getHeaders(headers) {
            let kind = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'key+value';
            const keys = Object.keys(headers[MAP]).sort();
            return keys.map('key' === kind ? function(k) {
                return k.toLowerCase();
            } : 'value' === kind ? function(k) {
                return headers[MAP][k].join(', ');
            } : function(k) {
                return [
                    k.toLowerCase(),
                    headers[MAP][k].join(', ')
                ];
            });
        }
        const INTERNAL = Symbol('internal');
        function createHeadersIterator(target, kind) {
            const iterator = Object.create(HeadersIteratorPrototype);
            iterator[INTERNAL] = {
                target,
                kind,
                index: 0
            };
            return iterator;
        }
        const HeadersIteratorPrototype = Object.setPrototypeOf({
            next () {
                if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) throw new TypeError('Value of `this` is not a HeadersIterator');
                var _INTERNAL = this[INTERNAL];
                const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
                const values = getHeaders(target, kind);
                const len = values.length;
                if (index >= len) return {
                    value: void 0,
                    done: true
                };
                this[INTERNAL].index = index + 1;
                return {
                    value: values[index],
                    done: false
                };
            }
        }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
        Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
            value: 'HeadersIterator',
            writable: false,
            enumerable: false,
            configurable: true
        });
        function exportNodeCompatibleHeaders(headers) {
            const obj = Object.assign({
                __proto__: null
            }, headers[MAP]);
            const hostHeaderKey = find(headers[MAP], 'Host');
            if (void 0 !== hostHeaderKey) obj[hostHeaderKey] = obj[hostHeaderKey][0];
            return obj;
        }
        function createHeadersLenient(obj) {
            const headers = new Headers();
            for (const name of Object.keys(obj))if (!invalidTokenRegex.test(name)) {
                if (Array.isArray(obj[name])) {
                    for (const val of obj[name])if (!invalidHeaderCharRegex.test(val)) if (void 0 === headers[MAP][name]) headers[MAP][name] = [
                        val
                    ];
                    else headers[MAP][name].push(val);
                } else if (!invalidHeaderCharRegex.test(obj[name])) headers[MAP][name] = [
                    obj[name]
                ];
            }
            return headers;
        }
        const INTERNALS$1 = Symbol('Response internals');
        const STATUS_CODES = external_http_.STATUS_CODES;
        class Response {
            constructor(){
                let body = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                let opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                Body.call(this, body, opts);
                const status = opts.status || 200;
                const headers = new Headers(opts.headers);
                if (null != body && !headers.has('Content-Type')) {
                    const contentType = extractContentType(body);
                    if (contentType) headers.append('Content-Type', contentType);
                }
                this[INTERNALS$1] = {
                    url: opts.url,
                    status,
                    statusText: opts.statusText || STATUS_CODES[status],
                    headers,
                    counter: opts.counter
                };
            }
            get url() {
                return this[INTERNALS$1].url || '';
            }
            get status() {
                return this[INTERNALS$1].status;
            }
            get ok() {
                return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
            }
            get redirected() {
                return this[INTERNALS$1].counter > 0;
            }
            get statusText() {
                return this[INTERNALS$1].statusText;
            }
            get headers() {
                return this[INTERNALS$1].headers;
            }
            clone() {
                return new Response(clone(this), {
                    url: this.url,
                    status: this.status,
                    statusText: this.statusText,
                    headers: this.headers,
                    ok: this.ok,
                    redirected: this.redirected
                });
            }
        }
        Body.mixIn(Response.prototype);
        Object.defineProperties(Response.prototype, {
            url: {
                enumerable: true
            },
            status: {
                enumerable: true
            },
            ok: {
                enumerable: true
            },
            redirected: {
                enumerable: true
            },
            statusText: {
                enumerable: true
            },
            headers: {
                enumerable: true
            },
            clone: {
                enumerable: true
            }
        });
        Object.defineProperty(Response.prototype, Symbol.toStringTag, {
            value: 'Response',
            writable: false,
            enumerable: false,
            configurable: true
        });
        const INTERNALS$2 = Symbol('Request internals');
        const lib_URL = external_url_.URL || public_api.URL;
        const parse_url = external_url_.parse;
        const format_url = external_url_.format;
        function parseURL(urlStr) {
            if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) urlStr = new lib_URL(urlStr).toString();
            return parse_url(urlStr);
        }
        const streamDestructionSupported = "destroy" in external_stream_.Readable.prototype;
        function isRequest(input) {
            return 'object' == typeof input && 'object' == typeof input[INTERNALS$2];
        }
        function isAbortSignal(signal) {
            const proto = signal && 'object' == typeof signal && Object.getPrototypeOf(signal);
            return !!(proto && 'AbortSignal' === proto.constructor.name);
        }
        class Request {
            constructor(input){
                let init = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                let parsedURL;
                if (isRequest(input)) parsedURL = parseURL(input.url);
                else {
                    parsedURL = input && input.href ? parseURL(input.href) : parseURL(`${input}`);
                    input = {};
                }
                let method = init.method || input.method || 'GET';
                method = method.toUpperCase();
                if ((null != init.body || isRequest(input) && null !== input.body) && ('GET' === method || 'HEAD' === method)) throw new TypeError('Request with GET/HEAD method cannot have body');
                let inputBody = null != init.body ? init.body : isRequest(input) && null !== input.body ? clone(input) : null;
                Body.call(this, inputBody, {
                    timeout: init.timeout || input.timeout || 0,
                    size: init.size || input.size || 0
                });
                const headers = new Headers(init.headers || input.headers || {});
                if (null != inputBody && !headers.has('Content-Type')) {
                    const contentType = extractContentType(inputBody);
                    if (contentType) headers.append('Content-Type', contentType);
                }
                let signal = isRequest(input) ? input.signal : null;
                if ('signal' in init) signal = init.signal;
                if (null != signal && !isAbortSignal(signal)) throw new TypeError('Expected signal to be an instanceof AbortSignal');
                this[INTERNALS$2] = {
                    method,
                    redirect: init.redirect || input.redirect || 'follow',
                    headers,
                    parsedURL,
                    signal
                };
                this.follow = void 0 !== init.follow ? init.follow : void 0 !== input.follow ? input.follow : 20;
                this.compress = void 0 !== init.compress ? init.compress : void 0 !== input.compress ? input.compress : true;
                this.counter = init.counter || input.counter || 0;
                this.agent = init.agent || input.agent;
            }
            get method() {
                return this[INTERNALS$2].method;
            }
            get url() {
                return format_url(this[INTERNALS$2].parsedURL);
            }
            get headers() {
                return this[INTERNALS$2].headers;
            }
            get redirect() {
                return this[INTERNALS$2].redirect;
            }
            get signal() {
                return this[INTERNALS$2].signal;
            }
            clone() {
                return new Request(this);
            }
        }
        Body.mixIn(Request.prototype);
        Object.defineProperty(Request.prototype, Symbol.toStringTag, {
            value: 'Request',
            writable: false,
            enumerable: false,
            configurable: true
        });
        Object.defineProperties(Request.prototype, {
            method: {
                enumerable: true
            },
            url: {
                enumerable: true
            },
            headers: {
                enumerable: true
            },
            redirect: {
                enumerable: true
            },
            clone: {
                enumerable: true
            },
            signal: {
                enumerable: true
            }
        });
        function getNodeRequestOptions(request) {
            const parsedURL = request[INTERNALS$2].parsedURL;
            const headers = new Headers(request[INTERNALS$2].headers);
            if (!headers.has('Accept')) headers.set('Accept', '*/*');
            if (!parsedURL.protocol || !parsedURL.hostname) throw new TypeError('Only absolute URLs are supported');
            if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError('Only HTTP(S) protocols are supported');
            if (request.signal && request.body instanceof external_stream_.Readable && !streamDestructionSupported) throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
            let contentLengthValue = null;
            if (null == request.body && /^(POST|PUT)$/i.test(request.method)) contentLengthValue = '0';
            if (null != request.body) {
                const totalBytes = getTotalBytes(request);
                if ('number' == typeof totalBytes) contentLengthValue = String(totalBytes);
            }
            if (contentLengthValue) headers.set('Content-Length', contentLengthValue);
            if (!headers.has('User-Agent')) headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
            if (request.compress && !headers.has('Accept-Encoding')) headers.set('Accept-Encoding', 'gzip,deflate');
            let agent = request.agent;
            if ('function' == typeof agent) agent = agent(parsedURL);
            return Object.assign({}, parsedURL, {
                method: request.method,
                headers: exportNodeCompatibleHeaders(headers),
                agent
            });
        }
        function lib_AbortError(message) {
            Error.call(this, message);
            this.type = 'aborted';
            this.message = message;
            Error.captureStackTrace(this, this.constructor);
        }
        lib_AbortError.prototype = Object.create(Error.prototype);
        lib_AbortError.prototype.constructor = lib_AbortError;
        lib_AbortError.prototype.name = 'AbortError';
        const URL$1 = external_url_.URL || public_api.URL;
        const PassThrough$1 = external_stream_.PassThrough;
        const lib_isDomainOrSubdomain = function(destination, original) {
            const orig = new URL$1(original).hostname;
            const dest = new URL$1(destination).hostname;
            return orig === dest || '.' === orig[orig.length - dest.length - 1] && orig.endsWith(dest);
        };
        const lib_isSameProtocol = function(destination, original) {
            const orig = new URL$1(original).protocol;
            const dest = new URL$1(destination).protocol;
            return orig === dest;
        };
        function fetch(url, opts) {
            if (!fetch.Promise) throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
            Body.Promise = fetch.Promise;
            return new fetch.Promise(function(resolve, reject) {
                const request = new Request(url, opts);
                const options = getNodeRequestOptions(request);
                const send = ('https:' === options.protocol ? external_https_ : external_http_).request;
                const signal = request.signal;
                let response = null;
                const abort = function() {
                    let error = new lib_AbortError('The user aborted a request.');
                    reject(error);
                    if (request.body && request.body instanceof external_stream_.Readable) destroyStream(request.body, error);
                    if (!response || !response.body) return;
                    response.body.emit('error', error);
                };
                if (signal && signal.aborted) return void abort();
                const abortAndFinalize = function() {
                    abort();
                    finalize();
                };
                const req = send(options);
                let reqTimeout;
                if (signal) signal.addEventListener('abort', abortAndFinalize);
                function finalize() {
                    req.abort();
                    if (signal) signal.removeEventListener('abort', abortAndFinalize);
                    clearTimeout(reqTimeout);
                }
                if (request.timeout) req.once('socket', function(socket) {
                    reqTimeout = setTimeout(function() {
                        reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
                        finalize();
                    }, request.timeout);
                });
                req.on('error', function(err) {
                    reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
                    if (response && response.body) destroyStream(response.body, err);
                    finalize();
                });
                fixResponseChunkedTransferBadEnding(req, function(err) {
                    if (signal && signal.aborted) return;
                    if (response && response.body) destroyStream(response.body, err);
                });
                if (parseInt(process.version.substring(1)) < 14) req.on('socket', function(s) {
                    s.addListener('close', function(hadError) {
                        const hasDataListener = s.listenerCount('data') > 0;
                        if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                            const err = new Error('Premature close');
                            err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                            response.body.emit('error', err);
                        }
                    });
                });
                req.on('response', function(res) {
                    clearTimeout(reqTimeout);
                    const headers = createHeadersLenient(res.headers);
                    if (fetch.isRedirect(res.statusCode)) {
                        const location = headers.get('Location');
                        let locationURL = null;
                        try {
                            locationURL = null === location ? null : new URL$1(location, request.url).toString();
                        } catch (err) {
                            if ('manual' !== request.redirect) {
                                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                                finalize();
                                return;
                            }
                        }
                        switch(request.redirect){
                            case 'error':
                                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                                finalize();
                                return;
                            case 'manual':
                                if (null !== locationURL) try {
                                    headers.set('Location', locationURL);
                                } catch (err) {
                                    reject(err);
                                }
                                break;
                            case 'follow':
                                if (null === locationURL) break;
                                if (request.counter >= request.follow) {
                                    reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                                    finalize();
                                    return;
                                }
                                const requestOpts = {
                                    headers: new Headers(request.headers),
                                    follow: request.follow,
                                    counter: request.counter + 1,
                                    agent: request.agent,
                                    compress: request.compress,
                                    method: request.method,
                                    body: request.body,
                                    signal: request.signal,
                                    timeout: request.timeout,
                                    size: request.size
                                };
                                if (!lib_isDomainOrSubdomain(request.url, locationURL) || !lib_isSameProtocol(request.url, locationURL)) for (const name of [
                                    'authorization',
                                    'www-authenticate',
                                    'cookie',
                                    'cookie2'
                                ])requestOpts.headers.delete(name);
                                if (303 !== res.statusCode && request.body && null === getTotalBytes(request)) {
                                    reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                                    finalize();
                                    return;
                                }
                                if (303 === res.statusCode || (301 === res.statusCode || 302 === res.statusCode) && 'POST' === request.method) {
                                    requestOpts.method = 'GET';
                                    requestOpts.body = void 0;
                                    requestOpts.headers.delete('content-length');
                                }
                                resolve(fetch(new Request(locationURL, requestOpts)));
                                finalize();
                                return;
                        }
                    }
                    res.once('end', function() {
                        if (signal) signal.removeEventListener('abort', abortAndFinalize);
                    });
                    let body = res.pipe(new PassThrough$1());
                    const response_options = {
                        url: request.url,
                        status: res.statusCode,
                        statusText: res.statusMessage,
                        headers: headers,
                        size: request.size,
                        timeout: request.timeout,
                        counter: request.counter
                    };
                    const codings = headers.get('Content-Encoding');
                    if (!request.compress || 'HEAD' === request.method || null === codings || 204 === res.statusCode || 304 === res.statusCode) {
                        response = new Response(body, response_options);
                        resolve(response);
                        return;
                    }
                    const zlibOptions = {
                        flush: external_zlib_.Z_SYNC_FLUSH,
                        finishFlush: external_zlib_.Z_SYNC_FLUSH
                    };
                    if ('gzip' == codings || 'x-gzip' == codings) {
                        body = body.pipe(external_zlib_.createGunzip(zlibOptions));
                        response = new Response(body, response_options);
                        resolve(response);
                        return;
                    }
                    if ('deflate' == codings || 'x-deflate' == codings) {
                        const raw = res.pipe(new PassThrough$1());
                        raw.once('data', function(chunk) {
                            body = (0x0F & chunk[0]) === 0x08 ? body.pipe(external_zlib_.createInflate()) : body.pipe(external_zlib_.createInflateRaw());
                            response = new Response(body, response_options);
                            resolve(response);
                        });
                        raw.on('end', function() {
                            if (!response) {
                                response = new Response(body, response_options);
                                resolve(response);
                            }
                        });
                        return;
                    }
                    if ('br' == codings && 'function' == typeof external_zlib_.createBrotliDecompress) {
                        body = body.pipe(external_zlib_.createBrotliDecompress());
                        response = new Response(body, response_options);
                        resolve(response);
                        return;
                    }
                    response = new Response(body, response_options);
                    resolve(response);
                });
                writeToStream(req, request);
            });
        }
        function fixResponseChunkedTransferBadEnding(request, errorCallback) {
            let socket;
            request.on('socket', function(s) {
                socket = s;
            });
            request.on('response', function(response) {
                const headers = response.headers;
                if ('chunked' === headers['transfer-encoding'] && !headers['content-length']) response.once('close', function(hadError) {
                    const hasDataListener = socket && socket.listenerCount('data') > 0;
                    if (hasDataListener && !hadError) {
                        const err = new Error('Premature close');
                        err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                        errorCallback(err);
                    }
                });
            });
        }
        function destroyStream(stream, err) {
            if (stream.destroy) stream.destroy(err);
            else {
                stream.emit('error', err);
                stream.end();
            }
        }
        fetch.isRedirect = function(code) {
            return 301 === code || 302 === code || 303 === code || 307 === code || 308 === code;
        };
        fetch.Promise = global.Promise;
        const lib = fetch;
        function getCachedAgent(isHttps, agentCache) {
            return isHttps ? agentCache.httpsAgent : agentCache.httpAgent;
        }
        class ReportTransform extends external_stream_.Transform {
            constructor(progressCallback){
                super();
                this.progressCallback = progressCallback;
                this.loadedBytes = 0;
            }
            _transform(chunk, _encoding, callback) {
                this.push(chunk);
                this.loadedBytes += chunk.length;
                this.progressCallback({
                    loadedBytes: this.loadedBytes
                });
                callback(void 0);
            }
        }
        function isReadableStream(body) {
            return body && "function" == typeof body.pipe;
        }
        function isStreamComplete(stream, aborter) {
            return new Promise((resolve)=>{
                stream.once("close", ()=>{
                    null == aborter || aborter.abort();
                    resolve();
                });
                stream.once("end", resolve);
                stream.once("error", resolve);
            });
        }
        function parseHeaders(headers) {
            const httpHeaders = new httpHeaders_HttpHeaders();
            headers.forEach((value, key)=>{
                httpHeaders.set(key, value);
            });
            return httpHeaders;
        }
        class NodeFetchHttpClient {
            constructor(){
                this.proxyAgentMap = new Map();
                this.keepAliveAgents = {};
            }
            async sendRequest(httpRequest) {
                var _a;
                if (!httpRequest && "object" != typeof httpRequest) throw new Error("'httpRequest' (WebResourceLike) cannot be null or undefined and must be of type object.");
                const abortController = new src_AbortController.z();
                let abortListener;
                if (httpRequest.abortSignal) {
                    if (httpRequest.abortSignal.aborted) throw new src_AbortController.l("The operation was aborted.");
                    abortListener = (event)=>{
                        if ("abort" === event.type) abortController.abort();
                    };
                    httpRequest.abortSignal.addEventListener("abort", abortListener);
                }
                if (httpRequest.timeout) setTimeout(()=>{
                    abortController.abort();
                }, httpRequest.timeout);
                if (httpRequest.formData) {
                    const formData = httpRequest.formData;
                    const requestForm = new (form_data_default())();
                    const appendFormValue = (key, value)=>{
                        if ("function" == typeof value) value = value();
                        if (value && Object.prototype.hasOwnProperty.call(value, "value") && Object.prototype.hasOwnProperty.call(value, "options")) requestForm.append(key, value.value, value.options);
                        else requestForm.append(key, value);
                    };
                    for (const formKey of Object.keys(formData)){
                        const formValue = formData[formKey];
                        if (Array.isArray(formValue)) for(let j = 0; j < formValue.length; j++)appendFormValue(formKey, formValue[j]);
                        else appendFormValue(formKey, formValue);
                    }
                    httpRequest.body = requestForm;
                    httpRequest.formData = void 0;
                    const contentType = httpRequest.headers.get("Content-Type");
                    if (contentType && -1 !== contentType.indexOf("multipart/form-data")) if ("function" == typeof requestForm.getBoundary) httpRequest.headers.set("Content-Type", `multipart/form-data; boundary=${requestForm.getBoundary()}`);
                    else httpRequest.headers.remove("Content-Type");
                }
                let body = httpRequest.body ? "function" == typeof httpRequest.body ? httpRequest.body() : httpRequest.body : void 0;
                if (httpRequest.onUploadProgress && httpRequest.body) {
                    const onUploadProgress = httpRequest.onUploadProgress;
                    const uploadReportStream = new ReportTransform(onUploadProgress);
                    if (isReadableStream(body)) body.pipe(uploadReportStream);
                    else uploadReportStream.end(body);
                    body = uploadReportStream;
                }
                const platformSpecificRequestInit = await this.prepareRequest(httpRequest);
                const requestInit = Object.assign({
                    body: body,
                    headers: httpRequest.headers.rawHeaders(),
                    method: httpRequest.method,
                    signal: abortController.signal,
                    redirect: "manual"
                }, platformSpecificRequestInit);
                let operationResponse;
                try {
                    const response = await this.fetch(httpRequest.url, requestInit);
                    const headers = parseHeaders(response.headers);
                    const streaming = (null == (_a = httpRequest.streamResponseStatusCodes) ? void 0 : _a.has(response.status)) || httpRequest.streamResponseBody;
                    operationResponse = {
                        headers: headers,
                        request: httpRequest,
                        status: response.status,
                        readableStreamBody: streaming ? response.body : void 0,
                        bodyAsText: streaming ? void 0 : await response.text()
                    };
                    const onDownloadProgress = httpRequest.onDownloadProgress;
                    if (onDownloadProgress) {
                        const responseBody = response.body || void 0;
                        if (isReadableStream(responseBody)) {
                            const downloadReportStream = new ReportTransform(onDownloadProgress);
                            responseBody.pipe(downloadReportStream);
                            operationResponse.readableStreamBody = downloadReportStream;
                        } else {
                            const length = parseInt(headers.get("Content-Length")) || void 0;
                            if (length) onDownloadProgress({
                                loadedBytes: length
                            });
                        }
                    }
                    await this.processRequest(operationResponse);
                    return operationResponse;
                } catch (error) {
                    const fetchError = error;
                    if ("ENOTFOUND" === fetchError.code) throw new RestError(fetchError.message, RestError.REQUEST_SEND_ERROR, void 0, httpRequest);
                    if ("aborted" === fetchError.type) throw new src_AbortController.l("The operation was aborted.");
                    throw fetchError;
                } finally{
                    if (httpRequest.abortSignal && abortListener) {
                        let uploadStreamDone = Promise.resolve();
                        if (isReadableStream(body)) uploadStreamDone = isStreamComplete(body);
                        let downloadStreamDone = Promise.resolve();
                        if (isReadableStream(null == operationResponse ? void 0 : operationResponse.readableStreamBody)) downloadStreamDone = isStreamComplete(operationResponse.readableStreamBody, abortController);
                        Promise.all([
                            uploadStreamDone,
                            downloadStreamDone
                        ]).then(()=>{
                            var _a;
                            null == (_a = httpRequest.abortSignal) || _a.removeEventListener("abort", abortListener);
                        }).catch((e)=>{
                            log_logger.warning("Error when cleaning up abortListener on httpRequest", e);
                        });
                    }
                }
            }
            getOrCreateAgent(httpRequest) {
                var _a;
                const isHttps = isUrlHttps(httpRequest.url);
                if (httpRequest.proxySettings) {
                    const { host, port, username, password } = httpRequest.proxySettings;
                    const key = `${host}:${port}:${username}:${password}`;
                    const proxyAgents = null != (_a = this.proxyAgentMap.get(key)) ? _a : {};
                    let agent = getCachedAgent(isHttps, proxyAgents);
                    if (agent) return agent;
                    const tunnel = createProxyAgent(httpRequest.url, httpRequest.proxySettings, httpRequest.headers);
                    agent = tunnel.agent;
                    if (tunnel.isHttps) proxyAgents.httpsAgent = tunnel.agent;
                    else proxyAgents.httpAgent = tunnel.agent;
                    this.proxyAgentMap.set(key, proxyAgents);
                    return agent;
                }
                if (!httpRequest.keepAlive) return isHttps ? external_https_.globalAgent : external_http_.globalAgent;
                {
                    let agent = getCachedAgent(isHttps, this.keepAliveAgents);
                    if (agent) return agent;
                    const agentOptions = {
                        keepAlive: httpRequest.keepAlive
                    };
                    agent = isHttps ? this.keepAliveAgents.httpsAgent = new external_https_.Agent(agentOptions) : this.keepAliveAgents.httpAgent = new external_http_.Agent(agentOptions);
                    return agent;
                }
            }
            async fetch(input, init) {
                return lib(input, init);
            }
            async prepareRequest(httpRequest) {
                const requestInit = {};
                requestInit.agent = this.getOrCreateAgent(httpRequest);
                requestInit.compress = httpRequest.decompressResponse;
                return requestInit;
            }
            async processRequest(_operationResponse) {}
        }
        const _defaultHttpClient = new NodeFetchHttpClient();
        function getCachedDefaultHttpClient() {
            return _defaultHttpClient;
        }
        const StorageBearerTokenChallengeAuthenticationPolicy_Constants = {
            DefaultScope: "/.default",
            HeaderConstants: {
                AUTHORIZATION: "authorization"
            }
        };
        const DEFAULT_CYCLER_OPTIONS = {
            forcedRefreshWindowInMs: 1000,
            retryIntervalInMs: 3000,
            refreshWindowInMs: 120000
        };
        async function beginRefresh(getAccessToken, retryIntervalInMs, timeoutInMs) {
            async function tryGetAccessToken() {
                if (Date.now() < timeoutInMs) try {
                    return await getAccessToken();
                } catch (_a) {
                    return null;
                }
                {
                    const finalToken = await getAccessToken();
                    if (null === finalToken) throw new Error("Failed to refresh access token.");
                    return finalToken;
                }
            }
            let token = await tryGetAccessToken();
            while(null === token){
                await delay_delay(retryIntervalInMs);
                token = await tryGetAccessToken();
            }
            return token;
        }
        function createTokenCycler(credential, scopes, tokenCyclerOptions) {
            let refreshWorker = null;
            let token = null;
            const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
            const cycler = {
                get isRefreshing () {
                    return null !== refreshWorker;
                },
                get shouldRefresh () {
                    var _a;
                    return !cycler.isRefreshing && (null != (_a = null == token ? void 0 : token.expiresOnTimestamp) ? _a : 0) - options.refreshWindowInMs < Date.now();
                },
                get mustRefresh () {
                    return null === token || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
                }
            };
            function refresh(getTokenOptions) {
                var _a;
                if (!cycler.isRefreshing) {
                    const tryGetAccessToken = ()=>credential.getToken(scopes, getTokenOptions);
                    refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, null != (_a = null == token ? void 0 : token.expiresOnTimestamp) ? _a : Date.now()).then((_token)=>{
                        refreshWorker = null;
                        token = _token;
                        return token;
                    }).catch((reason)=>{
                        refreshWorker = null;
                        token = null;
                        throw reason;
                    });
                }
                return refreshWorker;
            }
            return async (tokenOptions)=>{
                if (cycler.mustRefresh) return refresh(tokenOptions);
                if (cycler.shouldRefresh) refresh(tokenOptions);
                return token;
            };
        }
        function getChallenge(response) {
            const challenge = response.headers.get("WWW-Authenticate");
            if (401 === response.status && challenge) return challenge;
        }
        function parseChallenge(challenge) {
            const bearerChallenge = challenge.slice(7);
            const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x)=>x);
            const keyValuePairs = challengeParts.map((keyValue)=>(([key, value])=>({
                        [key]: value
                    }))(keyValue.trim().split("=")));
            return keyValuePairs.reduce((a, b)=>Object.assign(Object.assign({}, a), b), {});
        }
        function storageBearerTokenChallengeAuthenticationPolicy(credential, scopes) {
            let getToken = createTokenCycler(credential, scopes);
            class StorageBearerTokenChallengeAuthenticationPolicy extends BaseRequestPolicy {
                constructor(nextPolicy, options){
                    super(nextPolicy, options);
                }
                async sendRequest(webResource) {
                    if (!webResource.url.toLowerCase().startsWith("https://")) throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
                    const getTokenInternal = getToken;
                    const token = (await getTokenInternal({
                        abortSignal: webResource.abortSignal,
                        tracingOptions: {
                            tracingContext: webResource.tracingContext
                        }
                    })).token;
                    webResource.headers.set(StorageBearerTokenChallengeAuthenticationPolicy_Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);
                    const response = await this._nextPolicy.sendRequest(webResource);
                    if ((null == response ? void 0 : response.status) === 401) {
                        const challenge = getChallenge(response);
                        if (challenge) {
                            const challengeInfo = parseChallenge(challenge);
                            const challengeScopes = challengeInfo.resource_id + StorageBearerTokenChallengeAuthenticationPolicy_Constants.DefaultScope;
                            const parsedAuthUri = URLBuilder.parse(challengeInfo.authorization_uri);
                            const pathSegments = parsedAuthUri.getPath().split("/");
                            const tenantId = pathSegments[1];
                            const getTokenForChallenge = createTokenCycler(credential, challengeScopes);
                            const tokenForChallenge = (await getTokenForChallenge({
                                abortSignal: webResource.abortSignal,
                                tracingOptions: {
                                    tracingContext: webResource.tracingContext
                                },
                                tenantId: tenantId
                            })).token;
                            getToken = getTokenForChallenge;
                            webResource.headers.set(StorageBearerTokenChallengeAuthenticationPolicy_Constants.HeaderConstants.AUTHORIZATION, `Bearer ${tokenForChallenge}`);
                            return this._nextPolicy.sendRequest(webResource);
                        }
                    }
                    return response;
                }
            }
            return {
                create: (nextPolicy, options)=>new StorageBearerTokenChallengeAuthenticationPolicy(nextPolicy, options)
            };
        }
        function isPipelineLike(pipeline) {
            if (!pipeline || "object" != typeof pipeline) return false;
            const castPipeline = pipeline;
            return Array.isArray(castPipeline.factories) && "object" == typeof castPipeline.options && "function" == typeof castPipeline.toServiceClientOptions;
        }
        class Pipeline {
            constructor(factories, options = {}){
                this.factories = factories;
                this.options = Object.assign(Object.assign({}, options), {
                    httpClient: options.httpClient || getCachedDefaultHttpClient()
                });
            }
            toServiceClientOptions() {
                return {
                    httpClient: this.options.httpClient,
                    requestPolicyFactories: this.factories
                };
            }
        }
        function newPipeline(credential, pipelineOptions = {}) {
            var _a;
            if (void 0 === credential) credential = new AnonymousCredential();
            const telemetryPolicy = new TelemetryPolicyFactory(pipelineOptions.userAgentOptions);
            const factories = [
                tracingPolicy_tracingPolicy({
                    userAgent: telemetryPolicy.telemetryString
                }),
                keepAlivePolicy_keepAlivePolicy(pipelineOptions.keepAliveOptions),
                telemetryPolicy,
                generateClientRequestIdPolicy_generateClientRequestIdPolicy(),
                new StorageBrowserPolicyFactory(),
                new StorageRetryPolicyFactory(pipelineOptions.retryOptions),
                deserializationPolicy_deserializationPolicy(void 0, {
                    xmlCharKey: "#"
                }),
                logPolicy_logPolicy({
                    logger: src_log_logger.info,
                    allowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,
                    allowedQueryParameters: StorageBlobLoggingAllowedQueryParameters
                })
            ];
            if (checkEnvironment_isNode) {
                factories.push(proxyPolicy_proxyPolicy(pipelineOptions.proxyOptions));
                factories.push(disableResponseDecompressionPolicy_disableResponseDecompressionPolicy());
            }
            factories.push(isTokenCredential(credential) ? attachCredential(storageBearerTokenChallengeAuthenticationPolicy(credential, null != (_a = pipelineOptions.audience) ? _a : StorageOAuthScopes), credential) : credential);
            return new Pipeline(factories, pipelineOptions);
        }
        class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
            constructor(nextPolicy, options, factory){
                super(nextPolicy, options);
                this.factory = factory;
            }
            signRequest(request) {
                request.headers.set(constants_HeaderConstants.X_MS_DATE, new Date().toUTCString());
                if (request.body && ("string" == typeof request.body || void 0 !== request.body) && request.body.length > 0) request.headers.set(constants_HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
                const stringToSign = [
                    request.method.toUpperCase(),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.CONTENT_LANGUAGE),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.CONTENT_ENCODING),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.CONTENT_LENGTH),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.CONTENT_MD5),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.CONTENT_TYPE),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.DATE),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.IF_MODIFIED_SINCE),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.IF_MATCH),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.IF_NONE_MATCH),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.IF_UNMODIFIED_SINCE),
                    this.getHeaderValueToSign(request, constants_HeaderConstants.RANGE)
                ].join("\n") + "\n" + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request);
                const signature = this.factory.computeHMACSHA256(stringToSign);
                request.headers.set(constants_HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
                return request;
            }
            getHeaderValueToSign(request, headerName) {
                const value = request.headers.get(headerName);
                if (!value) return "";
                if (headerName === constants_HeaderConstants.CONTENT_LENGTH && "0" === value) return "";
                return value;
            }
            getCanonicalizedHeadersString(request) {
                let headersArray = request.headers.headersArray().filter((value)=>value.name.toLowerCase().startsWith(constants_HeaderConstants.PREFIX_FOR_STORAGE));
                headersArray.sort((a, b)=>a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
                headersArray = headersArray.filter((value, index, array)=>{
                    if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) return false;
                    return true;
                });
                let canonicalizedHeadersStringToSign = "";
                headersArray.forEach((header)=>{
                    canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}\n`;
                });
                return canonicalizedHeadersStringToSign;
            }
            getCanonicalizedResourceString(request) {
                const path = getURLPath(request.url) || "/";
                let canonicalizedResourceString = "";
                canonicalizedResourceString += `/${this.factory.accountName}${path}`;
                const queries = getURLQueries(request.url);
                const lowercaseQueries = {};
                if (queries) {
                    const queryKeys = [];
                    for(const key in queries)if (Object.prototype.hasOwnProperty.call(queries, key)) {
                        const lowercaseKey = key.toLowerCase();
                        lowercaseQueries[lowercaseKey] = queries[key];
                        queryKeys.push(lowercaseKey);
                    }
                    queryKeys.sort();
                    for (const key of queryKeys)canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
                }
                return canonicalizedResourceString;
            }
        }
        class StorageSharedKeyCredential extends Credential {
            constructor(accountName, accountKey){
                super();
                this.accountName = accountName;
                this.accountKey = Buffer.from(accountKey, "base64");
            }
            create(nextPolicy, options) {
                return new StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
            }
            computeHMACSHA256(stringToSign) {
                return (0, external_crypto_.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
            }
        }
        const allowedRedirect = [
            "GET",
            "HEAD"
        ];
        function redirectPolicy_redirectPolicy(maximumRetries = 20) {
            return {
                create: (nextPolicy, options)=>new RedirectPolicy(nextPolicy, options, maximumRetries)
            };
        }
        class RedirectPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, maxRetries = 20){
                super(nextPolicy, options);
                this.maxRetries = maxRetries;
            }
            sendRequest(request) {
                return this._nextPolicy.sendRequest(request).then((response)=>handleRedirect(this, response, 0));
            }
        }
        function handleRedirect(policy, response, currentRetries) {
            const { request, status } = response;
            const locationHeader = response.headers.get("location");
            if (locationHeader && (300 === status || 301 === status && allowedRedirect.includes(request.method) || 302 === status && allowedRedirect.includes(request.method) || 303 === status && "POST" === request.method || 307 === status) && (!policy.maxRetries || currentRetries < policy.maxRetries)) {
                const builder = URLBuilder.parse(request.url);
                builder.setPath(locationHeader);
                request.url = builder.toString();
                if (303 === status) {
                    request.method = "GET";
                    delete request.body;
                }
                return policy._nextPolicy.sendRequest(request).then((res)=>handleRedirect(policy, res, currentRetries + 1));
            }
            return Promise.resolve(response);
        }
        function isNumber(n) {
            return "number" == typeof n;
        }
        function shouldRetry(retryLimit, predicate, retryData, response, error) {
            if (!predicate(response, error)) return false;
            return retryData.retryCount < retryLimit;
        }
        function updateRetryData(retryOptions, retryData = {
            retryCount: 0,
            retryInterval: 0
        }, err) {
            if (err) {
                if (retryData.error) err.innerError = retryData.error;
                retryData.error = err;
            }
            retryData.retryCount++;
            let incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;
            const boundedRandDelta = 0.8 * retryOptions.retryInterval + Math.floor(Math.random() * (0.4 * retryOptions.retryInterval));
            incrementDelta *= boundedRandDelta;
            retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);
            return retryData;
        }
        function exponentialRetryPolicy_exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {
            return {
                create: (nextPolicy, options)=>new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval)
            };
        }
        var exponentialRetryPolicy_RetryMode;
        (function(RetryMode) {
            RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
        })(exponentialRetryPolicy_RetryMode || (exponentialRetryPolicy_RetryMode = {}));
        class ExponentialRetryPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, retryCount, retryInterval, maxRetryInterval){
                super(nextPolicy, options);
                this.retryCount = isNumber(retryCount) ? retryCount : 3;
                this.retryInterval = isNumber(retryInterval) ? retryInterval : 30000;
                this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : 90000;
            }
            sendRequest(request) {
                return this._nextPolicy.sendRequest(request.clone()).then((response)=>retry(this, request, response)).catch((error)=>retry(this, request, error.response, void 0, error));
            }
        }
        async function retry(policy, request, response, retryData, requestError) {
            function shouldPolicyRetry(responseParam) {
                const statusCode = null == responseParam ? void 0 : responseParam.status;
                if (503 === statusCode && (null == response ? void 0 : response.headers.get(constants_Constants.HeaderConstants.RETRY_AFTER))) return false;
                if (void 0 === statusCode || statusCode < 500 && 408 !== statusCode || 501 === statusCode || 505 === statusCode) return false;
                return true;
            }
            retryData = updateRetryData({
                retryInterval: policy.retryInterval,
                minRetryInterval: 0,
                maxRetryInterval: policy.maxRetryInterval
            }, retryData, requestError);
            const isAborted = request.abortSignal && request.abortSignal.aborted;
            if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {
                log_logger.info(`Retrying request in ${retryData.retryInterval}`);
                try {
                    await delay_delay(retryData.retryInterval);
                    const res = await policy._nextPolicy.sendRequest(request.clone());
                    return retry(policy, request, res, retryData);
                } catch (err) {
                    return retry(policy, request, response, retryData, err);
                }
            }
            if (!isAborted && !requestError && !!response) return response;
            {
                const err = retryData.error || new RestError("Failed to send the request.", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);
                throw err;
            }
        }
        function getPathStringFromParameter(parameter) {
            return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);
        }
        function getPathStringFromParameterPath(parameterPath, mapper) {
            let result;
            result = "string" == typeof parameterPath ? parameterPath : Array.isArray(parameterPath) ? parameterPath.join(".") : mapper.serializedName;
            return result;
        }
        function getStreamResponseStatusCodes(operationSpec) {
            const result = new Set();
            for(const statusCode in operationSpec.responses){
                const operationResponse = operationSpec.responses[statusCode];
                if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperType.Stream) result.add(Number(statusCode));
            }
            return result;
        }
        function getDefaultUserAgentKey() {
            return constants_Constants.HeaderConstants.USER_AGENT;
        }
        function getPlatformSpecificData() {
            const runtimeInfo = {
                key: "Node",
                value: process.version
            };
            const osInfo = {
                key: "OS",
                value: `(${external_os_.arch()}-${external_os_.type()}-${external_os_.release()})`
            };
            return [
                runtimeInfo,
                osInfo
            ];
        }
        function getRuntimeInfo() {
            const msRestRuntime = {
                key: "core-http",
                value: constants_Constants.coreHttpVersion
            };
            return [
                msRestRuntime
            ];
        }
        function getUserAgentString(telemetryInfo, keySeparator = " ", valueSeparator = "/") {
            return telemetryInfo.map((info)=>{
                const value = info.value ? `${valueSeparator}${info.value}` : "";
                return `${info.key}${value}`;
            }).join(keySeparator);
        }
        const getDefaultUserAgentHeaderName = getDefaultUserAgentKey;
        function userAgentPolicy_getDefaultUserAgentValue() {
            const runtimeInfo = getRuntimeInfo();
            const platformSpecificData = getPlatformSpecificData();
            const userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));
            return userAgent;
        }
        function userAgentPolicy_userAgentPolicy(userAgentData) {
            const key = userAgentData && void 0 !== userAgentData.key && null !== userAgentData.key ? userAgentData.key : getDefaultUserAgentKey();
            const value = userAgentData && void 0 !== userAgentData.value && null !== userAgentData.value ? userAgentData.value : userAgentPolicy_getDefaultUserAgentValue();
            return {
                create: (nextPolicy, options)=>new UserAgentPolicy(nextPolicy, options, key, value)
            };
        }
        class UserAgentPolicy extends BaseRequestPolicy {
            constructor(_nextPolicy, _options, headerKey, headerValue){
                super(_nextPolicy, _options);
                this._nextPolicy = _nextPolicy;
                this._options = _options;
                this.headerKey = headerKey;
                this.headerValue = headerValue;
            }
            sendRequest(request) {
                this.addUserAgentHeader(request);
                return this._nextPolicy.sendRequest(request);
            }
            addUserAgentHeader(request) {
                if (!request.headers) request.headers = new httpHeaders_HttpHeaders();
                if (!request.headers.get(this.headerKey) && this.headerValue) request.headers.set(this.headerKey, this.headerValue);
            }
        }
        const bearerTokenAuthenticationPolicy_DEFAULT_CYCLER_OPTIONS = {
            forcedRefreshWindowInMs: 1000,
            retryIntervalInMs: 3000,
            refreshWindowInMs: 120000
        };
        async function bearerTokenAuthenticationPolicy_beginRefresh(getAccessToken, retryIntervalInMs, timeoutInMs) {
            async function tryGetAccessToken() {
                if (Date.now() < timeoutInMs) try {
                    return await getAccessToken();
                } catch (_a) {
                    return null;
                }
                {
                    const finalToken = await getAccessToken();
                    if (null === finalToken) throw new Error("Failed to refresh access token.");
                    return finalToken;
                }
            }
            let token = await tryGetAccessToken();
            while(null === token){
                await delay_delay(retryIntervalInMs);
                token = await tryGetAccessToken();
            }
            return token;
        }
        function bearerTokenAuthenticationPolicy_createTokenCycler(credential, scopes, tokenCyclerOptions) {
            let refreshWorker = null;
            let token = null;
            const options = Object.assign(Object.assign({}, bearerTokenAuthenticationPolicy_DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
            const cycler = {
                get isRefreshing () {
                    return null !== refreshWorker;
                },
                get shouldRefresh () {
                    var _a;
                    return !cycler.isRefreshing && (null != (_a = null == token ? void 0 : token.expiresOnTimestamp) ? _a : 0) - options.refreshWindowInMs < Date.now();
                },
                get mustRefresh () {
                    return null === token || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
                }
            };
            function refresh(getTokenOptions) {
                var _a;
                if (!cycler.isRefreshing) {
                    const tryGetAccessToken = ()=>credential.getToken(scopes, getTokenOptions);
                    refreshWorker = bearerTokenAuthenticationPolicy_beginRefresh(tryGetAccessToken, options.retryIntervalInMs, null != (_a = null == token ? void 0 : token.expiresOnTimestamp) ? _a : Date.now()).then((_token)=>{
                        refreshWorker = null;
                        token = _token;
                        return token;
                    }).catch((reason)=>{
                        refreshWorker = null;
                        token = null;
                        throw reason;
                    });
                }
                return refreshWorker;
            }
            return async (tokenOptions)=>{
                if (cycler.mustRefresh) return refresh(tokenOptions);
                if (cycler.shouldRefresh) refresh(tokenOptions);
                return token;
            };
        }
        function bearerTokenAuthenticationPolicy(credential, scopes) {
            const getToken = bearerTokenAuthenticationPolicy_createTokenCycler(credential, scopes);
            class BearerTokenAuthenticationPolicy extends BaseRequestPolicy {
                constructor(nextPolicy, options){
                    super(nextPolicy, options);
                }
                async sendRequest(webResource) {
                    if (!webResource.url.toLowerCase().startsWith("https://")) throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
                    const { token } = await getToken({
                        abortSignal: webResource.abortSignal,
                        tracingOptions: {
                            tracingContext: webResource.tracingContext
                        }
                    });
                    webResource.headers.set(constants_Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);
                    return this._nextPolicy.sendRequest(webResource);
                }
            }
            return {
                create: (nextPolicy, options)=>new BearerTokenAuthenticationPolicy(nextPolicy, options)
            };
        }
        let cachedHttpClient;
        function httpClientCache_getCachedDefaultHttpClient() {
            if (!cachedHttpClient) cachedHttpClient = new NodeFetchHttpClient();
            return cachedHttpClient;
        }
        function rpRegistrationPolicy(retryTimeout = 30) {
            return {
                create: (nextPolicy, options)=>new RPRegistrationPolicy(nextPolicy, options, retryTimeout)
            };
        }
        class RPRegistrationPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, _retryTimeout = 30){
                super(nextPolicy, options);
                this._retryTimeout = _retryTimeout;
            }
            sendRequest(request) {
                return this._nextPolicy.sendRequest(request.clone()).then((response)=>registerIfNeeded(this, request, response));
            }
        }
        function registerIfNeeded(policy, request, response) {
            if (409 === response.status) {
                const rpName = checkRPNotRegisteredError(response.bodyAsText);
                if (rpName) {
                    const urlPrefix = extractSubscriptionUrl(request.url);
                    return registerRP(policy, urlPrefix, rpName, request).catch(()=>false).then((registrationStatus)=>{
                        if (registrationStatus) {
                            request.headers.set("x-ms-client-request-id", generateUuid());
                            return policy._nextPolicy.sendRequest(request.clone());
                        }
                        return response;
                    });
                }
            }
            return Promise.resolve(response);
        }
        function getRequestEssentials(originalRequest, reuseUrlToo = false) {
            const reqOptions = originalRequest.clone();
            if (reuseUrlToo) reqOptions.url = originalRequest.url;
            reqOptions.headers.set("x-ms-client-request-id", generateUuid());
            reqOptions.headers.set("Content-Type", "application/json; charset=utf-8");
            return reqOptions;
        }
        function checkRPNotRegisteredError(body) {
            let result, responseBody;
            if (body) {
                try {
                    responseBody = JSON.parse(body);
                } catch (err) {}
                if (responseBody && responseBody.error && responseBody.error.message && responseBody.error.code && "MissingSubscriptionRegistration" === responseBody.error.code) {
                    const matchRes = responseBody.error.message.match(/.*'(.*)'/i);
                    if (matchRes) result = matchRes.pop();
                }
            }
            return result;
        }
        function extractSubscriptionUrl(url) {
            let result;
            const matchRes = url.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);
            if (matchRes && matchRes[0]) result = matchRes[0];
            else throw new Error(`Unable to extract subscriptionId from the given url - ${url}.`);
            return result;
        }
        async function registerRP(policy, urlPrefix, provider, originalRequest) {
            const postUrl = `${urlPrefix}providers/${provider}/register?api-version=2016-02-01`;
            const getUrl = `${urlPrefix}providers/${provider}?api-version=2016-02-01`;
            const reqOptions = getRequestEssentials(originalRequest);
            reqOptions.method = "POST";
            reqOptions.url = postUrl;
            const response = await policy._nextPolicy.sendRequest(reqOptions);
            if (200 !== response.status) throw new Error(`Autoregistration of ${provider} failed. Please try registering manually.`);
            return getRegistrationStatus(policy, getUrl, originalRequest);
        }
        async function getRegistrationStatus(policy, url, originalRequest) {
            const reqOptions = getRequestEssentials(originalRequest);
            reqOptions.url = url;
            reqOptions.method = "GET";
            const res = await policy._nextPolicy.sendRequest(reqOptions);
            const obj = res.parsedBody;
            if (res.parsedBody && obj.registrationState && "Registered" === obj.registrationState) return true;
            await delay_delay(1000 * policy._retryTimeout);
            return getRegistrationStatus(policy, url, originalRequest);
        }
        function signingPolicy(authenticationProvider) {
            return {
                create: (nextPolicy, options)=>new SigningPolicy(nextPolicy, options, authenticationProvider)
            };
        }
        class SigningPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, authenticationProvider){
                super(nextPolicy, options);
                this.authenticationProvider = authenticationProvider;
            }
            signRequest(request) {
                return this.authenticationProvider.signRequest(request);
            }
            sendRequest(request) {
                return this.signRequest(request).then((nextRequest)=>this._nextPolicy.sendRequest(nextRequest));
            }
        }
        function systemErrorRetryPolicy_systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
            return {
                create: (nextPolicy, options)=>new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval)
            };
        }
        class SystemErrorRetryPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval){
                super(nextPolicy, options);
                this.retryCount = isNumber(retryCount) ? retryCount : 3;
                this.retryInterval = isNumber(retryInterval) ? retryInterval : 30000;
                this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : 3000;
                this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : 90000;
            }
            sendRequest(request) {
                return this._nextPolicy.sendRequest(request.clone()).catch((error)=>systemErrorRetryPolicy_retry(this, request, error.response, error));
            }
        }
        async function systemErrorRetryPolicy_retry(policy, request, operationResponse, err, retryData) {
            retryData = updateRetryData(policy, retryData, err);
            function shouldPolicyRetry(_response, error) {
                if (error && error.code && ("ETIMEDOUT" === error.code || "ESOCKETTIMEDOUT" === error.code || "ECONNREFUSED" === error.code || "ECONNRESET" === error.code || "ENOENT" === error.code)) return true;
                return false;
            }
            if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) try {
                await delay_delay(retryData.retryInterval);
                return policy._nextPolicy.sendRequest(request.clone());
            } catch (nestedErr) {
                return systemErrorRetryPolicy_retry(policy, request, operationResponse, nestedErr, retryData);
            }
            if (err) return Promise.reject(retryData.error);
            return operationResponse;
        }
        const StatusCodes = constants_Constants.HttpConstants.StatusCodes;
        function throttlingRetryPolicy_throttlingRetryPolicy() {
            return {
                create: (nextPolicy, options)=>new ThrottlingRetryPolicy(nextPolicy, options)
            };
        }
        const throttlingRetryPolicy_StandardAbortMessage = "The operation was aborted.";
        class ThrottlingRetryPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options, _handleResponse){
                super(nextPolicy, options);
                this.numberOfRetries = 0;
                this._handleResponse = _handleResponse || this._defaultResponseHandler;
            }
            async sendRequest(httpRequest) {
                const response = await this._nextPolicy.sendRequest(httpRequest.clone());
                if (response.status !== StatusCodes.TooManyRequests && response.status !== StatusCodes.ServiceUnavailable) return response;
                return this._handleResponse(httpRequest, response);
            }
            async _defaultResponseHandler(httpRequest, httpResponse) {
                var _a;
                const retryAfterHeader = httpResponse.headers.get(constants_Constants.HeaderConstants.RETRY_AFTER);
                if (retryAfterHeader) {
                    const delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);
                    if (delayInMs) {
                        this.numberOfRetries += 1;
                        await delay_delay(delayInMs, {
                            abortSignal: httpRequest.abortSignal,
                            abortErrorMsg: throttlingRetryPolicy_StandardAbortMessage
                        });
                        if (null == (_a = httpRequest.abortSignal) ? void 0 : _a.aborted) throw new src_AbortController.l(throttlingRetryPolicy_StandardAbortMessage);
                        if (this.numberOfRetries < 3) return this.sendRequest(httpRequest);
                        return this._nextPolicy.sendRequest(httpRequest);
                    }
                }
                return httpResponse;
            }
            static parseRetryAfterHeader(headerValue) {
                const retryAfterInSeconds = Number(headerValue);
                if (Number.isNaN(retryAfterInSeconds)) return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
                return 1000 * retryAfterInSeconds;
            }
            static parseDateRetryAfterHeader(headerValue) {
                try {
                    const now = Date.now();
                    const date = Date.parse(headerValue);
                    const diff = date - now;
                    return Number.isNaN(diff) ? void 0 : diff;
                } catch (error) {
                    return;
                }
            }
        }
        class ServiceClient {
            constructor(credentials, options){
                if (!options) options = {};
                this._withCredentials = options.withCredentials || false;
                this._httpClient = options.httpClient || httpClientCache_getCachedDefaultHttpClient();
                this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);
                let requestPolicyFactories;
                if (Array.isArray(options.requestPolicyFactories)) {
                    log_logger.info("ServiceClient: using custom request policies");
                    requestPolicyFactories = options.requestPolicyFactories;
                } else {
                    let authPolicyFactory;
                    if (isTokenCredential(credentials)) {
                        log_logger.info("ServiceClient: creating bearer token authentication policy from provided credentials");
                        const wrappedPolicyFactory = ()=>{
                            let bearerTokenPolicyFactory;
                            const serviceClient = this;
                            const serviceClientOptions = options;
                            return {
                                create (nextPolicy, createOptions) {
                                    const credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);
                                    if (!credentialScopes) throw new Error("When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy");
                                    if (null == bearerTokenPolicyFactory) bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);
                                    return bearerTokenPolicyFactory.create(nextPolicy, createOptions);
                                }
                            };
                        };
                        authPolicyFactory = wrappedPolicyFactory();
                    } else if (credentials && "function" == typeof credentials.signRequest) {
                        log_logger.info("ServiceClient: creating signing policy from provided credentials");
                        authPolicyFactory = signingPolicy(credentials);
                    } else if (null != credentials) throw new Error("The credentials argument must implement the TokenCredential interface");
                    log_logger.info("ServiceClient: using default request policies");
                    requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);
                    if (options.requestPolicyFactories) {
                        const newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);
                        if (newRequestPolicyFactories) requestPolicyFactories = newRequestPolicyFactories;
                    }
                }
                this._requestPolicyFactories = requestPolicyFactories;
            }
            sendRequest(options) {
                if (null == options || "object" != typeof options) throw new Error("options cannot be null or undefined and it must be of type object.");
                let httpRequest;
                try {
                    if (isWebResourceLike(options)) {
                        options.validateRequestProperties();
                        httpRequest = options;
                    } else {
                        httpRequest = new WebResource();
                        httpRequest = httpRequest.prepare(options);
                    }
                } catch (error) {
                    return Promise.reject(error);
                }
                let httpPipeline = this._httpClient;
                if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) for(let i = this._requestPolicyFactories.length - 1; i >= 0; --i)httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);
                return httpPipeline.sendRequest(httpRequest);
            }
            async sendOperationRequest(operationArguments, operationSpec, callback) {
                var _a;
                if ("function" == typeof operationArguments.options) {
                    callback = operationArguments.options;
                    operationArguments.options = void 0;
                }
                const serializerOptions = null == (_a = operationArguments.options) ? void 0 : _a.serializerOptions;
                const httpRequest = new WebResource();
                let result;
                try {
                    const baseUri = operationSpec.baseUrl || this.baseUri;
                    if (!baseUri) throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
                    httpRequest.method = operationSpec.httpMethod;
                    httpRequest.operationSpec = operationSpec;
                    const requestUrl = URLBuilder.parse(baseUri);
                    if (operationSpec.path) requestUrl.appendPath(operationSpec.path);
                    if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) for (const urlParameter of operationSpec.urlParameters){
                        let urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);
                        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);
                        if (!urlParameter.skipEncoding) urlParameterValue = encodeURIComponent(urlParameterValue);
                        requestUrl.replaceAll(`{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`, urlParameterValue);
                    }
                    if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) for (const queryParameter of operationSpec.queryParameters){
                        let queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);
                        if (null != queryParameterValue) {
                            queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);
                            if (void 0 !== queryParameter.collectionFormat && null !== queryParameter.collectionFormat) {
                                if (queryParameter.collectionFormat === queryCollectionFormat_QueryCollectionFormat.Multi) if (0 === queryParameterValue.length) continue;
                                else for(const index in queryParameterValue){
                                    const item = queryParameterValue[index];
                                    queryParameterValue[index] = null == item ? "" : item.toString();
                                }
                                else if (queryParameter.collectionFormat === queryCollectionFormat_QueryCollectionFormat.Ssv || queryParameter.collectionFormat === queryCollectionFormat_QueryCollectionFormat.Tsv) queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                            }
                            if (!queryParameter.skipEncoding) if (Array.isArray(queryParameterValue)) {
                                for(const index in queryParameterValue)if (void 0 !== queryParameterValue[index] && null !== queryParameterValue[index]) queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);
                            } else queryParameterValue = encodeURIComponent(queryParameterValue);
                            if (void 0 !== queryParameter.collectionFormat && null !== queryParameter.collectionFormat && queryParameter.collectionFormat !== queryCollectionFormat_QueryCollectionFormat.Multi && queryParameter.collectionFormat !== queryCollectionFormat_QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== queryCollectionFormat_QueryCollectionFormat.Tsv) queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                            requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
                        }
                    }
                    httpRequest.url = requestUrl.toString();
                    const contentType = operationSpec.contentType || this.requestContentType;
                    if (contentType && operationSpec.requestBody) httpRequest.headers.set("Content-Type", contentType);
                    if (operationSpec.headerParameters) for (const headerParameter of operationSpec.headerParameters){
                        let headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);
                        if (null != headerValue) {
                            headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);
                            const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
                            if (headerCollectionPrefix) for (const key of Object.keys(headerValue))httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);
                            else httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
                        }
                    }
                    const options = operationArguments.options;
                    if (options) {
                        if (options.customHeaders) for(const customHeaderName in options.customHeaders)httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);
                        if (options.abortSignal) httpRequest.abortSignal = options.abortSignal;
                        if (options.timeout) httpRequest.timeout = options.timeout;
                        if (options.onUploadProgress) httpRequest.onUploadProgress = options.onUploadProgress;
                        if (options.onDownloadProgress) httpRequest.onDownloadProgress = options.onDownloadProgress;
                        if (options.spanOptions) httpRequest.spanOptions = options.spanOptions;
                        if (options.tracingContext) httpRequest.tracingContext = options.tracingContext;
                        if (void 0 !== options.shouldDeserialize && null !== options.shouldDeserialize) httpRequest.shouldDeserialize = options.shouldDeserialize;
                    }
                    httpRequest.withCredentials = this._withCredentials;
                    serializeRequestBody(this, httpRequest, operationArguments, operationSpec);
                    if (void 0 === httpRequest.streamResponseStatusCodes) httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);
                    let rawResponse;
                    let sendRequestError;
                    try {
                        rawResponse = await this.sendRequest(httpRequest);
                    } catch (error) {
                        sendRequestError = error;
                    }
                    if (sendRequestError) {
                        if (sendRequestError.response) sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses["default"]);
                        result = Promise.reject(sendRequestError);
                    } else result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));
                } catch (error) {
                    result = Promise.reject(error);
                }
                const cb = callback;
                if (cb) result.then((res)=>cb(null, res._response.parsedBody, res._response.request, res._response)).catch((err)=>cb(err));
                return result;
            }
        }
        function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {
            var _a, _b, _c, _d, _e, _f;
            const serializerOptions = null != (_b = null == (_a = operationArguments.options) ? void 0 : _a.serializerOptions) ? _b : {};
            const updatedOptions = {
                rootName: null != (_c = serializerOptions.rootName) ? _c : "",
                includeRoot: null != (_d = serializerOptions.includeRoot) ? _d : false,
                xmlCharKey: null != (_e = serializerOptions.xmlCharKey) ? _e : "_"
            };
            const xmlCharKey = serializerOptions.xmlCharKey;
            if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
                httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);
                const bodyMapper = operationSpec.requestBody.mapper;
                const { required, xmlName, xmlElementName, serializedName, xmlNamespace, xmlNamespacePrefix } = bodyMapper;
                const typeName = bodyMapper.type.name;
                try {
                    if (void 0 !== httpRequest.body && null !== httpRequest.body || required) {
                        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
                        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);
                        const isStream = typeName === MapperType.Stream;
                        if (operationSpec.isXML) {
                            const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
                            const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);
                            if (typeName === MapperType.Sequence) httpRequest.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
                                rootName: xmlName || serializedName,
                                xmlCharKey
                            });
                            else if (!isStream) httpRequest.body = stringifyXML(value, {
                                rootName: xmlName || serializedName,
                                xmlCharKey
                            });
                        } else if (typeName === MapperType.String && ((null == (_f = operationSpec.contentType) ? void 0 : _f.match("text/plain")) || "text" === operationSpec.mediaType)) return;
                        else if (!isStream) httpRequest.body = JSON.stringify(httpRequest.body);
                    }
                } catch (error) {
                    throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
                }
            } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
                httpRequest.formData = {};
                for (const formDataParameter of operationSpec.formDataParameters){
                    const formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);
                    if (null != formDataParameterValue) {
                        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
                        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
                    }
                }
            }
        }
        function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
            if (xmlNamespace && ![
                "Composite",
                "Sequence",
                "Dictionary"
            ].includes(typeName)) {
                const result = {};
                result[options.xmlCharKey] = serializedValue;
                result["$"] = {
                    [xmlnsKey]: xmlNamespace
                };
                return result;
            }
            return serializedValue;
        }
        function getValueOrFunctionResult(value, defaultValueCreator) {
            let result;
            if ("string" == typeof value) result = value;
            else {
                result = defaultValueCreator();
                if ("function" == typeof value) result = value(result);
            }
            return result;
        }
        function createDefaultRequestPolicyFactories(authPolicyFactory, options) {
            const factories = [];
            if (options.generateClientRequestIdHeader) factories.push(generateClientRequestIdPolicy_generateClientRequestIdPolicy(options.clientRequestIdHeaderName));
            if (authPolicyFactory) factories.push(authPolicyFactory);
            const userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);
            const userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, userAgentPolicy_getDefaultUserAgentValue);
            if (userAgentHeaderName && userAgentHeaderValue) factories.push(userAgentPolicy_userAgentPolicy({
                key: userAgentHeaderName,
                value: userAgentHeaderValue
            }));
            factories.push(redirectPolicy_redirectPolicy());
            factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));
            if (!options.noRetryPolicy) {
                factories.push(exponentialRetryPolicy_exponentialRetryPolicy());
                factories.push(systemErrorRetryPolicy_systemErrorRetryPolicy());
                factories.push(throttlingRetryPolicy_throttlingRetryPolicy());
            }
            factories.push(deserializationPolicy_deserializationPolicy(options.deserializationContentTypes));
            if (checkEnvironment_isNode) factories.push(proxyPolicy_proxyPolicy(options.proxySettings));
            factories.push(logPolicy_logPolicy({
                logger: log_logger.info
            }));
            return factories;
        }
        function getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {
            return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);
        }
        function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {
            var _a;
            let value;
            if ("string" == typeof parameterPath) parameterPath = [
                parameterPath
            ];
            const serializerOptions = null == (_a = operationArguments.options) ? void 0 : _a.serializerOptions;
            if (Array.isArray(parameterPath)) {
                if (parameterPath.length > 0) {
                    if (parameterMapper.isConstant) value = parameterMapper.defaultValue;
                    else {
                        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
                        if (!propertySearchResult.propertyFound) propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);
                        let useDefaultValue = false;
                        if (!propertySearchResult.propertyFound) useDefaultValue = parameterMapper.required || "options" === parameterPath[0] && 2 === parameterPath.length;
                        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
                    }
                    const parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);
                    serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);
                }
            } else {
                if (parameterMapper.required) value = {};
                for(const propertyName in parameterPath){
                    const propertyMapper = parameterMapper.type.modelProperties[propertyName];
                    const propertyPath = parameterPath[propertyName];
                    const propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);
                    const propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);
                    serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);
                    if (null != propertyValue) {
                        if (!value) value = {};
                        value[propertyName] = propertyValue;
                    }
                }
            }
            return value;
        }
        function getPropertyFromParameterPath(parent, parameterPath) {
            const result = {
                propertyFound: false
            };
            let i = 0;
            for(; i < parameterPath.length; ++i){
                const parameterPathPart = parameterPath[i];
                if (null != parent && parameterPathPart in parent) parent = parent[parameterPathPart];
                else break;
            }
            if (i === parameterPath.length) {
                result.propertyValue = parent;
                result.propertyFound = true;
            }
            return result;
        }
        function flattenResponse(_response, responseSpec) {
            const parsedHeaders = _response.parsedHeaders;
            const bodyMapper = responseSpec && responseSpec.bodyMapper;
            const addOperationResponse = (obj)=>Object.defineProperty(obj, "_response", {
                    value: _response
                });
            if (bodyMapper) {
                const typeName = bodyMapper.type.name;
                if ("Stream" === typeName) return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {
                    blobBody: _response.blobBody,
                    readableStreamBody: _response.readableStreamBody
                }));
                const modelProperties = "Composite" === typeName && bodyMapper.type.modelProperties || {};
                const isPageableResponse = Object.keys(modelProperties).some((k)=>"" === modelProperties[k].serializedName);
                if ("Sequence" === typeName || isPageableResponse) {
                    const arrayResponse = [
                        ..._response.parsedBody || []
                    ];
                    for (const key of Object.keys(modelProperties))if (modelProperties[key].serializedName) arrayResponse[key] = _response.parsedBody[key];
                    if (parsedHeaders) for (const key of Object.keys(parsedHeaders))arrayResponse[key] = parsedHeaders[key];
                    addOperationResponse(arrayResponse);
                    return arrayResponse;
                }
                if ("Composite" === typeName || "Dictionary" === typeName) return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));
            }
            if (bodyMapper || "HEAD" === _response.request.method || isPrimitiveType(_response.parsedBody)) return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {
                body: _response.parsedBody
            }));
            return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));
        }
        function getCredentialScopes(options, baseUri) {
            if (null == options ? void 0 : options.credentialScopes) return options.credentialScopes;
            if (baseUri) return `${baseUri}/.default`;
        }
        const packageName = "azure-storage-blob";
        const packageVersion = "12.17.0";
        class StorageClientContext extends ServiceClient {
            constructor(url, options){
                if (void 0 === url) throw new Error("'url' cannot be null");
                if (!options) options = {};
                if (!options.userAgent) {
                    const defaultUserAgent = userAgentPolicy_getDefaultUserAgentValue();
                    options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
                }
                super(void 0, options);
                this.requestContentType = "application/json; charset=utf-8";
                this.baseUri = options.endpoint || "{url}";
                this.url = url;
                this.version = options.version || "2023-11-03";
            }
        }
        class StorageClient {
            constructor(url, pipeline){
                this.url = escapeURLPath(url);
                this.accountName = getAccountNameFromUrl(url);
                this.pipeline = pipeline;
                this.storageClientContext = new StorageClientContext(this.url, pipeline.toServiceClientOptions());
                this.isHttps = iEqual(getURLScheme(this.url) || "", "https");
                this.credential = new AnonymousCredential();
                for (const factory of this.pipeline.factories)if (checkEnvironment_isNode && factory instanceof StorageSharedKeyCredential || factory instanceof AnonymousCredential) this.credential = factory;
                else if (isTokenCredential(factory.credential)) this.credential = factory.credential;
                const storageClientContext = this.storageClientContext;
                storageClientContext.requestContentType = void 0;
            }
        }
        const tracing_createSpan = createSpanFunction({
            packagePrefix: "Azure.Storage.Blob",
            namespace: "Microsoft.Storage"
        });
        function convertTracingToRequestOptionsBase(options) {
            var _a, _b;
            return {
                spanOptions: null == (_a = null == options ? void 0 : options.tracingOptions) ? void 0 : _a.spanOptions,
                tracingContext: null == (_b = null == options ? void 0 : options.tracingOptions) ? void 0 : _b.tracingContext
            };
        }
        class BlobSASPermissions {
            constructor(){
                this.read = false;
                this.add = false;
                this.create = false;
                this.write = false;
                this.delete = false;
                this.deleteVersion = false;
                this.tag = false;
                this.move = false;
                this.execute = false;
                this.setImmutabilityPolicy = false;
                this.permanentDelete = false;
            }
            static parse(permissions) {
                const blobSASPermissions = new BlobSASPermissions();
                for (const char of permissions)switch(char){
                    case "r":
                        blobSASPermissions.read = true;
                        break;
                    case "a":
                        blobSASPermissions.add = true;
                        break;
                    case "c":
                        blobSASPermissions.create = true;
                        break;
                    case "w":
                        blobSASPermissions.write = true;
                        break;
                    case "d":
                        blobSASPermissions.delete = true;
                        break;
                    case "x":
                        blobSASPermissions.deleteVersion = true;
                        break;
                    case "t":
                        blobSASPermissions.tag = true;
                        break;
                    case "m":
                        blobSASPermissions.move = true;
                        break;
                    case "e":
                        blobSASPermissions.execute = true;
                        break;
                    case "i":
                        blobSASPermissions.setImmutabilityPolicy = true;
                        break;
                    case "y":
                        blobSASPermissions.permanentDelete = true;
                        break;
                    default:
                        throw new RangeError(`Invalid permission: ${char}`);
                }
                return blobSASPermissions;
            }
            static from(permissionLike) {
                const blobSASPermissions = new BlobSASPermissions();
                if (permissionLike.read) blobSASPermissions.read = true;
                if (permissionLike.add) blobSASPermissions.add = true;
                if (permissionLike.create) blobSASPermissions.create = true;
                if (permissionLike.write) blobSASPermissions.write = true;
                if (permissionLike.delete) blobSASPermissions.delete = true;
                if (permissionLike.deleteVersion) blobSASPermissions.deleteVersion = true;
                if (permissionLike.tag) blobSASPermissions.tag = true;
                if (permissionLike.move) blobSASPermissions.move = true;
                if (permissionLike.execute) blobSASPermissions.execute = true;
                if (permissionLike.setImmutabilityPolicy) blobSASPermissions.setImmutabilityPolicy = true;
                if (permissionLike.permanentDelete) blobSASPermissions.permanentDelete = true;
                return blobSASPermissions;
            }
            toString() {
                const permissions = [];
                if (this.read) permissions.push("r");
                if (this.add) permissions.push("a");
                if (this.create) permissions.push("c");
                if (this.write) permissions.push("w");
                if (this.delete) permissions.push("d");
                if (this.deleteVersion) permissions.push("x");
                if (this.tag) permissions.push("t");
                if (this.move) permissions.push("m");
                if (this.execute) permissions.push("e");
                if (this.setImmutabilityPolicy) permissions.push("i");
                if (this.permanentDelete) permissions.push("y");
                return permissions.join("");
            }
        }
        class ContainerSASPermissions {
            constructor(){
                this.read = false;
                this.add = false;
                this.create = false;
                this.write = false;
                this.delete = false;
                this.deleteVersion = false;
                this.list = false;
                this.tag = false;
                this.move = false;
                this.execute = false;
                this.setImmutabilityPolicy = false;
                this.permanentDelete = false;
                this.filterByTags = false;
            }
            static parse(permissions) {
                const containerSASPermissions = new ContainerSASPermissions();
                for (const char of permissions)switch(char){
                    case "r":
                        containerSASPermissions.read = true;
                        break;
                    case "a":
                        containerSASPermissions.add = true;
                        break;
                    case "c":
                        containerSASPermissions.create = true;
                        break;
                    case "w":
                        containerSASPermissions.write = true;
                        break;
                    case "d":
                        containerSASPermissions.delete = true;
                        break;
                    case "l":
                        containerSASPermissions.list = true;
                        break;
                    case "t":
                        containerSASPermissions.tag = true;
                        break;
                    case "x":
                        containerSASPermissions.deleteVersion = true;
                        break;
                    case "m":
                        containerSASPermissions.move = true;
                        break;
                    case "e":
                        containerSASPermissions.execute = true;
                        break;
                    case "i":
                        containerSASPermissions.setImmutabilityPolicy = true;
                        break;
                    case "y":
                        containerSASPermissions.permanentDelete = true;
                        break;
                    case "f":
                        containerSASPermissions.filterByTags = true;
                        break;
                    default:
                        throw new RangeError(`Invalid permission ${char}`);
                }
                return containerSASPermissions;
            }
            static from(permissionLike) {
                const containerSASPermissions = new ContainerSASPermissions();
                if (permissionLike.read) containerSASPermissions.read = true;
                if (permissionLike.add) containerSASPermissions.add = true;
                if (permissionLike.create) containerSASPermissions.create = true;
                if (permissionLike.write) containerSASPermissions.write = true;
                if (permissionLike.delete) containerSASPermissions.delete = true;
                if (permissionLike.list) containerSASPermissions.list = true;
                if (permissionLike.deleteVersion) containerSASPermissions.deleteVersion = true;
                if (permissionLike.tag) containerSASPermissions.tag = true;
                if (permissionLike.move) containerSASPermissions.move = true;
                if (permissionLike.execute) containerSASPermissions.execute = true;
                if (permissionLike.setImmutabilityPolicy) containerSASPermissions.setImmutabilityPolicy = true;
                if (permissionLike.permanentDelete) containerSASPermissions.permanentDelete = true;
                if (permissionLike.filterByTags) containerSASPermissions.filterByTags = true;
                return containerSASPermissions;
            }
            toString() {
                const permissions = [];
                if (this.read) permissions.push("r");
                if (this.add) permissions.push("a");
                if (this.create) permissions.push("c");
                if (this.write) permissions.push("w");
                if (this.delete) permissions.push("d");
                if (this.deleteVersion) permissions.push("x");
                if (this.list) permissions.push("l");
                if (this.tag) permissions.push("t");
                if (this.move) permissions.push("m");
                if (this.execute) permissions.push("e");
                if (this.setImmutabilityPolicy) permissions.push("i");
                if (this.permanentDelete) permissions.push("y");
                if (this.filterByTags) permissions.push("f");
                return permissions.join("");
            }
        }
        class UserDelegationKeyCredential {
            constructor(accountName, userDelegationKey){
                this.accountName = accountName;
                this.userDelegationKey = userDelegationKey;
                this.key = Buffer.from(userDelegationKey.value, "base64");
            }
            computeHMACSHA256(stringToSign) {
                return (0, external_crypto_.createHmac)("sha256", this.key).update(stringToSign, "utf8").digest("base64");
            }
        }
        function ipRangeToString(ipRange) {
            return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
        }
        var SASQueryParameters_SASProtocol;
        (function(SASProtocol) {
            SASProtocol["Https"] = "https";
            SASProtocol["HttpsAndHttp"] = "https,http";
        })(SASQueryParameters_SASProtocol || (SASQueryParameters_SASProtocol = {}));
        class SASQueryParameters {
            constructor(version, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope){
                this.version = version;
                this.signature = signature;
                if (void 0 !== permissionsOrOptions && "string" != typeof permissionsOrOptions) {
                    this.permissions = permissionsOrOptions.permissions;
                    this.services = permissionsOrOptions.services;
                    this.resourceTypes = permissionsOrOptions.resourceTypes;
                    this.protocol = permissionsOrOptions.protocol;
                    this.startsOn = permissionsOrOptions.startsOn;
                    this.expiresOn = permissionsOrOptions.expiresOn;
                    this.ipRangeInner = permissionsOrOptions.ipRange;
                    this.identifier = permissionsOrOptions.identifier;
                    this.encryptionScope = permissionsOrOptions.encryptionScope;
                    this.resource = permissionsOrOptions.resource;
                    this.cacheControl = permissionsOrOptions.cacheControl;
                    this.contentDisposition = permissionsOrOptions.contentDisposition;
                    this.contentEncoding = permissionsOrOptions.contentEncoding;
                    this.contentLanguage = permissionsOrOptions.contentLanguage;
                    this.contentType = permissionsOrOptions.contentType;
                    if (permissionsOrOptions.userDelegationKey) {
                        this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId;
                        this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId;
                        this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn;
                        this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn;
                        this.signedService = permissionsOrOptions.userDelegationKey.signedService;
                        this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion;
                        this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId;
                        this.correlationId = permissionsOrOptions.correlationId;
                    }
                } else {
                    this.services = services;
                    this.resourceTypes = resourceTypes;
                    this.expiresOn = expiresOn;
                    this.permissions = permissionsOrOptions;
                    this.protocol = protocol;
                    this.startsOn = startsOn;
                    this.ipRangeInner = ipRange;
                    this.encryptionScope = encryptionScope;
                    this.identifier = identifier;
                    this.resource = resource;
                    this.cacheControl = cacheControl;
                    this.contentDisposition = contentDisposition;
                    this.contentEncoding = contentEncoding;
                    this.contentLanguage = contentLanguage;
                    this.contentType = contentType;
                    if (userDelegationKey) {
                        this.signedOid = userDelegationKey.signedObjectId;
                        this.signedTenantId = userDelegationKey.signedTenantId;
                        this.signedStartsOn = userDelegationKey.signedStartsOn;
                        this.signedExpiresOn = userDelegationKey.signedExpiresOn;
                        this.signedService = userDelegationKey.signedService;
                        this.signedVersion = userDelegationKey.signedVersion;
                        this.preauthorizedAgentObjectId = preauthorizedAgentObjectId;
                        this.correlationId = correlationId;
                    }
                }
            }
            get ipRange() {
                if (this.ipRangeInner) return {
                    end: this.ipRangeInner.end,
                    start: this.ipRangeInner.start
                };
            }
            toString() {
                const params = [
                    "sv",
                    "ss",
                    "srt",
                    "spr",
                    "st",
                    "se",
                    "sip",
                    "si",
                    "ses",
                    "skoid",
                    "sktid",
                    "skt",
                    "ske",
                    "sks",
                    "skv",
                    "sr",
                    "sp",
                    "sig",
                    "rscc",
                    "rscd",
                    "rsce",
                    "rscl",
                    "rsct",
                    "saoid",
                    "scid"
                ];
                const queries = [];
                for (const param of params)switch(param){
                    case "sv":
                        this.tryAppendQueryParameter(queries, param, this.version);
                        break;
                    case "ss":
                        this.tryAppendQueryParameter(queries, param, this.services);
                        break;
                    case "srt":
                        this.tryAppendQueryParameter(queries, param, this.resourceTypes);
                        break;
                    case "spr":
                        this.tryAppendQueryParameter(queries, param, this.protocol);
                        break;
                    case "st":
                        this.tryAppendQueryParameter(queries, param, this.startsOn ? truncatedISO8061Date(this.startsOn, false) : void 0);
                        break;
                    case "se":
                        this.tryAppendQueryParameter(queries, param, this.expiresOn ? truncatedISO8061Date(this.expiresOn, false) : void 0);
                        break;
                    case "sip":
                        this.tryAppendQueryParameter(queries, param, this.ipRange ? ipRangeToString(this.ipRange) : void 0);
                        break;
                    case "si":
                        this.tryAppendQueryParameter(queries, param, this.identifier);
                        break;
                    case "ses":
                        this.tryAppendQueryParameter(queries, param, this.encryptionScope);
                        break;
                    case "skoid":
                        this.tryAppendQueryParameter(queries, param, this.signedOid);
                        break;
                    case "sktid":
                        this.tryAppendQueryParameter(queries, param, this.signedTenantId);
                        break;
                    case "skt":
                        this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? truncatedISO8061Date(this.signedStartsOn, false) : void 0);
                        break;
                    case "ske":
                        this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? truncatedISO8061Date(this.signedExpiresOn, false) : void 0);
                        break;
                    case "sks":
                        this.tryAppendQueryParameter(queries, param, this.signedService);
                        break;
                    case "skv":
                        this.tryAppendQueryParameter(queries, param, this.signedVersion);
                        break;
                    case "sr":
                        this.tryAppendQueryParameter(queries, param, this.resource);
                        break;
                    case "sp":
                        this.tryAppendQueryParameter(queries, param, this.permissions);
                        break;
                    case "sig":
                        this.tryAppendQueryParameter(queries, param, this.signature);
                        break;
                    case "rscc":
                        this.tryAppendQueryParameter(queries, param, this.cacheControl);
                        break;
                    case "rscd":
                        this.tryAppendQueryParameter(queries, param, this.contentDisposition);
                        break;
                    case "rsce":
                        this.tryAppendQueryParameter(queries, param, this.contentEncoding);
                        break;
                    case "rscl":
                        this.tryAppendQueryParameter(queries, param, this.contentLanguage);
                        break;
                    case "rsct":
                        this.tryAppendQueryParameter(queries, param, this.contentType);
                        break;
                    case "saoid":
                        this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
                        break;
                    case "scid":
                        this.tryAppendQueryParameter(queries, param, this.correlationId);
                        break;
                }
                return queries.join("&");
            }
            tryAppendQueryParameter(queries, key, value) {
                if (!value) return;
                key = encodeURIComponent(key);
                value = encodeURIComponent(value);
                if (key.length > 0 && value.length > 0) queries.push(`${key}=${value}`);
            }
        }
        function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
            const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;
            const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : void 0;
            let userDelegationKeyCredential;
            if (void 0 === sharedKeyCredential && void 0 !== accountName) userDelegationKeyCredential = new UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
            if (void 0 === sharedKeyCredential && void 0 === userDelegationKeyCredential) throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
            if (version >= "2020-12-06") if (void 0 !== sharedKeyCredential) return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
            else return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
            if (version >= "2018-11-09") if (void 0 !== sharedKeyCredential) return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
            else if (version >= "2020-02-10") return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
            else return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
            if (version >= "2015-04-05") if (void 0 !== sharedKeyCredential) return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
            else throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
            throw new RangeError("'version' must be >= '2015-04-05'.");
        }
        function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
            blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
            if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
            let resource = "c";
            if (blobSASSignatureValues.blobName) resource = "b";
            let verifiedPermissions;
            if (blobSASSignatureValues.permissions) verifiedPermissions = blobSASSignatureValues.blobName ? BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
            const stringToSign = [
                verifiedPermissions ? verifiedPermissions : "",
                blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
                blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
                getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
                blobSASSignatureValues.identifier,
                blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
                blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
                blobSASSignatureValues.version,
                blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
                blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
                blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
                blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
                blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
            ].join("\n");
            const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
            return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType);
        }
        function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
            blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
            if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
            let resource = "c";
            let timestamp = blobSASSignatureValues.snapshotTime;
            if (blobSASSignatureValues.blobName) {
                resource = "b";
                if (blobSASSignatureValues.snapshotTime) resource = "bs";
                else if (blobSASSignatureValues.versionId) {
                    resource = "bv";
                    timestamp = blobSASSignatureValues.versionId;
                }
            }
            let verifiedPermissions;
            if (blobSASSignatureValues.permissions) verifiedPermissions = blobSASSignatureValues.blobName ? BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
            const stringToSign = [
                verifiedPermissions ? verifiedPermissions : "",
                blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
                blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
                getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
                blobSASSignatureValues.identifier,
                blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
                blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
                blobSASSignatureValues.version,
                resource,
                timestamp,
                blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
                blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
                blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
                blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
                blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
            ].join("\n");
            const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
            return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType);
        }
        function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
            blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
            if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
            let resource = "c";
            let timestamp = blobSASSignatureValues.snapshotTime;
            if (blobSASSignatureValues.blobName) {
                resource = "b";
                if (blobSASSignatureValues.snapshotTime) resource = "bs";
                else if (blobSASSignatureValues.versionId) {
                    resource = "bv";
                    timestamp = blobSASSignatureValues.versionId;
                }
            }
            let verifiedPermissions;
            if (blobSASSignatureValues.permissions) verifiedPermissions = blobSASSignatureValues.blobName ? BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
            const stringToSign = [
                verifiedPermissions ? verifiedPermissions : "",
                blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
                blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
                getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
                blobSASSignatureValues.identifier,
                blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
                blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
                blobSASSignatureValues.version,
                resource,
                timestamp,
                blobSASSignatureValues.encryptionScope,
                blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
                blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
                blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
                blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
                blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
            ].join("\n");
            const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
            return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, void 0, void 0, void 0, blobSASSignatureValues.encryptionScope);
        }
        function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
            blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
            if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
            let resource = "c";
            let timestamp = blobSASSignatureValues.snapshotTime;
            if (blobSASSignatureValues.blobName) {
                resource = "b";
                if (blobSASSignatureValues.snapshotTime) resource = "bs";
                else if (blobSASSignatureValues.versionId) {
                    resource = "bv";
                    timestamp = blobSASSignatureValues.versionId;
                }
            }
            let verifiedPermissions;
            if (blobSASSignatureValues.permissions) verifiedPermissions = blobSASSignatureValues.blobName ? BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
            const stringToSign = [
                verifiedPermissions ? verifiedPermissions : "",
                blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
                blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
                getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
                userDelegationKeyCredential.userDelegationKey.signedObjectId,
                userDelegationKeyCredential.userDelegationKey.signedTenantId,
                userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
                userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
                userDelegationKeyCredential.userDelegationKey.signedService,
                userDelegationKeyCredential.userDelegationKey.signedVersion,
                blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
                blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
                blobSASSignatureValues.version,
                resource,
                timestamp,
                blobSASSignatureValues.cacheControl,
                blobSASSignatureValues.contentDisposition,
                blobSASSignatureValues.contentEncoding,
                blobSASSignatureValues.contentLanguage,
                blobSASSignatureValues.contentType
            ].join("\n");
            const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
            return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey);
        }
        function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
            blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
            if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
            let resource = "c";
            let timestamp = blobSASSignatureValues.snapshotTime;
            if (blobSASSignatureValues.blobName) {
                resource = "b";
                if (blobSASSignatureValues.snapshotTime) resource = "bs";
                else if (blobSASSignatureValues.versionId) {
                    resource = "bv";
                    timestamp = blobSASSignatureValues.versionId;
                }
            }
            let verifiedPermissions;
            if (blobSASSignatureValues.permissions) verifiedPermissions = blobSASSignatureValues.blobName ? BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
            const stringToSign = [
                verifiedPermissions ? verifiedPermissions : "",
                blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
                blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
                getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
                userDelegationKeyCredential.userDelegationKey.signedObjectId,
                userDelegationKeyCredential.userDelegationKey.signedTenantId,
                userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
                userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
                userDelegationKeyCredential.userDelegationKey.signedService,
                userDelegationKeyCredential.userDelegationKey.signedVersion,
                blobSASSignatureValues.preauthorizedAgentObjectId,
                void 0,
                blobSASSignatureValues.correlationId,
                blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
                blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
                blobSASSignatureValues.version,
                resource,
                timestamp,
                blobSASSignatureValues.cacheControl,
                blobSASSignatureValues.contentDisposition,
                blobSASSignatureValues.contentEncoding,
                blobSASSignatureValues.contentLanguage,
                blobSASSignatureValues.contentType
            ].join("\n");
            const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
            return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId);
        }
        function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
            blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
            if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
            let resource = "c";
            let timestamp = blobSASSignatureValues.snapshotTime;
            if (blobSASSignatureValues.blobName) {
                resource = "b";
                if (blobSASSignatureValues.snapshotTime) resource = "bs";
                else if (blobSASSignatureValues.versionId) {
                    resource = "bv";
                    timestamp = blobSASSignatureValues.versionId;
                }
            }
            let verifiedPermissions;
            if (blobSASSignatureValues.permissions) verifiedPermissions = blobSASSignatureValues.blobName ? BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
            const stringToSign = [
                verifiedPermissions ? verifiedPermissions : "",
                blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
                blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
                getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
                userDelegationKeyCredential.userDelegationKey.signedObjectId,
                userDelegationKeyCredential.userDelegationKey.signedTenantId,
                userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
                userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
                userDelegationKeyCredential.userDelegationKey.signedService,
                userDelegationKeyCredential.userDelegationKey.signedVersion,
                blobSASSignatureValues.preauthorizedAgentObjectId,
                void 0,
                blobSASSignatureValues.correlationId,
                blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
                blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
                blobSASSignatureValues.version,
                resource,
                timestamp,
                blobSASSignatureValues.encryptionScope,
                blobSASSignatureValues.cacheControl,
                blobSASSignatureValues.contentDisposition,
                blobSASSignatureValues.contentEncoding,
                blobSASSignatureValues.contentLanguage,
                blobSASSignatureValues.contentType
            ].join("\n");
            const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
            return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope);
        }
        function getCanonicalName(accountName, containerName, blobName) {
            const elements = [
                `/blob/${accountName}/${containerName}`
            ];
            if (blobName) elements.push(`/${blobName}`);
            return elements.join("");
        }
        function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
            const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;
            if (blobSASSignatureValues.snapshotTime && version < "2018-11-09") throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
            if (void 0 === blobSASSignatureValues.blobName && blobSASSignatureValues.snapshotTime) throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
            if (blobSASSignatureValues.versionId && version < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
            if (void 0 === blobSASSignatureValues.blobName && blobSASSignatureValues.versionId) throw RangeError("Must provide 'blobName' when providing 'versionId'.");
            if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04") throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
            if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
            if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
            if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version < "2019-12-12") throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
            if (version < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
            if (version < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
            if (version < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
            if (blobSASSignatureValues.encryptionScope && version < "2020-12-06") throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
            blobSASSignatureValues.version = version;
            return blobSASSignatureValues;
        }
        class blob_Blob {
            constructor(client){
                this.client = client;
            }
            download(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, downloadOperationSpec);
            }
            getProperties(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, blob_getPropertiesOperationSpec);
            }
            delete(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, blob_deleteOperationSpec);
            }
            undelete(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, undeleteOperationSpec);
            }
            setExpiry(expiryOptions, options) {
                const operationArguments = {
                    expiryOptions,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, setExpiryOperationSpec);
            }
            setHttpHeaders(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, setHttpHeadersOperationSpec);
            }
            setImmutabilityPolicy(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, setImmutabilityPolicyOperationSpec);
            }
            deleteImmutabilityPolicy(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, deleteImmutabilityPolicyOperationSpec);
            }
            setLegalHold(legalHold, options) {
                const operationArguments = {
                    legalHold,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, setLegalHoldOperationSpec);
            }
            setMetadata(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, blob_setMetadataOperationSpec);
            }
            acquireLease(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, blob_acquireLeaseOperationSpec);
            }
            releaseLease(leaseId, options) {
                const operationArguments = {
                    leaseId,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, blob_releaseLeaseOperationSpec);
            }
            renewLease(leaseId, options) {
                const operationArguments = {
                    leaseId,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, blob_renewLeaseOperationSpec);
            }
            changeLease(leaseId, proposedLeaseId, options) {
                const operationArguments = {
                    leaseId,
                    proposedLeaseId,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, blob_changeLeaseOperationSpec);
            }
            breakLease(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, blob_breakLeaseOperationSpec);
            }
            createSnapshot(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, createSnapshotOperationSpec);
            }
            startCopyFromURL(copySource, options) {
                const operationArguments = {
                    copySource,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, startCopyFromURLOperationSpec);
            }
            copyFromURL(copySource, options) {
                const operationArguments = {
                    copySource,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, copyFromURLOperationSpec);
            }
            abortCopyFromURL(copyId, options) {
                const operationArguments = {
                    copyId,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, abortCopyFromURLOperationSpec);
            }
            setTier(tier, options) {
                const operationArguments = {
                    tier,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, setTierOperationSpec);
            }
            getAccountInfo(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, blob_getAccountInfoOperationSpec);
            }
            query(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, queryOperationSpec);
            }
            getTags(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, getTagsOperationSpec);
            }
            setTags(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, setTagsOperationSpec);
            }
        }
        const blob_xmlSerializer = new Serializer(mappers_namespaceObject, true);
        const downloadOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: {
                        type: {
                            name: "Stream"
                        },
                        serializedName: "parsedResponse"
                    },
                    headersMapper: BlobDownloadHeaders
                },
                206: {
                    bodyMapper: {
                        type: {
                            name: "Stream"
                        },
                        serializedName: "parsedResponse"
                    },
                    headersMapper: BlobDownloadHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobDownloadExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_snapshot,
                parameters_versionId
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                parameters_range,
                rangeGetContentMD5,
                rangeGetContentCRC64,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const blob_getPropertiesOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "HEAD",
            responses: {
                200: {
                    headersMapper: BlobGetPropertiesHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobGetPropertiesExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_snapshot,
                parameters_versionId
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const blob_deleteOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "DELETE",
            responses: {
                202: {
                    headersMapper: BlobDeleteHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobDeleteExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_snapshot,
                parameters_versionId,
                blobDeleteType
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                ifMatch,
                ifNoneMatch,
                ifTags,
                deleteSnapshots
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const undeleteOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobUndeleteHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobUndeleteExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp8
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const setExpiryOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobSetExpiryHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobSetExpiryExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp11
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_expiryOptions,
                parameters_expiresOn
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const setHttpHeadersOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobSetHttpHeadersHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobSetHttpHeadersExceptionHeaders
                }
            },
            queryParameters: [
                comp,
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                ifMatch,
                ifNoneMatch,
                ifTags,
                blobCacheControl,
                blobContentType,
                blobContentMD5,
                blobContentEncoding,
                blobContentLanguage,
                blobContentDisposition
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const setImmutabilityPolicyOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobSetImmutabilityPolicyHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobSetImmutabilityPolicyExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp12
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifUnmodifiedSince,
                immutabilityPolicyExpiry,
                immutabilityPolicyMode
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const deleteImmutabilityPolicyOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "DELETE",
            responses: {
                200: {
                    headersMapper: BlobDeleteImmutabilityPolicyHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobDeleteImmutabilityPolicyExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp12
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const setLegalHoldOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobSetLegalHoldHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobSetLegalHoldExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp13
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_legalHold
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const blob_setMetadataOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobSetMetadataHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobSetMetadataExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp6
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_encryptionScope
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const blob_acquireLeaseOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: BlobAcquireLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobAcquireLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                action,
                parameters_duration,
                parameters_proposedLeaseId,
                ifMatch,
                ifNoneMatch,
                ifTags
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const blob_releaseLeaseOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobReleaseLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobReleaseLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                action1,
                leaseId1,
                ifMatch,
                ifNoneMatch,
                ifTags
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const blob_renewLeaseOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobRenewLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobRenewLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                leaseId1,
                action2,
                ifMatch,
                ifNoneMatch,
                ifTags
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const blob_changeLeaseOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobChangeLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobChangeLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                leaseId1,
                action4,
                proposedLeaseId1,
                ifMatch,
                ifNoneMatch,
                ifTags
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const blob_breakLeaseOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                202: {
                    headersMapper: BlobBreakLeaseHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobBreakLeaseExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp10
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                action3,
                parameters_breakPeriod,
                ifMatch,
                ifNoneMatch,
                ifTags
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const createSnapshotOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: BlobCreateSnapshotHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobCreateSnapshotExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp14
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_encryptionScope
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const startCopyFromURLOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                202: {
                    headersMapper: BlobStartCopyFromURLHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobStartCopyFromURLExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                ifMatch,
                ifNoneMatch,
                ifTags,
                immutabilityPolicyExpiry,
                immutabilityPolicyMode,
                parameters_tier,
                rehydratePriority,
                sourceIfModifiedSince,
                sourceIfUnmodifiedSince,
                sourceIfMatch,
                sourceIfNoneMatch,
                sourceIfTags,
                parameters_copySource,
                blobTagsString,
                sealBlob,
                legalHold1
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const copyFromURLOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                202: {
                    headersMapper: BlobCopyFromURLHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobCopyFromURLExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                ifMatch,
                ifNoneMatch,
                ifTags,
                immutabilityPolicyExpiry,
                immutabilityPolicyMode,
                parameters_encryptionScope,
                parameters_tier,
                sourceIfModifiedSince,
                sourceIfUnmodifiedSince,
                sourceIfMatch,
                sourceIfNoneMatch,
                parameters_copySource,
                blobTagsString,
                legalHold1,
                xMsRequiresSync,
                sourceContentMD5,
                copySourceAuthorization,
                copySourceTags
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const abortCopyFromURLOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                204: {
                    headersMapper: BlobAbortCopyFromURLHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobAbortCopyFromURLExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp15,
                parameters_copyId
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                copyActionAbortConstant
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const setTierOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: BlobSetTierHeaders
                },
                202: {
                    headersMapper: BlobSetTierHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobSetTierExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_snapshot,
                parameters_versionId,
                comp16
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifTags,
                rehydratePriority,
                tier1
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const blob_getAccountInfoOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "GET",
            responses: {
                200: {
                    headersMapper: BlobGetAccountInfoHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobGetAccountInfoExceptionHeaders
                }
            },
            queryParameters: [
                comp,
                restype1
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                accept1
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const queryOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "POST",
            responses: {
                200: {
                    bodyMapper: {
                        type: {
                            name: "Stream"
                        },
                        serializedName: "parsedResponse"
                    },
                    headersMapper: BlobQueryHeaders
                },
                206: {
                    bodyMapper: {
                        type: {
                            name: "Stream"
                        },
                        serializedName: "parsedResponse"
                    },
                    headersMapper: BlobQueryHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobQueryExceptionHeaders
                }
            },
            requestBody: queryRequest,
            queryParameters: [
                timeoutInSeconds,
                parameters_snapshot,
                comp17
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_contentType,
                parameters_accept,
                parameters_version,
                requestId,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags
            ],
            isXML: true,
            contentType: "application/xml; charset=utf-8",
            mediaType: "xml",
            serializer: blob_xmlSerializer
        };
        const getTagsOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: BlobTags,
                    headersMapper: BlobGetTagsHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobGetTagsExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_snapshot,
                parameters_versionId,
                comp18
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifTags
            ],
            isXML: true,
            serializer: blob_xmlSerializer
        };
        const setTagsOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                204: {
                    headersMapper: BlobSetTagsHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlobSetTagsExceptionHeaders
                }
            },
            requestBody: parameters_tags,
            queryParameters: [
                timeoutInSeconds,
                parameters_versionId,
                comp18
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_contentType,
                parameters_accept,
                parameters_version,
                requestId,
                parameters_leaseId,
                ifTags,
                transactionalContentMD5,
                transactionalContentCrc64
            ],
            isXML: true,
            contentType: "application/xml; charset=utf-8",
            mediaType: "xml",
            serializer: blob_xmlSerializer
        };
        class BlobLeaseClient {
            constructor(client, leaseId){
                const clientContext = new StorageClientContext(client.url, client.pipeline.toServiceClientOptions());
                this._url = client.url;
                if (void 0 === client.name) {
                    this._isContainer = true;
                    this._containerOrBlobOperation = new Container(clientContext);
                } else {
                    this._isContainer = false;
                    this._containerOrBlobOperation = new blob_Blob(clientContext);
                }
                if (!leaseId) leaseId = generateUuid();
                this._leaseId = leaseId;
            }
            get leaseId() {
                return this._leaseId;
            }
            get url() {
                return this._url;
            }
            async acquireLease(duration, options = {}) {
                var _a, _b, _c, _d, _e, _f;
                const { span, updatedOptions } = tracing_createSpan("BlobLeaseClient-acquireLease", options);
                if (this._isContainer && ((null == (_a = options.conditions) ? void 0 : _a.ifMatch) && (null == (_b = options.conditions) ? void 0 : _b.ifMatch) !== "" || (null == (_c = options.conditions) ? void 0 : _c.ifNoneMatch) && (null == (_d = options.conditions) ? void 0 : _d.ifNoneMatch) !== "" || (null == (_e = options.conditions) ? void 0 : _e.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                try {
                    return await this._containerOrBlobOperation.acquireLease(Object.assign({
                        abortSignal: options.abortSignal,
                        duration,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_f = options.conditions) ? void 0 : _f.tagConditions
                        }),
                        proposedLeaseId: this._leaseId
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async changeLease(proposedLeaseId, options = {}) {
                var _a, _b, _c, _d, _e, _f;
                const { span, updatedOptions } = tracing_createSpan("BlobLeaseClient-changeLease", options);
                if (this._isContainer && ((null == (_a = options.conditions) ? void 0 : _a.ifMatch) && (null == (_b = options.conditions) ? void 0 : _b.ifMatch) !== "" || (null == (_c = options.conditions) ? void 0 : _c.ifNoneMatch) && (null == (_d = options.conditions) ? void 0 : _d.ifNoneMatch) !== "" || (null == (_e = options.conditions) ? void 0 : _e.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                try {
                    const response = await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId, Object.assign({
                        abortSignal: options.abortSignal,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_f = options.conditions) ? void 0 : _f.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    this._leaseId = proposedLeaseId;
                    return response;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async releaseLease(options = {}) {
                var _a, _b, _c, _d, _e, _f;
                const { span, updatedOptions } = tracing_createSpan("BlobLeaseClient-releaseLease", options);
                if (this._isContainer && ((null == (_a = options.conditions) ? void 0 : _a.ifMatch) && (null == (_b = options.conditions) ? void 0 : _b.ifMatch) !== "" || (null == (_c = options.conditions) ? void 0 : _c.ifNoneMatch) && (null == (_d = options.conditions) ? void 0 : _d.ifNoneMatch) !== "" || (null == (_e = options.conditions) ? void 0 : _e.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                try {
                    return await this._containerOrBlobOperation.releaseLease(this._leaseId, Object.assign({
                        abortSignal: options.abortSignal,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_f = options.conditions) ? void 0 : _f.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async renewLease(options = {}) {
                var _a, _b, _c, _d, _e, _f;
                const { span, updatedOptions } = tracing_createSpan("BlobLeaseClient-renewLease", options);
                if (this._isContainer && ((null == (_a = options.conditions) ? void 0 : _a.ifMatch) && (null == (_b = options.conditions) ? void 0 : _b.ifMatch) !== "" || (null == (_c = options.conditions) ? void 0 : _c.ifNoneMatch) && (null == (_d = options.conditions) ? void 0 : _d.ifNoneMatch) !== "" || (null == (_e = options.conditions) ? void 0 : _e.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                try {
                    return await this._containerOrBlobOperation.renewLease(this._leaseId, Object.assign({
                        abortSignal: options.abortSignal,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_f = options.conditions) ? void 0 : _f.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async breakLease(breakPeriod, options = {}) {
                var _a, _b, _c, _d, _e, _f;
                const { span, updatedOptions } = tracing_createSpan("BlobLeaseClient-breakLease", options);
                if (this._isContainer && ((null == (_a = options.conditions) ? void 0 : _a.ifMatch) && (null == (_b = options.conditions) ? void 0 : _b.ifMatch) !== "" || (null == (_c = options.conditions) ? void 0 : _c.ifNoneMatch) && (null == (_d = options.conditions) ? void 0 : _d.ifNoneMatch) !== "" || (null == (_e = options.conditions) ? void 0 : _e.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                try {
                    const operationOptions = Object.assign({
                        abortSignal: options.abortSignal,
                        breakPeriod,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_f = options.conditions) ? void 0 : _f.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions));
                    return await this._containerOrBlobOperation.breakLease(operationOptions);
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
        }
        class RetriableReadableStream extends external_stream_.Readable {
            constructor(source, getter, offset, count, options = {}){
                super({
                    highWaterMark: options.highWaterMark
                });
                this.retries = 0;
                this.sourceDataHandler = (data)=>{
                    if (this.options.doInjectErrorOnce) {
                        this.options.doInjectErrorOnce = void 0;
                        this.source.pause();
                        this.source.removeAllListeners("data");
                        this.source.emit("end");
                        return;
                    }
                    this.offset += data.length;
                    if (this.onProgress) this.onProgress({
                        loadedBytes: this.offset - this.start
                    });
                    if (!this.push(data)) this.source.pause();
                };
                this.sourceErrorOrEndHandler = (err)=>{
                    if (err && "AbortError" === err.name) return void this.destroy(err);
                    this.removeSourceEventHandlers();
                    if (this.offset - 1 === this.end) this.push(null);
                    else if (this.offset <= this.end) if (this.retries < this.maxRetryRequests) {
                        this.retries += 1;
                        this.getter(this.offset).then((newSource)=>{
                            this.source = newSource;
                            this.setSourceEventHandlers();
                        }).catch((error)=>{
                            this.destroy(error);
                        });
                    } else this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
                    else this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
                };
                this.getter = getter;
                this.source = source;
                this.start = offset;
                this.offset = offset;
                this.end = offset + count - 1;
                this.maxRetryRequests = options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
                this.onProgress = options.onProgress;
                this.options = options;
                this.setSourceEventHandlers();
            }
            _read() {
                this.source.resume();
            }
            setSourceEventHandlers() {
                this.source.on("data", this.sourceDataHandler);
                this.source.on("end", this.sourceErrorOrEndHandler);
                this.source.on("error", this.sourceErrorOrEndHandler);
            }
            removeSourceEventHandlers() {
                this.source.removeListener("data", this.sourceDataHandler);
                this.source.removeListener("end", this.sourceErrorOrEndHandler);
                this.source.removeListener("error", this.sourceErrorOrEndHandler);
            }
            _destroy(error, callback) {
                this.removeSourceEventHandlers();
                this.source.destroy();
                callback(null === error ? void 0 : error);
            }
        }
        class BlobDownloadResponse {
            constructor(originalResponse, getter, offset, count, options = {}){
                this.originalResponse = originalResponse;
                this.blobDownloadStream = new RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
            }
            get acceptRanges() {
                return this.originalResponse.acceptRanges;
            }
            get cacheControl() {
                return this.originalResponse.cacheControl;
            }
            get contentDisposition() {
                return this.originalResponse.contentDisposition;
            }
            get contentEncoding() {
                return this.originalResponse.contentEncoding;
            }
            get contentLanguage() {
                return this.originalResponse.contentLanguage;
            }
            get blobSequenceNumber() {
                return this.originalResponse.blobSequenceNumber;
            }
            get blobType() {
                return this.originalResponse.blobType;
            }
            get contentLength() {
                return this.originalResponse.contentLength;
            }
            get contentMD5() {
                return this.originalResponse.contentMD5;
            }
            get contentRange() {
                return this.originalResponse.contentRange;
            }
            get contentType() {
                return this.originalResponse.contentType;
            }
            get copyCompletedOn() {
                return this.originalResponse.copyCompletedOn;
            }
            get copyId() {
                return this.originalResponse.copyId;
            }
            get copyProgress() {
                return this.originalResponse.copyProgress;
            }
            get copySource() {
                return this.originalResponse.copySource;
            }
            get copyStatus() {
                return this.originalResponse.copyStatus;
            }
            get copyStatusDescription() {
                return this.originalResponse.copyStatusDescription;
            }
            get leaseDuration() {
                return this.originalResponse.leaseDuration;
            }
            get leaseState() {
                return this.originalResponse.leaseState;
            }
            get leaseStatus() {
                return this.originalResponse.leaseStatus;
            }
            get date() {
                return this.originalResponse.date;
            }
            get blobCommittedBlockCount() {
                return this.originalResponse.blobCommittedBlockCount;
            }
            get etag() {
                return this.originalResponse.etag;
            }
            get tagCount() {
                return this.originalResponse.tagCount;
            }
            get errorCode() {
                return this.originalResponse.errorCode;
            }
            get isServerEncrypted() {
                return this.originalResponse.isServerEncrypted;
            }
            get blobContentMD5() {
                return this.originalResponse.blobContentMD5;
            }
            get lastModified() {
                return this.originalResponse.lastModified;
            }
            get lastAccessed() {
                return this.originalResponse.lastAccessed;
            }
            get createdOn() {
                return this.originalResponse.createdOn;
            }
            get metadata() {
                return this.originalResponse.metadata;
            }
            get requestId() {
                return this.originalResponse.requestId;
            }
            get clientRequestId() {
                return this.originalResponse.clientRequestId;
            }
            get version() {
                return this.originalResponse.version;
            }
            get versionId() {
                return this.originalResponse.versionId;
            }
            get isCurrentVersion() {
                return this.originalResponse.isCurrentVersion;
            }
            get encryptionKeySha256() {
                return this.originalResponse.encryptionKeySha256;
            }
            get contentCrc64() {
                return this.originalResponse.contentCrc64;
            }
            get objectReplicationDestinationPolicyId() {
                return this.originalResponse.objectReplicationDestinationPolicyId;
            }
            get objectReplicationSourceProperties() {
                return this.originalResponse.objectReplicationSourceProperties;
            }
            get isSealed() {
                return this.originalResponse.isSealed;
            }
            get immutabilityPolicyExpiresOn() {
                return this.originalResponse.immutabilityPolicyExpiresOn;
            }
            get immutabilityPolicyMode() {
                return this.originalResponse.immutabilityPolicyMode;
            }
            get legalHold() {
                return this.originalResponse.legalHold;
            }
            get contentAsBlob() {
                return this.originalResponse.blobBody;
            }
            get readableStreamBody() {
                return checkEnvironment_isNode ? this.blobDownloadStream : void 0;
            }
            get _response() {
                return this.originalResponse._response;
            }
        }
        const AVRO_INIT_BYTES = new Uint8Array([
            79,
            98,
            106,
            1
        ]);
        const AVRO_CODEC_KEY = "avro.codec";
        const AVRO_SCHEMA_KEY = "avro.schema";
        class AvroParser {
            static async readFixedBytes(stream, length, options = {}) {
                const bytes = await stream.read(length, {
                    abortSignal: options.abortSignal
                });
                if (bytes.length !== length) throw new Error("Hit stream end.");
                return bytes;
            }
            static async readByte(stream, options = {}) {
                const buf = await AvroParser.readFixedBytes(stream, 1, options);
                return buf[0];
            }
            static async readZigZagLong(stream, options = {}) {
                let zigZagEncoded = 0;
                let significanceInBit = 0;
                let byte, haveMoreByte, significanceInFloat;
                do {
                    byte = await AvroParser.readByte(stream, options);
                    haveMoreByte = 0x80 & byte;
                    zigZagEncoded |= (0x7f & byte) << significanceInBit;
                    significanceInBit += 7;
                }while (haveMoreByte && significanceInBit < 28);
                if (haveMoreByte) {
                    significanceInFloat = 268435456;
                    do {
                        byte = await AvroParser.readByte(stream, options);
                        zigZagEncoded += (0x7f & byte) * significanceInFloat;
                        significanceInFloat *= 128;
                    }while (0x80 & byte);
                    const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
                    if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) throw new Error("Integer overflow.");
                    return res;
                }
                return zigZagEncoded >> 1 ^ -(1 & zigZagEncoded);
            }
            static async readLong(stream, options = {}) {
                return AvroParser.readZigZagLong(stream, options);
            }
            static async readInt(stream, options = {}) {
                return AvroParser.readZigZagLong(stream, options);
            }
            static async readNull() {
                return null;
            }
            static async readBoolean(stream, options = {}) {
                const b = await AvroParser.readByte(stream, options);
                if (1 === b) return true;
                if (0 === b) return false;
                throw new Error("Byte was not a boolean.");
            }
            static async readFloat(stream, options = {}) {
                const u8arr = await AvroParser.readFixedBytes(stream, 4, options);
                const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
                return view.getFloat32(0, true);
            }
            static async readDouble(stream, options = {}) {
                const u8arr = await AvroParser.readFixedBytes(stream, 8, options);
                const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
                return view.getFloat64(0, true);
            }
            static async readBytes(stream, options = {}) {
                const size = await AvroParser.readLong(stream, options);
                if (size < 0) throw new Error("Bytes size was negative.");
                return stream.read(size, {
                    abortSignal: options.abortSignal
                });
            }
            static async readString(stream, options = {}) {
                const u8arr = await AvroParser.readBytes(stream, options);
                const utf8decoder = new TextDecoder();
                return utf8decoder.decode(u8arr);
            }
            static async readMapPair(stream, readItemMethod, options = {}) {
                const key = await AvroParser.readString(stream, options);
                const value = await readItemMethod(stream, options);
                return {
                    key,
                    value
                };
            }
            static async readMap(stream, readItemMethod, options = {}) {
                const readPairMethod = (s, opts = {})=>AvroParser.readMapPair(s, readItemMethod, opts);
                const pairs = await AvroParser.readArray(stream, readPairMethod, options);
                const dict = {};
                for (const pair of pairs)dict[pair.key] = pair.value;
                return dict;
            }
            static async readArray(stream, readItemMethod, options = {}) {
                const items = [];
                for(let count = await AvroParser.readLong(stream, options); 0 !== count; count = await AvroParser.readLong(stream, options)){
                    if (count < 0) {
                        await AvroParser.readLong(stream, options);
                        count = -count;
                    }
                    while(count--){
                        const item = await readItemMethod(stream, options);
                        items.push(item);
                    }
                }
                return items;
            }
        }
        var AvroParser_AvroComplex;
        (function(AvroComplex) {
            AvroComplex["RECORD"] = "record";
            AvroComplex["ENUM"] = "enum";
            AvroComplex["ARRAY"] = "array";
            AvroComplex["MAP"] = "map";
            AvroComplex["UNION"] = "union";
            AvroComplex["FIXED"] = "fixed";
        })(AvroParser_AvroComplex || (AvroParser_AvroComplex = {}));
        var AvroParser_AvroPrimitive;
        (function(AvroPrimitive) {
            AvroPrimitive["NULL"] = "null";
            AvroPrimitive["BOOLEAN"] = "boolean";
            AvroPrimitive["INT"] = "int";
            AvroPrimitive["LONG"] = "long";
            AvroPrimitive["FLOAT"] = "float";
            AvroPrimitive["DOUBLE"] = "double";
            AvroPrimitive["BYTES"] = "bytes";
            AvroPrimitive["STRING"] = "string";
        })(AvroParser_AvroPrimitive || (AvroParser_AvroPrimitive = {}));
        class AvroType {
            static fromSchema(schema) {
                if ("string" == typeof schema) return AvroType.fromStringSchema(schema);
                if (Array.isArray(schema)) return AvroType.fromArraySchema(schema);
                return AvroType.fromObjectSchema(schema);
            }
            static fromStringSchema(schema) {
                switch(schema){
                    case AvroParser_AvroPrimitive.NULL:
                    case AvroParser_AvroPrimitive.BOOLEAN:
                    case AvroParser_AvroPrimitive.INT:
                    case AvroParser_AvroPrimitive.LONG:
                    case AvroParser_AvroPrimitive.FLOAT:
                    case AvroParser_AvroPrimitive.DOUBLE:
                    case AvroParser_AvroPrimitive.BYTES:
                    case AvroParser_AvroPrimitive.STRING:
                        return new AvroPrimitiveType(schema);
                    default:
                        throw new Error(`Unexpected Avro type ${schema}`);
                }
            }
            static fromArraySchema(schema) {
                return new AvroUnionType(schema.map(AvroType.fromSchema));
            }
            static fromObjectSchema(schema) {
                const type = schema.type;
                try {
                    return AvroType.fromStringSchema(type);
                } catch (err) {}
                switch(type){
                    case AvroParser_AvroComplex.RECORD:
                        if (schema.aliases) throw new Error(`aliases currently is not supported, schema: ${schema}`);
                        if (!schema.name) throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
                        const fields = {};
                        if (!schema.fields) throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
                        for (const field of schema.fields)fields[field.name] = AvroType.fromSchema(field.type);
                        return new AvroRecordType(fields, schema.name);
                    case AvroParser_AvroComplex.ENUM:
                        if (schema.aliases) throw new Error(`aliases currently is not supported, schema: ${schema}`);
                        if (!schema.symbols) throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
                        return new AvroEnumType(schema.symbols);
                    case AvroParser_AvroComplex.MAP:
                        if (!schema.values) throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
                        return new AvroMapType(AvroType.fromSchema(schema.values));
                    case AvroParser_AvroComplex.ARRAY:
                    case AvroParser_AvroComplex.FIXED:
                    default:
                        throw new Error(`Unexpected Avro type ${type} in ${schema}`);
                }
            }
        }
        class AvroPrimitiveType extends AvroType {
            constructor(primitive){
                super();
                this._primitive = primitive;
            }
            read(stream, options = {}) {
                switch(this._primitive){
                    case AvroParser_AvroPrimitive.NULL:
                        return AvroParser.readNull();
                    case AvroParser_AvroPrimitive.BOOLEAN:
                        return AvroParser.readBoolean(stream, options);
                    case AvroParser_AvroPrimitive.INT:
                        return AvroParser.readInt(stream, options);
                    case AvroParser_AvroPrimitive.LONG:
                        return AvroParser.readLong(stream, options);
                    case AvroParser_AvroPrimitive.FLOAT:
                        return AvroParser.readFloat(stream, options);
                    case AvroParser_AvroPrimitive.DOUBLE:
                        return AvroParser.readDouble(stream, options);
                    case AvroParser_AvroPrimitive.BYTES:
                        return AvroParser.readBytes(stream, options);
                    case AvroParser_AvroPrimitive.STRING:
                        return AvroParser.readString(stream, options);
                    default:
                        throw new Error("Unknown Avro Primitive");
                }
            }
        }
        class AvroEnumType extends AvroType {
            constructor(symbols){
                super();
                this._symbols = symbols;
            }
            async read(stream, options = {}) {
                const value = await AvroParser.readInt(stream, options);
                return this._symbols[value];
            }
        }
        class AvroUnionType extends AvroType {
            constructor(types){
                super();
                this._types = types;
            }
            async read(stream, options = {}) {
                const typeIndex = await AvroParser.readInt(stream, options);
                return this._types[typeIndex].read(stream, options);
            }
        }
        class AvroMapType extends AvroType {
            constructor(itemType){
                super();
                this._itemType = itemType;
            }
            read(stream, options = {}) {
                const readItemMethod = (s, opts)=>this._itemType.read(s, opts);
                return AvroParser.readMap(stream, readItemMethod, options);
            }
        }
        class AvroRecordType extends AvroType {
            constructor(fields, name){
                super();
                this._fields = fields;
                this._name = name;
            }
            async read(stream, options = {}) {
                const record = {};
                record["$schema"] = this._name;
                for(const key in this._fields)if (Object.prototype.hasOwnProperty.call(this._fields, key)) record[key] = await this._fields[key].read(stream, options);
                return record;
            }
        }
        function arraysEqual(a, b) {
            if (a === b) return true;
            if (null == a || null == b) return false;
            if (a.length !== b.length) return false;
            for(let i = 0; i < a.length; ++i)if (a[i] !== b[i]) return false;
            return true;
        }
        class AvroReader {
            constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock){
                this._dataStream = dataStream;
                this._headerStream = headerStream || dataStream;
                this._initialized = false;
                this._blockOffset = currentBlockOffset || 0;
                this._objectIndex = indexWithinCurrentBlock || 0;
                this._initialBlockOffset = currentBlockOffset || 0;
            }
            get blockOffset() {
                return this._blockOffset;
            }
            get objectIndex() {
                return this._objectIndex;
            }
            async initialize(options = {}) {
                const header = await AvroParser.readFixedBytes(this._headerStream, AVRO_INIT_BYTES.length, {
                    abortSignal: options.abortSignal
                });
                if (!arraysEqual(header, AVRO_INIT_BYTES)) throw new Error("Stream is not an Avro file.");
                this._metadata = await AvroParser.readMap(this._headerStream, AvroParser.readString, {
                    abortSignal: options.abortSignal
                });
                const codec = this._metadata[AVRO_CODEC_KEY];
                if (!(null == codec || "null" === codec)) throw new Error("Codecs are not supported");
                this._syncMarker = await AvroParser.readFixedBytes(this._headerStream, 16, {
                    abortSignal: options.abortSignal
                });
                const schema = JSON.parse(this._metadata[AVRO_SCHEMA_KEY]);
                this._itemType = AvroType.fromSchema(schema);
                if (0 === this._blockOffset) this._blockOffset = this._initialBlockOffset + this._dataStream.position;
                this._itemsRemainingInBlock = await AvroParser.readLong(this._dataStream, {
                    abortSignal: options.abortSignal
                });
                await AvroParser.readLong(this._dataStream, {
                    abortSignal: options.abortSignal
                });
                this._initialized = true;
                if (this._objectIndex && this._objectIndex > 0) for(let i = 0; i < this._objectIndex; i++){
                    await this._itemType.read(this._dataStream, {
                        abortSignal: options.abortSignal
                    });
                    this._itemsRemainingInBlock--;
                }
            }
            hasNext() {
                return !this._initialized || this._itemsRemainingInBlock > 0;
            }
            parseObjects(options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    if (!this._initialized) yield __await(this.initialize(options));
                    while(this.hasNext()){
                        const result = yield __await(this._itemType.read(this._dataStream, {
                            abortSignal: options.abortSignal
                        }));
                        this._itemsRemainingInBlock--;
                        this._objectIndex++;
                        if (0 === this._itemsRemainingInBlock) {
                            const marker = yield __await(AvroParser.readFixedBytes(this._dataStream, 16, {
                                abortSignal: options.abortSignal
                            }));
                            this._blockOffset = this._initialBlockOffset + this._dataStream.position;
                            this._objectIndex = 0;
                            if (!arraysEqual(this._syncMarker, marker)) throw new Error("Stream is not a valid Avro file.");
                            try {
                                this._itemsRemainingInBlock = yield __await(AvroParser.readLong(this._dataStream, {
                                    abortSignal: options.abortSignal
                                }));
                            } catch (err) {
                                this._itemsRemainingInBlock = 0;
                            }
                            if (this._itemsRemainingInBlock > 0) yield __await(AvroParser.readLong(this._dataStream, {
                                abortSignal: options.abortSignal
                            }));
                        }
                        yield yield __await(result);
                    }
                });
            }
        }
        class AvroReadable {
        }
        const ABORT_ERROR = new src_AbortController.l("Reading from the avro stream was aborted.");
        class AvroReadableFromStream extends AvroReadable {
            constructor(readable){
                super();
                this._readable = readable;
                this._position = 0;
            }
            toUint8Array(data) {
                if ("string" == typeof data) return Buffer.from(data);
                return data;
            }
            get position() {
                return this._position;
            }
            async read(size, options = {}) {
                var _a;
                if (null == (_a = options.abortSignal) ? void 0 : _a.aborted) throw ABORT_ERROR;
                if (size < 0) throw new Error(`size parameter should be positive: ${size}`);
                if (0 === size) return new Uint8Array();
                if (!this._readable.readable) throw new Error("Stream no longer readable.");
                const chunk = this._readable.read(size);
                if (!chunk) return new Promise((resolve, reject)=>{
                    const cleanUp = ()=>{
                        this._readable.removeListener("readable", readableCallback);
                        this._readable.removeListener("error", rejectCallback);
                        this._readable.removeListener("end", rejectCallback);
                        this._readable.removeListener("close", rejectCallback);
                        if (options.abortSignal) options.abortSignal.removeEventListener("abort", abortHandler);
                    };
                    const readableCallback = ()=>{
                        const callbackChunk = this._readable.read(size);
                        if (callbackChunk) {
                            this._position += callbackChunk.length;
                            cleanUp();
                            resolve(this.toUint8Array(callbackChunk));
                        }
                    };
                    const rejectCallback = ()=>{
                        cleanUp();
                        reject();
                    };
                    const abortHandler = ()=>{
                        cleanUp();
                        reject(ABORT_ERROR);
                    };
                    this._readable.on("readable", readableCallback);
                    this._readable.once("error", rejectCallback);
                    this._readable.once("end", rejectCallback);
                    this._readable.once("close", rejectCallback);
                    if (options.abortSignal) options.abortSignal.addEventListener("abort", abortHandler);
                });
                this._position += chunk.length;
                return this.toUint8Array(chunk);
            }
        }
        class BlobQuickQueryStream extends external_stream_.Readable {
            constructor(source, options = {}){
                super();
                this.avroPaused = true;
                this.source = source;
                this.onProgress = options.onProgress;
                this.onError = options.onError;
                this.avroReader = new AvroReader(new AvroReadableFromStream(this.source));
                this.avroIter = this.avroReader.parseObjects({
                    abortSignal: options.abortSignal
                });
            }
            _read() {
                if (this.avroPaused) this.readInternal().catch((err)=>{
                    this.emit("error", err);
                });
            }
            async readInternal() {
                this.avroPaused = false;
                let avroNext;
                do {
                    avroNext = await this.avroIter.next();
                    if (avroNext.done) break;
                    const obj = avroNext.value;
                    const schema = obj.$schema;
                    if ("string" != typeof schema) throw Error("Missing schema in avro record.");
                    switch(schema){
                        case "com.microsoft.azure.storage.queryBlobContents.resultData":
                            {
                                const data = obj.data;
                                if (data instanceof Uint8Array === false) throw Error("Invalid data in avro result record.");
                                if (!this.push(Buffer.from(data))) this.avroPaused = true;
                            }
                            break;
                        case "com.microsoft.azure.storage.queryBlobContents.progress":
                            {
                                const bytesScanned = obj.bytesScanned;
                                if ("number" != typeof bytesScanned) throw Error("Invalid bytesScanned in avro progress record.");
                                if (this.onProgress) this.onProgress({
                                    loadedBytes: bytesScanned
                                });
                            }
                            break;
                        case "com.microsoft.azure.storage.queryBlobContents.end":
                            if (this.onProgress) {
                                const totalBytes = obj.totalBytes;
                                if ("number" != typeof totalBytes) throw Error("Invalid totalBytes in avro end record.");
                                this.onProgress({
                                    loadedBytes: totalBytes
                                });
                            }
                            this.push(null);
                            break;
                        case "com.microsoft.azure.storage.queryBlobContents.error":
                            if (this.onError) {
                                const fatal = obj.fatal;
                                if ("boolean" != typeof fatal) throw Error("Invalid fatal in avro error record.");
                                const name = obj.name;
                                if ("string" != typeof name) throw Error("Invalid name in avro error record.");
                                const description = obj.description;
                                if ("string" != typeof description) throw Error("Invalid description in avro error record.");
                                const position = obj.position;
                                if ("number" != typeof position) throw Error("Invalid position in avro error record.");
                                this.onError({
                                    position,
                                    name,
                                    isFatal: fatal,
                                    description
                                });
                            }
                            break;
                        default:
                            throw Error(`Unknown schema ${schema} in avro progress record.`);
                    }
                }while (!avroNext.done && !this.avroPaused);
            }
        }
        class BlobQueryResponse {
            constructor(originalResponse, options = {}){
                this.originalResponse = originalResponse;
                this.blobDownloadStream = new BlobQuickQueryStream(this.originalResponse.readableStreamBody, options);
            }
            get acceptRanges() {
                return this.originalResponse.acceptRanges;
            }
            get cacheControl() {
                return this.originalResponse.cacheControl;
            }
            get contentDisposition() {
                return this.originalResponse.contentDisposition;
            }
            get contentEncoding() {
                return this.originalResponse.contentEncoding;
            }
            get contentLanguage() {
                return this.originalResponse.contentLanguage;
            }
            get blobSequenceNumber() {
                return this.originalResponse.blobSequenceNumber;
            }
            get blobType() {
                return this.originalResponse.blobType;
            }
            get contentLength() {
                return this.originalResponse.contentLength;
            }
            get contentMD5() {
                return this.originalResponse.contentMD5;
            }
            get contentRange() {
                return this.originalResponse.contentRange;
            }
            get contentType() {
                return this.originalResponse.contentType;
            }
            get copyCompletedOn() {}
            get copyId() {
                return this.originalResponse.copyId;
            }
            get copyProgress() {
                return this.originalResponse.copyProgress;
            }
            get copySource() {
                return this.originalResponse.copySource;
            }
            get copyStatus() {
                return this.originalResponse.copyStatus;
            }
            get copyStatusDescription() {
                return this.originalResponse.copyStatusDescription;
            }
            get leaseDuration() {
                return this.originalResponse.leaseDuration;
            }
            get leaseState() {
                return this.originalResponse.leaseState;
            }
            get leaseStatus() {
                return this.originalResponse.leaseStatus;
            }
            get date() {
                return this.originalResponse.date;
            }
            get blobCommittedBlockCount() {
                return this.originalResponse.blobCommittedBlockCount;
            }
            get etag() {
                return this.originalResponse.etag;
            }
            get errorCode() {
                return this.originalResponse.errorCode;
            }
            get isServerEncrypted() {
                return this.originalResponse.isServerEncrypted;
            }
            get blobContentMD5() {
                return this.originalResponse.blobContentMD5;
            }
            get lastModified() {
                return this.originalResponse.lastModified;
            }
            get metadata() {
                return this.originalResponse.metadata;
            }
            get requestId() {
                return this.originalResponse.requestId;
            }
            get clientRequestId() {
                return this.originalResponse.clientRequestId;
            }
            get version() {
                return this.originalResponse.version;
            }
            get encryptionKeySha256() {
                return this.originalResponse.encryptionKeySha256;
            }
            get contentCrc64() {
                return this.originalResponse.contentCrc64;
            }
            get blobBody() {}
            get readableStreamBody() {
                return checkEnvironment_isNode ? this.blobDownloadStream : void 0;
            }
            get _response() {
                return this.originalResponse._response;
            }
        }
        class AppendBlob {
            constructor(client){
                this.client = client;
            }
            create(contentLength, options) {
                const operationArguments = {
                    contentLength,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, appendBlob_createOperationSpec);
            }
            appendBlock(contentLength, body, options) {
                const operationArguments = {
                    contentLength,
                    body,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, appendBlockOperationSpec);
            }
            appendBlockFromUrl(sourceUrl, contentLength, options) {
                const operationArguments = {
                    sourceUrl,
                    contentLength,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, appendBlockFromUrlOperationSpec);
            }
            seal(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, sealOperationSpec);
            }
        }
        const appendBlob_xmlSerializer = new Serializer(mappers_namespaceObject, true);
        const appendBlob_serializer = new Serializer(mappers_namespaceObject, false);
        const appendBlob_createOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: AppendBlobCreateHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: AppendBlobCreateExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_contentLength,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                blobCacheControl,
                blobContentType,
                blobContentMD5,
                blobContentEncoding,
                blobContentLanguage,
                blobContentDisposition,
                immutabilityPolicyExpiry,
                immutabilityPolicyMode,
                parameters_encryptionScope,
                blobTagsString,
                legalHold1,
                blobType1
            ],
            isXML: true,
            serializer: appendBlob_xmlSerializer
        };
        const appendBlockOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: AppendBlobAppendBlockHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: AppendBlobAppendBlockExceptionHeaders
                }
            },
            requestBody: body1,
            queryParameters: [
                timeoutInSeconds,
                comp22
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                parameters_contentLength,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_encryptionScope,
                transactionalContentMD5,
                transactionalContentCrc64,
                contentType1,
                accept2,
                maxSize,
                appendPosition
            ],
            mediaType: "binary",
            serializer: appendBlob_serializer
        };
        const appendBlockFromUrlOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: AppendBlobAppendBlockFromUrlHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: AppendBlobAppendBlockFromUrlExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp22
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_contentLength,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_encryptionScope,
                sourceIfModifiedSince,
                sourceIfUnmodifiedSince,
                sourceIfMatch,
                sourceIfNoneMatch,
                sourceContentMD5,
                copySourceAuthorization,
                transactionalContentMD5,
                parameters_sourceUrl,
                sourceContentCrc64,
                maxSize,
                appendPosition,
                sourceRange1
            ],
            isXML: true,
            serializer: appendBlob_xmlSerializer
        };
        const sealOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: AppendBlobSealHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: AppendBlobSealExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp23
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                ifMatch,
                ifNoneMatch,
                appendPosition
            ],
            isXML: true,
            serializer: appendBlob_xmlSerializer
        };
        class BlockBlob {
            constructor(client){
                this.client = client;
            }
            upload(contentLength, body, options) {
                const operationArguments = {
                    contentLength,
                    body,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, uploadOperationSpec);
            }
            putBlobFromUrl(contentLength, copySource, options) {
                const operationArguments = {
                    contentLength,
                    copySource,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, putBlobFromUrlOperationSpec);
            }
            stageBlock(blockId, contentLength, body, options) {
                const operationArguments = {
                    blockId,
                    contentLength,
                    body,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, stageBlockOperationSpec);
            }
            stageBlockFromURL(blockId, contentLength, sourceUrl, options) {
                const operationArguments = {
                    blockId,
                    contentLength,
                    sourceUrl,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, stageBlockFromURLOperationSpec);
            }
            commitBlockList(blocks, options) {
                const operationArguments = {
                    blocks,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, commitBlockListOperationSpec);
            }
            getBlockList(listType, options) {
                const operationArguments = {
                    listType,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, getBlockListOperationSpec);
            }
        }
        const blockBlob_xmlSerializer = new Serializer(mappers_namespaceObject, true);
        const blockBlob_serializer = new Serializer(mappers_namespaceObject, false);
        const uploadOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: BlockBlobUploadHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlockBlobUploadExceptionHeaders
                }
            },
            requestBody: body1,
            queryParameters: [
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                parameters_contentLength,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                blobCacheControl,
                blobContentType,
                blobContentMD5,
                blobContentEncoding,
                blobContentLanguage,
                blobContentDisposition,
                immutabilityPolicyExpiry,
                immutabilityPolicyMode,
                parameters_encryptionScope,
                parameters_tier,
                blobTagsString,
                legalHold1,
                transactionalContentMD5,
                transactionalContentCrc64,
                contentType1,
                accept2,
                blobType2
            ],
            mediaType: "binary",
            serializer: blockBlob_serializer
        };
        const putBlobFromUrlOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: BlockBlobPutBlobFromUrlHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlockBlobPutBlobFromUrlExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_contentLength,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                blobCacheControl,
                blobContentType,
                blobContentMD5,
                blobContentEncoding,
                blobContentLanguage,
                blobContentDisposition,
                parameters_encryptionScope,
                parameters_tier,
                sourceIfModifiedSince,
                sourceIfUnmodifiedSince,
                sourceIfMatch,
                sourceIfNoneMatch,
                sourceIfTags,
                parameters_copySource,
                blobTagsString,
                sourceContentMD5,
                copySourceAuthorization,
                copySourceTags,
                transactionalContentMD5,
                blobType2,
                copySourceBlobProperties
            ],
            isXML: true,
            serializer: blockBlob_xmlSerializer
        };
        const stageBlockOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: BlockBlobStageBlockHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlockBlobStageBlockExceptionHeaders
                }
            },
            requestBody: body1,
            queryParameters: [
                timeoutInSeconds,
                comp24,
                parameters_blockId
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                parameters_contentLength,
                parameters_leaseId,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                parameters_encryptionScope,
                transactionalContentMD5,
                transactionalContentCrc64,
                contentType1,
                accept2
            ],
            mediaType: "binary",
            serializer: blockBlob_serializer
        };
        const stageBlockFromURLOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: BlockBlobStageBlockFromURLHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlockBlobStageBlockFromURLExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp24,
                parameters_blockId
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_contentLength,
                parameters_leaseId,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                parameters_encryptionScope,
                sourceIfModifiedSince,
                sourceIfUnmodifiedSince,
                sourceIfMatch,
                sourceIfNoneMatch,
                sourceContentMD5,
                copySourceAuthorization,
                parameters_sourceUrl,
                sourceContentCrc64,
                sourceRange1
            ],
            isXML: true,
            serializer: blockBlob_xmlSerializer
        };
        const commitBlockListOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: BlockBlobCommitBlockListHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlockBlobCommitBlockListExceptionHeaders
                }
            },
            requestBody: parameters_blocks,
            queryParameters: [
                timeoutInSeconds,
                comp25
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_contentType,
                parameters_accept,
                parameters_version,
                requestId,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                blobCacheControl,
                blobContentType,
                blobContentMD5,
                blobContentEncoding,
                blobContentLanguage,
                blobContentDisposition,
                immutabilityPolicyExpiry,
                immutabilityPolicyMode,
                parameters_encryptionScope,
                parameters_tier,
                blobTagsString,
                legalHold1,
                transactionalContentMD5,
                transactionalContentCrc64
            ],
            isXML: true,
            contentType: "application/xml; charset=utf-8",
            mediaType: "xml",
            serializer: blockBlob_xmlSerializer
        };
        const getBlockListOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: BlockList,
                    headersMapper: BlockBlobGetBlockListHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: BlockBlobGetBlockListExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_snapshot,
                comp25,
                parameters_listType
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifTags
            ],
            isXML: true,
            serializer: blockBlob_xmlSerializer
        };
        class PageBlob {
            constructor(client){
                this.client = client;
            }
            create(contentLength, blobContentLength, options) {
                const operationArguments = {
                    contentLength,
                    blobContentLength,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, pageBlob_createOperationSpec);
            }
            uploadPages(contentLength, body, options) {
                const operationArguments = {
                    contentLength,
                    body,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, uploadPagesOperationSpec);
            }
            clearPages(contentLength, options) {
                const operationArguments = {
                    contentLength,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, clearPagesOperationSpec);
            }
            uploadPagesFromURL(sourceUrl, sourceRange, contentLength, range, options) {
                const operationArguments = {
                    sourceUrl,
                    sourceRange,
                    contentLength,
                    range,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, uploadPagesFromURLOperationSpec);
            }
            getPageRanges(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, getPageRangesOperationSpec);
            }
            getPageRangesDiff(options) {
                const operationArguments = {
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, getPageRangesDiffOperationSpec);
            }
            resize(blobContentLength, options) {
                const operationArguments = {
                    blobContentLength,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, resizeOperationSpec);
            }
            updateSequenceNumber(sequenceNumberAction, options) {
                const operationArguments = {
                    sequenceNumberAction,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, updateSequenceNumberOperationSpec);
            }
            copyIncremental(copySource, options) {
                const operationArguments = {
                    copySource,
                    options: operationOptionsToRequestOptionsBase(options || {})
                };
                return this.client.sendOperationRequest(operationArguments, copyIncrementalOperationSpec);
            }
        }
        const pageBlob_xmlSerializer = new Serializer(mappers_namespaceObject, true);
        const pageBlob_serializer = new Serializer(mappers_namespaceObject, false);
        const pageBlob_createOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: PageBlobCreateHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: PageBlobCreateExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_contentLength,
                parameters_metadata,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                blobCacheControl,
                blobContentType,
                blobContentMD5,
                blobContentEncoding,
                blobContentLanguage,
                blobContentDisposition,
                immutabilityPolicyExpiry,
                immutabilityPolicyMode,
                parameters_encryptionScope,
                parameters_tier,
                blobTagsString,
                legalHold1,
                blobType,
                parameters_blobContentLength,
                blobSequenceNumber
            ],
            isXML: true,
            serializer: pageBlob_xmlSerializer
        };
        const uploadPagesOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: PageBlobUploadPagesHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: PageBlobUploadPagesExceptionHeaders
                }
            },
            requestBody: body1,
            queryParameters: [
                timeoutInSeconds,
                comp19
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                parameters_contentLength,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                parameters_range,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_encryptionScope,
                transactionalContentMD5,
                transactionalContentCrc64,
                contentType1,
                accept2,
                pageWrite,
                ifSequenceNumberLessThanOrEqualTo,
                ifSequenceNumberLessThan,
                ifSequenceNumberEqualTo
            ],
            mediaType: "binary",
            serializer: pageBlob_serializer
        };
        const clearPagesOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: PageBlobClearPagesHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: PageBlobClearPagesExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp19
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_contentLength,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                parameters_range,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_encryptionScope,
                ifSequenceNumberLessThanOrEqualTo,
                ifSequenceNumberLessThan,
                ifSequenceNumberEqualTo,
                pageWrite1
            ],
            isXML: true,
            serializer: pageBlob_xmlSerializer
        };
        const uploadPagesFromURLOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                201: {
                    headersMapper: PageBlobUploadPagesFromURLHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: PageBlobUploadPagesFromURLExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp19
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_contentLength,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_encryptionScope,
                sourceIfModifiedSince,
                sourceIfUnmodifiedSince,
                sourceIfMatch,
                sourceIfNoneMatch,
                sourceContentMD5,
                copySourceAuthorization,
                pageWrite,
                ifSequenceNumberLessThanOrEqualTo,
                ifSequenceNumberLessThan,
                ifSequenceNumberEqualTo,
                parameters_sourceUrl,
                parameters_sourceRange,
                sourceContentCrc64,
                range1
            ],
            isXML: true,
            serializer: pageBlob_xmlSerializer
        };
        const getPageRangesOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: PageList,
                    headersMapper: PageBlobGetPageRangesHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: PageBlobGetPageRangesExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_marker,
                maxPageSize,
                parameters_snapshot,
                comp20
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                parameters_range,
                ifMatch,
                ifNoneMatch,
                ifTags
            ],
            isXML: true,
            serializer: pageBlob_xmlSerializer
        };
        const getPageRangesDiffOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: PageList,
                    headersMapper: PageBlobGetPageRangesDiffHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: PageBlobGetPageRangesDiffExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                parameters_marker,
                maxPageSize,
                parameters_snapshot,
                comp20,
                prevsnapshot
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                parameters_range,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_prevSnapshotUrl
            ],
            isXML: true,
            serializer: pageBlob_xmlSerializer
        };
        const resizeOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: PageBlobResizeHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: PageBlobResizeExceptionHeaders
                }
            },
            queryParameters: [
                comp,
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                encryptionKey,
                encryptionKeySha256,
                encryptionAlgorithm,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_encryptionScope,
                parameters_blobContentLength
            ],
            isXML: true,
            serializer: pageBlob_xmlSerializer
        };
        const updateSequenceNumberOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                200: {
                    headersMapper: PageBlobUpdateSequenceNumberHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: PageBlobUpdateSequenceNumberExceptionHeaders
                }
            },
            queryParameters: [
                comp,
                timeoutInSeconds
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                parameters_leaseId,
                ifModifiedSince,
                ifUnmodifiedSince,
                ifMatch,
                ifNoneMatch,
                ifTags,
                blobSequenceNumber,
                parameters_sequenceNumberAction
            ],
            isXML: true,
            serializer: pageBlob_xmlSerializer
        };
        const copyIncrementalOperationSpec = {
            path: "/{containerName}/{blob}",
            httpMethod: "PUT",
            responses: {
                202: {
                    headersMapper: PageBlobCopyIncrementalHeaders
                },
                default: {
                    bodyMapper: StorageError,
                    headersMapper: PageBlobCopyIncrementalExceptionHeaders
                }
            },
            queryParameters: [
                timeoutInSeconds,
                comp21
            ],
            urlParameters: [
                parameters_url
            ],
            headerParameters: [
                parameters_version,
                requestId,
                accept1,
                ifModifiedSince,
                ifUnmodifiedSince,
                ifMatch,
                ifNoneMatch,
                ifTags,
                parameters_copySource
            ],
            isXML: true,
            serializer: pageBlob_xmlSerializer
        };
        var models_BlockBlobTier;
        (function(BlockBlobTier) {
            BlockBlobTier["Hot"] = "Hot";
            BlockBlobTier["Cool"] = "Cool";
            BlockBlobTier["Cold"] = "Cold";
            BlockBlobTier["Archive"] = "Archive";
        })(models_BlockBlobTier || (models_BlockBlobTier = {}));
        var models_PremiumPageBlobTier;
        (function(PremiumPageBlobTier) {
            PremiumPageBlobTier["P4"] = "P4";
            PremiumPageBlobTier["P6"] = "P6";
            PremiumPageBlobTier["P10"] = "P10";
            PremiumPageBlobTier["P15"] = "P15";
            PremiumPageBlobTier["P20"] = "P20";
            PremiumPageBlobTier["P30"] = "P30";
            PremiumPageBlobTier["P40"] = "P40";
            PremiumPageBlobTier["P50"] = "P50";
            PremiumPageBlobTier["P60"] = "P60";
            PremiumPageBlobTier["P70"] = "P70";
            PremiumPageBlobTier["P80"] = "P80";
        })(models_PremiumPageBlobTier || (models_PremiumPageBlobTier = {}));
        function toAccessTier(tier) {
            if (void 0 === tier) return;
            return tier;
        }
        function ensureCpkIfSpecified(cpk, isHttps) {
            if (cpk && !isHttps) throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
            if (cpk && !cpk.encryptionAlgorithm) cpk.encryptionAlgorithm = "AES256";
        }
        var models_StorageBlobAudience;
        (function(StorageBlobAudience) {
            StorageBlobAudience["StorageOAuthScopes"] = "https://storage.azure.com/.default";
            StorageBlobAudience["DiskComputeOAuthScopes"] = "https://disk.compute.azure.com/.default";
        })(models_StorageBlobAudience || (models_StorageBlobAudience = {}));
        function getBlobServiceAccountAudience(storageAccountName) {
            return `https://${storageAccountName}.blob.core.windows.net/.default`;
        }
        function rangeResponseFromModel(response) {
            const pageRange = (response._response.parsedBody.pageRange || []).map((x)=>({
                    offset: x.start,
                    count: x.end - x.start
                }));
            const clearRange = (response._response.parsedBody.clearRange || []).map((x)=>({
                    offset: x.start,
                    count: x.end - x.start
                }));
            return Object.assign(Object.assign({}, response), {
                pageRange,
                clearRange,
                _response: Object.assign(Object.assign({}, response._response), {
                    parsedBody: {
                        pageRange,
                        clearRange
                    }
                })
            });
        }
        createClientLogger("core-lro");
        class PollerStoppedError extends Error {
            constructor(message){
                super(message);
                this.name = "PollerStoppedError";
                Object.setPrototypeOf(this, PollerStoppedError.prototype);
            }
        }
        class PollerCancelledError extends Error {
            constructor(message){
                super(message);
                this.name = "PollerCancelledError";
                Object.setPrototypeOf(this, PollerCancelledError.prototype);
            }
        }
        class Poller {
            resolveOnUnsuccessful = false;
            stopped = true;
            resolve;
            reject;
            pollOncePromise;
            cancelPromise;
            promise;
            pollProgressCallbacks = [];
            operation;
            constructor(operation){
                this.operation = operation;
                this.promise = new Promise((resolve, reject)=>{
                    this.resolve = resolve;
                    this.reject = reject;
                });
                this.promise.catch(()=>{});
            }
            async startPolling(pollOptions = {}) {
                if (this.stopped) this.stopped = false;
                while(!this.isStopped() && !this.isDone()){
                    await this.poll(pollOptions);
                    await this.delay();
                }
            }
            async pollOnce(options = {}) {
                if (!this.isDone()) this.operation = await this.operation.update({
                    abortSignal: options.abortSignal,
                    fireProgress: this.fireProgress.bind(this)
                });
                this.processUpdatedState();
            }
            fireProgress(state) {
                for (const callback of this.pollProgressCallbacks)callback(state);
            }
            async cancelOnce(options = {}) {
                this.operation = await this.operation.cancel(options);
            }
            poll(options = {}) {
                if (!this.pollOncePromise) {
                    this.pollOncePromise = this.pollOnce(options);
                    const clearPollOncePromise = ()=>{
                        this.pollOncePromise = void 0;
                    };
                    this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
                }
                return this.pollOncePromise;
            }
            processUpdatedState() {
                if (this.operation.state.error) {
                    this.stopped = true;
                    if (!this.resolveOnUnsuccessful) {
                        this.reject(this.operation.state.error);
                        throw this.operation.state.error;
                    }
                }
                if (this.operation.state.isCancelled) {
                    this.stopped = true;
                    if (!this.resolveOnUnsuccessful) {
                        const error = new PollerCancelledError("Operation was canceled");
                        this.reject(error);
                        throw error;
                    }
                }
                if (this.isDone() && this.resolve) this.resolve(this.getResult());
            }
            async pollUntilDone(pollOptions = {}) {
                if (this.stopped) this.startPolling(pollOptions).catch(this.reject);
                this.processUpdatedState();
                return this.promise;
            }
            onProgress(callback) {
                this.pollProgressCallbacks.push(callback);
                return ()=>{
                    this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c)=>c !== callback);
                };
            }
            isDone() {
                const state = this.operation.state;
                return Boolean(state.isCompleted || state.isCancelled || state.error);
            }
            stopPolling() {
                if (!this.stopped) {
                    this.stopped = true;
                    if (this.reject) this.reject(new PollerStoppedError("This poller is already stopped"));
                }
            }
            isStopped() {
                return this.stopped;
            }
            cancelOperation(options = {}) {
                if (this.cancelPromise) {
                    if (options.abortSignal) throw new Error("A cancel request is currently pending");
                } else this.cancelPromise = this.cancelOnce(options);
                return this.cancelPromise;
            }
            getOperationState() {
                return this.operation.state;
            }
            getResult() {
                const state = this.operation.state;
                return state.result;
            }
            toString() {
                return this.operation.toString();
            }
        }
        class BlobBeginCopyFromUrlPoller extends Poller {
            constructor(options){
                const { blobClient, copySource, intervalInMs = 15000, onProgress, resumeFrom, startCopyFromURLOptions } = options;
                let state;
                if (resumeFrom) state = JSON.parse(resumeFrom).state;
                const operation = makeBlobBeginCopyFromURLPollOperation(Object.assign(Object.assign({}, state), {
                    blobClient,
                    copySource,
                    startCopyFromURLOptions
                }));
                super(operation);
                if ("function" == typeof onProgress) this.onProgress(onProgress);
                this.intervalInMs = intervalInMs;
            }
            delay() {
                return delay_delay(this.intervalInMs);
            }
        }
        const BlobStartCopyFromUrlPoller_cancel = async function(options = {}) {
            const state = this.state;
            const { copyId } = state;
            if (state.isCompleted) return makeBlobBeginCopyFromURLPollOperation(state);
            if (!copyId) {
                state.isCancelled = true;
                return makeBlobBeginCopyFromURLPollOperation(state);
            }
            await state.blobClient.abortCopyFromURL(copyId, {
                abortSignal: options.abortSignal
            });
            state.isCancelled = true;
            return makeBlobBeginCopyFromURLPollOperation(state);
        };
        const BlobStartCopyFromUrlPoller_update = async function(options = {}) {
            const state = this.state;
            const { blobClient, copySource, startCopyFromURLOptions } = state;
            if (state.isStarted) {
                if (!state.isCompleted) try {
                    const result = await state.blobClient.getProperties({
                        abortSignal: options.abortSignal
                    });
                    const { copyStatus, copyProgress } = result;
                    const prevCopyProgress = state.copyProgress;
                    if (copyProgress) state.copyProgress = copyProgress;
                    if ("pending" === copyStatus && copyProgress !== prevCopyProgress && "function" == typeof options.fireProgress) options.fireProgress(state);
                    else if ("success" === copyStatus) {
                        state.result = result;
                        state.isCompleted = true;
                    } else if ("failed" === copyStatus) {
                        state.error = new Error(`Blob copy failed with reason: "${result.copyStatusDescription || "unknown"}"`);
                        state.isCompleted = true;
                    }
                } catch (err) {
                    state.error = err;
                    state.isCompleted = true;
                }
            } else {
                state.isStarted = true;
                const result = await blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);
                state.copyId = result.copyId;
                if ("success" === result.copyStatus) {
                    state.result = result;
                    state.isCompleted = true;
                }
            }
            return makeBlobBeginCopyFromURLPollOperation(state);
        };
        const BlobStartCopyFromUrlPoller_toString = function() {
            return JSON.stringify({
                state: this.state
            }, (key, value)=>{
                if ("blobClient" === key) return;
                return value;
            });
        };
        function makeBlobBeginCopyFromURLPollOperation(state) {
            return {
                state: Object.assign({}, state),
                cancel: BlobStartCopyFromUrlPoller_cancel,
                toString: BlobStartCopyFromUrlPoller_toString,
                update: BlobStartCopyFromUrlPoller_update
            };
        }
        function rangeToString(iRange) {
            if (iRange.offset < 0) throw new RangeError("Range.offset cannot be smaller than 0.");
            if (iRange.count && iRange.count <= 0) throw new RangeError("Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.");
            return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
        }
        var external_events_ = __webpack_require__("events");
        var Batch_BatchStates;
        (function(BatchStates) {
            BatchStates[BatchStates["Good"] = 0] = "Good";
            BatchStates[BatchStates["Error"] = 1] = "Error";
        })(Batch_BatchStates || (Batch_BatchStates = {}));
        class Batch {
            constructor(concurrency = 5){
                this.actives = 0;
                this.completed = 0;
                this.offset = 0;
                this.operations = [];
                this.state = Batch_BatchStates.Good;
                if (concurrency < 1) throw new RangeError("concurrency must be larger than 0");
                this.concurrency = concurrency;
                this.emitter = new external_events_.EventEmitter();
            }
            addOperation(operation) {
                this.operations.push(async ()=>{
                    try {
                        this.actives++;
                        await operation();
                        this.actives--;
                        this.completed++;
                        this.parallelExecute();
                    } catch (error) {
                        this.emitter.emit("error", error);
                    }
                });
            }
            async do() {
                if (0 === this.operations.length) return Promise.resolve();
                this.parallelExecute();
                return new Promise((resolve, reject)=>{
                    this.emitter.on("finish", resolve);
                    this.emitter.on("error", (error)=>{
                        this.state = Batch_BatchStates.Error;
                        reject(error);
                    });
                });
            }
            nextOperation() {
                if (this.offset < this.operations.length) return this.operations[this.offset++];
                return null;
            }
            parallelExecute() {
                if (this.state === Batch_BatchStates.Error) return;
                if (this.completed >= this.operations.length) return void this.emitter.emit("finish");
                while(this.actives < this.concurrency){
                    const operation = this.nextOperation();
                    if (!operation) return;
                    operation();
                }
            }
        }
        class BuffersStream extends external_stream_.Readable {
            constructor(buffers, byteLength, options){
                super(options);
                this.buffers = buffers;
                this.byteLength = byteLength;
                this.byteOffsetInCurrentBuffer = 0;
                this.bufferIndex = 0;
                this.pushedBytesLength = 0;
                let buffersLength = 0;
                for (const buf of this.buffers)buffersLength += buf.byteLength;
                if (buffersLength < this.byteLength) throw new Error("Data size shouldn't be larger than the total length of buffers.");
            }
            _read(size) {
                if (this.pushedBytesLength >= this.byteLength) this.push(null);
                if (!size) size = this.readableHighWaterMark;
                const outBuffers = [];
                let i = 0;
                while(i < size && this.pushedBytesLength < this.byteLength){
                    const remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength;
                    const remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer;
                    const remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
                    if (remaining > size - i) {
                        const end = this.byteOffsetInCurrentBuffer + size - i;
                        outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
                        this.pushedBytesLength += size - i;
                        this.byteOffsetInCurrentBuffer = end;
                        i = size;
                        break;
                    }
                    {
                        const end = this.byteOffsetInCurrentBuffer + remaining;
                        outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
                        if (remaining === remainingCapacityInThisBuffer) {
                            this.byteOffsetInCurrentBuffer = 0;
                            this.bufferIndex++;
                        } else this.byteOffsetInCurrentBuffer = end;
                        this.pushedBytesLength += remaining;
                        i += remaining;
                    }
                }
                if (outBuffers.length > 1) this.push(Buffer.concat(outBuffers));
                else if (1 === outBuffers.length) this.push(outBuffers[0]);
            }
        }
        const maxBufferLength = __webpack_require__("buffer").constants.MAX_LENGTH;
        class PooledBuffer {
            constructor(capacity, buffers, totalLength){
                this.buffers = [];
                this.capacity = capacity;
                this._size = 0;
                const bufferNum = Math.ceil(capacity / maxBufferLength);
                for(let i = 0; i < bufferNum; i++){
                    let len = i === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
                    if (0 === len) len = maxBufferLength;
                    this.buffers.push(Buffer.allocUnsafe(len));
                }
                if (buffers) this.fill(buffers, totalLength);
            }
            get size() {
                return this._size;
            }
            fill(buffers, totalLength) {
                this._size = Math.min(this.capacity, totalLength);
                let i = 0, j = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0;
                while(totalCopiedNum < this._size){
                    const source = buffers[i];
                    const target = this.buffers[j];
                    const copiedNum = source.copy(target, targetOffset, sourceOffset);
                    totalCopiedNum += copiedNum;
                    sourceOffset += copiedNum;
                    targetOffset += copiedNum;
                    if (sourceOffset === source.length) {
                        i++;
                        sourceOffset = 0;
                    }
                    if (targetOffset === target.length) {
                        j++;
                        targetOffset = 0;
                    }
                }
                buffers.splice(0, i);
                if (buffers.length > 0) buffers[0] = buffers[0].slice(sourceOffset);
            }
            getReadableStream() {
                return new BuffersStream(this.buffers, this.size);
            }
        }
        class BufferScheduler {
            constructor(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding){
                this.emitter = new external_events_.EventEmitter();
                this.offset = 0;
                this.isStreamEnd = false;
                this.isError = false;
                this.executingOutgoingHandlers = 0;
                this.numBuffers = 0;
                this.unresolvedDataArray = [];
                this.unresolvedLength = 0;
                this.incoming = [];
                this.outgoing = [];
                if (bufferSize <= 0) throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
                if (maxBuffers <= 0) throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
                if (concurrency <= 0) throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
                this.bufferSize = bufferSize;
                this.maxBuffers = maxBuffers;
                this.readable = readable;
                this.outgoingHandler = outgoingHandler;
                this.concurrency = concurrency;
                this.encoding = encoding;
            }
            async do() {
                return new Promise((resolve, reject)=>{
                    this.readable.on("data", (data)=>{
                        data = "string" == typeof data ? Buffer.from(data, this.encoding) : data;
                        this.appendUnresolvedData(data);
                        if (!this.resolveData()) this.readable.pause();
                    });
                    this.readable.on("error", (err)=>{
                        this.emitter.emit("error", err);
                    });
                    this.readable.on("end", ()=>{
                        this.isStreamEnd = true;
                        this.emitter.emit("checkEnd");
                    });
                    this.emitter.on("error", (err)=>{
                        this.isError = true;
                        this.readable.pause();
                        reject(err);
                    });
                    this.emitter.on("checkEnd", ()=>{
                        if (this.outgoing.length > 0) return void this.triggerOutgoingHandlers();
                        if (this.isStreamEnd && 0 === this.executingOutgoingHandlers) if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
                            const buffer = this.shiftBufferFromUnresolvedDataArray();
                            this.outgoingHandler(()=>buffer.getReadableStream(), buffer.size, this.offset).then(resolve).catch(reject);
                        } else {
                            if (this.unresolvedLength >= this.bufferSize) return;
                            resolve();
                        }
                    });
                });
            }
            appendUnresolvedData(data) {
                this.unresolvedDataArray.push(data);
                this.unresolvedLength += data.length;
            }
            shiftBufferFromUnresolvedDataArray(buffer) {
                if (buffer) buffer.fill(this.unresolvedDataArray, this.unresolvedLength);
                else buffer = new PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength);
                this.unresolvedLength -= buffer.size;
                return buffer;
            }
            resolveData() {
                while(this.unresolvedLength >= this.bufferSize){
                    let buffer;
                    if (this.incoming.length > 0) {
                        buffer = this.incoming.shift();
                        this.shiftBufferFromUnresolvedDataArray(buffer);
                    } else {
                        if (!(this.numBuffers < this.maxBuffers)) return false;
                        buffer = this.shiftBufferFromUnresolvedDataArray();
                        this.numBuffers++;
                    }
                    this.outgoing.push(buffer);
                    this.triggerOutgoingHandlers();
                }
                return true;
            }
            async triggerOutgoingHandlers() {
                let buffer;
                do {
                    if (this.executingOutgoingHandlers >= this.concurrency) return;
                    buffer = this.outgoing.shift();
                    if (buffer) this.triggerOutgoingHandler(buffer);
                }while (buffer);
            }
            async triggerOutgoingHandler(buffer) {
                const bufferLength = buffer.size;
                this.executingOutgoingHandlers++;
                this.offset += bufferLength;
                try {
                    await this.outgoingHandler(()=>buffer.getReadableStream(), bufferLength, this.offset - bufferLength);
                } catch (err) {
                    this.emitter.emit("error", err);
                    return;
                }
                this.executingOutgoingHandlers--;
                this.reuseBuffer(buffer);
                this.emitter.emit("checkEnd");
            }
            reuseBuffer(buffer) {
                this.incoming.push(buffer);
                if (!this.isError && this.resolveData() && !this.isStreamEnd) this.readable.resume();
            }
        }
        var external_fs_ = __webpack_require__("fs");
        async function streamToBuffer(stream, buffer, offset, end, encoding) {
            let pos = 0;
            const count = end - offset;
            return new Promise((resolve, reject)=>{
                const timeout = setTimeout(()=>reject(new Error("The operation cannot be completed in timeout.")), 100000);
                stream.on("readable", ()=>{
                    if (pos >= count) {
                        clearTimeout(timeout);
                        resolve();
                        return;
                    }
                    let chunk = stream.read();
                    if (!chunk) return;
                    if ("string" == typeof chunk) chunk = Buffer.from(chunk, encoding);
                    const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
                    buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
                    pos += chunkLength;
                });
                stream.on("end", ()=>{
                    clearTimeout(timeout);
                    if (pos < count) reject(new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
                    resolve();
                });
                stream.on("error", (msg)=>{
                    clearTimeout(timeout);
                    reject(msg);
                });
            });
        }
        async function streamToBuffer2(stream, buffer, encoding) {
            let pos = 0;
            const bufferSize = buffer.length;
            return new Promise((resolve, reject)=>{
                stream.on("readable", ()=>{
                    let chunk = stream.read();
                    if (!chunk) return;
                    if ("string" == typeof chunk) chunk = Buffer.from(chunk, encoding);
                    if (pos + chunk.length > bufferSize) return void reject(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
                    buffer.fill(chunk, pos, pos + chunk.length);
                    pos += chunk.length;
                });
                stream.on("end", ()=>{
                    resolve(pos);
                });
                stream.on("error", reject);
            });
        }
        async function readStreamToLocalFile(rs, file) {
            return new Promise((resolve, reject)=>{
                const ws = external_fs_.createWriteStream(file);
                rs.on("error", (err)=>{
                    reject(err);
                });
                ws.on("error", (err)=>{
                    reject(err);
                });
                ws.on("close", resolve);
                rs.pipe(ws);
            });
        }
        const fsStat = external_util_.promisify(external_fs_.stat);
        const fsCreateReadStream = external_fs_.createReadStream;
        class BlobClient extends StorageClient {
            constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options){
                options = options || {};
                let pipeline;
                let url;
                if (isPipelineLike(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    pipeline = credentialOrPipelineOrContainerName;
                } else if (checkEnvironment_isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    options = blobNameOrOptions;
                    pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
                } else if (credentialOrPipelineOrContainerName || "string" == typeof credentialOrPipelineOrContainerName) if (credentialOrPipelineOrContainerName && "string" == typeof credentialOrPipelineOrContainerName && blobNameOrOptions && "string" == typeof blobNameOrOptions) {
                    const containerName = credentialOrPipelineOrContainerName;
                    const blobName = blobNameOrOptions;
                    const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
                    if ("AccountConnString" === extractedCreds.kind) if (checkEnvironment_isNode) {
                        const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
                        if (!options.proxyOptions) options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                        pipeline = newPipeline(sharedKeyCredential, options);
                    } else throw new Error("Account connection string is only supported in Node.js environment");
                    else if ("SASConnString" === extractedCreds.kind) {
                        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
                        pipeline = newPipeline(new AnonymousCredential(), options);
                    } else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
                } else throw new Error("Expecting non-empty strings for containerName and blobName parameters");
                else {
                    url = urlOrConnectionString;
                    if (blobNameOrOptions && "string" != typeof blobNameOrOptions) options = blobNameOrOptions;
                    pipeline = newPipeline(new AnonymousCredential(), options);
                }
                super(url, pipeline);
                ({ blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl());
                this.blobContext = new blob_Blob(this.storageClientContext);
                this._snapshot = getURLParameter(this.url, constants_URLConstants.Parameters.SNAPSHOT);
                this._versionId = getURLParameter(this.url, constants_URLConstants.Parameters.VERSIONID);
            }
            get name() {
                return this._name;
            }
            get containerName() {
                return this._containerName;
            }
            withSnapshot(snapshot) {
                return new BlobClient(setURLParameter(this.url, constants_URLConstants.Parameters.SNAPSHOT, 0 === snapshot.length ? void 0 : snapshot), this.pipeline);
            }
            withVersion(versionId) {
                return new BlobClient(setURLParameter(this.url, constants_URLConstants.Parameters.VERSIONID, 0 === versionId.length ? void 0 : versionId), this.pipeline);
            }
            getAppendBlobClient() {
                return new AppendBlobClient(this.url, this.pipeline);
            }
            getBlockBlobClient() {
                return new BlockBlobClient(this.url, this.pipeline);
            }
            getPageBlobClient() {
                return new PageBlobClient(this.url, this.pipeline);
            }
            async download(offset = 0, count, options = {}) {
                var _a;
                options.conditions = options.conditions || {};
                options.conditions = options.conditions || {};
                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                const { span, updatedOptions } = tracing_createSpan("BlobClient-download", options);
                try {
                    const res = await this.blobContext.download(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        requestOptions: {
                            onDownloadProgress: checkEnvironment_isNode ? void 0 : options.onProgress
                        },
                        range: 0 !== offset || count ? rangeToString({
                            offset,
                            count
                        }) : void 0,
                        rangeGetContentMD5: options.rangeGetContentMD5,
                        rangeGetContentCRC64: options.rangeGetContentCrc64,
                        snapshot: options.snapshot,
                        cpkInfo: options.customerProvidedKey
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    const wrappedRes = Object.assign(Object.assign({}, res), {
                        _response: res._response,
                        objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
                        objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules)
                    });
                    if (!checkEnvironment_isNode) return wrappedRes;
                    if (void 0 === options.maxRetryRequests || options.maxRetryRequests < 0) options.maxRetryRequests = 5;
                    if (void 0 === res.contentLength) throw new RangeError("File download response doesn't contain valid content length header");
                    if (!res.etag) throw new RangeError("File download response doesn't contain valid etag header");
                    return new BlobDownloadResponse(wrappedRes, async (start)=>{
                        var _a;
                        const updatedDownloadOptions = {
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: {
                                ifMatch: options.conditions.ifMatch || res.etag,
                                ifModifiedSince: options.conditions.ifModifiedSince,
                                ifNoneMatch: options.conditions.ifNoneMatch,
                                ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,
                                ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                            },
                            range: rangeToString({
                                count: offset + res.contentLength - start,
                                offset: start
                            }),
                            rangeGetContentMD5: options.rangeGetContentMD5,
                            rangeGetContentCRC64: options.rangeGetContentCrc64,
                            snapshot: options.snapshot,
                            cpkInfo: options.customerProvidedKey
                        };
                        return (await this.blobContext.download(Object.assign({
                            abortSignal: options.abortSignal
                        }, updatedDownloadOptions))).readableStreamBody;
                    }, offset, res.contentLength, {
                        maxRetryRequests: options.maxRetryRequests,
                        onProgress: options.onProgress
                    });
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async exists(options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobClient-exists", options);
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    await this.getProperties({
                        abortSignal: options.abortSignal,
                        customerProvidedKey: options.customerProvidedKey,
                        conditions: options.conditions,
                        tracingOptions: updatedOptions.tracingOptions
                    });
                    return true;
                } catch (e) {
                    if (404 === e.statusCode) return false;
                    if (409 === e.statusCode && (e.details.errorCode === BlobUsesCustomerSpecifiedEncryptionMsg || e.details.errorCode === BlobDoesNotUseCustomerSpecifiedEncryption)) return true;
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async getProperties(options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-getProperties", options);
                try {
                    options.conditions = options.conditions || {};
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    const res = await this.blobContext.getProperties(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        cpkInfo: options.customerProvidedKey
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    return Object.assign(Object.assign({}, res), {
                        _response: res._response,
                        objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
                        objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules)
                    });
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async delete(options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-delete", options);
                options.conditions = options.conditions || {};
                try {
                    return await this.blobContext.delete(Object.assign({
                        abortSignal: options.abortSignal,
                        deleteSnapshots: options.deleteSnapshots,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async deleteIfExists(options = {}) {
                var _a, _b;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-deleteIfExists", options);
                try {
                    const res = await this.delete(updatedOptions);
                    return Object.assign(Object.assign({
                        succeeded: true
                    }, res), {
                        _response: res._response
                    });
                } catch (e) {
                    if ((null == (_a = e.details) ? void 0 : _a.errorCode) === "BlobNotFound") {
                        span.setStatus({
                            code: interfaces_SpanStatusCode.ERROR,
                            message: "Expected exception when deleting a blob or snapshot only if it exists."
                        });
                        return Object.assign(Object.assign({
                            succeeded: false
                        }, null == (_b = e.response) ? void 0 : _b.parsedHeaders), {
                            _response: e.response
                        });
                    }
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async undelete(options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobClient-undelete", options);
                try {
                    return await this.blobContext.undelete(Object.assign({
                        abortSignal: options.abortSignal
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setHTTPHeaders(blobHTTPHeaders, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-setHTTPHeaders", options);
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.blobContext.setHttpHeaders(Object.assign({
                        abortSignal: options.abortSignal,
                        blobHttpHeaders: blobHTTPHeaders,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setMetadata(metadata, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-setMetadata", options);
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.blobContext.setMetadata(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        metadata,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setTags(tags, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-setTags", options);
                try {
                    return await this.blobContext.setTags(Object.assign(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)), {
                        tags: toBlobTags(tags)
                    }));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async getTags(options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-getTags", options);
                try {
                    const response = await this.blobContext.getTags(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    const wrappedResponse = Object.assign(Object.assign({}, response), {
                        _response: response._response,
                        tags: toTags({
                            blobTagSet: response.blobTagSet
                        }) || {}
                    });
                    return wrappedResponse;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            getBlobLeaseClient(proposeLeaseId) {
                return new BlobLeaseClient(this, proposeLeaseId);
            }
            async createSnapshot(options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-createSnapshot", options);
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.blobContext.createSnapshot(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        metadata: options.metadata,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async beginCopyFromURL(copySource, options = {}) {
                const client = {
                    abortCopyFromURL: (...args)=>this.abortCopyFromURL(...args),
                    getProperties: (...args)=>this.getProperties(...args),
                    startCopyFromURL: (...args)=>this.startCopyFromURL(...args)
                };
                const poller = new BlobBeginCopyFromUrlPoller({
                    blobClient: client,
                    copySource,
                    intervalInMs: options.intervalInMs,
                    onProgress: options.onProgress,
                    resumeFrom: options.resumeFrom,
                    startCopyFromURLOptions: options
                });
                await poller.poll();
                return poller;
            }
            async abortCopyFromURL(copyId, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobClient-abortCopyFromURL", options);
                try {
                    return await this.blobContext.abortCopyFromURL(copyId, Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async syncCopyFromURL(copySource, options = {}) {
                var _a, _b, _c;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-syncCopyFromURL", options);
                options.conditions = options.conditions || {};
                options.sourceConditions = options.sourceConditions || {};
                try {
                    return await this.blobContext.copyFromURL(copySource, Object.assign({
                        abortSignal: options.abortSignal,
                        metadata: options.metadata,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        sourceModifiedAccessConditions: {
                            sourceIfMatch: options.sourceConditions.ifMatch,
                            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
                        },
                        sourceContentMD5: options.sourceContentMD5,
                        copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
                        tier: toAccessTier(options.tier),
                        blobTagsString: toBlobTagsString(options.tags),
                        immutabilityPolicyExpiry: null == (_b = options.immutabilityPolicy) ? void 0 : _b.expiriesOn,
                        immutabilityPolicyMode: null == (_c = options.immutabilityPolicy) ? void 0 : _c.policyMode,
                        legalHold: options.legalHold,
                        encryptionScope: options.encryptionScope,
                        copySourceTags: options.copySourceTags
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setAccessTier(tier, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-setAccessTier", options);
                try {
                    return await this.blobContext.setTier(toAccessTier(tier), Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        rehydratePriority: options.rehydratePriority
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async downloadToBuffer(param1, param2, param3, param4 = {}) {
                let buffer;
                let offset = 0;
                let count = 0;
                let options = param4;
                if (param1 instanceof Buffer) {
                    buffer = param1;
                    offset = param2 || 0;
                    count = "number" == typeof param3 ? param3 : 0;
                } else {
                    offset = "number" == typeof param1 ? param1 : 0;
                    count = "number" == typeof param2 ? param2 : 0;
                    options = param3 || {};
                }
                const { span, updatedOptions } = tracing_createSpan("BlobClient-downloadToBuffer", options);
                try {
                    if (!options.blockSize) options.blockSize = 0;
                    if (options.blockSize < 0) throw new RangeError("blockSize option must be >= 0");
                    if (0 === options.blockSize) options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
                    if (offset < 0) throw new RangeError("offset option must be >= 0");
                    if (count && count <= 0) throw new RangeError("count option must be greater than 0");
                    if (!options.conditions) options.conditions = {};
                    if (!count) {
                        const response = await this.getProperties(Object.assign(Object.assign({}, options), {
                            tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
                        }));
                        count = response.contentLength - offset;
                        if (count < 0) throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);
                    }
                    if (!buffer) try {
                        buffer = Buffer.alloc(count);
                    } catch (error) {
                        throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".\t ${error.message}`);
                    }
                    if (buffer.length < count) throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
                    let transferProgress = 0;
                    const batch = new Batch(options.concurrency);
                    for(let off = offset; off < offset + count; off += options.blockSize)batch.addOperation(async ()=>{
                        let chunkEnd = offset + count;
                        if (off + options.blockSize < chunkEnd) chunkEnd = off + options.blockSize;
                        const response = await this.download(off, chunkEnd - off, {
                            abortSignal: options.abortSignal,
                            conditions: options.conditions,
                            maxRetryRequests: options.maxRetryRequestsPerBlock,
                            customerProvidedKey: options.customerProvidedKey,
                            tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
                        });
                        const stream = response.readableStreamBody;
                        await streamToBuffer(stream, buffer, off - offset, chunkEnd - offset);
                        transferProgress += chunkEnd - off;
                        if (options.onProgress) options.onProgress({
                            loadedBytes: transferProgress
                        });
                    });
                    await batch.do();
                    return buffer;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async downloadToFile(filePath, offset = 0, count, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobClient-downloadToFile", options);
                try {
                    const response = await this.download(offset, count, Object.assign(Object.assign({}, options), {
                        tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
                    }));
                    if (response.readableStreamBody) await readStreamToLocalFile(response.readableStreamBody, filePath);
                    response.blobDownloadStream = void 0;
                    return response;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            getBlobAndContainerNamesFromUrl() {
                let containerName;
                let blobName;
                try {
                    const parsedUrl = URLBuilder.parse(this.url);
                    if ("blob" === parsedUrl.getHost().split(".")[1]) {
                        const pathComponents = parsedUrl.getPath().match("/([^/]*)(/(.*))?");
                        containerName = pathComponents[1];
                        blobName = pathComponents[3];
                    } else if (isIpEndpointStyle(parsedUrl)) {
                        const pathComponents = parsedUrl.getPath().match("/([^/]*)/([^/]*)(/(.*))?");
                        containerName = pathComponents[2];
                        blobName = pathComponents[4];
                    } else {
                        const pathComponents = parsedUrl.getPath().match("/([^/]*)(/(.*))?");
                        containerName = pathComponents[1];
                        blobName = pathComponents[3];
                    }
                    containerName = decodeURIComponent(containerName);
                    blobName = decodeURIComponent(blobName);
                    blobName = blobName.replace(/\\/g, "/");
                    if (!containerName) throw new Error("Provided containerName is invalid.");
                    return {
                        blobName,
                        containerName
                    };
                } catch (error) {
                    throw new Error("Unable to extract blobName and containerName with provided information.");
                }
            }
            async startCopyFromURL(copySource, options = {}) {
                var _a, _b, _c;
                const { span, updatedOptions } = tracing_createSpan("BlobClient-startCopyFromURL", options);
                options.conditions = options.conditions || {};
                options.sourceConditions = options.sourceConditions || {};
                try {
                    return await this.blobContext.startCopyFromURL(copySource, Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        metadata: options.metadata,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        sourceModifiedAccessConditions: {
                            sourceIfMatch: options.sourceConditions.ifMatch,
                            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,
                            sourceIfTags: options.sourceConditions.tagConditions
                        },
                        immutabilityPolicyExpiry: null == (_b = options.immutabilityPolicy) ? void 0 : _b.expiriesOn,
                        immutabilityPolicyMode: null == (_c = options.immutabilityPolicy) ? void 0 : _c.policyMode,
                        legalHold: options.legalHold,
                        rehydratePriority: options.rehydratePriority,
                        tier: toAccessTier(options.tier),
                        blobTagsString: toBlobTagsString(options.tags),
                        sealBlob: options.sealBlob
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            generateSasUrl(options) {
                return new Promise((resolve)=>{
                    if (!(this.credential instanceof StorageSharedKeyCredential)) throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
                    const sas = generateBlobSASQueryParameters(Object.assign({
                        containerName: this._containerName,
                        blobName: this._name,
                        snapshotTime: this._snapshot,
                        versionId: this._versionId
                    }, options), this.credential).toString();
                    resolve(appendToURLQuery(this.url, sas));
                });
            }
            async deleteImmutabilityPolicy(options) {
                const { span, updatedOptions } = tracing_createSpan("BlobClient-deleteImmutabilityPolicy", options);
                try {
                    return await this.blobContext.deleteImmutabilityPolicy(Object.assign({
                        abortSignal: null == options ? void 0 : options.abortSignal
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setImmutabilityPolicy(immutabilityPolicy, options) {
                const { span, updatedOptions } = tracing_createSpan("BlobClient-setImmutabilityPolicy", options);
                try {
                    return await this.blobContext.setImmutabilityPolicy(Object.assign({
                        abortSignal: null == options ? void 0 : options.abortSignal,
                        immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,
                        immutabilityPolicyMode: immutabilityPolicy.policyMode,
                        modifiedAccessConditions: null == options ? void 0 : options.modifiedAccessCondition
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setLegalHold(legalHoldEnabled, options) {
                const { span, updatedOptions } = tracing_createSpan("BlobClient-setLegalHold", options);
                try {
                    return await this.blobContext.setLegalHold(legalHoldEnabled, Object.assign({
                        abortSignal: null == options ? void 0 : options.abortSignal
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
        }
        class AppendBlobClient extends BlobClient {
            constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options){
                let pipeline;
                let url;
                options = options || {};
                if (isPipelineLike(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    pipeline = credentialOrPipelineOrContainerName;
                } else if (checkEnvironment_isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    options = blobNameOrOptions;
                    pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
                } else if (credentialOrPipelineOrContainerName || "string" == typeof credentialOrPipelineOrContainerName) if (credentialOrPipelineOrContainerName && "string" == typeof credentialOrPipelineOrContainerName && blobNameOrOptions && "string" == typeof blobNameOrOptions) {
                    const containerName = credentialOrPipelineOrContainerName;
                    const blobName = blobNameOrOptions;
                    const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
                    if ("AccountConnString" === extractedCreds.kind) if (checkEnvironment_isNode) {
                        const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
                        if (!options.proxyOptions) options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                        pipeline = newPipeline(sharedKeyCredential, options);
                    } else throw new Error("Account connection string is only supported in Node.js environment");
                    else if ("SASConnString" === extractedCreds.kind) {
                        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
                        pipeline = newPipeline(new AnonymousCredential(), options);
                    } else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
                } else throw new Error("Expecting non-empty strings for containerName and blobName parameters");
                else {
                    url = urlOrConnectionString;
                    pipeline = newPipeline(new AnonymousCredential(), options);
                }
                super(url, pipeline);
                this.appendBlobContext = new AppendBlob(this.storageClientContext);
            }
            withSnapshot(snapshot) {
                return new AppendBlobClient(setURLParameter(this.url, constants_URLConstants.Parameters.SNAPSHOT, 0 === snapshot.length ? void 0 : snapshot), this.pipeline);
            }
            async create(options = {}) {
                var _a, _b, _c;
                const { span, updatedOptions } = tracing_createSpan("AppendBlobClient-create", options);
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.appendBlobContext.create(0, Object.assign({
                        abortSignal: options.abortSignal,
                        blobHttpHeaders: options.blobHTTPHeaders,
                        leaseAccessConditions: options.conditions,
                        metadata: options.metadata,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope,
                        immutabilityPolicyExpiry: null == (_b = options.immutabilityPolicy) ? void 0 : _b.expiriesOn,
                        immutabilityPolicyMode: null == (_c = options.immutabilityPolicy) ? void 0 : _c.policyMode,
                        legalHold: options.legalHold,
                        blobTagsString: toBlobTagsString(options.tags)
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async createIfNotExists(options = {}) {
                var _a, _b;
                const { span, updatedOptions } = tracing_createSpan("AppendBlobClient-createIfNotExists", options);
                const conditions = {
                    ifNoneMatch: "*"
                };
                try {
                    const res = await this.create(Object.assign(Object.assign({}, updatedOptions), {
                        conditions
                    }));
                    return Object.assign(Object.assign({
                        succeeded: true
                    }, res), {
                        _response: res._response
                    });
                } catch (e) {
                    if ((null == (_a = e.details) ? void 0 : _a.errorCode) === "BlobAlreadyExists") {
                        span.setStatus({
                            code: interfaces_SpanStatusCode.ERROR,
                            message: "Expected exception when creating a blob only if it does not already exist."
                        });
                        return Object.assign(Object.assign({
                            succeeded: false
                        }, null == (_b = e.response) ? void 0 : _b.parsedHeaders), {
                            _response: e.response
                        });
                    }
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async seal(options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("AppendBlobClient-seal", options);
                options.conditions = options.conditions || {};
                try {
                    return await this.appendBlobContext.seal(Object.assign({
                        abortSignal: options.abortSignal,
                        appendPositionAccessConditions: options.conditions,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async appendBlock(body, contentLength, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("AppendBlobClient-appendBlock", options);
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.appendBlobContext.appendBlock(contentLength, body, Object.assign({
                        abortSignal: options.abortSignal,
                        appendPositionAccessConditions: options.conditions,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        requestOptions: {
                            onUploadProgress: options.onProgress
                        },
                        transactionalContentMD5: options.transactionalContentMD5,
                        transactionalContentCrc64: options.transactionalContentCrc64,
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("AppendBlobClient-appendBlockFromURL", options);
                options.conditions = options.conditions || {};
                options.sourceConditions = options.sourceConditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, Object.assign({
                        abortSignal: options.abortSignal,
                        sourceRange: rangeToString({
                            offset: sourceOffset,
                            count
                        }),
                        sourceContentMD5: options.sourceContentMD5,
                        sourceContentCrc64: options.sourceContentCrc64,
                        leaseAccessConditions: options.conditions,
                        appendPositionAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        sourceModifiedAccessConditions: {
                            sourceIfMatch: options.sourceConditions.ifMatch,
                            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
                        },
                        copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
        }
        class BlockBlobClient extends BlobClient {
            constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options){
                let pipeline;
                let url;
                options = options || {};
                if (isPipelineLike(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    pipeline = credentialOrPipelineOrContainerName;
                } else if (checkEnvironment_isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    options = blobNameOrOptions;
                    pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
                } else if (credentialOrPipelineOrContainerName || "string" == typeof credentialOrPipelineOrContainerName) if (credentialOrPipelineOrContainerName && "string" == typeof credentialOrPipelineOrContainerName && blobNameOrOptions && "string" == typeof blobNameOrOptions) {
                    const containerName = credentialOrPipelineOrContainerName;
                    const blobName = blobNameOrOptions;
                    const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
                    if ("AccountConnString" === extractedCreds.kind) if (checkEnvironment_isNode) {
                        const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
                        if (!options.proxyOptions) options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                        pipeline = newPipeline(sharedKeyCredential, options);
                    } else throw new Error("Account connection string is only supported in Node.js environment");
                    else if ("SASConnString" === extractedCreds.kind) {
                        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
                        pipeline = newPipeline(new AnonymousCredential(), options);
                    } else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
                } else throw new Error("Expecting non-empty strings for containerName and blobName parameters");
                else {
                    url = urlOrConnectionString;
                    if (blobNameOrOptions && "string" != typeof blobNameOrOptions) options = blobNameOrOptions;
                    pipeline = newPipeline(new AnonymousCredential(), options);
                }
                super(url, pipeline);
                this.blockBlobContext = new BlockBlob(this.storageClientContext);
                this._blobContext = new blob_Blob(this.storageClientContext);
            }
            withSnapshot(snapshot) {
                return new BlockBlobClient(setURLParameter(this.url, constants_URLConstants.Parameters.SNAPSHOT, 0 === snapshot.length ? void 0 : snapshot), this.pipeline);
            }
            async query(query, options = {}) {
                var _a;
                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-query", options);
                try {
                    if (!checkEnvironment_isNode) throw new Error("This operation currently is only supported in Node.js.");
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    const response = await this._blobContext.query(Object.assign({
                        abortSignal: options.abortSignal,
                        queryRequest: {
                            queryType: "SQL",
                            expression: query,
                            inputSerialization: toQuerySerialization(options.inputTextConfiguration),
                            outputSerialization: toQuerySerialization(options.outputTextConfiguration)
                        },
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        cpkInfo: options.customerProvidedKey
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    return new BlobQueryResponse(response, {
                        abortSignal: options.abortSignal,
                        onProgress: options.onProgress,
                        onError: options.onError
                    });
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async upload(body, contentLength, options = {}) {
                var _a, _b, _c;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-upload", options);
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.blockBlobContext.upload(contentLength, body, Object.assign({
                        abortSignal: options.abortSignal,
                        blobHttpHeaders: options.blobHTTPHeaders,
                        leaseAccessConditions: options.conditions,
                        metadata: options.metadata,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        requestOptions: {
                            onUploadProgress: options.onProgress
                        },
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope,
                        immutabilityPolicyExpiry: null == (_b = options.immutabilityPolicy) ? void 0 : _b.expiriesOn,
                        immutabilityPolicyMode: null == (_c = options.immutabilityPolicy) ? void 0 : _c.policyMode,
                        legalHold: options.legalHold,
                        tier: toAccessTier(options.tier),
                        blobTagsString: toBlobTagsString(options.tags)
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async syncUploadFromURL(sourceURL, options = {}) {
                var _a, _b, _c, _d, _e;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-syncUploadFromURL", options);
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.blockBlobContext.putBlobFromUrl(0, sourceURL, Object.assign(Object.assign(Object.assign({}, options), {
                        blobHttpHeaders: options.blobHTTPHeaders,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: options.conditions.tagConditions
                        }),
                        sourceModifiedAccessConditions: {
                            sourceIfMatch: null == (_a = options.sourceConditions) ? void 0 : _a.ifMatch,
                            sourceIfModifiedSince: null == (_b = options.sourceConditions) ? void 0 : _b.ifModifiedSince,
                            sourceIfNoneMatch: null == (_c = options.sourceConditions) ? void 0 : _c.ifNoneMatch,
                            sourceIfUnmodifiedSince: null == (_d = options.sourceConditions) ? void 0 : _d.ifUnmodifiedSince,
                            sourceIfTags: null == (_e = options.sourceConditions) ? void 0 : _e.tagConditions
                        },
                        cpkInfo: options.customerProvidedKey,
                        copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
                        tier: toAccessTier(options.tier),
                        blobTagsString: toBlobTagsString(options.tags),
                        copySourceTags: options.copySourceTags
                    }), convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async stageBlock(blockId, body, contentLength, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-stageBlock", options);
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.blockBlobContext.stageBlock(blockId, contentLength, body, Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        requestOptions: {
                            onUploadProgress: options.onProgress
                        },
                        transactionalContentMD5: options.transactionalContentMD5,
                        transactionalContentCrc64: options.transactionalContentCrc64,
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async stageBlockFromURL(blockId, sourceURL, offset = 0, count, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-stageBlockFromURL", options);
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        sourceContentMD5: options.sourceContentMD5,
                        sourceContentCrc64: options.sourceContentCrc64,
                        sourceRange: 0 !== offset || count ? rangeToString({
                            offset,
                            count
                        }) : void 0,
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope,
                        copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization)
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async commitBlockList(blocks, options = {}) {
                var _a, _b, _c;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-commitBlockList", options);
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.blockBlobContext.commitBlockList({
                        latest: blocks
                    }, Object.assign({
                        abortSignal: options.abortSignal,
                        blobHttpHeaders: options.blobHTTPHeaders,
                        leaseAccessConditions: options.conditions,
                        metadata: options.metadata,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope,
                        immutabilityPolicyExpiry: null == (_b = options.immutabilityPolicy) ? void 0 : _b.expiriesOn,
                        immutabilityPolicyMode: null == (_c = options.immutabilityPolicy) ? void 0 : _c.policyMode,
                        legalHold: options.legalHold,
                        tier: toAccessTier(options.tier),
                        blobTagsString: toBlobTagsString(options.tags)
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async getBlockList(listType, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-getBlockList", options);
                try {
                    const res = await this.blockBlobContext.getBlockList(listType, Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    if (!res.committedBlocks) res.committedBlocks = [];
                    if (!res.uncommittedBlocks) res.uncommittedBlocks = [];
                    return res;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async uploadData(data, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-uploadData", options);
                try {
                    if (checkEnvironment_isNode) {
                        let buffer;
                        buffer = data instanceof Buffer ? data : data instanceof ArrayBuffer ? Buffer.from(data) : Buffer.from(data.buffer, data.byteOffset, data.byteLength);
                        return this.uploadSeekableInternal((offset, size)=>buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);
                    }
                    {
                        const browserBlob = new Blob([
                            data
                        ]);
                        return this.uploadSeekableInternal((offset, size)=>browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
                    }
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async uploadBrowserData(browserData, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-uploadBrowserData", options);
                try {
                    const browserBlob = new Blob([
                        browserData
                    ]);
                    return await this.uploadSeekableInternal((offset, size)=>browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async uploadSeekableInternal(bodyFactory, size, options = {}) {
                if (!options.blockSize) options.blockSize = 0;
                if (options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) throw new RangeError(`blockSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);
                if (0 !== options.maxSingleShotSize && !options.maxSingleShotSize) options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
                if (options.maxSingleShotSize < 0 || options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);
                if (0 === options.blockSize) {
                    if (size > 50000 * BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) throw new RangeError(`${size} is too larger to upload to a block blob.`);
                    if (size > options.maxSingleShotSize) {
                        options.blockSize = Math.ceil(size / 50000);
                        if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
                    }
                }
                if (!options.blobHTTPHeaders) options.blobHTTPHeaders = {};
                if (!options.conditions) options.conditions = {};
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-uploadSeekableInternal", options);
                try {
                    if (size <= options.maxSingleShotSize) return await this.upload(bodyFactory(0, size), size, updatedOptions);
                    const numBlocks = Math.floor((size - 1) / options.blockSize) + 1;
                    if (numBlocks > 50000) throw new RangeError("The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= 50000");
                    const blockList = [];
                    const blockIDPrefix = generateUuid();
                    let transferProgress = 0;
                    const batch = new Batch(options.concurrency);
                    for(let i = 0; i < numBlocks; i++)batch.addOperation(async ()=>{
                        const blockID = generateBlockID(blockIDPrefix, i);
                        const start = options.blockSize * i;
                        const end = i === numBlocks - 1 ? size : start + options.blockSize;
                        const contentLength = end - start;
                        blockList.push(blockID);
                        await this.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {
                            abortSignal: options.abortSignal,
                            conditions: options.conditions,
                            encryptionScope: options.encryptionScope,
                            tracingOptions: updatedOptions.tracingOptions
                        });
                        transferProgress += contentLength;
                        if (options.onProgress) options.onProgress({
                            loadedBytes: transferProgress
                        });
                    });
                    await batch.do();
                    return this.commitBlockList(blockList, updatedOptions);
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async uploadFile(filePath, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-uploadFile", options);
                try {
                    const size = (await fsStat(filePath)).size;
                    return await this.uploadSeekableInternal((offset, count)=>()=>fsCreateReadStream(filePath, {
                                autoClose: true,
                                end: count ? offset + count - 1 : 1 / 0,
                                start: offset
                            }), size, Object.assign(Object.assign({}, options), {
                        tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
                    }));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async uploadStream(stream, bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {
                if (!options.blobHTTPHeaders) options.blobHTTPHeaders = {};
                if (!options.conditions) options.conditions = {};
                const { span, updatedOptions } = tracing_createSpan("BlockBlobClient-uploadStream", options);
                try {
                    let blockNum = 0;
                    const blockIDPrefix = generateUuid();
                    let transferProgress = 0;
                    const blockList = [];
                    const scheduler = new BufferScheduler(stream, bufferSize, maxConcurrency, async (body, length)=>{
                        const blockID = generateBlockID(blockIDPrefix, blockNum);
                        blockList.push(blockID);
                        blockNum++;
                        await this.stageBlock(blockID, body, length, {
                            conditions: options.conditions,
                            encryptionScope: options.encryptionScope,
                            tracingOptions: updatedOptions.tracingOptions
                        });
                        transferProgress += length;
                        if (options.onProgress) options.onProgress({
                            loadedBytes: transferProgress
                        });
                    }, Math.ceil(maxConcurrency / 4 * 3));
                    await scheduler.do();
                    return await this.commitBlockList(blockList, Object.assign(Object.assign({}, options), {
                        tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
                    }));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
        }
        class PageBlobClient extends BlobClient {
            constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options){
                let pipeline;
                let url;
                options = options || {};
                if (isPipelineLike(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    pipeline = credentialOrPipelineOrContainerName;
                } else if (checkEnvironment_isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    options = blobNameOrOptions;
                    pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
                } else if (credentialOrPipelineOrContainerName || "string" == typeof credentialOrPipelineOrContainerName) if (credentialOrPipelineOrContainerName && "string" == typeof credentialOrPipelineOrContainerName && blobNameOrOptions && "string" == typeof blobNameOrOptions) {
                    const containerName = credentialOrPipelineOrContainerName;
                    const blobName = blobNameOrOptions;
                    const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
                    if ("AccountConnString" === extractedCreds.kind) if (checkEnvironment_isNode) {
                        const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
                        if (!options.proxyOptions) options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                        pipeline = newPipeline(sharedKeyCredential, options);
                    } else throw new Error("Account connection string is only supported in Node.js environment");
                    else if ("SASConnString" === extractedCreds.kind) {
                        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
                        pipeline = newPipeline(new AnonymousCredential(), options);
                    } else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
                } else throw new Error("Expecting non-empty strings for containerName and blobName parameters");
                else {
                    url = urlOrConnectionString;
                    pipeline = newPipeline(new AnonymousCredential(), options);
                }
                super(url, pipeline);
                this.pageBlobContext = new PageBlob(this.storageClientContext);
            }
            withSnapshot(snapshot) {
                return new PageBlobClient(setURLParameter(this.url, constants_URLConstants.Parameters.SNAPSHOT, 0 === snapshot.length ? void 0 : snapshot), this.pipeline);
            }
            async create(size, options = {}) {
                var _a, _b, _c;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-create", options);
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.pageBlobContext.create(0, size, Object.assign({
                        abortSignal: options.abortSignal,
                        blobHttpHeaders: options.blobHTTPHeaders,
                        blobSequenceNumber: options.blobSequenceNumber,
                        leaseAccessConditions: options.conditions,
                        metadata: options.metadata,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope,
                        immutabilityPolicyExpiry: null == (_b = options.immutabilityPolicy) ? void 0 : _b.expiriesOn,
                        immutabilityPolicyMode: null == (_c = options.immutabilityPolicy) ? void 0 : _c.policyMode,
                        legalHold: options.legalHold,
                        tier: toAccessTier(options.tier),
                        blobTagsString: toBlobTagsString(options.tags)
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async createIfNotExists(size, options = {}) {
                var _a, _b;
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-createIfNotExists", options);
                try {
                    const conditions = {
                        ifNoneMatch: "*"
                    };
                    const res = await this.create(size, Object.assign(Object.assign({}, options), {
                        conditions,
                        tracingOptions: updatedOptions.tracingOptions
                    }));
                    return Object.assign(Object.assign({
                        succeeded: true
                    }, res), {
                        _response: res._response
                    });
                } catch (e) {
                    if ((null == (_a = e.details) ? void 0 : _a.errorCode) === "BlobAlreadyExists") {
                        span.setStatus({
                            code: interfaces_SpanStatusCode.ERROR,
                            message: "Expected exception when creating a blob only if it does not already exist."
                        });
                        return Object.assign(Object.assign({
                            succeeded: false
                        }, null == (_b = e.response) ? void 0 : _b.parsedHeaders), {
                            _response: e.response
                        });
                    }
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async uploadPages(body, offset, count, options = {}) {
                var _a;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-uploadPages", options);
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.pageBlobContext.uploadPages(count, body, Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        requestOptions: {
                            onUploadProgress: options.onProgress
                        },
                        range: rangeToString({
                            offset,
                            count
                        }),
                        sequenceNumberAccessConditions: options.conditions,
                        transactionalContentMD5: options.transactionalContentMD5,
                        transactionalContentCrc64: options.transactionalContentCrc64,
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {
                var _a;
                options.conditions = options.conditions || {};
                options.sourceConditions = options.sourceConditions || {};
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-uploadPagesFromURL", options);
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return await this.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({
                        offset: sourceOffset,
                        count
                    }), 0, rangeToString({
                        offset: destOffset,
                        count
                    }), Object.assign({
                        abortSignal: options.abortSignal,
                        sourceContentMD5: options.sourceContentMD5,
                        sourceContentCrc64: options.sourceContentCrc64,
                        leaseAccessConditions: options.conditions,
                        sequenceNumberAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        sourceModifiedAccessConditions: {
                            sourceIfMatch: options.sourceConditions.ifMatch,
                            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
                        },
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope,
                        copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization)
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async clearPages(offset = 0, count, options = {}) {
                var _a;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-clearPages", options);
                try {
                    return await this.pageBlobContext.clearPages(0, Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        range: rangeToString({
                            offset,
                            count
                        }),
                        sequenceNumberAccessConditions: options.conditions,
                        cpkInfo: options.customerProvidedKey,
                        encryptionScope: options.encryptionScope
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async getPageRanges(offset = 0, count, options = {}) {
                var _a;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-getPageRanges", options);
                try {
                    return await this.pageBlobContext.getPageRanges(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        range: rangeToString({
                            offset,
                            count
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async listPageRangesSegment(offset = 0, count, marker, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-getPageRangesSegment", options);
                try {
                    return await this.pageBlobContext.getPageRanges(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        range: rangeToString({
                            offset,
                            count
                        }),
                        marker: marker,
                        maxPageSize: options.maxPageSize
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            listPageRangeItemSegments(offset = 0, count, marker, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    let getPageRangeItemSegmentsResponse;
                    if (!!marker || void 0 === marker) do {
                        getPageRangeItemSegmentsResponse = yield __await(this.listPageRangesSegment(offset, count, marker, options));
                        marker = getPageRangeItemSegmentsResponse.continuationToken;
                        yield yield __await((yield __await(getPageRangeItemSegmentsResponse)));
                    }while (marker);
                });
            }
            listPageRangeItems(offset = 0, count, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    var e_1, _a;
                    let marker;
                    try {
                        for(var _b = __asyncValues(this.listPageRangeItemSegments(offset, count, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;){
                            const getPageRangesSegment = _c.value;
                            yield __await((yield* __asyncDelegator(__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment)))));
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally{
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                        } finally{
                            if (e_1) throw e_1.error;
                        }
                    }
                });
            }
            listPageRanges(offset = 0, count, options = {}) {
                options.conditions = options.conditions || {};
                const iter = this.listPageRangeItems(offset, count, options);
                return {
                    next () {
                        return iter.next();
                    },
                    [Symbol.asyncIterator] () {
                        return this;
                    },
                    byPage: (settings = {})=>this.listPageRangeItemSegments(offset, count, settings.continuationToken, Object.assign({
                            maxPageSize: settings.maxPageSize
                        }, options))
                };
            }
            async getPageRangesDiff(offset, count, prevSnapshot, options = {}) {
                var _a;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-getPageRangesDiff", options);
                try {
                    return await this.pageBlobContext.getPageRangesDiff(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        prevsnapshot: prevSnapshot,
                        range: rangeToString({
                            offset,
                            count
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-getPageRangesDiffSegment", options);
                try {
                    return await this.pageBlobContext.getPageRangesDiff(Object.assign({
                        abortSignal: null == options ? void 0 : options.abortSignal,
                        leaseAccessConditions: null == options ? void 0 : options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, null == options ? void 0 : options.conditions), {
                            ifTags: null == (_a = null == options ? void 0 : options.conditions) ? void 0 : _a.tagConditions
                        }),
                        prevsnapshot: prevSnapshotOrUrl,
                        range: rangeToString({
                            offset: offset,
                            count: count
                        }),
                        marker: marker,
                        maxPageSize: null == options ? void 0 : options.maxPageSize
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options) {
                return __asyncGenerator(this, arguments, function*() {
                    let getPageRangeItemSegmentsResponse;
                    if (!!marker || void 0 === marker) do {
                        getPageRangeItemSegmentsResponse = yield __await(this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options));
                        marker = getPageRangeItemSegmentsResponse.continuationToken;
                        yield yield __await((yield __await(getPageRangeItemSegmentsResponse)));
                    }while (marker);
                });
            }
            listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {
                return __asyncGenerator(this, arguments, function*() {
                    var e_2, _a;
                    let marker;
                    try {
                        for(var _b = __asyncValues(this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;){
                            const getPageRangesSegment = _c.value;
                            yield __await((yield* __asyncDelegator(__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment)))));
                        }
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally{
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                        } finally{
                            if (e_2) throw e_2.error;
                        }
                    }
                });
            }
            listPageRangesDiff(offset, count, prevSnapshot, options = {}) {
                options.conditions = options.conditions || {};
                const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, Object.assign({}, options));
                return {
                    next () {
                        return iter.next();
                    },
                    [Symbol.asyncIterator] () {
                        return this;
                    },
                    byPage: (settings = {})=>this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, Object.assign({
                            maxPageSize: settings.maxPageSize
                        }, options))
                };
            }
            async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options = {}) {
                var _a;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options);
                try {
                    return await this.pageBlobContext.getPageRangesDiff(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        prevSnapshotUrl,
                        range: rangeToString({
                            offset,
                            count
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async resize(size, options = {}) {
                var _a;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-resize", options);
                try {
                    return await this.pageBlobContext.resize(size, Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        }),
                        encryptionScope: options.encryptionScope
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async updateSequenceNumber(sequenceNumberAction, sequenceNumber, options = {}) {
                var _a;
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-updateSequenceNumber", options);
                try {
                    return await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, Object.assign({
                        abortSignal: options.abortSignal,
                        blobSequenceNumber: sequenceNumber,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async startCopyIncremental(copySource, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("PageBlobClient-startCopyIncremental", options);
                try {
                    return await this.pageBlobContext.copyIncremental(copySource, Object.assign({
                        abortSignal: options.abortSignal,
                        modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {
                            ifTags: null == (_a = options.conditions) ? void 0 : _a.tagConditions
                        })
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
        }
        async function getBodyAsText(batchResponse) {
            let buffer = Buffer.alloc(BATCH_MAX_PAYLOAD_IN_BYTES);
            const responseLength = await streamToBuffer2(batchResponse.readableStreamBody, buffer);
            buffer = buffer.slice(0, responseLength);
            return buffer.toString();
        }
        function utf8ByteLength(str) {
            return Buffer.byteLength(str);
        }
        const HTTP_HEADER_DELIMITER = ": ";
        const SPACE_DELIMITER = " ";
        const NOT_FOUND = -1;
        class BatchResponseParser {
            constructor(batchResponse, subRequests){
                if (!batchResponse || !batchResponse.contentType) throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
                if (!subRequests || 0 === subRequests.size) throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
                this.batchResponse = batchResponse;
                this.subRequests = subRequests;
                this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1];
                this.perResponsePrefix = `--${this.responseBatchBoundary}\r\n`;
                this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
            }
            async parseBatchResponse() {
                if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
                const responseBodyAsText = await getBodyAsText(this.batchResponse);
                const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1);
                const subResponseCount = subResponses.length;
                if (subResponseCount !== this.subRequests.size && 1 !== subResponseCount) throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
                const deserializedSubResponses = new Array(subResponseCount);
                let subResponsesSucceededCount = 0;
                let subResponsesFailedCount = 0;
                for(let index = 0; index < subResponseCount; index++){
                    const subResponse = subResponses[index];
                    const deserializedSubResponse = {};
                    deserializedSubResponse.headers = new httpHeaders_HttpHeaders();
                    const responseLines = subResponse.split(`\r\n`);
                    let subRespHeaderStartFound = false;
                    let subRespHeaderEndFound = false;
                    let subRespFailed = false;
                    let contentId = NOT_FOUND;
                    for (const responseLine of responseLines){
                        if (!subRespHeaderStartFound) {
                            if (responseLine.startsWith(constants_HeaderConstants.CONTENT_ID)) contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
                            if (responseLine.startsWith(HTTP_VERSION_1_1)) {
                                subRespHeaderStartFound = true;
                                const tokens = responseLine.split(SPACE_DELIMITER);
                                deserializedSubResponse.status = parseInt(tokens[1]);
                                deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
                            }
                            continue;
                        }
                        if ("" === responseLine.trim()) {
                            if (!subRespHeaderEndFound) subRespHeaderEndFound = true;
                            continue;
                        }
                        if (subRespHeaderEndFound) {
                            if (!deserializedSubResponse.bodyAsText) deserializedSubResponse.bodyAsText = "";
                            deserializedSubResponse.bodyAsText += responseLine;
                        } else {
                            if (-1 === responseLine.indexOf(HTTP_HEADER_DELIMITER)) throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
                            const tokens = responseLine.split(HTTP_HEADER_DELIMITER);
                            deserializedSubResponse.headers.set(tokens[0], tokens[1]);
                            if (tokens[0] === constants_HeaderConstants.X_MS_ERROR_CODE) {
                                deserializedSubResponse.errorCode = tokens[1];
                                subRespFailed = true;
                            }
                        }
                    }
                    if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && void 0 === deserializedSubResponses[contentId]) {
                        deserializedSubResponse._request = this.subRequests.get(contentId);
                        deserializedSubResponses[contentId] = deserializedSubResponse;
                    } else src_log_logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
                    if (subRespFailed) subResponsesFailedCount++;
                    else subResponsesSucceededCount++;
                }
                return {
                    subResponses: deserializedSubResponses,
                    subResponsesSucceededCount: subResponsesSucceededCount,
                    subResponsesFailedCount: subResponsesFailedCount
                };
            }
        }
        var Mutex_MutexLockStatus;
        (function(MutexLockStatus) {
            MutexLockStatus[MutexLockStatus["LOCKED"] = 0] = "LOCKED";
            MutexLockStatus[MutexLockStatus["UNLOCKED"] = 1] = "UNLOCKED";
        })(Mutex_MutexLockStatus || (Mutex_MutexLockStatus = {}));
        class Mutex {
            static async lock(key) {
                return new Promise((resolve)=>{
                    if (void 0 === this.keys[key] || this.keys[key] === Mutex_MutexLockStatus.UNLOCKED) {
                        this.keys[key] = Mutex_MutexLockStatus.LOCKED;
                        resolve();
                    } else this.onUnlockEvent(key, ()=>{
                        this.keys[key] = Mutex_MutexLockStatus.LOCKED;
                        resolve();
                    });
                });
            }
            static async unlock(key) {
                return new Promise((resolve)=>{
                    if (this.keys[key] === Mutex_MutexLockStatus.LOCKED) this.emitUnlockEvent(key);
                    delete this.keys[key];
                    resolve();
                });
            }
            static onUnlockEvent(key, handler) {
                if (void 0 === this.listeners[key]) this.listeners[key] = [
                    handler
                ];
                else this.listeners[key].push(handler);
            }
            static emitUnlockEvent(key) {
                if (void 0 !== this.listeners[key] && this.listeners[key].length > 0) {
                    const handler = this.listeners[key].shift();
                    setImmediate(()=>{
                        handler.call(this);
                    });
                }
            }
        }
        Mutex.keys = {};
        Mutex.listeners = {};
        class BlobBatch {
            constructor(){
                this.batch = "batch";
                this.batchRequest = new InnerBatchRequest();
            }
            getMultiPartContentType() {
                return this.batchRequest.getMultipartContentType();
            }
            getHttpRequestBody() {
                return this.batchRequest.getHttpRequestBody();
            }
            getSubRequests() {
                return this.batchRequest.getSubRequests();
            }
            async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
                await Mutex.lock(this.batch);
                try {
                    this.batchRequest.preAddSubRequest(subRequest);
                    await assembleSubRequestFunc();
                    this.batchRequest.postAddSubRequest(subRequest);
                } finally{
                    await Mutex.unlock(this.batch);
                }
            }
            setBatchType(batchType) {
                if (!this.batchType) this.batchType = batchType;
                if (this.batchType !== batchType) throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
            }
            async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {
                let url;
                let credential;
                if ("string" == typeof urlOrBlobClient && (checkEnvironment_isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || isTokenCredential(credentialOrOptions))) {
                    url = urlOrBlobClient;
                    credential = credentialOrOptions;
                } else if (urlOrBlobClient instanceof BlobClient) {
                    url = urlOrBlobClient.url;
                    credential = urlOrBlobClient.credential;
                    options = credentialOrOptions;
                } else throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
                if (!options) options = {};
                const { span, updatedOptions } = tracing_createSpan("BatchDeleteRequest-addSubRequest", options);
                try {
                    this.setBatchType("delete");
                    await this.addSubRequestInternal({
                        url: url,
                        credential: credential
                    }, async ()=>{
                        await new BlobClient(url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
                    });
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {
                let url;
                let credential;
                let tier;
                if ("string" == typeof urlOrBlobClient && (checkEnvironment_isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || isTokenCredential(credentialOrTier))) {
                    url = urlOrBlobClient;
                    credential = credentialOrTier;
                    tier = tierOrOptions;
                } else if (urlOrBlobClient instanceof BlobClient) {
                    url = urlOrBlobClient.url;
                    credential = urlOrBlobClient.credential;
                    tier = credentialOrTier;
                    options = tierOrOptions;
                } else throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
                if (!options) options = {};
                const { span, updatedOptions } = tracing_createSpan("BatchSetTierRequest-addSubRequest", options);
                try {
                    this.setBatchType("setAccessTier");
                    await this.addSubRequestInternal({
                        url: url,
                        credential: credential
                    }, async ()=>{
                        await new BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);
                    });
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
        }
        class InnerBatchRequest {
            constructor(){
                this.operationCount = 0;
                this.body = "";
                const tempGuid = generateUuid();
                this.boundary = `batch_${tempGuid}`;
                this.subRequestPrefix = `--${this.boundary}\r\n${constants_HeaderConstants.CONTENT_TYPE}: application/http\r\n${constants_HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;
                this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;
                this.batchRequestEnding = `--${this.boundary}--`;
                this.subRequests = new Map();
            }
            createPipeline(credential) {
                const isAnonymousCreds = credential instanceof AnonymousCredential;
                const policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1);
                const factories = new Array(policyFactoryLength);
                factories[0] = deserializationPolicy_deserializationPolicy();
                factories[1] = new BatchHeaderFilterPolicyFactory();
                if (!isAnonymousCreds) factories[2] = isTokenCredential(credential) ? attachCredential(bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes), credential) : credential;
                factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this);
                return new Pipeline(factories, {});
            }
            appendSubRequestToBody(request) {
                this.body += [
                    this.subRequestPrefix,
                    `${constants_HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
                    "",
                    `${request.method.toString()} ${getURLPathAndQuery(request.url)} ${HTTP_VERSION_1_1}\r\n`
                ].join("\r\n");
                for (const header of request.headers.headersArray())this.body += `${header.name}: ${header.value}\r\n`;
                this.body += "\r\n";
            }
            preAddSubRequest(subRequest) {
                if (this.operationCount >= 256) throw new RangeError("Cannot exceed 256 sub requests in a single batch");
                const path = getURLPath(subRequest.url);
                if (!path || "" === path) throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);
            }
            postAddSubRequest(subRequest) {
                this.subRequests.set(this.operationCount, subRequest);
                this.operationCount++;
            }
            getHttpRequestBody() {
                return `${this.body}${this.batchRequestEnding}\r\n`;
            }
            getMultipartContentType() {
                return this.multipartContentType;
            }
            getSubRequests() {
                return this.subRequests;
            }
        }
        class BatchRequestAssemblePolicy extends BaseRequestPolicy {
            constructor(batchRequest, nextPolicy, options){
                super(nextPolicy, options);
                this.dummyResponse = {
                    request: new WebResource(),
                    status: 200,
                    headers: new httpHeaders_HttpHeaders()
                };
                this.batchRequest = batchRequest;
            }
            async sendRequest(request) {
                await this.batchRequest.appendSubRequestToBody(request);
                return this.dummyResponse;
            }
        }
        class BatchRequestAssemblePolicyFactory {
            constructor(batchRequest){
                this.batchRequest = batchRequest;
            }
            create(nextPolicy, options) {
                return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);
            }
        }
        class BatchHeaderFilterPolicy extends BaseRequestPolicy {
            constructor(nextPolicy, options){
                super(nextPolicy, options);
            }
            async sendRequest(request) {
                let xMsHeaderName = "";
                for (const header of request.headers.headersArray())if (iEqual(header.name, constants_HeaderConstants.X_MS_VERSION)) xMsHeaderName = header.name;
                if ("" !== xMsHeaderName) request.headers.remove(xMsHeaderName);
                return this._nextPolicy.sendRequest(request);
            }
        }
        class BatchHeaderFilterPolicyFactory {
            create(nextPolicy, options) {
                return new BatchHeaderFilterPolicy(nextPolicy, options);
            }
        }
        class BlobBatchClient {
            constructor(url, credentialOrPipeline, options){
                let pipeline;
                pipeline = isPipelineLike(credentialOrPipeline) ? credentialOrPipeline : credentialOrPipeline ? newPipeline(credentialOrPipeline, options) : newPipeline(new AnonymousCredential(), options);
                const storageClientContext = new StorageClientContext(url, pipeline.toServiceClientOptions());
                const path = getURLPath(url);
                if (path && "/" !== path) this.serviceOrContainerContext = new Container(storageClientContext);
                else this.serviceOrContainerContext = new Service(storageClientContext);
            }
            createBatch() {
                return new BlobBatch();
            }
            async deleteBlobs(urlsOrBlobClients, credentialOrOptions, options) {
                const batch = new BlobBatch();
                for (const urlOrBlobClient of urlsOrBlobClients)if ("string" == typeof urlOrBlobClient) await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options);
                else await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
                return this.submitBatch(batch);
            }
            async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, options) {
                const batch = new BlobBatch();
                for (const urlOrBlobClient of urlsOrBlobClients)if ("string" == typeof urlOrBlobClient) await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options);
                else await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
                return this.submitBatch(batch);
            }
            async submitBatch(batchRequest, options = {}) {
                if (!batchRequest || 0 === batchRequest.getSubRequests().size) throw new RangeError("Batch request should contain one or more sub requests.");
                const { span, updatedOptions } = tracing_createSpan("BlobBatchClient-submitBatch", options);
                try {
                    const batchRequestBody = batchRequest.getHttpRequestBody();
                    const rawBatchResponse = await this.serviceOrContainerContext.submitBatch(utf8ByteLength(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
                    const batchResponseParser = new BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests());
                    const responseSummary = await batchResponseParser.parseBatchResponse();
                    const res = {
                        _response: rawBatchResponse._response,
                        contentType: rawBatchResponse.contentType,
                        errorCode: rawBatchResponse.errorCode,
                        requestId: rawBatchResponse.requestId,
                        clientRequestId: rawBatchResponse.clientRequestId,
                        version: rawBatchResponse.version,
                        subResponses: responseSummary.subResponses,
                        subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
                        subResponsesFailedCount: responseSummary.subResponsesFailedCount
                    };
                    return res;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
        }
        class ContainerClient extends StorageClient {
            constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, options){
                let pipeline;
                let url;
                options = options || {};
                if (isPipelineLike(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    pipeline = credentialOrPipelineOrContainerName;
                } else if (checkEnvironment_isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {
                    url = urlOrConnectionString;
                    pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
                } else if (credentialOrPipelineOrContainerName || "string" == typeof credentialOrPipelineOrContainerName) if (credentialOrPipelineOrContainerName && "string" == typeof credentialOrPipelineOrContainerName) {
                    const containerName = credentialOrPipelineOrContainerName;
                    const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
                    if ("AccountConnString" === extractedCreds.kind) if (checkEnvironment_isNode) {
                        const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                        url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));
                        if (!options.proxyOptions) options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                        pipeline = newPipeline(sharedKeyCredential, options);
                    } else throw new Error("Account connection string is only supported in Node.js environment");
                    else if ("SASConnString" === extractedCreds.kind) {
                        url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas;
                        pipeline = newPipeline(new AnonymousCredential(), options);
                    } else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
                } else throw new Error("Expecting non-empty strings for containerName parameter");
                else {
                    url = urlOrConnectionString;
                    pipeline = newPipeline(new AnonymousCredential(), options);
                }
                super(url, pipeline);
                this._containerName = this.getContainerNameFromUrl();
                this.containerContext = new Container(this.storageClientContext);
            }
            get containerName() {
                return this._containerName;
            }
            async create(options = {}) {
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-create", options);
                try {
                    return await this.containerContext.create(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async createIfNotExists(options = {}) {
                var _a, _b;
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-createIfNotExists", options);
                try {
                    const res = await this.create(updatedOptions);
                    return Object.assign(Object.assign({
                        succeeded: true
                    }, res), {
                        _response: res._response
                    });
                } catch (e) {
                    if ((null == (_a = e.details) ? void 0 : _a.errorCode) === "ContainerAlreadyExists") {
                        span.setStatus({
                            code: interfaces_SpanStatusCode.ERROR,
                            message: "Expected exception when creating a container only if it does not already exist."
                        });
                        return Object.assign(Object.assign({
                            succeeded: false
                        }, null == (_b = e.response) ? void 0 : _b.parsedHeaders), {
                            _response: e.response
                        });
                    }
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async exists(options = {}) {
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-exists", options);
                try {
                    await this.getProperties({
                        abortSignal: options.abortSignal,
                        tracingOptions: updatedOptions.tracingOptions
                    });
                    return true;
                } catch (e) {
                    if (404 === e.statusCode) {
                        span.setStatus({
                            code: interfaces_SpanStatusCode.ERROR,
                            message: "Expected exception when checking container existence"
                        });
                        return false;
                    }
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            getBlobClient(blobName) {
                return new BlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
            }
            getAppendBlobClient(blobName) {
                return new AppendBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
            }
            getBlockBlobClient(blobName) {
                return new BlockBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
            }
            getPageBlobClient(blobName) {
                return new PageBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
            }
            async getProperties(options = {}) {
                if (!options.conditions) options.conditions = {};
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-getProperties", options);
                try {
                    return await this.containerContext.getProperties(Object.assign(Object.assign({
                        abortSignal: options.abortSignal
                    }, options.conditions), convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async delete(options = {}) {
                if (!options.conditions) options.conditions = {};
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-delete", options);
                try {
                    return await this.containerContext.delete(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: options.conditions
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async deleteIfExists(options = {}) {
                var _a, _b;
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-deleteIfExists", options);
                try {
                    const res = await this.delete(updatedOptions);
                    return Object.assign(Object.assign({
                        succeeded: true
                    }, res), {
                        _response: res._response
                    });
                } catch (e) {
                    if ((null == (_a = e.details) ? void 0 : _a.errorCode) === "ContainerNotFound") {
                        span.setStatus({
                            code: interfaces_SpanStatusCode.ERROR,
                            message: "Expected exception when deleting a container only if it exists."
                        });
                        return Object.assign(Object.assign({
                            succeeded: false
                        }, null == (_b = e.response) ? void 0 : _b.parsedHeaders), {
                            _response: e.response
                        });
                    }
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setMetadata(metadata, options = {}) {
                if (!options.conditions) options.conditions = {};
                if (options.conditions.ifUnmodifiedSince) throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-setMetadata", options);
                try {
                    return await this.containerContext.setMetadata(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions,
                        metadata,
                        modifiedAccessConditions: options.conditions
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async getAccessPolicy(options = {}) {
                if (!options.conditions) options.conditions = {};
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-getAccessPolicy", options);
                try {
                    const response = await this.containerContext.getAccessPolicy(Object.assign({
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.conditions
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    const res = {
                        _response: response._response,
                        blobPublicAccess: response.blobPublicAccess,
                        date: response.date,
                        etag: response.etag,
                        errorCode: response.errorCode,
                        lastModified: response.lastModified,
                        requestId: response.requestId,
                        clientRequestId: response.clientRequestId,
                        signedIdentifiers: [],
                        version: response.version
                    };
                    for (const identifier of response){
                        let accessPolicy;
                        if (identifier.accessPolicy) {
                            accessPolicy = {
                                permissions: identifier.accessPolicy.permissions
                            };
                            if (identifier.accessPolicy.expiresOn) accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
                            if (identifier.accessPolicy.startsOn) accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
                        }
                        res.signedIdentifiers.push({
                            accessPolicy,
                            id: identifier.id
                        });
                    }
                    return res;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setAccessPolicy(access, containerAcl, options = {}) {
                options.conditions = options.conditions || {};
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-setAccessPolicy", options);
                try {
                    const acl = [];
                    for (const identifier of containerAcl || [])acl.push({
                        accessPolicy: {
                            expiresOn: identifier.accessPolicy.expiresOn ? truncatedISO8061Date(identifier.accessPolicy.expiresOn) : "",
                            permissions: identifier.accessPolicy.permissions,
                            startsOn: identifier.accessPolicy.startsOn ? truncatedISO8061Date(identifier.accessPolicy.startsOn) : ""
                        },
                        id: identifier.id
                    });
                    return await this.containerContext.setAccessPolicy(Object.assign({
                        abortSignal: options.abortSignal,
                        access,
                        containerAcl: acl,
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: options.conditions
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            getBlobLeaseClient(proposeLeaseId) {
                return new BlobLeaseClient(this, proposeLeaseId);
            }
            async uploadBlockBlob(blobName, body, contentLength, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-uploadBlockBlob", options);
                try {
                    const blockBlobClient = this.getBlockBlobClient(blobName);
                    const response = await blockBlobClient.upload(body, contentLength, updatedOptions);
                    return {
                        blockBlobClient,
                        response
                    };
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async deleteBlob(blobName, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-deleteBlob", options);
                try {
                    let blobClient = this.getBlobClient(blobName);
                    if (options.versionId) blobClient = blobClient.withVersion(options.versionId);
                    return await blobClient.delete(updatedOptions);
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async listBlobFlatSegment(marker, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-listBlobFlatSegment", options);
                try {
                    const response = await this.containerContext.listBlobFlatSegment(Object.assign(Object.assign({
                        marker
                    }, options), convertTracingToRequestOptionsBase(updatedOptions)));
                    const wrappedResponse = Object.assign(Object.assign({}, response), {
                        _response: Object.assign(Object.assign({}, response._response), {
                            parsedBody: ConvertInternalResponseOfListBlobFlat(response._response.parsedBody)
                        }),
                        segment: Object.assign(Object.assign({}, response.segment), {
                            blobItems: response.segment.blobItems.map((blobItemInteral)=>{
                                const blobItem = Object.assign(Object.assign({}, blobItemInteral), {
                                    name: BlobNameToString(blobItemInteral.name),
                                    tags: toTags(blobItemInteral.blobTags),
                                    objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)
                                });
                                return blobItem;
                            })
                        })
                    });
                    return wrappedResponse;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async listBlobHierarchySegment(delimiter, marker, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-listBlobHierarchySegment", options);
                try {
                    const response = await this.containerContext.listBlobHierarchySegment(delimiter, Object.assign(Object.assign({
                        marker
                    }, options), convertTracingToRequestOptionsBase(updatedOptions)));
                    const wrappedResponse = Object.assign(Object.assign({}, response), {
                        _response: Object.assign(Object.assign({}, response._response), {
                            parsedBody: ConvertInternalResponseOfListBlobHierarchy(response._response.parsedBody)
                        }),
                        segment: Object.assign(Object.assign({}, response.segment), {
                            blobItems: response.segment.blobItems.map((blobItemInteral)=>{
                                const blobItem = Object.assign(Object.assign({}, blobItemInteral), {
                                    name: BlobNameToString(blobItemInteral.name),
                                    tags: toTags(blobItemInteral.blobTags),
                                    objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)
                                });
                                return blobItem;
                            }),
                            blobPrefixes: null == (_a = response.segment.blobPrefixes) ? void 0 : _a.map((blobPrefixInternal)=>{
                                const blobPrefix = Object.assign(Object.assign({}, blobPrefixInternal), {
                                    name: BlobNameToString(blobPrefixInternal.name)
                                });
                                return blobPrefix;
                            })
                        })
                    });
                    return wrappedResponse;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            listSegments(marker, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    let listBlobsFlatSegmentResponse;
                    if (!!marker || void 0 === marker) do {
                        listBlobsFlatSegmentResponse = yield __await(this.listBlobFlatSegment(marker, options));
                        marker = listBlobsFlatSegmentResponse.continuationToken;
                        yield yield __await((yield __await(listBlobsFlatSegmentResponse)));
                    }while (marker);
                });
            }
            listItems(options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    var e_1, _a;
                    let marker;
                    try {
                        for(var _b = __asyncValues(this.listSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;){
                            const listBlobsFlatSegmentResponse = _c.value;
                            yield __await((yield* __asyncDelegator(__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems))));
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally{
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                        } finally{
                            if (e_1) throw e_1.error;
                        }
                    }
                });
            }
            listBlobsFlat(options = {}) {
                const include = [];
                if (options.includeCopy) include.push("copy");
                if (options.includeDeleted) include.push("deleted");
                if (options.includeMetadata) include.push("metadata");
                if (options.includeSnapshots) include.push("snapshots");
                if (options.includeVersions) include.push("versions");
                if (options.includeUncommitedBlobs) include.push("uncommittedblobs");
                if (options.includeTags) include.push("tags");
                if (options.includeDeletedWithVersions) include.push("deletedwithversions");
                if (options.includeImmutabilityPolicy) include.push("immutabilitypolicy");
                if (options.includeLegalHold) include.push("legalhold");
                if ("" === options.prefix) options.prefix = void 0;
                const updatedOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {
                    include: include
                } : {});
                const iter = this.listItems(updatedOptions);
                return {
                    next () {
                        return iter.next();
                    },
                    [Symbol.asyncIterator] () {
                        return this;
                    },
                    byPage: (settings = {})=>this.listSegments(settings.continuationToken, Object.assign({
                            maxPageSize: settings.maxPageSize
                        }, updatedOptions))
                };
            }
            listHierarchySegments(delimiter, marker, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    let listBlobsHierarchySegmentResponse;
                    if (!!marker || void 0 === marker) do {
                        listBlobsHierarchySegmentResponse = yield __await(this.listBlobHierarchySegment(delimiter, marker, options));
                        marker = listBlobsHierarchySegmentResponse.continuationToken;
                        yield yield __await((yield __await(listBlobsHierarchySegmentResponse)));
                    }while (marker);
                });
            }
            listItemsByHierarchy(delimiter, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    var e_2, _a;
                    let marker;
                    try {
                        for(var _b = __asyncValues(this.listHierarchySegments(delimiter, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;){
                            const listBlobsHierarchySegmentResponse = _c.value;
                            const segment = listBlobsHierarchySegmentResponse.segment;
                            if (segment.blobPrefixes) for (const prefix of segment.blobPrefixes)yield yield __await(Object.assign({
                                kind: "prefix"
                            }, prefix));
                            for (const blob of segment.blobItems)yield yield __await(Object.assign({
                                kind: "blob"
                            }, blob));
                        }
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally{
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                        } finally{
                            if (e_2) throw e_2.error;
                        }
                    }
                });
            }
            listBlobsByHierarchy(delimiter, options = {}) {
                if ("" === delimiter) throw new RangeError("delimiter should contain one or more characters");
                const include = [];
                if (options.includeCopy) include.push("copy");
                if (options.includeDeleted) include.push("deleted");
                if (options.includeMetadata) include.push("metadata");
                if (options.includeSnapshots) include.push("snapshots");
                if (options.includeVersions) include.push("versions");
                if (options.includeUncommitedBlobs) include.push("uncommittedblobs");
                if (options.includeTags) include.push("tags");
                if (options.includeDeletedWithVersions) include.push("deletedwithversions");
                if (options.includeImmutabilityPolicy) include.push("immutabilitypolicy");
                if (options.includeLegalHold) include.push("legalhold");
                if ("" === options.prefix) options.prefix = void 0;
                const updatedOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {
                    include: include
                } : {});
                const iter = this.listItemsByHierarchy(delimiter, updatedOptions);
                return {
                    async next () {
                        return iter.next();
                    },
                    [Symbol.asyncIterator] () {
                        return this;
                    },
                    byPage: (settings = {})=>this.listHierarchySegments(delimiter, settings.continuationToken, Object.assign({
                            maxPageSize: settings.maxPageSize
                        }, updatedOptions))
                };
            }
            async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("ContainerClient-findBlobsByTagsSegment", options);
                try {
                    const response = await this.containerContext.filterBlobs(Object.assign({
                        abortSignal: options.abortSignal,
                        where: tagFilterSqlExpression,
                        marker,
                        maxPageSize: options.maxPageSize
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    const wrappedResponse = Object.assign(Object.assign({}, response), {
                        _response: response._response,
                        blobs: response.blobs.map((blob)=>{
                            var _a;
                            let tagValue = "";
                            if ((null == (_a = blob.tags) ? void 0 : _a.blobTagSet.length) === 1) tagValue = blob.tags.blobTagSet[0].value;
                            return Object.assign(Object.assign({}, blob), {
                                tags: toTags(blob.tags),
                                tagValue
                            });
                        })
                    });
                    return wrappedResponse;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    let response;
                    if (!!marker || void 0 === marker) do {
                        response = yield __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options));
                        response.blobs = response.blobs || [];
                        marker = response.continuationToken;
                        yield yield __await(response);
                    }while (marker);
                });
            }
            findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    var e_3, _a;
                    let marker;
                    try {
                        for(var _b = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;){
                            const segment = _c.value;
                            yield __await((yield* __asyncDelegator(__asyncValues(segment.blobs))));
                        }
                    } catch (e_3_1) {
                        e_3 = {
                            error: e_3_1
                        };
                    } finally{
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                        } finally{
                            if (e_3) throw e_3.error;
                        }
                    }
                });
            }
            findBlobsByTags(tagFilterSqlExpression, options = {}) {
                const listSegmentOptions = Object.assign({}, options);
                const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
                return {
                    next () {
                        return iter.next();
                    },
                    [Symbol.asyncIterator] () {
                        return this;
                    },
                    byPage: (settings = {})=>this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({
                            maxPageSize: settings.maxPageSize
                        }, listSegmentOptions))
                };
            }
            getContainerNameFromUrl() {
                let containerName;
                try {
                    const parsedUrl = URLBuilder.parse(this.url);
                    containerName = "blob" === parsedUrl.getHost().split(".")[1] ? parsedUrl.getPath().split("/")[1] : isIpEndpointStyle(parsedUrl) ? parsedUrl.getPath().split("/")[2] : parsedUrl.getPath().split("/")[1];
                    containerName = decodeURIComponent(containerName);
                    if (!containerName) throw new Error("Provided containerName is invalid.");
                    return containerName;
                } catch (error) {
                    throw new Error("Unable to extract containerName with provided information.");
                }
            }
            generateSasUrl(options) {
                return new Promise((resolve)=>{
                    if (!(this.credential instanceof StorageSharedKeyCredential)) throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
                    const sas = generateBlobSASQueryParameters(Object.assign({
                        containerName: this._containerName
                    }, options), this.credential).toString();
                    resolve(appendToURLQuery(this.url, sas));
                });
            }
            getBlobBatchClient() {
                return new BlobBatchClient(this.url, this.pipeline);
            }
        }
        class AccountSASPermissions {
            constructor(){
                this.read = false;
                this.write = false;
                this.delete = false;
                this.deleteVersion = false;
                this.list = false;
                this.add = false;
                this.create = false;
                this.update = false;
                this.process = false;
                this.tag = false;
                this.filter = false;
                this.setImmutabilityPolicy = false;
                this.permanentDelete = false;
            }
            static parse(permissions) {
                const accountSASPermissions = new AccountSASPermissions();
                for (const c of permissions)switch(c){
                    case "r":
                        accountSASPermissions.read = true;
                        break;
                    case "w":
                        accountSASPermissions.write = true;
                        break;
                    case "d":
                        accountSASPermissions.delete = true;
                        break;
                    case "x":
                        accountSASPermissions.deleteVersion = true;
                        break;
                    case "l":
                        accountSASPermissions.list = true;
                        break;
                    case "a":
                        accountSASPermissions.add = true;
                        break;
                    case "c":
                        accountSASPermissions.create = true;
                        break;
                    case "u":
                        accountSASPermissions.update = true;
                        break;
                    case "p":
                        accountSASPermissions.process = true;
                        break;
                    case "t":
                        accountSASPermissions.tag = true;
                        break;
                    case "f":
                        accountSASPermissions.filter = true;
                        break;
                    case "i":
                        accountSASPermissions.setImmutabilityPolicy = true;
                        break;
                    case "y":
                        accountSASPermissions.permanentDelete = true;
                        break;
                    default:
                        throw new RangeError(`Invalid permission character: ${c}`);
                }
                return accountSASPermissions;
            }
            static from(permissionLike) {
                const accountSASPermissions = new AccountSASPermissions();
                if (permissionLike.read) accountSASPermissions.read = true;
                if (permissionLike.write) accountSASPermissions.write = true;
                if (permissionLike.delete) accountSASPermissions.delete = true;
                if (permissionLike.deleteVersion) accountSASPermissions.deleteVersion = true;
                if (permissionLike.filter) accountSASPermissions.filter = true;
                if (permissionLike.tag) accountSASPermissions.tag = true;
                if (permissionLike.list) accountSASPermissions.list = true;
                if (permissionLike.add) accountSASPermissions.add = true;
                if (permissionLike.create) accountSASPermissions.create = true;
                if (permissionLike.update) accountSASPermissions.update = true;
                if (permissionLike.process) accountSASPermissions.process = true;
                if (permissionLike.setImmutabilityPolicy) accountSASPermissions.setImmutabilityPolicy = true;
                if (permissionLike.permanentDelete) accountSASPermissions.permanentDelete = true;
                return accountSASPermissions;
            }
            toString() {
                const permissions = [];
                if (this.read) permissions.push("r");
                if (this.write) permissions.push("w");
                if (this.delete) permissions.push("d");
                if (this.deleteVersion) permissions.push("x");
                if (this.filter) permissions.push("f");
                if (this.tag) permissions.push("t");
                if (this.list) permissions.push("l");
                if (this.add) permissions.push("a");
                if (this.create) permissions.push("c");
                if (this.update) permissions.push("u");
                if (this.process) permissions.push("p");
                if (this.setImmutabilityPolicy) permissions.push("i");
                if (this.permanentDelete) permissions.push("y");
                return permissions.join("");
            }
        }
        class AccountSASResourceTypes {
            constructor(){
                this.service = false;
                this.container = false;
                this.object = false;
            }
            static parse(resourceTypes) {
                const accountSASResourceTypes = new AccountSASResourceTypes();
                for (const c of resourceTypes)switch(c){
                    case "s":
                        accountSASResourceTypes.service = true;
                        break;
                    case "c":
                        accountSASResourceTypes.container = true;
                        break;
                    case "o":
                        accountSASResourceTypes.object = true;
                        break;
                    default:
                        throw new RangeError(`Invalid resource type: ${c}`);
                }
                return accountSASResourceTypes;
            }
            toString() {
                const resourceTypes = [];
                if (this.service) resourceTypes.push("s");
                if (this.container) resourceTypes.push("c");
                if (this.object) resourceTypes.push("o");
                return resourceTypes.join("");
            }
        }
        class AccountSASServices {
            constructor(){
                this.blob = false;
                this.file = false;
                this.queue = false;
                this.table = false;
            }
            static parse(services) {
                const accountSASServices = new AccountSASServices();
                for (const c of services)switch(c){
                    case "b":
                        accountSASServices.blob = true;
                        break;
                    case "f":
                        accountSASServices.file = true;
                        break;
                    case "q":
                        accountSASServices.queue = true;
                        break;
                    case "t":
                        accountSASServices.table = true;
                        break;
                    default:
                        throw new RangeError(`Invalid service character: ${c}`);
                }
                return accountSASServices;
            }
            toString() {
                const services = [];
                if (this.blob) services.push("b");
                if (this.table) services.push("t");
                if (this.queue) services.push("q");
                if (this.file) services.push("f");
                return services.join("");
            }
        }
        function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
            const version = accountSASSignatureValues.version ? accountSASSignatureValues.version : SERVICE_VERSION;
            if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04") throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
            if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
            if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
            if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version < "2019-12-12") throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
            if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version < "2019-12-12") throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
            if (accountSASSignatureValues.encryptionScope && version < "2020-12-06") throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
            const parsedPermissions = AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString());
            const parsedServices = AccountSASServices.parse(accountSASSignatureValues.services).toString();
            const parsedResourceTypes = AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
            let stringToSign;
            stringToSign = version >= "2020-12-06" ? [
                sharedKeyCredential.accountName,
                parsedPermissions,
                parsedServices,
                parsedResourceTypes,
                accountSASSignatureValues.startsOn ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false) : "",
                truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
                accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
                accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
                version,
                accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
                ""
            ].join("\n") : [
                sharedKeyCredential.accountName,
                parsedPermissions,
                parsedServices,
                parsedResourceTypes,
                accountSASSignatureValues.startsOn ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false) : "",
                truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
                accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
                accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
                version,
                ""
            ].join("\n");
            const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
            return new SASQueryParameters(version, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, accountSASSignatureValues.encryptionScope);
        }
        class BlobServiceClient extends StorageClient {
            constructor(url, credentialOrPipeline, options){
                let pipeline;
                pipeline = isPipelineLike(credentialOrPipeline) ? credentialOrPipeline : checkEnvironment_isNode && credentialOrPipeline instanceof StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential || isTokenCredential(credentialOrPipeline) ? newPipeline(credentialOrPipeline, options) : newPipeline(new AnonymousCredential(), options);
                super(url, pipeline);
                this.serviceContext = new Service(this.storageClientContext);
            }
            static fromConnectionString(connectionString, options) {
                options = options || {};
                const extractedCreds = extractConnectionStringParts(connectionString);
                if ("AccountConnString" === extractedCreds.kind) if (checkEnvironment_isNode) {
                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    if (!options.proxyOptions) options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                    const pipeline = newPipeline(sharedKeyCredential, options);
                    return new BlobServiceClient(extractedCreds.url, pipeline);
                } else throw new Error("Account connection string is only supported in Node.js environment");
                if ("SASConnString" === extractedCreds.kind) {
                    const pipeline = newPipeline(new AnonymousCredential(), options);
                    return new BlobServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
                }
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
            getContainerClient(containerName) {
                return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);
            }
            async createContainer(containerName, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-createContainer", options);
                try {
                    const containerClient = this.getContainerClient(containerName);
                    const containerCreateResponse = await containerClient.create(updatedOptions);
                    return {
                        containerClient,
                        containerCreateResponse
                    };
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async deleteContainer(containerName, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-deleteContainer", options);
                try {
                    const containerClient = this.getContainerClient(containerName);
                    return await containerClient.delete(updatedOptions);
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async undeleteContainer(deletedContainerName, deletedContainerVersion, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-undeleteContainer", options);
                try {
                    const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName);
                    const containerContext = new Container(containerClient["storageClientContext"]);
                    const containerUndeleteResponse = await containerContext.restore(Object.assign({
                        deletedContainerName,
                        deletedContainerVersion
                    }, updatedOptions));
                    return {
                        containerClient,
                        containerUndeleteResponse
                    };
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async renameContainer(sourceContainerName, destinationContainerName, options = {}) {
                var _a;
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-renameContainer", options);
                try {
                    const containerClient = this.getContainerClient(destinationContainerName);
                    const containerContext = new Container(containerClient["storageClientContext"]);
                    const containerRenameResponse = await containerContext.rename(sourceContainerName, Object.assign(Object.assign({}, updatedOptions), {
                        sourceLeaseId: null == (_a = options.sourceCondition) ? void 0 : _a.leaseId
                    }));
                    return {
                        containerClient,
                        containerRenameResponse
                    };
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async getProperties(options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-getProperties", options);
                try {
                    return await this.serviceContext.getProperties(Object.assign({
                        abortSignal: options.abortSignal
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async setProperties(properties, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-setProperties", options);
                try {
                    return await this.serviceContext.setProperties(properties, Object.assign({
                        abortSignal: options.abortSignal
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async getStatistics(options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-getStatistics", options);
                try {
                    return await this.serviceContext.getStatistics(Object.assign({
                        abortSignal: options.abortSignal
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async getAccountInfo(options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-getAccountInfo", options);
                try {
                    return await this.serviceContext.getAccountInfo(Object.assign({
                        abortSignal: options.abortSignal
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async listContainersSegment(marker, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-listContainersSegment", options);
                try {
                    return await this.serviceContext.listContainersSegment(Object.assign(Object.assign(Object.assign({
                        abortSignal: options.abortSignal,
                        marker
                    }, options), {
                        include: "string" == typeof options.include ? [
                            options.include
                        ] : options.include
                    }), convertTracingToRequestOptionsBase(updatedOptions)));
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-findBlobsByTagsSegment", options);
                try {
                    const response = await this.serviceContext.filterBlobs(Object.assign({
                        abortSignal: options.abortSignal,
                        where: tagFilterSqlExpression,
                        marker,
                        maxPageSize: options.maxPageSize
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    const wrappedResponse = Object.assign(Object.assign({}, response), {
                        _response: response._response,
                        blobs: response.blobs.map((blob)=>{
                            var _a;
                            let tagValue = "";
                            if ((null == (_a = blob.tags) ? void 0 : _a.blobTagSet.length) === 1) tagValue = blob.tags.blobTagSet[0].value;
                            return Object.assign(Object.assign({}, blob), {
                                tags: toTags(blob.tags),
                                tagValue
                            });
                        })
                    });
                    return wrappedResponse;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    let response;
                    if (!!marker || void 0 === marker) do {
                        response = yield __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options));
                        response.blobs = response.blobs || [];
                        marker = response.continuationToken;
                        yield yield __await(response);
                    }while (marker);
                });
            }
            findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    var e_1, _a;
                    let marker;
                    try {
                        for(var _b = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;){
                            const segment = _c.value;
                            yield __await((yield* __asyncDelegator(__asyncValues(segment.blobs))));
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally{
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                        } finally{
                            if (e_1) throw e_1.error;
                        }
                    }
                });
            }
            findBlobsByTags(tagFilterSqlExpression, options = {}) {
                const listSegmentOptions = Object.assign({}, options);
                const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
                return {
                    next () {
                        return iter.next();
                    },
                    [Symbol.asyncIterator] () {
                        return this;
                    },
                    byPage: (settings = {})=>this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({
                            maxPageSize: settings.maxPageSize
                        }, listSegmentOptions))
                };
            }
            listSegments(marker, options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    let listContainersSegmentResponse;
                    if (!!marker || void 0 === marker) do {
                        listContainersSegmentResponse = yield __await(this.listContainersSegment(marker, options));
                        listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];
                        marker = listContainersSegmentResponse.continuationToken;
                        yield yield __await((yield __await(listContainersSegmentResponse)));
                    }while (marker);
                });
            }
            listItems(options = {}) {
                return __asyncGenerator(this, arguments, function*() {
                    var e_2, _a;
                    let marker;
                    try {
                        for(var _b = __asyncValues(this.listSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;){
                            const segment = _c.value;
                            yield __await((yield* __asyncDelegator(__asyncValues(segment.containerItems))));
                        }
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally{
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                        } finally{
                            if (e_2) throw e_2.error;
                        }
                    }
                });
            }
            listContainers(options = {}) {
                if ("" === options.prefix) options.prefix = void 0;
                const include = [];
                if (options.includeDeleted) include.push("deleted");
                if (options.includeMetadata) include.push("metadata");
                if (options.includeSystem) include.push("system");
                const listSegmentOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {
                    include
                } : {});
                const iter = this.listItems(listSegmentOptions);
                return {
                    next () {
                        return iter.next();
                    },
                    [Symbol.asyncIterator] () {
                        return this;
                    },
                    byPage: (settings = {})=>this.listSegments(settings.continuationToken, Object.assign({
                            maxPageSize: settings.maxPageSize
                        }, listSegmentOptions))
                };
            }
            async getUserDelegationKey(startsOn, expiresOn, options = {}) {
                const { span, updatedOptions } = tracing_createSpan("BlobServiceClient-getUserDelegationKey", options);
                try {
                    const response = await this.serviceContext.getUserDelegationKey({
                        startsOn: truncatedISO8061Date(startsOn, false),
                        expiresOn: truncatedISO8061Date(expiresOn, false)
                    }, Object.assign({
                        abortSignal: options.abortSignal
                    }, convertTracingToRequestOptionsBase(updatedOptions)));
                    const userDelegationKey = {
                        signedObjectId: response.signedObjectId,
                        signedTenantId: response.signedTenantId,
                        signedStartsOn: new Date(response.signedStartsOn),
                        signedExpiresOn: new Date(response.signedExpiresOn),
                        signedService: response.signedService,
                        signedVersion: response.signedVersion,
                        value: response.value
                    };
                    const res = Object.assign({
                        _response: response._response,
                        requestId: response.requestId,
                        clientRequestId: response.clientRequestId,
                        version: response.version,
                        date: response.date,
                        errorCode: response.errorCode
                    }, userDelegationKey);
                    return res;
                } catch (e) {
                    span.setStatus({
                        code: interfaces_SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                } finally{
                    span.end();
                }
            }
            getBlobBatchClient() {
                return new BlobBatchClient(this.url, this.pipeline);
            }
            generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
                if (!(this.credential instanceof StorageSharedKeyCredential)) throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
                if (void 0 === expiresOn) {
                    const now = new Date();
                    expiresOn = new Date(now.getTime() + 3600000);
                }
                const sas = generateAccountSASQueryParameters(Object.assign({
                    permissions,
                    expiresOn,
                    resourceTypes,
                    services: AccountSASServices.parse("b").toString()
                }, options), this.credential).toString();
                return appendToURLQuery(this.url, sas);
            }
        }
        var generatedModels_KnownEncryptionAlgorithmType;
        (function(KnownEncryptionAlgorithmType) {
            KnownEncryptionAlgorithmType["AES256"] = "AES256";
        })(generatedModels_KnownEncryptionAlgorithmType || (generatedModels_KnownEncryptionAlgorithmType = {}));
    },
    "../../../node_modules/.pnpm/accepts@2.0.0/node_modules/accepts/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Negotiator = __webpack_require__("../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/index.js");
        var mime = __webpack_require__("../../../node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/index.js");
        module.exports = Accepts;
        function Accepts(req) {
            if (!(this instanceof Accepts)) return new Accepts(req);
            this.headers = req.headers;
            this.negotiator = new Negotiator(req);
        }
        Accepts.prototype.type = Accepts.prototype.types = function(types_) {
            var types = types_;
            if (types && !Array.isArray(types)) {
                types = new Array(arguments.length);
                for(var i = 0; i < types.length; i++)types[i] = arguments[i];
            }
            if (!types || 0 === types.length) return this.negotiator.mediaTypes();
            if (!this.headers.accept) return types[0];
            var mimes = types.map(extToMime);
            var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
            var first = accepts[0];
            return first ? types[mimes.indexOf(first)] : false;
        };
        Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
            var encodings = encodings_;
            if (encodings && !Array.isArray(encodings)) {
                encodings = new Array(arguments.length);
                for(var i = 0; i < encodings.length; i++)encodings[i] = arguments[i];
            }
            if (!encodings || 0 === encodings.length) return this.negotiator.encodings();
            return this.negotiator.encodings(encodings)[0] || false;
        };
        Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
            var charsets = charsets_;
            if (charsets && !Array.isArray(charsets)) {
                charsets = new Array(arguments.length);
                for(var i = 0; i < charsets.length; i++)charsets[i] = arguments[i];
            }
            if (!charsets || 0 === charsets.length) return this.negotiator.charsets();
            return this.negotiator.charsets(charsets)[0] || false;
        };
        Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
            var languages = languages_;
            if (languages && !Array.isArray(languages)) {
                languages = new Array(arguments.length);
                for(var i = 0; i < languages.length; i++)languages[i] = arguments[i];
            }
            if (!languages || 0 === languages.length) return this.negotiator.languages();
            return this.negotiator.languages(languages)[0] || false;
        };
        function extToMime(type) {
            return -1 === type.indexOf('/') ? mime.lookup(type) : type;
        }
        function validMime(type) {
            return 'string' == typeof type;
        }
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        module.exports = {
            parallel: __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"),
            serial: __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"),
            serialOrdered: __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js")
        };
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js" (module) {
        module.exports = abort;
        function abort(state) {
            Object.keys(state.jobs).forEach(clean.bind(state));
            state.jobs = {};
        }
        function clean(key) {
            if ('function' == typeof this.jobs[key]) this.jobs[key]();
        }
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js" (module, __unused_rspack_exports, __webpack_require__) {
        var defer = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js");
        module.exports = async;
        function async(callback) {
            var isAsync = false;
            defer(function() {
                isAsync = true;
            });
            return function(err, result) {
                if (isAsync) callback(err, result);
                else defer(function() {
                    callback(err, result);
                });
            };
        }
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js" (module) {
        module.exports = defer;
        function defer(fn) {
            var nextTick = 'function' == typeof setImmediate ? setImmediate : 'object' == typeof process && 'function' == typeof process.nextTick ? process.nextTick : null;
            if (nextTick) nextTick(fn);
            else setTimeout(fn, 0);
        }
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js" (module, __unused_rspack_exports, __webpack_require__) {
        var async = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"), abort = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js");
        module.exports = iterate;
        function iterate(list, iterator, state, callback) {
            var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;
            state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
                if (!(key in state.jobs)) return;
                delete state.jobs[key];
                if (error) abort(state);
                else state.results[key] = output;
                callback(error, state.results);
            });
        }
        function runJob(iterator, key, item, callback) {
            var aborter;
            aborter = 2 == iterator.length ? iterator(item, async(callback)) : iterator(item, key, async(callback));
            return aborter;
        }
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js" (module) {
        module.exports = state;
        function state(list, sortMethod) {
            var isNamedList = !Array.isArray(list), initState = {
                index: 0,
                keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
                jobs: {},
                results: isNamedList ? {} : [],
                size: isNamedList ? Object.keys(list).length : list.length
            };
            if (sortMethod) initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
                return sortMethod(list[a], list[b]);
            });
            return initState;
        }
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js" (module, __unused_rspack_exports, __webpack_require__) {
        var abort = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"), async = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js");
        module.exports = terminator;
        function terminator(callback) {
            if (!Object.keys(this.jobs).length) return;
            this.index = this.size;
            abort(this);
            async(callback)(null, this.results);
        }
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js" (module, __unused_rspack_exports, __webpack_require__) {
        var iterate = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"), initState = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"), terminator = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js");
        module.exports = parallel;
        function parallel(list, iterator, callback) {
            var state = initState(list);
            while(state.index < (state['keyedList'] || list).length){
                iterate(list, iterator, state, function(error, result) {
                    if (error) return void callback(error, result);
                    if (0 === Object.keys(state.jobs).length) return void callback(null, state.results);
                });
                state.index++;
            }
            return terminator.bind(state, callback);
        }
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js" (module, __unused_rspack_exports, __webpack_require__) {
        var serialOrdered = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js");
        module.exports = serial;
        function serial(list, iterator, callback) {
            return serialOrdered(list, iterator, null, callback);
        }
    },
    "../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js" (module, __unused_rspack_exports, __webpack_require__) {
        var iterate = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"), initState = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"), terminator = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js");
        module.exports = serialOrdered;
        module.exports.ascending = ascending;
        module.exports.descending = descending;
        function serialOrdered(list, iterator, sortMethod, callback) {
            var state = initState(list, sortMethod);
            iterate(list, iterator, state, function iteratorHandler(error, result) {
                if (error) return void callback(error, result);
                state.index++;
                if (state.index < (state['keyedList'] || list).length) return void iterate(list, iterator, state, iteratorHandler);
                callback(null, state.results);
            });
            return terminator.bind(state, callback);
        }
        function ascending(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }
        function descending(a, b) {
            return -1 * ascending(a, b);
        }
    },
    "../../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js" (module) {
        "use strict";
        module.exports = balanced;
        function balanced(a, b, str) {
            if (a instanceof RegExp) a = maybeMatch(a, str);
            if (b instanceof RegExp) b = maybeMatch(b, str);
            var r = range(a, b, str);
            return r && {
                start: r[0],
                end: r[1],
                pre: str.slice(0, r[0]),
                body: str.slice(r[0] + a.length, r[1]),
                post: str.slice(r[1] + b.length)
            };
        }
        function maybeMatch(reg, str) {
            var m = str.match(reg);
            return m ? m[0] : null;
        }
        balanced.range = range;
        function range(a, b, str) {
            var begs, beg, left, right, result;
            var ai = str.indexOf(a);
            var bi = str.indexOf(b, ai + 1);
            var i = ai;
            if (ai >= 0 && bi > 0) {
                if (a === b) return [
                    ai,
                    bi
                ];
                begs = [];
                left = str.length;
                while(i >= 0 && !result){
                    if (i == ai) {
                        begs.push(i);
                        ai = str.indexOf(a, i + 1);
                    } else if (1 == begs.length) result = [
                        begs.pop(),
                        bi
                    ];
                    else {
                        beg = begs.pop();
                        if (beg < left) {
                            left = beg;
                            right = bi;
                        }
                        bi = str.indexOf(b, i + 1);
                    }
                    i = ai < bi && ai >= 0 ? ai : bi;
                }
                if (begs.length) result = [
                    left,
                    right
                ];
            }
            return result;
        }
    },
    "../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/index.js" (module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ exports1 = module.exports = bodyParser;
        Object.defineProperty(exports1, "json", {
            configurable: true,
            enumerable: true,
            get: ()=>__webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/types/json.js")
        });
        Object.defineProperty(exports1, "raw", {
            configurable: true,
            enumerable: true,
            get: ()=>__webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/types/raw.js")
        });
        Object.defineProperty(exports1, "text", {
            configurable: true,
            enumerable: true,
            get: ()=>__webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/types/text.js")
        });
        Object.defineProperty(exports1, "urlencoded", {
            configurable: true,
            enumerable: true,
            get: ()=>__webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/types/urlencoded.js")
        });
        function bodyParser() {
            throw new Error('The bodyParser() generic has been split into individual middleware to use instead.');
        }
    },
    "../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/read.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var createError = __webpack_require__("../../../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var getBody = __webpack_require__("../../../node_modules/.pnpm/raw-body@3.0.1/node_modules/raw-body/index.js");
        var iconv = __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/index.js");
        var onFinished = __webpack_require__("../../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var zlib = __webpack_require__("node:zlib");
        var hasBody = __webpack_require__("../../../node_modules/.pnpm/type-is@2.0.1/node_modules/type-is/index.js").hasBody;
        var { getCharset } = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/utils.js");
        module.exports = read;
        function read(req, res, next, parse, debug, options) {
            if (onFinished.isFinished(req)) {
                debug('body already parsed');
                next();
                return;
            }
            if (!('body' in req)) req.body = void 0;
            if (!hasBody(req)) {
                debug('skip empty body');
                next();
                return;
            }
            debug('content-type %j', req.headers['content-type']);
            if (!options.shouldParse(req)) {
                debug('skip parsing');
                next();
                return;
            }
            var encoding = null;
            if (options?.skipCharset !== true) {
                encoding = getCharset(req) || options.defaultCharset;
                if (!!options?.isValidCharset && !options.isValidCharset(encoding)) {
                    debug('invalid charset');
                    next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
                        charset: encoding,
                        type: 'charset.unsupported'
                    }));
                    return;
                }
            }
            var length;
            var opts = options;
            var stream;
            var verify = opts.verify;
            try {
                stream = contentstream(req, debug, opts.inflate);
                length = stream.length;
                stream.length = void 0;
            } catch (err) {
                return next(err);
            }
            opts.length = length;
            opts.encoding = verify ? null : encoding;
            if (null === opts.encoding && null !== encoding && !iconv.encodingExists(encoding)) return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
                charset: encoding.toLowerCase(),
                type: 'charset.unsupported'
            }));
            debug('read body');
            getBody(stream, opts, function(error, body) {
                if (error) {
                    var _error;
                    _error = 'encoding.unsupported' === error.type ? createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
                        charset: encoding.toLowerCase(),
                        type: 'charset.unsupported'
                    }) : createError(400, error);
                    if (stream !== req) {
                        req.unpipe();
                        stream.destroy();
                    }
                    dump(req, function() {
                        next(createError(400, _error));
                    });
                    return;
                }
                if (verify) try {
                    debug('verify body');
                    verify(req, res, body, encoding);
                } catch (err) {
                    next(createError(403, err, {
                        body: body,
                        type: err.type || 'entity.verify.failed'
                    }));
                    return;
                }
                var str = body;
                try {
                    debug('parse body');
                    str = 'string' != typeof body && null !== encoding ? iconv.decode(body, encoding) : body;
                    req.body = parse(str, encoding);
                } catch (err) {
                    next(createError(400, err, {
                        body: str,
                        type: err.type || 'entity.parse.failed'
                    }));
                    return;
                }
                next();
            });
        }
        function contentstream(req, debug, inflate) {
            var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase();
            var length = req.headers['content-length'];
            debug('content-encoding "%s"', encoding);
            if (false === inflate && 'identity' !== encoding) throw createError(415, 'content encoding unsupported', {
                encoding: encoding,
                type: 'encoding.unsupported'
            });
            if ('identity' === encoding) {
                req.length = length;
                return req;
            }
            var stream = createDecompressionStream(encoding, debug);
            req.pipe(stream);
            return stream;
        }
        function createDecompressionStream(encoding, debug) {
            switch(encoding){
                case 'deflate':
                    debug('inflate body');
                    return zlib.createInflate();
                case 'gzip':
                    debug('gunzip body');
                    return zlib.createGunzip();
                case 'br':
                    debug('brotli decompress body');
                    return zlib.createBrotliDecompress();
                default:
                    throw createError(415, 'unsupported content encoding "' + encoding + '"', {
                        encoding: encoding,
                        type: 'encoding.unsupported'
                    });
            }
        }
        function dump(req, callback) {
            if (onFinished.isFinished(req)) callback(null);
            else {
                onFinished(req, callback);
                req.resume();
            }
        }
    },
    "../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/types/json.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js")('body-parser:json');
        var read = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/read.js");
        var { normalizeOptions } = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/utils.js");
        module.exports = json;
        var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
        var JSON_SYNTAX_CHAR = '#';
        var JSON_SYNTAX_REGEXP = /#+/g;
        function json(options) {
            const normalizedOptions = normalizeOptions(options, 'application/json');
            var reviver = options?.reviver;
            var strict = options?.strict !== false;
            function parse(body) {
                if (0 === body.length) return {};
                if (strict) {
                    var first = firstchar(body);
                    if ('{' !== first && '[' !== first) {
                        debug('strict violation');
                        throw createStrictSyntaxError(body, first);
                    }
                }
                try {
                    debug('parse json');
                    return JSON.parse(body, reviver);
                } catch (e) {
                    throw normalizeJsonSyntaxError(e, {
                        message: e.message,
                        stack: e.stack
                    });
                }
            }
            const readOptions = {
                ...normalizedOptions,
                isValidCharset: (charset)=>'utf-' === charset.slice(0, 4)
            };
            return function(req, res, next) {
                read(req, res, next, parse, debug, readOptions);
            };
        }
        function createStrictSyntaxError(str, char) {
            var index = str.indexOf(char);
            var partial = '';
            if (-1 !== index) partial = str.substring(0, index) + JSON_SYNTAX_CHAR.repeat(str.length - index);
            try {
                JSON.parse(partial);
                throw new SyntaxError('strict violation');
            } catch (e) {
                return normalizeJsonSyntaxError(e, {
                    message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
                        return str.substring(index, index + placeholder.length);
                    }),
                    stack: e.stack
                });
            }
        }
        function firstchar(str) {
            var match = FIRST_CHAR_REGEXP.exec(str);
            return match ? match[1] : void 0;
        }
        function normalizeJsonSyntaxError(error, obj) {
            var keys = Object.getOwnPropertyNames(error);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                if ('stack' !== key && 'message' !== key) delete error[key];
            }
            error.stack = obj.stack.replace(error.message, obj.message);
            error.message = obj.message;
            return error;
        }
    },
    "../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/types/raw.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js")('body-parser:raw');
        var read = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/read.js");
        var { normalizeOptions, passthrough } = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/utils.js");
        module.exports = raw;
        function raw(options) {
            const normalizedOptions = normalizeOptions(options, 'application/octet-stream');
            const readOptions = {
                ...normalizedOptions,
                skipCharset: true
            };
            return function(req, res, next) {
                read(req, res, next, passthrough, debug, readOptions);
            };
        }
    },
    "../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/types/text.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js")('body-parser:text');
        var read = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/read.js");
        var { normalizeOptions, passthrough } = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/utils.js");
        module.exports = text;
        function text(options) {
            const normalizedOptions = normalizeOptions(options, 'text/plain');
            return function(req, res, next) {
                read(req, res, next, passthrough, debug, normalizedOptions);
            };
        }
    },
    "../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/types/urlencoded.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var createError = __webpack_require__("../../../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js")('body-parser:urlencoded');
        var read = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/read.js");
        var qs = __webpack_require__("../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/index.js");
        var { normalizeOptions } = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/utils.js");
        module.exports = urlencoded;
        function urlencoded(options) {
            const normalizedOptions = normalizeOptions(options, 'application/x-www-form-urlencoded');
            if ('utf-8' !== normalizedOptions.defaultCharset && 'iso-8859-1' !== normalizedOptions.defaultCharset) throw new TypeError('option defaultCharset must be either utf-8 or iso-8859-1');
            var queryparse = createQueryParser(options);
            function parse(body, encoding) {
                return body.length ? queryparse(body, encoding) : {};
            }
            const readOptions = {
                ...normalizedOptions,
                isValidCharset: (charset)=>'utf-8' === charset || 'iso-8859-1' === charset
            };
            return function(req, res, next) {
                read(req, res, next, parse, debug, readOptions);
            };
        }
        function createQueryParser(options) {
            var extended = Boolean(options?.extended);
            var parameterLimit = options?.parameterLimit !== void 0 ? options?.parameterLimit : 1000;
            var charsetSentinel = options?.charsetSentinel;
            var interpretNumericEntities = options?.interpretNumericEntities;
            var depth = extended ? options?.depth !== void 0 ? options?.depth : 32 : 0;
            if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError('option parameterLimit must be a positive number');
            if (isNaN(depth) || depth < 0) throw new TypeError('option depth must be a zero or a positive number');
            if (isFinite(parameterLimit)) parameterLimit |= 0;
            return function(body, encoding) {
                var paramCount = parameterCount(body, parameterLimit);
                if (void 0 === paramCount) {
                    debug('too many parameters');
                    throw createError(413, 'too many parameters', {
                        type: 'parameters.too.many'
                    });
                }
                var arrayLimit = extended ? Math.max(100, paramCount) : paramCount;
                debug('parse ' + (extended ? 'extended ' : '') + 'urlencoding');
                try {
                    return qs.parse(body, {
                        allowPrototypes: true,
                        arrayLimit: arrayLimit,
                        depth: depth,
                        charsetSentinel: charsetSentinel,
                        interpretNumericEntities: interpretNumericEntities,
                        charset: encoding,
                        parameterLimit: parameterLimit,
                        strictDepth: true
                    });
                } catch (err) {
                    if (err instanceof RangeError) throw createError(400, 'The input exceeded the depth', {
                        type: 'querystring.parse.rangeError'
                    });
                    throw err;
                }
            };
        }
        function parameterCount(body, limit) {
            let count = 0;
            let index = -1;
            do {
                count++;
                if (count > limit) return;
                index = body.indexOf('&', index + 1);
            }while (-1 !== index);
            return count;
        }
    },
    "../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/lib/utils.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var bytes = __webpack_require__("../../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var contentType = __webpack_require__("../../../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var typeis = __webpack_require__("../../../node_modules/.pnpm/type-is@2.0.1/node_modules/type-is/index.js");
        module.exports = {
            getCharset,
            normalizeOptions,
            passthrough
        };
        function getCharset(req) {
            try {
                return (contentType.parse(req).parameters.charset || '').toLowerCase();
            } catch  {
                return;
            }
        }
        function typeChecker(type) {
            return function(req) {
                return Boolean(typeis(req, type));
            };
        }
        function normalizeOptions(options, defaultType) {
            if (!defaultType) throw new TypeError('defaultType must be provided');
            var inflate = options?.inflate !== false;
            var limit = 'number' != typeof options?.limit ? bytes.parse(options?.limit || '100kb') : options?.limit;
            var type = options?.type || defaultType;
            var verify = options?.verify || false;
            var defaultCharset = options?.defaultCharset || 'utf-8';
            if (false !== verify && 'function' != typeof verify) throw new TypeError('option verify must be function');
            var shouldParse = 'function' != typeof type ? typeChecker(type) : type;
            return {
                inflate,
                limit,
                verify,
                defaultCharset,
                shouldParse
            };
        }
        function passthrough(value) {
            return value;
        }
    },
    "../../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        var concatMap = __webpack_require__("../../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js");
        var balanced = __webpack_require__("../../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js");
        module.exports = expandTop;
        var escSlash = '\0SLASH' + Math.random() + '\0';
        var escOpen = '\0OPEN' + Math.random() + '\0';
        var escClose = '\0CLOSE' + Math.random() + '\0';
        var escComma = '\0COMMA' + Math.random() + '\0';
        var escPeriod = '\0PERIOD' + Math.random() + '\0';
        function numeric(str) {
            return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
        }
        function escapeBraces(str) {
            return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
        }
        function unescapeBraces(str) {
            return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
        }
        function parseCommaParts(str) {
            if (!str) return [
                ''
            ];
            var parts = [];
            var m = balanced('{', '}', str);
            if (!m) return str.split(',');
            var pre = m.pre;
            var body = m.body;
            var post = m.post;
            var p = pre.split(',');
            p[p.length - 1] += '{' + body + '}';
            var postParts = parseCommaParts(post);
            if (post.length) {
                p[p.length - 1] += postParts.shift();
                p.push.apply(p, postParts);
            }
            parts.push.apply(parts, p);
            return parts;
        }
        function expandTop(str) {
            if (!str) return [];
            if ('{}' === str.substr(0, 2)) str = '\\{\\}' + str.substr(2);
            return expand(escapeBraces(str), true).map(unescapeBraces);
        }
        function embrace(str) {
            return '{' + str + '}';
        }
        function isPadded(el) {
            return /^-?0\d/.test(el);
        }
        function lte(i, y) {
            return i <= y;
        }
        function gte(i, y) {
            return i >= y;
        }
        function expand(str, isTop) {
            var expansions = [];
            var m = balanced('{', '}', str);
            if (!m || /\$$/.test(m.pre)) return [
                str
            ];
            var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
            var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
            var isSequence = isNumericSequence || isAlphaSequence;
            var isOptions = m.body.indexOf(',') >= 0;
            if (!isSequence && !isOptions) {
                if (m.post.match(/,.*\}/)) {
                    str = m.pre + '{' + m.body + escClose + m.post;
                    return expand(str);
                }
                return [
                    str
                ];
            }
            var n;
            if (isSequence) n = m.body.split(/\.\./);
            else {
                n = parseCommaParts(m.body);
                if (1 === n.length) {
                    n = expand(n[0], false).map(embrace);
                    if (1 === n.length) {
                        var post = m.post.length ? expand(m.post, false) : [
                            ''
                        ];
                        return post.map(function(p) {
                            return m.pre + n[0] + p;
                        });
                    }
                }
            }
            var pre = m.pre;
            var post = m.post.length ? expand(m.post, false) : [
                ''
            ];
            var N;
            if (isSequence) {
                var x = numeric(n[0]);
                var y = numeric(n[1]);
                var width = Math.max(n[0].length, n[1].length);
                var incr = 3 == n.length ? Math.abs(numeric(n[2])) : 1;
                var test = lte;
                var reverse = y < x;
                if (reverse) {
                    incr *= -1;
                    test = gte;
                }
                var pad = n.some(isPadded);
                N = [];
                for(var i = x; test(i, y); i += incr){
                    var c;
                    if (isAlphaSequence) {
                        c = String.fromCharCode(i);
                        if ('\\' === c) c = '';
                    } else {
                        c = String(i);
                        if (pad) {
                            var need = width - c.length;
                            if (need > 0) {
                                var z = new Array(need + 1).join('0');
                                c = i < 0 ? '-' + z + c.slice(1) : z + c;
                            }
                        }
                    }
                    N.push(c);
                }
            } else N = concatMap(n, function(el) {
                return expand(el, false);
            });
            for(var j = 0; j < N.length; j++)for(var k = 0; k < post.length; k++){
                var expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion) expansions.push(expansion);
            }
            return expansions;
        }
    },
    "../../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js" (module) {
        "use strict";
        /*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */ module.exports = bytes;
        module.exports.format = format;
        module.exports.parse = parse;
        var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
        var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
        var map = {
            b: 1,
            kb: 1024,
            mb: 1048576,
            gb: 1073741824,
            tb: Math.pow(1024, 4),
            pb: Math.pow(1024, 5)
        };
        var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
        function bytes(value, options) {
            if ('string' == typeof value) return parse(value);
            if ('number' == typeof value) return format(value, options);
            return null;
        }
        function format(value, options) {
            if (!Number.isFinite(value)) return null;
            var mag = Math.abs(value);
            var thousandsSeparator = options && options.thousandsSeparator || '';
            var unitSeparator = options && options.unitSeparator || '';
            var decimalPlaces = options && void 0 !== options.decimalPlaces ? options.decimalPlaces : 2;
            var fixedDecimals = Boolean(options && options.fixedDecimals);
            var unit = options && options.unit || '';
            if (!unit || !map[unit.toLowerCase()]) unit = mag >= map.pb ? 'PB' : mag >= map.tb ? 'TB' : mag >= map.gb ? 'GB' : mag >= map.mb ? 'MB' : mag >= map.kb ? 'KB' : 'B';
            var val = value / map[unit.toLowerCase()];
            var str = val.toFixed(decimalPlaces);
            if (!fixedDecimals) str = str.replace(formatDecimalsRegExp, '$1');
            if (thousandsSeparator) str = str.split('.').map(function(s, i) {
                return 0 === i ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
            }).join('.');
            return str + unitSeparator + unit;
        }
        function parse(val) {
            if ('number' == typeof val && !isNaN(val)) return val;
            if ('string' != typeof val) return null;
            var results = parseRegExp.exec(val);
            var floatValue;
            var unit = 'b';
            if (results) {
                floatValue = parseFloat(results[1]);
                unit = results[4].toLowerCase();
            } else {
                floatValue = parseInt(val, 10);
                unit = 'b';
            }
            if (isNaN(floatValue)) return null;
            return Math.floor(map[unit] * floatValue);
        }
    },
    "../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var bind = __webpack_require__("../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        var $apply = __webpack_require__("../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
        var $call = __webpack_require__("../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
        var $reflectApply = __webpack_require__("../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js");
        module.exports = $reflectApply || bind.call($call, $apply);
    },
    "../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js" (module) {
        "use strict";
        module.exports = Function.prototype.apply;
    },
    "../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js" (module) {
        "use strict";
        module.exports = Function.prototype.call;
    },
    "../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var bind = __webpack_require__("../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        var $TypeError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $call = __webpack_require__("../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
        var $actualApply = __webpack_require__("../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js");
        module.exports = function(args) {
            if (args.length < 1 || 'function' != typeof args[0]) throw new $TypeError('a function is required');
            return $actualApply(bind, $call, args);
        };
    },
    "../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js" (module) {
        "use strict";
        module.exports = "u" > typeof Reflect && Reflect && Reflect.apply;
    },
    "../../../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var callBindBasic = __webpack_require__("../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
        var $indexOf = callBindBasic([
            GetIntrinsic('%String.prototype.indexOf%')
        ]);
        module.exports = function(name, allowMissing) {
            var intrinsic = GetIntrinsic(name, !!allowMissing);
            if ('function' == typeof intrinsic && $indexOf(name, '.prototype.') > -1) return callBindBasic([
                intrinsic
            ]);
            return intrinsic;
        };
    },
    "../../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js" (module, __unused_rspack_exports, __webpack_require__) {
        var util = __webpack_require__("util");
        var Stream = __webpack_require__("stream").Stream;
        var DelayedStream = __webpack_require__("../../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js");
        module.exports = CombinedStream;
        function CombinedStream() {
            this.writable = false;
            this.readable = true;
            this.dataSize = 0;
            this.maxDataSize = 2097152;
            this.pauseStreams = true;
            this._released = false;
            this._streams = [];
            this._currentStream = null;
            this._insideLoop = false;
            this._pendingNext = false;
        }
        util.inherits(CombinedStream, Stream);
        CombinedStream.create = function(options) {
            var combinedStream = new this();
            options = options || {};
            for(var option in options)combinedStream[option] = options[option];
            return combinedStream;
        };
        CombinedStream.isStreamLike = function(stream) {
            return 'function' != typeof stream && 'string' != typeof stream && 'boolean' != typeof stream && 'number' != typeof stream && !Buffer.isBuffer(stream);
        };
        CombinedStream.prototype.append = function(stream) {
            var isStreamLike = CombinedStream.isStreamLike(stream);
            if (isStreamLike) {
                if (!(stream instanceof DelayedStream)) {
                    var newStream = DelayedStream.create(stream, {
                        maxDataSize: 1 / 0,
                        pauseStream: this.pauseStreams
                    });
                    stream.on('data', this._checkDataSize.bind(this));
                    stream = newStream;
                }
                this._handleErrors(stream);
                if (this.pauseStreams) stream.pause();
            }
            this._streams.push(stream);
            return this;
        };
        CombinedStream.prototype.pipe = function(dest, options) {
            Stream.prototype.pipe.call(this, dest, options);
            this.resume();
            return dest;
        };
        CombinedStream.prototype._getNext = function() {
            this._currentStream = null;
            if (this._insideLoop) {
                this._pendingNext = true;
                return;
            }
            this._insideLoop = true;
            try {
                do {
                    this._pendingNext = false;
                    this._realGetNext();
                }while (this._pendingNext);
            } finally{
                this._insideLoop = false;
            }
        };
        CombinedStream.prototype._realGetNext = function() {
            var stream = this._streams.shift();
            if (void 0 === stream) return void this.end();
            if ('function' != typeof stream) return void this._pipeNext(stream);
            var getStream = stream;
            getStream((function(stream) {
                var isStreamLike = CombinedStream.isStreamLike(stream);
                if (isStreamLike) {
                    stream.on('data', this._checkDataSize.bind(this));
                    this._handleErrors(stream);
                }
                this._pipeNext(stream);
            }).bind(this));
        };
        CombinedStream.prototype._pipeNext = function(stream) {
            this._currentStream = stream;
            var isStreamLike = CombinedStream.isStreamLike(stream);
            if (isStreamLike) {
                stream.on('end', this._getNext.bind(this));
                stream.pipe(this, {
                    end: false
                });
                return;
            }
            var value = stream;
            this.write(value);
            this._getNext();
        };
        CombinedStream.prototype._handleErrors = function(stream) {
            var self1 = this;
            stream.on('error', function(err) {
                self1._emitError(err);
            });
        };
        CombinedStream.prototype.write = function(data) {
            this.emit('data', data);
        };
        CombinedStream.prototype.pause = function() {
            if (!this.pauseStreams) return;
            if (this.pauseStreams && this._currentStream && 'function' == typeof this._currentStream.pause) this._currentStream.pause();
            this.emit('pause');
        };
        CombinedStream.prototype.resume = function() {
            if (!this._released) {
                this._released = true;
                this.writable = true;
                this._getNext();
            }
            if (this.pauseStreams && this._currentStream && 'function' == typeof this._currentStream.resume) this._currentStream.resume();
            this.emit('resume');
        };
        CombinedStream.prototype.end = function() {
            this._reset();
            this.emit('end');
        };
        CombinedStream.prototype.destroy = function() {
            this._reset();
            this.emit('close');
        };
        CombinedStream.prototype._reset = function() {
            this.writable = false;
            this._streams = [];
            this._currentStream = null;
        };
        CombinedStream.prototype._checkDataSize = function() {
            this._updateDataSize();
            if (this.dataSize <= this.maxDataSize) return;
            var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
            this._emitError(new Error(message));
        };
        CombinedStream.prototype._updateDataSize = function() {
            this.dataSize = 0;
            var self1 = this;
            this._streams.forEach(function(stream) {
                if (!stream.dataSize) return;
                self1.dataSize += stream.dataSize;
            });
            if (this._currentStream && this._currentStream.dataSize) this.dataSize += this._currentStream.dataSize;
        };
        CombinedStream.prototype._emitError = function(err) {
            this._reset();
            this.emit('error', err);
        };
    },
    "../../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js" (module) {
        module.exports = function(xs, fn) {
            var res = [];
            for(var i = 0; i < xs.length; i++){
                var x = fn(xs[i], i);
                if (isArray(x)) res.push.apply(res, x);
                else res.push(x);
            }
            return res;
        };
        var isArray = Array.isArray || function(xs) {
            return '[object Array]' === Object.prototype.toString.call(xs);
        };
    },
    "../../../node_modules/.pnpm/content-disposition@1.0.0/node_modules/content-disposition/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = contentDisposition;
        module.exports.parse = parse;
        var basename = __webpack_require__("path").basename;
        var Buffer1 = __webpack_require__("../../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer;
        var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
        var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
        var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
        var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
        var QESC_REGEXP = /\\([\u0000-\u007f])/g;
        var QUOTE_REGEXP = /([\\"])/g;
        var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
        var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
        var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
        var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
        var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
        function contentDisposition(filename, options) {
            var opts = options || {};
            var type = opts.type || 'attachment';
            var params = createparams(filename, opts.fallback);
            return format(new ContentDisposition(type, params));
        }
        function createparams(filename, fallback) {
            if (void 0 === filename) return;
            var params = {};
            if ('string' != typeof filename) throw new TypeError('filename must be a string');
            if (void 0 === fallback) fallback = true;
            if ('string' != typeof fallback && 'boolean' != typeof fallback) throw new TypeError('fallback must be a string or boolean');
            if ('string' == typeof fallback && NON_LATIN1_REGEXP.test(fallback)) throw new TypeError('fallback must be ISO-8859-1 string');
            var name = basename(filename);
            var isQuotedString = TEXT_REGEXP.test(name);
            var fallbackName = 'string' != typeof fallback ? fallback && getlatin1(name) : basename(fallback);
            var hasFallback = 'string' == typeof fallbackName && fallbackName !== name;
            if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) params['filename*'] = name;
            if (isQuotedString || hasFallback) params.filename = hasFallback ? fallbackName : name;
            return params;
        }
        function format(obj) {
            var parameters = obj.parameters;
            var type = obj.type;
            if (!type || 'string' != typeof type || !TOKEN_REGEXP.test(type)) throw new TypeError('invalid type');
            var string = String(type).toLowerCase();
            if (parameters && 'object' == typeof parameters) {
                var param;
                var params = Object.keys(parameters).sort();
                for(var i = 0; i < params.length; i++){
                    param = params[i];
                    var val = '*' === param.slice(-1) ? ustring(parameters[param]) : qstring(parameters[param]);
                    string += '; ' + param + '=' + val;
                }
            }
            return string;
        }
        function decodefield(str) {
            var match = EXT_VALUE_REGEXP.exec(str);
            if (!match) throw new TypeError('invalid extended field value');
            var charset = match[1].toLowerCase();
            var encoded = match[2];
            var value;
            var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
            switch(charset){
                case 'iso-8859-1':
                    value = getlatin1(binary);
                    break;
                case 'utf-8':
                case 'utf8':
                    value = Buffer1.from(binary, 'binary').toString('utf8');
                    break;
                default:
                    throw new TypeError('unsupported charset in extended field');
            }
            return value;
        }
        function getlatin1(val) {
            return String(val).replace(NON_LATIN1_REGEXP, '?');
        }
        function parse(string) {
            if (!string || 'string' != typeof string) throw new TypeError('argument string is required');
            var match = DISPOSITION_TYPE_REGEXP.exec(string);
            if (!match) throw new TypeError('invalid type format');
            var index = match[0].length;
            var type = match[1].toLowerCase();
            var key;
            var names = [];
            var params = {};
            var value;
            index = PARAM_REGEXP.lastIndex = ';' === match[0].slice(-1) ? index - 1 : index;
            while(match = PARAM_REGEXP.exec(string)){
                if (match.index !== index) throw new TypeError('invalid parameter format');
                index += match[0].length;
                key = match[1].toLowerCase();
                value = match[2];
                if (-1 !== names.indexOf(key)) throw new TypeError('invalid duplicate parameter');
                names.push(key);
                if (key.indexOf('*') + 1 === key.length) {
                    key = key.slice(0, -1);
                    value = decodefield(value);
                    params[key] = value;
                    continue;
                }
                if ('string' == typeof params[key]) continue;
                if ('"' === value[0]) value = value.slice(1, -1).replace(QESC_REGEXP, '$1');
                params[key] = value;
            }
            if (-1 !== index && index !== string.length) throw new TypeError('invalid parameter format');
            return new ContentDisposition(type, params);
        }
        function pdecode(str, hex) {
            return String.fromCharCode(parseInt(hex, 16));
        }
        function pencode(char) {
            return '%' + String(char).charCodeAt(0).toString(16).toUpperCase();
        }
        function qstring(val) {
            var str = String(val);
            return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
        }
        function ustring(val) {
            var str = String(val);
            var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
            return 'UTF-8\'\'' + encoded;
        }
        function ContentDisposition(type, parameters) {
            this.type = type;
            this.parameters = parameters;
        }
    },
    "../../../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js" (__unused_rspack_module, exports1) {
        "use strict";
        /*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
        var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
        var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
        var QUOTE_REGEXP = /([\\"])/g;
        var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        exports1.format = format;
        exports1.parse = parse;
        function format(obj) {
            if (!obj || 'object' != typeof obj) throw new TypeError('argument obj is required');
            var parameters = obj.parameters;
            var type = obj.type;
            if (!type || !TYPE_REGEXP.test(type)) throw new TypeError('invalid type');
            var string = type;
            if (parameters && 'object' == typeof parameters) {
                var param;
                var params = Object.keys(parameters).sort();
                for(var i = 0; i < params.length; i++){
                    param = params[i];
                    if (!TOKEN_REGEXP.test(param)) throw new TypeError('invalid parameter name');
                    string += '; ' + param + '=' + qstring(parameters[param]);
                }
            }
            return string;
        }
        function parse(string) {
            if (!string) throw new TypeError('argument string is required');
            var header = 'object' == typeof string ? getcontenttype(string) : string;
            if ('string' != typeof header) throw new TypeError('argument string is required to be a string');
            var index = header.indexOf(';');
            var type = -1 !== index ? header.slice(0, index).trim() : header.trim();
            if (!TYPE_REGEXP.test(type)) throw new TypeError('invalid media type');
            var obj = new ContentType(type.toLowerCase());
            if (-1 !== index) {
                var key;
                var match;
                var value;
                PARAM_REGEXP.lastIndex = index;
                while(match = PARAM_REGEXP.exec(header)){
                    if (match.index !== index) throw new TypeError('invalid parameter format');
                    index += match[0].length;
                    key = match[1].toLowerCase();
                    value = match[2];
                    if (0x22 === value.charCodeAt(0)) {
                        value = value.slice(1, -1);
                        if (-1 !== value.indexOf('\\')) value = value.replace(QESC_REGEXP, '$1');
                    }
                    obj.parameters[key] = value;
                }
                if (index !== header.length) throw new TypeError('invalid parameter format');
            }
            return obj;
        }
        function getcontenttype(obj) {
            var header;
            if ('function' == typeof obj.getHeader) header = obj.getHeader('content-type');
            else if ('object' == typeof obj.headers) header = obj.headers && obj.headers['content-type'];
            if ('string' != typeof header) throw new TypeError('content-type header is missing from object');
            return header;
        }
        function qstring(val) {
            var str = String(val);
            if (TOKEN_REGEXP.test(str)) return str;
            if (str.length > 0 && !TEXT_REGEXP.test(str)) throw new TypeError('invalid parameter value');
            return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
        }
        function ContentType(type) {
            this.parameters = Object.create(null);
            this.type = type;
        }
    },
    "../../../node_modules/.pnpm/cookie-signature@1.2.2/node_modules/cookie-signature/index.js" (__unused_rspack_module, exports1, __webpack_require__) {
        var crypto = __webpack_require__("crypto");
        exports1.sign = function(val, secret) {
            if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
            if (null == secret) throw new TypeError("Secret key must be provided.");
            return val + '.' + crypto.createHmac('sha256', secret).update(val).digest('base64').replace(/\=+$/, '');
        };
        exports1.unsign = function(input, secret) {
            if ('string' != typeof input) throw new TypeError("Signed cookie string must be provided.");
            if (null == secret) throw new TypeError("Secret key must be provided.");
            var tentativeValue = input.slice(0, input.lastIndexOf('.')), expectedInput = exports1.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
            return expectedBuffer.length === inputBuffer.length && crypto.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
        };
    },
    "../../../node_modules/.pnpm/cookie@0.7.2/node_modules/cookie/index.js" (__unused_rspack_module, exports1) {
        "use strict";
        /*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ exports1.parse = parse;
        exports1.serialize = serialize;
        var __toString = Object.prototype.toString;
        var __hasOwnProperty = Object.prototype.hasOwnProperty;
        var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
        var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
        var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
        var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
        function parse(str, opt) {
            if ('string' != typeof str) throw new TypeError('argument str must be a string');
            var obj = {};
            var len = str.length;
            if (len < 2) return obj;
            var dec = opt && opt.decode || decode;
            var index = 0;
            var eqIdx = 0;
            var endIdx = 0;
            do {
                eqIdx = str.indexOf('=', index);
                if (-1 === eqIdx) break;
                endIdx = str.indexOf(';', index);
                if (-1 === endIdx) endIdx = len;
                else if (eqIdx > endIdx) {
                    index = str.lastIndexOf(';', eqIdx - 1) + 1;
                    continue;
                }
                var keyStartIdx = startIndex(str, index, eqIdx);
                var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
                var key = str.slice(keyStartIdx, keyEndIdx);
                if (!__hasOwnProperty.call(obj, key)) {
                    var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
                    var valEndIdx = endIndex(str, endIdx, valStartIdx);
                    if (0x22 === str.charCodeAt(valStartIdx) && 0x22 === str.charCodeAt(valEndIdx - 1)) {
                        valStartIdx++;
                        valEndIdx--;
                    }
                    var val = str.slice(valStartIdx, valEndIdx);
                    obj[key] = tryDecode(val, dec);
                }
                index = endIdx + 1;
            }while (index < len);
            return obj;
        }
        function startIndex(str, index, max) {
            do {
                var code = str.charCodeAt(index);
                if (0x20 !== code && 0x09 !== code) return index;
            }while (++index < max);
            return max;
        }
        function endIndex(str, index, min) {
            while(index > min){
                var code = str.charCodeAt(--index);
                if (0x20 !== code && 0x09 !== code) return index + 1;
            }
            return min;
        }
        function serialize(name, val, opt) {
            var enc = opt && opt.encode || encodeURIComponent;
            if ('function' != typeof enc) throw new TypeError('option encode is invalid');
            if (!cookieNameRegExp.test(name)) throw new TypeError('argument name is invalid');
            var value = enc(val);
            if (!cookieValueRegExp.test(value)) throw new TypeError('argument val is invalid');
            var str = name + '=' + value;
            if (!opt) return str;
            if (null != opt.maxAge) {
                var maxAge = Math.floor(opt.maxAge);
                if (!isFinite(maxAge)) throw new TypeError('option maxAge is invalid');
                str += '; Max-Age=' + maxAge;
            }
            if (opt.domain) {
                if (!domainValueRegExp.test(opt.domain)) throw new TypeError('option domain is invalid');
                str += '; Domain=' + opt.domain;
            }
            if (opt.path) {
                if (!pathValueRegExp.test(opt.path)) throw new TypeError('option path is invalid');
                str += '; Path=' + opt.path;
            }
            if (opt.expires) {
                var expires = opt.expires;
                if (!isDate(expires) || isNaN(expires.valueOf())) throw new TypeError('option expires is invalid');
                str += '; Expires=' + expires.toUTCString();
            }
            if (opt.httpOnly) str += '; HttpOnly';
            if (opt.secure) str += '; Secure';
            if (opt.partitioned) str += '; Partitioned';
            if (opt.priority) {
                var priority = 'string' == typeof opt.priority ? opt.priority.toLowerCase() : opt.priority;
                switch(priority){
                    case 'low':
                        str += '; Priority=Low';
                        break;
                    case 'medium':
                        str += '; Priority=Medium';
                        break;
                    case 'high':
                        str += '; Priority=High';
                        break;
                    default:
                        throw new TypeError('option priority is invalid');
                }
            }
            if (opt.sameSite) {
                var sameSite = 'string' == typeof opt.sameSite ? opt.sameSite.toLowerCase() : opt.sameSite;
                switch(sameSite){
                    case true:
                        str += '; SameSite=Strict';
                        break;
                    case 'lax':
                        str += '; SameSite=Lax';
                        break;
                    case 'strict':
                        str += '; SameSite=Strict';
                        break;
                    case 'none':
                        str += '; SameSite=None';
                        break;
                    default:
                        throw new TypeError('option sameSite is invalid');
                }
            }
            return str;
        }
        function decode(str) {
            return -1 !== str.indexOf('%') ? decodeURIComponent(str) : str;
        }
        function isDate(val) {
            return '[object Date]' === __toString.call(val);
        }
        function tryDecode(str, decode) {
            try {
                return decode(str);
            } catch (e) {
                return str;
            }
        }
    },
    "../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js" (module, exports1, __webpack_require__) {
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.storage = localstorage();
        exports1.destroy = (()=>{
            let warned = false;
            return ()=>{
                if (!warned) {
                    warned = true;
                    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
                }
            };
        })();
        exports1.colors = [
            '#0000CC',
            '#0000FF',
            '#0033CC',
            '#0033FF',
            '#0066CC',
            '#0066FF',
            '#0099CC',
            '#0099FF',
            '#00CC00',
            '#00CC33',
            '#00CC66',
            '#00CC99',
            '#00CCCC',
            '#00CCFF',
            '#3300CC',
            '#3300FF',
            '#3333CC',
            '#3333FF',
            '#3366CC',
            '#3366FF',
            '#3399CC',
            '#3399FF',
            '#33CC00',
            '#33CC33',
            '#33CC66',
            '#33CC99',
            '#33CCCC',
            '#33CCFF',
            '#6600CC',
            '#6600FF',
            '#6633CC',
            '#6633FF',
            '#66CC00',
            '#66CC33',
            '#9900CC',
            '#9900FF',
            '#9933CC',
            '#9933FF',
            '#99CC00',
            '#99CC33',
            '#CC0000',
            '#CC0033',
            '#CC0066',
            '#CC0099',
            '#CC00CC',
            '#CC00FF',
            '#CC3300',
            '#CC3333',
            '#CC3366',
            '#CC3399',
            '#CC33CC',
            '#CC33FF',
            '#CC6600',
            '#CC6633',
            '#CC9900',
            '#CC9933',
            '#CCCC00',
            '#CCCC33',
            '#FF0000',
            '#FF0033',
            '#FF0066',
            '#FF0099',
            '#FF00CC',
            '#FF00FF',
            '#FF3300',
            '#FF3333',
            '#FF3366',
            '#FF3399',
            '#FF33CC',
            '#FF33FF',
            '#FF6600',
            '#FF6633',
            '#FF9900',
            '#FF9933',
            '#FFCC00',
            '#FFCC33'
        ];
        function useColors() {
            if ("u" > typeof window && window.process && ('renderer' === window.process.type || window.process.__nwjs)) return true;
            if ("u" > typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
            let m;
            return "u" > typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "u" > typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "u" > typeof navigator && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || "u" > typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
            args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
            if (!this.useColors) return;
            const c = 'color: ' + this.color;
            args.splice(1, 0, c, 'color: inherit');
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match)=>{
                if ('%%' === match) return;
                index++;
                if ('%c' === match) lastC = index;
            });
            args.splice(lastC, 0, c);
        }
        exports1.log = console.debug || console.log || (()=>{});
        function save(namespaces) {
            try {
                if (namespaces) exports1.storage.setItem('debug', namespaces);
                else exports1.storage.removeItem('debug');
            } catch (error) {}
        }
        function load() {
            let r;
            try {
                r = exports1.storage.getItem('debug') || exports1.storage.getItem('DEBUG');
            } catch (error) {}
            if (!r && "u" > typeof process && 'env' in process) r = process.env.DEBUG;
            return r;
        }
        function localstorage() {
            try {
                return localStorage;
            } catch (error) {}
        }
        module.exports = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js")(exports1);
        const { formatters } = module.exports;
        formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (error) {
                return '[UnexpectedJSONParseError]: ' + error.message;
            }
        };
    },
    "../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js" (module, __unused_rspack_exports, __webpack_require__) {
        function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__("../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js");
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key)=>{
                createDebug[key] = env[key];
            });
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
                let hash = 0;
                for(let i = 0; i < namespace.length; i++){
                    hash = (hash << 5) - hash + namespace.charCodeAt(i);
                    hash |= 0;
                }
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
                let prevTime;
                let enableOverride = null;
                let namespacesCache;
                let enabledCache;
                function debug(...args) {
                    if (!debug.enabled) return;
                    const self1 = debug;
                    const curr = Number(new Date());
                    const ms = curr - (prevTime || curr);
                    self1.diff = ms;
                    self1.prev = prevTime;
                    self1.curr = curr;
                    prevTime = curr;
                    args[0] = createDebug.coerce(args[0]);
                    if ('string' != typeof args[0]) args.unshift('%O');
                    let index = 0;
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                        if ('%%' === match) return '%';
                        index++;
                        const formatter = createDebug.formatters[format];
                        if ('function' == typeof formatter) {
                            const val = args[index];
                            match = formatter.call(self1, val);
                            args.splice(index, 1);
                            index--;
                        }
                        return match;
                    });
                    createDebug.formatArgs.call(self1, args);
                    const logFn = self1.log || createDebug.log;
                    logFn.apply(self1, args);
                }
                debug.namespace = namespace;
                debug.useColors = createDebug.useColors();
                debug.color = createDebug.selectColor(namespace);
                debug.extend = extend;
                debug.destroy = createDebug.destroy;
                Object.defineProperty(debug, 'enabled', {
                    enumerable: true,
                    configurable: false,
                    get: ()=>{
                        if (null !== enableOverride) return enableOverride;
                        if (namespacesCache !== createDebug.namespaces) {
                            namespacesCache = createDebug.namespaces;
                            enabledCache = createDebug.enabled(namespace);
                        }
                        return enabledCache;
                    },
                    set: (v)=>{
                        enableOverride = v;
                    }
                });
                if ('function' == typeof createDebug.init) createDebug.init(debug);
                return debug;
            }
            function extend(namespace, delimiter) {
                const newDebug = createDebug(this.namespace + (void 0 === delimiter ? ':' : delimiter) + namespace);
                newDebug.log = this.log;
                return newDebug;
            }
            function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.namespaces = namespaces;
                createDebug.names = [];
                createDebug.skips = [];
                const split = ('string' == typeof namespaces ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
                for (const ns of split)if ('-' === ns[0]) createDebug.skips.push(ns.slice(1));
                else createDebug.names.push(ns);
            }
            function matchesTemplate(search, template) {
                let searchIndex = 0;
                let templateIndex = 0;
                let starIndex = -1;
                let matchIndex = 0;
                while(searchIndex < search.length)if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || '*' === template[templateIndex])) if ('*' === template[templateIndex]) {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++;
                } else {
                    searchIndex++;
                    templateIndex++;
                }
                else {
                    if (-1 === starIndex) return false;
                    templateIndex = starIndex + 1;
                    matchIndex++;
                    searchIndex = matchIndex;
                }
                while(templateIndex < template.length && '*' === template[templateIndex])templateIndex++;
                return templateIndex === template.length;
            }
            function disable() {
                const namespaces = [
                    ...createDebug.names,
                    ...createDebug.skips.map((namespace)=>'-' + namespace)
                ].join(',');
                createDebug.enable('');
                return namespaces;
            }
            function enabled(name) {
                for (const skip of createDebug.skips)if (matchesTemplate(name, skip)) return false;
                for (const ns of createDebug.names)if (matchesTemplate(name, ns)) return true;
                return false;
            }
            function coerce(val) {
                if (val instanceof Error) return val.stack || val.message;
                return val;
            }
            function destroy() {
                console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
            }
            createDebug.enable(createDebug.load());
            return createDebug;
        }
        module.exports = setup;
    },
    "../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        if ("u" < typeof process || 'renderer' === process.type || true === process.browser || process.__nwjs) module.exports = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js");
        else module.exports = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js");
    },
    "../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js" (module, exports1, __webpack_require__) {
        const tty = __webpack_require__("tty");
        const util = __webpack_require__("util");
        exports1.init = init;
        exports1.log = log;
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        exports1.colors = [
            6,
            2,
            3,
            4,
            5,
            1
        ];
        try {
            const supportsColor = __webpack_require__(Object(function() {
                var e = new Error("Cannot find module 'supports-color'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            }()));
            if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports1.colors = [
                20,
                21,
                26,
                27,
                32,
                33,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                56,
                57,
                62,
                63,
                68,
                69,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                92,
                93,
                98,
                99,
                112,
                113,
                128,
                129,
                134,
                135,
                148,
                149,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                178,
                179,
                184,
                185,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                214,
                215,
                220,
                221
            ];
        } catch (error) {}
        exports1.inspectOpts = Object.keys(process.env).filter((key)=>/^debug_/i.test(key)).reduce((obj, key)=>{
            const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>k.toUpperCase());
            let val = process.env[key];
            val = /^(yes|on|true|enabled)$/i.test(val) ? true : /^(no|off|false|disabled)$/i.test(val) ? false : 'null' === val ? null : Number(val);
            obj[prop] = val;
            return obj;
        }, {});
        function useColors() {
            return 'colors' in exports1.inspectOpts ? Boolean(exports1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }
        function formatArgs(args) {
            const { namespace: name, useColors } = this;
            if (useColors) {
                const c = this.color;
                const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
                const prefix = `  ${colorCode};1m${name} \u001B[0m`;
                args[0] = prefix + args[0].split('\n').join('\n' + prefix);
                args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
            } else args[0] = getDate() + name + ' ' + args[0];
        }
        function getDate() {
            if (exports1.inspectOpts.hideDate) return '';
            return new Date().toISOString() + ' ';
        }
        function log(...args) {
            return process.stderr.write(util.formatWithOptions(exports1.inspectOpts, ...args) + '\n');
        }
        function save(namespaces) {
            if (namespaces) process.env.DEBUG = namespaces;
            else delete process.env.DEBUG;
        }
        function load() {
            return process.env.DEBUG;
        }
        function init(debug) {
            debug.inspectOpts = {};
            const keys = Object.keys(exports1.inspectOpts);
            for(let i = 0; i < keys.length; i++)debug.inspectOpts[keys[i]] = exports1.inspectOpts[keys[i]];
        }
        module.exports = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js")(exports1);
        const { formatters } = module.exports;
        formatters.o = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
        };
        formatters.O = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts);
        };
    },
    "../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js" (module, exports1, __webpack_require__) {
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.storage = localstorage();
        exports1.destroy = (()=>{
            let warned = false;
            return ()=>{
                if (!warned) {
                    warned = true;
                    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
                }
            };
        })();
        exports1.colors = [
            '#0000CC',
            '#0000FF',
            '#0033CC',
            '#0033FF',
            '#0066CC',
            '#0066FF',
            '#0099CC',
            '#0099FF',
            '#00CC00',
            '#00CC33',
            '#00CC66',
            '#00CC99',
            '#00CCCC',
            '#00CCFF',
            '#3300CC',
            '#3300FF',
            '#3333CC',
            '#3333FF',
            '#3366CC',
            '#3366FF',
            '#3399CC',
            '#3399FF',
            '#33CC00',
            '#33CC33',
            '#33CC66',
            '#33CC99',
            '#33CCCC',
            '#33CCFF',
            '#6600CC',
            '#6600FF',
            '#6633CC',
            '#6633FF',
            '#66CC00',
            '#66CC33',
            '#9900CC',
            '#9900FF',
            '#9933CC',
            '#9933FF',
            '#99CC00',
            '#99CC33',
            '#CC0000',
            '#CC0033',
            '#CC0066',
            '#CC0099',
            '#CC00CC',
            '#CC00FF',
            '#CC3300',
            '#CC3333',
            '#CC3366',
            '#CC3399',
            '#CC33CC',
            '#CC33FF',
            '#CC6600',
            '#CC6633',
            '#CC9900',
            '#CC9933',
            '#CCCC00',
            '#CCCC33',
            '#FF0000',
            '#FF0033',
            '#FF0066',
            '#FF0099',
            '#FF00CC',
            '#FF00FF',
            '#FF3300',
            '#FF3333',
            '#FF3366',
            '#FF3399',
            '#FF33CC',
            '#FF33FF',
            '#FF6600',
            '#FF6633',
            '#FF9900',
            '#FF9933',
            '#FFCC00',
            '#FFCC33'
        ];
        function useColors() {
            if ("u" > typeof window && window.process && ('renderer' === window.process.type || window.process.__nwjs)) return true;
            if ("u" > typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
            let m;
            return "u" > typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "u" > typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "u" > typeof navigator && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || "u" > typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
            args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
            if (!this.useColors) return;
            const c = 'color: ' + this.color;
            args.splice(1, 0, c, 'color: inherit');
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match)=>{
                if ('%%' === match) return;
                index++;
                if ('%c' === match) lastC = index;
            });
            args.splice(lastC, 0, c);
        }
        exports1.log = console.debug || console.log || (()=>{});
        function save(namespaces) {
            try {
                if (namespaces) exports1.storage.setItem('debug', namespaces);
                else exports1.storage.removeItem('debug');
            } catch (error) {}
        }
        function load() {
            let r;
            try {
                r = exports1.storage.getItem('debug') || exports1.storage.getItem('DEBUG');
            } catch (error) {}
            if (!r && "u" > typeof process && 'env' in process) r = process.env.DEBUG;
            return r;
        }
        function localstorage() {
            try {
                return localStorage;
            } catch (error) {}
        }
        module.exports = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js")(exports1);
        const { formatters } = module.exports;
        formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (error) {
                return '[UnexpectedJSONParseError]: ' + error.message;
            }
        };
    },
    "../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js" (module, __unused_rspack_exports, __webpack_require__) {
        function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__("../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js");
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key)=>{
                createDebug[key] = env[key];
            });
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
                let hash = 0;
                for(let i = 0; i < namespace.length; i++){
                    hash = (hash << 5) - hash + namespace.charCodeAt(i);
                    hash |= 0;
                }
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
                let prevTime;
                let enableOverride = null;
                let namespacesCache;
                let enabledCache;
                function debug(...args) {
                    if (!debug.enabled) return;
                    const self1 = debug;
                    const curr = Number(new Date());
                    const ms = curr - (prevTime || curr);
                    self1.diff = ms;
                    self1.prev = prevTime;
                    self1.curr = curr;
                    prevTime = curr;
                    args[0] = createDebug.coerce(args[0]);
                    if ('string' != typeof args[0]) args.unshift('%O');
                    let index = 0;
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                        if ('%%' === match) return '%';
                        index++;
                        const formatter = createDebug.formatters[format];
                        if ('function' == typeof formatter) {
                            const val = args[index];
                            match = formatter.call(self1, val);
                            args.splice(index, 1);
                            index--;
                        }
                        return match;
                    });
                    createDebug.formatArgs.call(self1, args);
                    const logFn = self1.log || createDebug.log;
                    logFn.apply(self1, args);
                }
                debug.namespace = namespace;
                debug.useColors = createDebug.useColors();
                debug.color = createDebug.selectColor(namespace);
                debug.extend = extend;
                debug.destroy = createDebug.destroy;
                Object.defineProperty(debug, 'enabled', {
                    enumerable: true,
                    configurable: false,
                    get: ()=>{
                        if (null !== enableOverride) return enableOverride;
                        if (namespacesCache !== createDebug.namespaces) {
                            namespacesCache = createDebug.namespaces;
                            enabledCache = createDebug.enabled(namespace);
                        }
                        return enabledCache;
                    },
                    set: (v)=>{
                        enableOverride = v;
                    }
                });
                if ('function' == typeof createDebug.init) createDebug.init(debug);
                return debug;
            }
            function extend(namespace, delimiter) {
                const newDebug = createDebug(this.namespace + (void 0 === delimiter ? ':' : delimiter) + namespace);
                newDebug.log = this.log;
                return newDebug;
            }
            function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.namespaces = namespaces;
                createDebug.names = [];
                createDebug.skips = [];
                const split = ('string' == typeof namespaces ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
                for (const ns of split)if ('-' === ns[0]) createDebug.skips.push(ns.slice(1));
                else createDebug.names.push(ns);
            }
            function matchesTemplate(search, template) {
                let searchIndex = 0;
                let templateIndex = 0;
                let starIndex = -1;
                let matchIndex = 0;
                while(searchIndex < search.length)if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || '*' === template[templateIndex])) if ('*' === template[templateIndex]) {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++;
                } else {
                    searchIndex++;
                    templateIndex++;
                }
                else {
                    if (-1 === starIndex) return false;
                    templateIndex = starIndex + 1;
                    matchIndex++;
                    searchIndex = matchIndex;
                }
                while(templateIndex < template.length && '*' === template[templateIndex])templateIndex++;
                return templateIndex === template.length;
            }
            function disable() {
                const namespaces = [
                    ...createDebug.names,
                    ...createDebug.skips.map((namespace)=>'-' + namespace)
                ].join(',');
                createDebug.enable('');
                return namespaces;
            }
            function enabled(name) {
                for (const skip of createDebug.skips)if (matchesTemplate(name, skip)) return false;
                for (const ns of createDebug.names)if (matchesTemplate(name, ns)) return true;
                return false;
            }
            function coerce(val) {
                if (val instanceof Error) return val.stack || val.message;
                return val;
            }
            function destroy() {
                console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
            }
            createDebug.enable(createDebug.load());
            return createDebug;
        }
        module.exports = setup;
    },
    "../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        if ("u" < typeof process || 'renderer' === process.type || true === process.browser || process.__nwjs) module.exports = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js");
        else module.exports = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js");
    },
    "../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js" (module, exports1, __webpack_require__) {
        const tty = __webpack_require__("tty");
        const util = __webpack_require__("util");
        exports1.init = init;
        exports1.log = log;
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        exports1.colors = [
            6,
            2,
            3,
            4,
            5,
            1
        ];
        try {
            const supportsColor = __webpack_require__(Object(function() {
                var e = new Error("Cannot find module 'supports-color'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            }()));
            if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports1.colors = [
                20,
                21,
                26,
                27,
                32,
                33,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                56,
                57,
                62,
                63,
                68,
                69,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                92,
                93,
                98,
                99,
                112,
                113,
                128,
                129,
                134,
                135,
                148,
                149,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                178,
                179,
                184,
                185,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                214,
                215,
                220,
                221
            ];
        } catch (error) {}
        exports1.inspectOpts = Object.keys(process.env).filter((key)=>/^debug_/i.test(key)).reduce((obj, key)=>{
            const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>k.toUpperCase());
            let val = process.env[key];
            val = /^(yes|on|true|enabled)$/i.test(val) ? true : /^(no|off|false|disabled)$/i.test(val) ? false : 'null' === val ? null : Number(val);
            obj[prop] = val;
            return obj;
        }, {});
        function useColors() {
            return 'colors' in exports1.inspectOpts ? Boolean(exports1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }
        function formatArgs(args) {
            const { namespace: name, useColors } = this;
            if (useColors) {
                const c = this.color;
                const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
                const prefix = `  ${colorCode};1m${name} \u001B[0m`;
                args[0] = prefix + args[0].split('\n').join('\n' + prefix);
                args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
            } else args[0] = getDate() + name + ' ' + args[0];
        }
        function getDate() {
            if (exports1.inspectOpts.hideDate) return '';
            return new Date().toISOString() + ' ';
        }
        function log(...args) {
            return process.stderr.write(util.formatWithOptions(exports1.inspectOpts, ...args) + '\n');
        }
        function save(namespaces) {
            if (namespaces) process.env.DEBUG = namespaces;
            else delete process.env.DEBUG;
        }
        function load() {
            return process.env.DEBUG;
        }
        function init(debug) {
            debug.inspectOpts = {};
            const keys = Object.keys(exports1.inspectOpts);
            for(let i = 0; i < keys.length; i++)debug.inspectOpts[keys[i]] = exports1.inspectOpts[keys[i]];
        }
        module.exports = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js")(exports1);
        const { formatters } = module.exports;
        formatters.o = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
        };
        formatters.O = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts);
        };
    },
    "../../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js" (module, __unused_rspack_exports, __webpack_require__) {
        var Stream = __webpack_require__("stream").Stream;
        var util = __webpack_require__("util");
        module.exports = DelayedStream;
        function DelayedStream() {
            this.source = null;
            this.dataSize = 0;
            this.maxDataSize = 1048576;
            this.pauseStream = true;
            this._maxDataSizeExceeded = false;
            this._released = false;
            this._bufferedEvents = [];
        }
        util.inherits(DelayedStream, Stream);
        DelayedStream.create = function(source, options) {
            var delayedStream = new this();
            options = options || {};
            for(var option in options)delayedStream[option] = options[option];
            delayedStream.source = source;
            var realEmit = source.emit;
            source.emit = function() {
                delayedStream._handleEmit(arguments);
                return realEmit.apply(source, arguments);
            };
            source.on('error', function() {});
            if (delayedStream.pauseStream) source.pause();
            return delayedStream;
        };
        Object.defineProperty(DelayedStream.prototype, 'readable', {
            configurable: true,
            enumerable: true,
            get: function() {
                return this.source.readable;
            }
        });
        DelayedStream.prototype.setEncoding = function() {
            return this.source.setEncoding.apply(this.source, arguments);
        };
        DelayedStream.prototype.resume = function() {
            if (!this._released) this.release();
            this.source.resume();
        };
        DelayedStream.prototype.pause = function() {
            this.source.pause();
        };
        DelayedStream.prototype.release = function() {
            this._released = true;
            this._bufferedEvents.forEach((function(args) {
                this.emit.apply(this, args);
            }).bind(this));
            this._bufferedEvents = [];
        };
        DelayedStream.prototype.pipe = function() {
            var r = Stream.prototype.pipe.apply(this, arguments);
            this.resume();
            return r;
        };
        DelayedStream.prototype._handleEmit = function(args) {
            if (this._released) return void this.emit.apply(this, args);
            if ('data' === args[0]) {
                this.dataSize += args[1].length;
                this._checkIfMaxDataSizeExceeded();
            }
            this._bufferedEvents.push(args);
        };
        DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
            if (this._maxDataSizeExceeded) return;
            if (this.dataSize <= this.maxDataSize) return;
            this._maxDataSizeExceeded = true;
            var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
            this.emit('error', new Error(message));
        };
    },
    "../../../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        /*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */ var relative = __webpack_require__("path").relative;
        module.exports = depd;
        var basePath = process.cwd();
        function containsNamespace(str, namespace) {
            var vals = str.split(/[ ,]+/);
            var ns = String(namespace).toLowerCase();
            for(var i = 0; i < vals.length; i++){
                var val = vals[i];
                if (val && ('*' === val || val.toLowerCase() === ns)) return true;
            }
            return false;
        }
        function convertDataDescriptorToAccessor(obj, prop, message) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            var value = descriptor.value;
            descriptor.get = function() {
                return value;
            };
            if (descriptor.writable) descriptor.set = function(val) {
                return value = val;
            };
            delete descriptor.value;
            delete descriptor.writable;
            Object.defineProperty(obj, prop, descriptor);
            return descriptor;
        }
        function createArgumentsString(arity) {
            var str = '';
            for(var i = 0; i < arity; i++)str += ', arg' + i;
            return str.substr(2);
        }
        function createStackString(stack) {
            var str = this.name + ': ' + this.namespace;
            if (this.message) str += ' deprecated ' + this.message;
            for(var i = 0; i < stack.length; i++)str += '\n    at ' + stack[i].toString();
            return str;
        }
        function depd(namespace) {
            if (!namespace) throw new TypeError('argument namespace is required');
            var stack = getStack();
            var site = callSiteLocation(stack[1]);
            var file = site[0];
            function deprecate(message) {
                log.call(deprecate, message);
            }
            deprecate._file = file;
            deprecate._ignored = isignored(namespace);
            deprecate._namespace = namespace;
            deprecate._traced = istraced(namespace);
            deprecate._warned = Object.create(null);
            deprecate.function = wrapfunction;
            deprecate.property = wrapproperty;
            return deprecate;
        }
        function eehaslisteners(emitter, type) {
            var count = 'function' != typeof emitter.listenerCount ? emitter.listeners(type).length : emitter.listenerCount(type);
            return count > 0;
        }
        function isignored(namespace) {
            if (process.noDeprecation) return true;
            var str = process.env.NO_DEPRECATION || '';
            return containsNamespace(str, namespace);
        }
        function istraced(namespace) {
            if (process.traceDeprecation) return true;
            var str = process.env.TRACE_DEPRECATION || '';
            return containsNamespace(str, namespace);
        }
        function log(message, site) {
            var haslisteners = eehaslisteners(process, 'deprecation');
            if (!haslisteners && this._ignored) return;
            var caller;
            var callFile;
            var callSite;
            var depSite;
            var i = 0;
            var seen = false;
            var stack = getStack();
            var file = this._file;
            if (site) {
                depSite = site;
                callSite = callSiteLocation(stack[1]);
                callSite.name = depSite.name;
                file = callSite[0];
            } else {
                i = 2;
                depSite = callSiteLocation(stack[i]);
                callSite = depSite;
            }
            for(; i < stack.length; i++){
                caller = callSiteLocation(stack[i]);
                callFile = caller[0];
                if (callFile === file) seen = true;
                else if (callFile === this._file) file = this._file;
                else if (seen) break;
            }
            var key = caller ? depSite.join(':') + '__' + caller.join(':') : void 0;
            if (void 0 !== key && key in this._warned) return;
            this._warned[key] = true;
            var msg = message;
            if (!msg) msg = callSite !== depSite && callSite.name ? defaultMessage(callSite) : defaultMessage(depSite);
            if (haslisteners) {
                var err = DeprecationError(this._namespace, msg, stack.slice(i));
                process.emit('deprecation', err);
                return;
            }
            var format = process.stderr.isTTY ? formatColor : formatPlain;
            var output = format.call(this, msg, caller, stack.slice(i));
            process.stderr.write(output + '\n', 'utf8');
        }
        function callSiteLocation(callSite) {
            var file = callSite.getFileName() || '<anonymous>';
            var line = callSite.getLineNumber();
            var colm = callSite.getColumnNumber();
            if (callSite.isEval()) file = callSite.getEvalOrigin() + ', ' + file;
            var site = [
                file,
                line,
                colm
            ];
            site.callSite = callSite;
            site.name = callSite.getFunctionName();
            return site;
        }
        function defaultMessage(site) {
            var callSite = site.callSite;
            var funcName = site.name;
            if (!funcName) funcName = '<anonymous@' + formatLocation(site) + '>';
            var context = callSite.getThis();
            var typeName = context && callSite.getTypeName();
            if ('Object' === typeName) typeName = void 0;
            if ('Function' === typeName) typeName = context.name || typeName;
            return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
        }
        function formatPlain(msg, caller, stack) {
            var timestamp = new Date().toUTCString();
            var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;
            if (this._traced) {
                for(var i = 0; i < stack.length; i++)formatted += '\n    at ' + stack[i].toString();
                return formatted;
            }
            if (caller) formatted += ' at ' + formatLocation(caller);
            return formatted;
        }
        function formatColor(msg, caller, stack) {
            var formatted = '\x1b[36;1m' + this._namespace + "\x1b[22;39m \x1b[33;1mdeprecated\x1b[22;39m \x1b[0m" + msg + '\x1b[39m';
            if (this._traced) {
                for(var i = 0; i < stack.length; i++)formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m';
                return formatted;
            }
            if (caller) formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m';
            return formatted;
        }
        function formatLocation(callSite) {
            return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
        }
        function getStack() {
            var limit = Error.stackTraceLimit;
            var obj = {};
            var prep = Error.prepareStackTrace;
            Error.prepareStackTrace = prepareObjectStackTrace;
            Error.stackTraceLimit = Math.max(10, limit);
            Error.captureStackTrace(obj);
            var stack = obj.stack.slice(1);
            Error.prepareStackTrace = prep;
            Error.stackTraceLimit = limit;
            return stack;
        }
        function prepareObjectStackTrace(obj, stack) {
            return stack;
        }
        function wrapfunction(fn, message) {
            if ('function' != typeof fn) throw new TypeError('argument fn must be a function');
            var args = createArgumentsString(fn.length);
            var stack = getStack();
            var site = callSiteLocation(stack[1]);
            site.name = fn.name;
            var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site', '"use strict"\nreturn function (' + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}")(fn, log, this, message, site);
            return deprecatedfn;
        }
        function wrapproperty(obj, prop, message) {
            if (!obj || 'object' != typeof obj && 'function' != typeof obj) throw new TypeError('argument obj must be object');
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            if (!descriptor) throw new TypeError('must call property on owner object');
            if (!descriptor.configurable) throw new TypeError('property must be configurable');
            var deprecate = this;
            var stack = getStack();
            var site = callSiteLocation(stack[1]);
            site.name = prop;
            if ('value' in descriptor) descriptor = convertDataDescriptorToAccessor(obj, prop, message);
            var get = descriptor.get;
            var set = descriptor.set;
            if ('function' == typeof get) descriptor.get = function() {
                log.call(deprecate, message, site);
                return get.apply(this, arguments);
            };
            if ('function' == typeof set) descriptor.set = function() {
                log.call(deprecate, message, site);
                return set.apply(this, arguments);
            };
            Object.defineProperty(obj, prop, descriptor);
        }
        function DeprecationError(namespace, message, stack) {
            var error = new Error();
            var stackString;
            Object.defineProperty(error, 'constructor', {
                value: DeprecationError
            });
            Object.defineProperty(error, 'message', {
                configurable: true,
                enumerable: false,
                value: message,
                writable: true
            });
            Object.defineProperty(error, 'name', {
                enumerable: false,
                configurable: true,
                value: 'DeprecationError',
                writable: true
            });
            Object.defineProperty(error, 'namespace', {
                configurable: true,
                enumerable: false,
                value: namespace,
                writable: true
            });
            Object.defineProperty(error, 'stack', {
                configurable: true,
                enumerable: false,
                get: function() {
                    if (void 0 !== stackString) return stackString;
                    return stackString = createStackString.call(this, stack);
                },
                set: function(val) {
                    stackString = val;
                }
            });
            return error;
        }
    },
    "../../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var callBind = __webpack_require__("../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
        var gOPD = __webpack_require__("../../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
        var hasProtoAccessor;
        try {
            hasProtoAccessor = [].__proto__ === Array.prototype;
        } catch (e) {
            if (!e || 'object' != typeof e || !('code' in e) || 'ERR_PROTO_ACCESS' !== e.code) throw e;
        }
        var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
        var $Object = Object;
        var $getPrototypeOf = $Object.getPrototypeOf;
        module.exports = desc && 'function' == typeof desc.get ? callBind([
            desc.get
        ]) : 'function' == typeof $getPrototypeOf ? function(value) {
            return $getPrototypeOf(null == value ? value : $Object(value));
        } : false;
    },
    "../../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js" (module) {
        "use strict";
        /*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */ module.exports = first;
        function first(stuff, done) {
            if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');
            var cleanups = [];
            for(var i = 0; i < stuff.length; i++){
                var arr = stuff[i];
                if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');
                var ee = arr[0];
                for(var j = 1; j < arr.length; j++){
                    var event = arr[j];
                    var fn = listener(event, callback);
                    ee.on(event, fn);
                    cleanups.push({
                        ee: ee,
                        event: event,
                        fn: fn
                    });
                }
            }
            function callback() {
                cleanup();
                done.apply(null, arguments);
            }
            function cleanup() {
                var x;
                for(var i = 0; i < cleanups.length; i++){
                    x = cleanups[i];
                    x.ee.removeListener(x.event, x.fn);
                }
            }
            function thunk(fn) {
                done = fn;
            }
            thunk.cancel = cleanup;
            return thunk;
        }
        function listener(event, done) {
            return function(arg1) {
                var args = new Array(arguments.length);
                var ee = this;
                var err = 'error' === event ? arg1 : null;
                for(var i = 0; i < args.length; i++)args[i] = arguments[i];
                done(err, ee, event, args);
            };
        }
    },
    "../../../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js" (module) {
        "use strict";
        /*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = encodeUrl;
        var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
        var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
        var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';
        function encodeUrl(url) {
            return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
        }
    },
    "../../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js" (module) {
        "use strict";
        var $defineProperty = Object.defineProperty || false;
        if ($defineProperty) try {
            $defineProperty({}, 'a', {
                value: 1
            });
        } catch (e) {
            $defineProperty = false;
        }
        module.exports = $defineProperty;
    },
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js" (module) {
        "use strict";
        module.exports = EvalError;
    },
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js" (module) {
        "use strict";
        module.exports = Error;
    },
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js" (module) {
        "use strict";
        module.exports = RangeError;
    },
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js" (module) {
        "use strict";
        module.exports = ReferenceError;
    },
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js" (module) {
        "use strict";
        module.exports = SyntaxError;
    },
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js" (module) {
        "use strict";
        module.exports = TypeError;
    },
    "../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js" (module) {
        "use strict";
        module.exports = URIError;
    },
    "../../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js" (module) {
        "use strict";
        module.exports = Object;
    },
    "../../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
        var hasToStringTag = __webpack_require__("../../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js")();
        var hasOwn = __webpack_require__("../../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
        var $TypeError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
        module.exports = function(object, value) {
            var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
            var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
            if (void 0 !== overrideIfSet && 'boolean' != typeof overrideIfSet || void 0 !== nonConfigurable && 'boolean' != typeof nonConfigurable) throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
            if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) if ($defineProperty) $defineProperty(object, toStringTag, {
                configurable: !nonConfigurable,
                enumerable: false,
                value: value,
                writable: false
            });
            else object[toStringTag] = value;
        };
    },
    "../../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js" (module) {
        "use strict";
        /*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ var matchHtmlRegExp = /["'&<>]/;
        module.exports = escapeHtml;
        function escapeHtml(string) {
            var str = '' + string;
            var match = matchHtmlRegExp.exec(str);
            if (!match) return str;
            var escape1;
            var html = '';
            var index = 0;
            var lastIndex = 0;
            for(index = match.index; index < str.length; index++){
                switch(str.charCodeAt(index)){
                    case 34:
                        escape1 = '&quot;';
                        break;
                    case 38:
                        escape1 = '&amp;';
                        break;
                    case 39:
                        escape1 = '&#39;';
                        break;
                    case 60:
                        escape1 = '&lt;';
                        break;
                    case 62:
                        escape1 = '&gt;';
                        break;
                    default:
                        continue;
                }
                if (lastIndex !== index) html += str.substring(lastIndex, index);
                lastIndex = index + 1;
                html += escape1;
            }
            return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
    },
    "../../../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = etag;
        var crypto = __webpack_require__("crypto");
        var Stats = __webpack_require__("fs").Stats;
        var toString = Object.prototype.toString;
        function entitytag(entity) {
            if (0 === entity.length) return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
            var hash = crypto.createHash('sha1').update(entity, 'utf8').digest('base64').substring(0, 27);
            var len = 'string' == typeof entity ? Buffer.byteLength(entity, 'utf8') : entity.length;
            return '"' + len.toString(16) + '-' + hash + '"';
        }
        function etag(entity, options) {
            if (null == entity) throw new TypeError('argument entity is required');
            var isStats = isstats(entity);
            var weak = options && 'boolean' == typeof options.weak ? options.weak : isStats;
            if (!isStats && 'string' != typeof entity && !Buffer.isBuffer(entity)) throw new TypeError('argument entity must be string, Buffer, or fs.Stats');
            var tag = isStats ? stattag(entity) : entitytag(entity);
            return weak ? 'W/' + tag : tag;
        }
        function isstats(obj) {
            if ('function' == typeof Stats && obj instanceof Stats) return true;
            return obj && 'object' == typeof obj && 'ctime' in obj && '[object Date]' === toString.call(obj.ctime) && 'mtime' in obj && '[object Date]' === toString.call(obj.mtime) && 'ino' in obj && 'number' == typeof obj.ino && 'size' in obj && 'number' == typeof obj.size;
        }
        function stattag(stat) {
            var mtime = stat.mtime.getTime().toString(16);
            var size = stat.size.toString(16);
            return '"' + size + '-' + mtime + '"';
        }
    },
    "../../../node_modules/.pnpm/express@5.2.1/node_modules/express/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/express.js");
    },
    "../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/application.js" (module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var finalhandler = __webpack_require__("../../../node_modules/.pnpm/finalhandler@2.1.0/node_modules/finalhandler/index.js");
        var debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js")('express:application');
        var View = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/view.js");
        var http = __webpack_require__("node:http");
        var methods = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/utils.js").methods;
        var compileETag = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/utils.js").compileETag;
        var compileQueryParser = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/utils.js").compileQueryParser;
        var compileTrust = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/utils.js").compileTrust;
        var resolve = __webpack_require__("node:path").resolve;
        var once = __webpack_require__("../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js");
        var Router = __webpack_require__("../../../node_modules/.pnpm/router@2.2.0/node_modules/router/index.js");
        var slice = Array.prototype.slice;
        var flatten = Array.prototype.flat;
        var app = module.exports = {};
        var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';
        app.init = function() {
            var router = null;
            this.cache = Object.create(null);
            this.engines = Object.create(null);
            this.settings = Object.create(null);
            this.defaultConfiguration();
            Object.defineProperty(this, 'router', {
                configurable: true,
                enumerable: true,
                get: function() {
                    if (null === router) router = new Router({
                        caseSensitive: this.enabled('case sensitive routing'),
                        strict: this.enabled('strict routing')
                    });
                    return router;
                }
            });
        };
        app.defaultConfiguration = function() {
            var env = process.env.NODE_ENV || 'development';
            this.enable('x-powered-by');
            this.set('etag', 'weak');
            this.set('env', env);
            this.set('query parser', 'simple');
            this.set('subdomain offset', 2);
            this.set('trust proxy', false);
            Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                configurable: true,
                value: true
            });
            debug('booting in %s mode', env);
            this.on('mount', function(parent) {
                if (true === this.settings[trustProxyDefaultSymbol] && 'function' == typeof parent.settings['trust proxy fn']) {
                    delete this.settings['trust proxy'];
                    delete this.settings['trust proxy fn'];
                }
                Object.setPrototypeOf(this.request, parent.request);
                Object.setPrototypeOf(this.response, parent.response);
                Object.setPrototypeOf(this.engines, parent.engines);
                Object.setPrototypeOf(this.settings, parent.settings);
            });
            this.locals = Object.create(null);
            this.mountpath = '/';
            this.locals.settings = this.settings;
            this.set('view', View);
            this.set('views', resolve('views'));
            this.set('jsonp callback name', 'callback');
            if ('production' === env) this.enable('view cache');
        };
        app.handle = function(req, res, callback) {
            var done = callback || finalhandler(req, res, {
                env: this.get('env'),
                onerror: logerror.bind(this)
            });
            if (this.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
            req.res = res;
            res.req = req;
            Object.setPrototypeOf(req, this.request);
            Object.setPrototypeOf(res, this.response);
            if (!res.locals) res.locals = Object.create(null);
            this.router.handle(req, res, done);
        };
        app.use = function(fn) {
            var offset = 0;
            var path = '/';
            if ('function' != typeof fn) {
                var arg = fn;
                while(Array.isArray(arg) && 0 !== arg.length)arg = arg[0];
                if ('function' != typeof arg) {
                    offset = 1;
                    path = fn;
                }
            }
            var fns = flatten.call(slice.call(arguments, offset), 1 / 0);
            if (0 === fns.length) throw new TypeError('app.use() requires a middleware function');
            var router = this.router;
            fns.forEach(function(fn) {
                if (!fn || !fn.handle || !fn.set) return router.use(path, fn);
                debug('.use app under %s', path);
                fn.mountpath = path;
                fn.parent = this;
                router.use(path, function(req, res, next) {
                    var orig = req.app;
                    fn.handle(req, res, function(err) {
                        Object.setPrototypeOf(req, orig.request);
                        Object.setPrototypeOf(res, orig.response);
                        next(err);
                    });
                });
                fn.emit('mount', this);
            }, this);
            return this;
        };
        app.route = function(path) {
            return this.router.route(path);
        };
        app.engine = function(ext, fn) {
            if ('function' != typeof fn) throw new Error('callback function required');
            var extension = '.' !== ext[0] ? '.' + ext : ext;
            this.engines[extension] = fn;
            return this;
        };
        app.param = function(name, fn) {
            if (Array.isArray(name)) {
                for(var i = 0; i < name.length; i++)this.param(name[i], fn);
                return this;
            }
            this.router.param(name, fn);
            return this;
        };
        app.set = function(setting, val) {
            if (1 === arguments.length) return this.settings[setting];
            debug('set "%s" to %o', setting, val);
            this.settings[setting] = val;
            switch(setting){
                case 'etag':
                    this.set('etag fn', compileETag(val));
                    break;
                case 'query parser':
                    this.set('query parser fn', compileQueryParser(val));
                    break;
                case 'trust proxy':
                    this.set('trust proxy fn', compileTrust(val));
                    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                        configurable: true,
                        value: false
                    });
                    break;
            }
            return this;
        };
        app.path = function() {
            return this.parent ? this.parent.path() + this.mountpath : '';
        };
        app.enabled = function(setting) {
            return Boolean(this.set(setting));
        };
        app.disabled = function(setting) {
            return !this.set(setting);
        };
        app.enable = function(setting) {
            return this.set(setting, true);
        };
        app.disable = function(setting) {
            return this.set(setting, false);
        };
        methods.forEach(function(method) {
            app[method] = function(path) {
                if ('get' === method && 1 === arguments.length) return this.set(path);
                var route = this.route(path);
                route[method].apply(route, slice.call(arguments, 1));
                return this;
            };
        });
        app.all = function(path) {
            var route = this.route(path);
            var args = slice.call(arguments, 1);
            for(var i = 0; i < methods.length; i++)route[methods[i]].apply(route, args);
            return this;
        };
        app.render = function(name, options, callback) {
            var cache = this.cache;
            var done = callback;
            var engines = this.engines;
            var opts = options;
            var view;
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            var renderOptions = {
                ...this.locals,
                ...opts._locals,
                ...opts
            };
            if (null == renderOptions.cache) renderOptions.cache = this.enabled('view cache');
            if (renderOptions.cache) view = cache[name];
            if (!view) {
                var View = this.get('view');
                view = new View(name, {
                    defaultEngine: this.get('view engine'),
                    root: this.get('views'),
                    engines: engines
                });
                if (!view.path) {
                    var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
                    var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
                    err.view = view;
                    return done(err);
                }
                if (renderOptions.cache) cache[name] = view;
            }
            tryRender(view, renderOptions, done);
        };
        app.listen = function() {
            var server = http.createServer(this);
            var args = slice.call(arguments);
            if ('function' == typeof args[args.length - 1]) {
                var done = args[args.length - 1] = once(args[args.length - 1]);
                server.once('error', done);
            }
            return server.listen.apply(server, args);
        };
        function logerror(err) {
            if ('test' !== this.get('env')) console.error(err.stack || err.toString());
        }
        function tryRender(view, options, callback) {
            try {
                view.render(options, callback);
            } catch (err) {
                callback(err);
            }
        }
    },
    "../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/express.js" (module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bodyParser = __webpack_require__("../../../node_modules/.pnpm/body-parser@2.2.2/node_modules/body-parser/index.js");
        var EventEmitter = __webpack_require__("node:events").EventEmitter;
        var mixin = __webpack_require__("../../../node_modules/.pnpm/merge-descriptors@2.0.0/node_modules/merge-descriptors/index.js");
        var proto = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/application.js");
        var Router = __webpack_require__("../../../node_modules/.pnpm/router@2.2.0/node_modules/router/index.js");
        var req = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/request.js");
        var res = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/response.js");
        exports1 = module.exports = createApplication;
        function createApplication() {
            var app = function(req, res, next) {
                app.handle(req, res, next);
            };
            mixin(app, EventEmitter.prototype, false);
            mixin(app, proto, false);
            app.request = Object.create(req, {
                app: {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: app
                }
            });
            app.response = Object.create(res, {
                app: {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: app
                }
            });
            app.init();
            return app;
        }
        exports1.application = proto;
        exports1.request = req;
        exports1.response = res;
        exports1.Route = Router.Route;
        exports1.Router = Router;
        exports1.json = bodyParser.json;
        exports1.raw = bodyParser.raw;
        exports1["static"] = __webpack_require__("../../../node_modules/.pnpm/serve-static@2.2.0/node_modules/serve-static/index.js");
        exports1.text = bodyParser.text;
        exports1.urlencoded = bodyParser.urlencoded;
    },
    "../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/request.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var accepts = __webpack_require__("../../../node_modules/.pnpm/accepts@2.0.0/node_modules/accepts/index.js");
        var isIP = __webpack_require__("node:net").isIP;
        var typeis = __webpack_require__("../../../node_modules/.pnpm/type-is@2.0.1/node_modules/type-is/index.js");
        var http = __webpack_require__("node:http");
        var fresh = __webpack_require__("../../../node_modules/.pnpm/fresh@2.0.0/node_modules/fresh/index.js");
        var parseRange = __webpack_require__("../../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js");
        var parse = __webpack_require__("../../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var proxyaddr = __webpack_require__("../../../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js");
        var req = Object.create(http.IncomingMessage.prototype);
        module.exports = req;
        req.get = req.header = function(name) {
            if (!name) throw new TypeError('name argument is required to req.get');
            if ('string' != typeof name) throw new TypeError('name must be a string to req.get');
            var lc = name.toLowerCase();
            switch(lc){
                case 'referer':
                case 'referrer':
                    return this.headers.referrer || this.headers.referer;
                default:
                    return this.headers[lc];
            }
        };
        req.accepts = function() {
            var accept = accepts(this);
            return accept.types.apply(accept, arguments);
        };
        req.acceptsEncodings = function() {
            var accept = accepts(this);
            return accept.encodings.apply(accept, arguments);
        };
        req.acceptsCharsets = function() {
            var accept = accepts(this);
            return accept.charsets.apply(accept, arguments);
        };
        req.acceptsLanguages = function(...languages) {
            return accepts(this).languages(...languages);
        };
        req.range = function(size, options) {
            var range = this.get('Range');
            if (!range) return;
            return parseRange(size, range, options);
        };
        defineGetter(req, 'query', function() {
            var queryparse = this.app.get('query parser fn');
            if (!queryparse) return Object.create(null);
            var querystring = parse(this).query;
            return queryparse(querystring);
        });
        req.is = function(types) {
            var arr = types;
            if (!Array.isArray(types)) {
                arr = new Array(arguments.length);
                for(var i = 0; i < arr.length; i++)arr[i] = arguments[i];
            }
            return typeis(this, arr);
        };
        defineGetter(req, 'protocol', function() {
            var proto = this.socket.encrypted ? 'https' : 'http';
            var trust = this.app.get('trust proxy fn');
            if (!trust(this.socket.remoteAddress, 0)) return proto;
            var header = this.get('X-Forwarded-Proto') || proto;
            var index = header.indexOf(',');
            return -1 !== index ? header.substring(0, index).trim() : header.trim();
        });
        defineGetter(req, 'secure', function() {
            return 'https' === this.protocol;
        });
        defineGetter(req, 'ip', function() {
            var trust = this.app.get('trust proxy fn');
            return proxyaddr(this, trust);
        });
        defineGetter(req, 'ips', function() {
            var trust = this.app.get('trust proxy fn');
            var addrs = proxyaddr.all(this, trust);
            addrs.reverse().pop();
            return addrs;
        });
        defineGetter(req, 'subdomains', function() {
            var hostname = this.hostname;
            if (!hostname) return [];
            var offset = this.app.get('subdomain offset');
            var subdomains = isIP(hostname) ? [
                hostname
            ] : hostname.split('.').reverse();
            return subdomains.slice(offset);
        });
        defineGetter(req, 'path', function() {
            return parse(this).pathname;
        });
        defineGetter(req, 'host', function() {
            var trust = this.app.get('trust proxy fn');
            var val = this.get('X-Forwarded-Host');
            if (val && trust(this.socket.remoteAddress, 0)) {
                if (-1 !== val.indexOf(',')) val = val.substring(0, val.indexOf(',')).trimRight();
            } else val = this.get('Host');
            return val || void 0;
        });
        defineGetter(req, 'hostname', function() {
            var host = this.host;
            if (!host) return;
            var offset = '[' === host[0] ? host.indexOf(']') + 1 : 0;
            var index = host.indexOf(':', offset);
            return -1 !== index ? host.substring(0, index) : host;
        });
        defineGetter(req, 'fresh', function() {
            var method = this.method;
            var res = this.res;
            var status = res.statusCode;
            if ('GET' !== method && 'HEAD' !== method) return false;
            if (status >= 200 && status < 300 || 304 === status) return fresh(this.headers, {
                etag: res.get('ETag'),
                'last-modified': res.get('Last-Modified')
            });
            return false;
        });
        defineGetter(req, 'stale', function() {
            return !this.fresh;
        });
        defineGetter(req, 'xhr', function() {
            var val = this.get('X-Requested-With') || '';
            return 'xmlhttprequest' === val.toLowerCase();
        });
        function defineGetter(obj, name, getter) {
            Object.defineProperty(obj, name, {
                configurable: true,
                enumerable: true,
                get: getter
            });
        }
    },
    "../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/response.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var contentDisposition = __webpack_require__("../../../node_modules/.pnpm/content-disposition@1.0.0/node_modules/content-disposition/index.js");
        var createError = __webpack_require__("../../../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var deprecate = __webpack_require__("../../../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var encodeUrl = __webpack_require__("../../../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var http = __webpack_require__("node:http");
        var onFinished = __webpack_require__("../../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var mime = __webpack_require__("../../../node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/index.js");
        var path = __webpack_require__("node:path");
        var pathIsAbsolute = __webpack_require__("node:path").isAbsolute;
        var statuses = __webpack_require__("../../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var sign = __webpack_require__("../../../node_modules/.pnpm/cookie-signature@1.2.2/node_modules/cookie-signature/index.js").sign;
        var normalizeType = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/utils.js").normalizeType;
        var normalizeTypes = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/utils.js").normalizeTypes;
        var setCharset = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/utils.js").setCharset;
        var cookie = __webpack_require__("../../../node_modules/.pnpm/cookie@0.7.2/node_modules/cookie/index.js");
        var send = __webpack_require__("../../../node_modules/.pnpm/send@1.2.0/node_modules/send/index.js");
        var extname = path.extname;
        var resolve = path.resolve;
        var vary = __webpack_require__("../../../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js");
        const { Buffer: Buffer1 } = __webpack_require__("node:buffer");
        var res = Object.create(http.ServerResponse.prototype);
        module.exports = res;
        res.status = function(code) {
            if (!Number.isInteger(code)) throw new TypeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be an integer.`);
            if (code < 100 || code > 999) throw new RangeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be greater than 99 and less than 1000.`);
            this.statusCode = code;
            return this;
        };
        res.links = function(links) {
            var link = this.get('Link') || '';
            if (link) link += ', ';
            return this.set('Link', link + Object.keys(links).map(function(rel) {
                if (Array.isArray(links[rel])) return links[rel].map(function(singleLink) {
                    return `<${singleLink}>; rel="${rel}"`;
                }).join(', ');
                return `<${links[rel]}>; rel="${rel}"`;
            }).join(', '));
        };
        res.send = function(body) {
            var chunk = body;
            var encoding;
            var req = this.req;
            var type;
            var app = this.app;
            switch(typeof chunk){
                case 'string':
                    if (!this.get('Content-Type')) this.type('html');
                    break;
                case 'boolean':
                case 'number':
                case 'object':
                    if (null === chunk) chunk = '';
                    else if (!ArrayBuffer.isView(chunk)) return this.json(chunk);
                    else if (!this.get('Content-Type')) this.type('bin');
                    break;
            }
            if ('string' == typeof chunk) {
                encoding = 'utf8';
                type = this.get('Content-Type');
                if ('string' == typeof type) this.set('Content-Type', setCharset(type, 'utf-8'));
            }
            var etagFn = app.get('etag fn');
            var generateETag = !this.get('ETag') && 'function' == typeof etagFn;
            var len;
            if (void 0 !== chunk) {
                if (Buffer1.isBuffer(chunk)) len = chunk.length;
                else if (!generateETag && chunk.length < 1000) len = Buffer1.byteLength(chunk, encoding);
                else {
                    chunk = Buffer1.from(chunk, encoding);
                    encoding = void 0;
                    len = chunk.length;
                }
                this.set('Content-Length', len);
            }
            var etag;
            if (generateETag && void 0 !== len) {
                if (etag = etagFn(chunk, encoding)) this.set('ETag', etag);
            }
            if (req.fresh) this.status(304);
            if (204 === this.statusCode || 304 === this.statusCode) {
                this.removeHeader('Content-Type');
                this.removeHeader('Content-Length');
                this.removeHeader('Transfer-Encoding');
                chunk = '';
            }
            if (205 === this.statusCode) {
                this.set('Content-Length', '0');
                this.removeHeader('Transfer-Encoding');
                chunk = '';
            }
            if ('HEAD' === req.method) this.end();
            else this.end(chunk, encoding);
            return this;
        };
        res.json = function(obj) {
            var app = this.app;
            var escape1 = app.get('json escape');
            var replacer = app.get('json replacer');
            var spaces = app.get('json spaces');
            var body = stringify(obj, replacer, spaces, escape1);
            if (!this.get('Content-Type')) this.set('Content-Type', 'application/json');
            return this.send(body);
        };
        res.jsonp = function(obj) {
            var app = this.app;
            var escape1 = app.get('json escape');
            var replacer = app.get('json replacer');
            var spaces = app.get('json spaces');
            var body = stringify(obj, replacer, spaces, escape1);
            var callback = this.req.query[app.get('jsonp callback name')];
            if (!this.get('Content-Type')) {
                this.set('X-Content-Type-Options', 'nosniff');
                this.set('Content-Type', 'application/json');
            }
            if (Array.isArray(callback)) callback = callback[0];
            if ('string' == typeof callback && 0 !== callback.length) {
                this.set('X-Content-Type-Options', 'nosniff');
                this.set('Content-Type', "text/javascript");
                callback = callback.replace(/[^\[\]\w$.]/g, '');
                if (void 0 === body) body = '';
                else if ('string' == typeof body) body = body.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
                body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
            }
            return this.send(body);
        };
        res.sendStatus = function(statusCode) {
            var body = statuses.message[statusCode] || String(statusCode);
            this.status(statusCode);
            this.type('txt');
            return this.send(body);
        };
        res.sendFile = function(path, options, callback) {
            var done = callback;
            var req = this.req;
            var res = this;
            var next = req.next;
            var opts = options || {};
            if (!path) throw new TypeError('path argument is required to res.sendFile');
            if ('string' != typeof path) throw new TypeError('path must be a string to res.sendFile');
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            if (!opts.root && !pathIsAbsolute(path)) throw new TypeError('path must be absolute or specify root to res.sendFile');
            var pathname = encodeURI(path);
            opts.etag = this.app.enabled('etag');
            var file = send(req, pathname, opts);
            sendfile(res, file, opts, function(err) {
                if (done) return done(err);
                if (err && 'EISDIR' === err.code) return next();
                if (err && 'ECONNABORTED' !== err.code && 'write' !== err.syscall) next(err);
            });
        };
        res.download = function(path, filename, options, callback) {
            var done = callback;
            var name = filename;
            var opts = options || null;
            if ('function' == typeof filename) {
                done = filename;
                name = null;
                opts = null;
            } else if ('function' == typeof options) {
                done = options;
                opts = null;
            }
            if ('object' == typeof filename && ('function' == typeof options || void 0 === options)) {
                name = null;
                opts = filename;
            }
            var headers = {
                'Content-Disposition': contentDisposition(name || path)
            };
            if (opts && opts.headers) {
                var keys = Object.keys(opts.headers);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if ('content-disposition' !== key.toLowerCase()) headers[key] = opts.headers[key];
                }
            }
            opts = Object.create(opts);
            opts.headers = headers;
            var fullPath = opts.root ? path : resolve(path);
            return this.sendFile(fullPath, opts, done);
        };
        res.contentType = res.type = function(type) {
            var ct = -1 === type.indexOf('/') ? mime.contentType(type) || 'application/octet-stream' : type;
            return this.set('Content-Type', ct);
        };
        res.format = function(obj) {
            var req = this.req;
            var next = req.next;
            var keys = Object.keys(obj).filter(function(v) {
                return 'default' !== v;
            });
            var key = keys.length > 0 ? req.accepts(keys) : false;
            this.vary("Accept");
            if (key) {
                this.set('Content-Type', normalizeType(key).value);
                obj[key](req, this, next);
            } else if (obj.default) obj.default(req, this, next);
            else next(createError(406, {
                types: normalizeTypes(keys).map(function(o) {
                    return o.value;
                })
            }));
            return this;
        };
        res.attachment = function(filename) {
            if (filename) this.type(extname(filename));
            this.set('Content-Disposition', contentDisposition(filename));
            return this;
        };
        res.append = function(field, val) {
            var prev = this.get(field);
            var value = val;
            if (prev) value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [
                prev
            ].concat(val) : [
                prev,
                val
            ];
            return this.set(field, value);
        };
        res.set = res.header = function(field, val) {
            if (2 === arguments.length) {
                var value = Array.isArray(val) ? val.map(String) : String(val);
                if ('content-type' === field.toLowerCase()) {
                    if (Array.isArray(value)) throw new TypeError('Content-Type cannot be set to an Array');
                    value = mime.contentType(value);
                }
                this.setHeader(field, value);
            } else for(var key in field)this.set(key, field[key]);
            return this;
        };
        res.get = function(field) {
            return this.getHeader(field);
        };
        res.clearCookie = function(name, options) {
            const opts = {
                path: '/',
                ...options,
                expires: new Date(1)
            };
            delete opts.maxAge;
            return this.cookie(name, '', opts);
        };
        res.cookie = function(name, value, options) {
            var opts = {
                ...options
            };
            var secret = this.req.secret;
            var signed = opts.signed;
            if (signed && !secret) throw new Error('cookieParser("secret") required for signed cookies');
            var val = 'object' == typeof value ? 'j:' + JSON.stringify(value) : String(value);
            if (signed) val = 's:' + sign(val, secret);
            if (null != opts.maxAge) {
                var maxAge = opts.maxAge - 0;
                if (!isNaN(maxAge)) {
                    opts.expires = new Date(Date.now() + maxAge);
                    opts.maxAge = Math.floor(maxAge / 1000);
                }
            }
            if (null == opts.path) opts.path = '/';
            this.append('Set-Cookie', cookie.serialize(name, String(val), opts));
            return this;
        };
        res.location = function(url) {
            return this.set('Location', encodeUrl(url));
        };
        res.redirect = function(url) {
            var address = url;
            var body;
            var status = 302;
            if (2 === arguments.length) {
                status = arguments[0];
                address = arguments[1];
            }
            if (!address) deprecate('Provide a url argument');
            if ('string' != typeof address) deprecate('Url must be a string');
            if ('number' != typeof status) deprecate('Status must be a number');
            address = this.location(address).get('Location');
            this.format({
                text: function() {
                    body = statuses.message[status] + '. Redirecting to ' + address;
                },
                html: function() {
                    var u = escapeHtml(address);
                    body = '<p>' + statuses.message[status] + '. Redirecting to ' + u + '</p>';
                },
                default: function() {
                    body = '';
                }
            });
            this.status(status);
            this.set('Content-Length', Buffer1.byteLength(body));
            if ('HEAD' === this.req.method) this.end();
            else this.end(body);
        };
        res.vary = function(field) {
            vary(this, field);
            return this;
        };
        res.render = function(view, options, callback) {
            var app = this.req.app;
            var done = callback;
            var opts = options || {};
            var req = this.req;
            var self1 = this;
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            opts._locals = self1.locals;
            done = done || function(err, str) {
                if (err) return req.next(err);
                self1.send(str);
            };
            app.render(view, opts, done);
        };
        function sendfile(res, file, options, callback) {
            var done = false;
            var streaming;
            function onaborted() {
                if (done) return;
                done = true;
                var err = new Error('Request aborted');
                err.code = 'ECONNABORTED';
                callback(err);
            }
            function ondirectory() {
                if (done) return;
                done = true;
                var err = new Error('EISDIR, read');
                err.code = 'EISDIR';
                callback(err);
            }
            function onerror(err) {
                if (done) return;
                done = true;
                callback(err);
            }
            function onend() {
                if (done) return;
                done = true;
                callback();
            }
            function onfile() {
                streaming = false;
            }
            function onfinish(err) {
                if (err && 'ECONNRESET' === err.code) return onaborted();
                if (err) return onerror(err);
                if (done) return;
                setImmediate(function() {
                    if (false !== streaming && !done) return void onaborted();
                    if (done) return;
                    done = true;
                    callback();
                });
            }
            function onstream() {
                streaming = true;
            }
            file.on('directory', ondirectory);
            file.on('end', onend);
            file.on('error', onerror);
            file.on('file', onfile);
            file.on('stream', onstream);
            onFinished(res, onfinish);
            if (options.headers) file.on('headers', function(res) {
                var obj = options.headers;
                var keys = Object.keys(obj);
                for(var i = 0; i < keys.length; i++){
                    var k = keys[i];
                    res.setHeader(k, obj[k]);
                }
            });
            file.pipe(res);
        }
        function stringify(value, replacer, spaces, escape1) {
            var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
            if (escape1 && 'string' == typeof json) json = json.replace(/[<>&]/g, function(c) {
                switch(c.charCodeAt(0)){
                    case 0x3c:
                        return '\\u003c';
                    case 0x3e:
                        return '\\u003e';
                    case 0x26:
                        return '\\u0026';
                    default:
                        return c;
                }
            });
            return json;
        }
    },
    "../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/utils.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var { METHODS } = __webpack_require__("node:http");
        var contentType = __webpack_require__("../../../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var etag = __webpack_require__("../../../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js");
        var mime = __webpack_require__("../../../node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/index.js");
        var proxyaddr = __webpack_require__("../../../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js");
        var qs = __webpack_require__("../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/index.js");
        var querystring = __webpack_require__("node:querystring");
        const { Buffer: Buffer1 } = __webpack_require__("node:buffer");
        exports1.methods = METHODS.map((method)=>method.toLowerCase());
        exports1.etag = createETagGenerator({
            weak: false
        });
        exports1.wetag = createETagGenerator({
            weak: true
        });
        exports1.normalizeType = function(type) {
            return ~type.indexOf('/') ? acceptParams(type) : {
                value: mime.lookup(type) || 'application/octet-stream',
                params: {}
            };
        };
        exports1.normalizeTypes = function(types) {
            return types.map(exports1.normalizeType);
        };
        function acceptParams(str) {
            var length = str.length;
            var colonIndex = str.indexOf(';');
            var index = -1 === colonIndex ? length : colonIndex;
            var ret = {
                value: str.slice(0, index).trim(),
                quality: 1,
                params: {}
            };
            while(index < length){
                var splitIndex = str.indexOf('=', index);
                if (-1 === splitIndex) break;
                var colonIndex = str.indexOf(';', index);
                var endIndex = -1 === colonIndex ? length : colonIndex;
                if (splitIndex > endIndex) {
                    index = str.lastIndexOf(';', splitIndex - 1) + 1;
                    continue;
                }
                var key = str.slice(index, splitIndex).trim();
                var value = str.slice(splitIndex + 1, endIndex).trim();
                if ('q' === key) ret.quality = parseFloat(value);
                else ret.params[key] = value;
                index = endIndex + 1;
            }
            return ret;
        }
        exports1.compileETag = function(val) {
            var fn;
            if ('function' == typeof val) return val;
            switch(val){
                case true:
                case 'weak':
                    fn = exports1.wetag;
                    break;
                case false:
                    break;
                case 'strong':
                    fn = exports1.etag;
                    break;
                default:
                    throw new TypeError('unknown value for etag function: ' + val);
            }
            return fn;
        };
        exports1.compileQueryParser = function(val) {
            var fn;
            if ('function' == typeof val) return val;
            switch(val){
                case true:
                case 'simple':
                    fn = querystring.parse;
                    break;
                case false:
                    break;
                case 'extended':
                    fn = parseExtendedQueryString;
                    break;
                default:
                    throw new TypeError('unknown value for query parser function: ' + val);
            }
            return fn;
        };
        exports1.compileTrust = function(val) {
            if ('function' == typeof val) return val;
            if (true === val) return function() {
                return true;
            };
            if ('number' == typeof val) return function(a, i) {
                return i < val;
            };
            if ('string' == typeof val) val = val.split(',').map(function(v) {
                return v.trim();
            });
            return proxyaddr.compile(val || []);
        };
        exports1.setCharset = function(type, charset) {
            if (!type || !charset) return type;
            var parsed = contentType.parse(type);
            parsed.parameters.charset = charset;
            return contentType.format(parsed);
        };
        function createETagGenerator(options) {
            return function(body, encoding) {
                var buf = Buffer1.isBuffer(body) ? body : Buffer1.from(body, encoding);
                return etag(buf, options);
            };
        }
        function parseExtendedQueryString(str) {
            return qs.parse(str, {
                allowPrototypes: true
            });
        }
    },
    "../../../node_modules/.pnpm/express@5.2.1/node_modules/express/lib/view.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js")('express:view');
        var path = __webpack_require__("node:path");
        var fs = __webpack_require__("node:fs");
        var dirname = path.dirname;
        var basename = path.basename;
        var extname = path.extname;
        var join = path.join;
        var resolve = path.resolve;
        module.exports = View;
        function View(name, options) {
            var opts = options || {};
            this.defaultEngine = opts.defaultEngine;
            this.ext = extname(name);
            this.name = name;
            this.root = opts.root;
            if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');
            var fileName = name;
            if (!this.ext) {
                this.ext = '.' !== this.defaultEngine[0] ? '.' + this.defaultEngine : this.defaultEngine;
                fileName += this.ext;
            }
            if (!opts.engines[this.ext]) {
                var mod = this.ext.slice(1);
                debug('require "%s"', mod);
                var fn = require(mod).__express;
                if ('function' != typeof fn) throw new Error('Module "' + mod + '" does not provide a view engine.');
                opts.engines[this.ext] = fn;
            }
            this.engine = opts.engines[this.ext];
            this.path = this.lookup(fileName);
        }
        View.prototype.lookup = function(name) {
            var path;
            var roots = [].concat(this.root);
            debug('lookup "%s"', name);
            for(var i = 0; i < roots.length && !path; i++){
                var root = roots[i];
                var loc = resolve(root, name);
                var dir = dirname(loc);
                var file = basename(loc);
                path = this.resolve(dir, file);
            }
            return path;
        };
        View.prototype.render = function(options, callback) {
            var sync = true;
            debug('render "%s"', this.path);
            this.engine(this.path, options, function() {
                if (!sync) return callback.apply(this, arguments);
                var args = new Array(arguments.length);
                var cntx = this;
                for(var i = 0; i < arguments.length; i++)args[i] = arguments[i];
                return process.nextTick(function() {
                    return callback.apply(cntx, args);
                });
            });
            sync = false;
        };
        View.prototype.resolve = function(dir, file) {
            var ext = this.ext;
            var path = join(dir, file);
            var stat = tryStat(path);
            if (stat && stat.isFile()) return path;
            path = join(dir, basename(file, ext), 'index' + ext);
            stat = tryStat(path);
            if (stat && stat.isFile()) return path;
        };
        function tryStat(path) {
            debug('stat "%s"', path);
            try {
                return fs.statSync(path);
            } catch (e) {
                return;
            }
        }
    },
    "../../../node_modules/.pnpm/finalhandler@2.1.0/node_modules/finalhandler/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js")('finalhandler');
        var encodeUrl = __webpack_require__("../../../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var onFinished = __webpack_require__("../../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var parseUrl = __webpack_require__("../../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var statuses = __webpack_require__("../../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var isFinished = onFinished.isFinished;
        function createHtmlDocument(message) {
            var body = escapeHtml(message).replaceAll('\n', '<br>').replaceAll('  ', ' &nbsp;');
            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
        }
        module.exports = finalhandler;
        function finalhandler(req, res, options) {
            var opts = options || {};
            var env = opts.env || process.env.NODE_ENV || 'development';
            var onerror = opts.onerror;
            return function(err) {
                var headers;
                var msg;
                var status;
                if (!err && res.headersSent) return void debug('cannot 404 after headers sent');
                if (err) {
                    status = getErrorStatusCode(err);
                    if (void 0 === status) status = getResponseStatusCode(res);
                    else headers = getErrorHeaders(err);
                    msg = getErrorMessage(err, status, env);
                } else {
                    status = 404;
                    msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req));
                }
                debug('default %s', status);
                if (err && onerror) setImmediate(onerror, err, req, res);
                if (res.headersSent) {
                    debug('cannot %d after headers sent', status);
                    if (req.socket) req.socket.destroy();
                    return;
                }
                send(req, res, status, headers, msg);
            };
        }
        function getErrorHeaders(err) {
            if (!err.headers || 'object' != typeof err.headers) return;
            return {
                ...err.headers
            };
        }
        function getErrorMessage(err, status, env) {
            var msg;
            if ('production' !== env) {
                msg = err.stack;
                if (!msg && 'function' == typeof err.toString) msg = err.toString();
            }
            return msg || statuses.message[status];
        }
        function getErrorStatusCode(err) {
            if ('number' == typeof err.status && err.status >= 400 && err.status < 600) return err.status;
            if ('number' == typeof err.statusCode && err.statusCode >= 400 && err.statusCode < 600) return err.statusCode;
        }
        function getResourceName(req) {
            try {
                return parseUrl.original(req).pathname;
            } catch (e) {
                return 'resource';
            }
        }
        function getResponseStatusCode(res) {
            var status = res.statusCode;
            if ('number' != typeof status || status < 400 || status > 599) status = 500;
            return status;
        }
        function send(req, res, status, headers, message) {
            function write() {
                var body = createHtmlDocument(message);
                res.statusCode = status;
                if (req.httpVersionMajor < 2) res.statusMessage = statuses.message[status];
                res.removeHeader('Content-Encoding');
                res.removeHeader('Content-Language');
                res.removeHeader('Content-Range');
                for (const [key, value] of Object.entries(headers ?? {}))res.setHeader(key, value);
                res.setHeader('Content-Security-Policy', "default-src 'none'");
                res.setHeader('X-Content-Type-Options', 'nosniff');
                res.setHeader('Content-Type', 'text/html; charset=utf-8');
                res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'));
                if ('HEAD' === req.method) return void res.end();
                res.end(body, 'utf8');
            }
            if (isFinished(req)) return void write();
            req.unpipe();
            onFinished(req, write);
            req.resume();
        }
    },
    "../../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/form_data.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var CombinedStream = __webpack_require__("../../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js");
        var util = __webpack_require__("util");
        var path = __webpack_require__("path");
        var http = __webpack_require__("http");
        var https = __webpack_require__("https");
        var parseUrl = __webpack_require__("url").parse;
        var fs = __webpack_require__("fs");
        var Stream = __webpack_require__("stream").Stream;
        var crypto = __webpack_require__("crypto");
        var mime = __webpack_require__("../../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js");
        var asynckit = __webpack_require__("../../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js");
        var setToStringTag = __webpack_require__("../../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js");
        var hasOwn = __webpack_require__("../../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
        var populate = __webpack_require__("../../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/populate.js");
        function FormData(options) {
            if (!(this instanceof FormData)) return new FormData(options);
            this._overheadLength = 0;
            this._valueLength = 0;
            this._valuesToMeasure = [];
            CombinedStream.call(this);
            options = options || {};
            for(var option in options)this[option] = options[option];
        }
        util.inherits(FormData, CombinedStream);
        FormData.LINE_BREAK = '\r\n';
        FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
        FormData.prototype.append = function(field, value, options) {
            options = options || {};
            if ('string' == typeof options) options = {
                filename: options
            };
            var append = CombinedStream.prototype.append.bind(this);
            if ('number' == typeof value || null == value) value = String(value);
            if (Array.isArray(value)) return void this._error(new Error('Arrays are not supported.'));
            var header = this._multiPartHeader(field, value, options);
            var footer = this._multiPartFooter();
            append(header);
            append(value);
            append(footer);
            this._trackLength(header, value, options);
        };
        FormData.prototype._trackLength = function(header, value, options) {
            var valueLength = 0;
            if (null != options.knownLength) valueLength += Number(options.knownLength);
            else if (Buffer.isBuffer(value)) valueLength = value.length;
            else if ('string' == typeof value) valueLength = Buffer.byteLength(value);
            this._valueLength += valueLength;
            this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
            if (!value || !value.path && !(value.readable && hasOwn(value, 'httpVersion')) && !(value instanceof Stream)) return;
            if (!options.knownLength) this._valuesToMeasure.push(value);
        };
        FormData.prototype._lengthRetriever = function(value, callback) {
            if (hasOwn(value, 'fd')) if (void 0 != value.end && value.end != 1 / 0 && void 0 != value.start) callback(null, value.end + 1 - (value.start ? value.start : 0));
            else fs.stat(value.path, function(err, stat) {
                if (err) return void callback(err);
                var fileSize = stat.size - (value.start ? value.start : 0);
                callback(null, fileSize);
            });
            else if (hasOwn(value, 'httpVersion')) callback(null, Number(value.headers['content-length']));
            else if (hasOwn(value, 'httpModule')) {
                value.on('response', function(response) {
                    value.pause();
                    callback(null, Number(response.headers['content-length']));
                });
                value.resume();
            } else callback('Unknown stream');
        };
        FormData.prototype._multiPartHeader = function(field, value, options) {
            if ('string' == typeof options.header) return options.header;
            var contentDisposition = this._getContentDisposition(value, options);
            var contentType = this._getContentType(value, options);
            var contents = '';
            var headers = {
                'Content-Disposition': [
                    'form-data',
                    'name="' + field + '"'
                ].concat(contentDisposition || []),
                'Content-Type': [].concat(contentType || [])
            };
            if ('object' == typeof options.header) populate(headers, options.header);
            var header;
            for(var prop in headers)if (hasOwn(headers, prop)) {
                header = headers[prop];
                if (null == header) continue;
                if (!Array.isArray(header)) header = [
                    header
                ];
                if (header.length) contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
            }
            return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
        };
        FormData.prototype._getContentDisposition = function(value, options) {
            var filename;
            if ('string' == typeof options.filepath) filename = path.normalize(options.filepath).replace(/\\/g, '/');
            else if (options.filename || value && (value.name || value.path)) filename = path.basename(options.filename || value && (value.name || value.path));
            else if (value && value.readable && hasOwn(value, 'httpVersion')) filename = path.basename(value.client._httpMessage.path || '');
            if (filename) return 'filename="' + filename + '"';
        };
        FormData.prototype._getContentType = function(value, options) {
            var contentType = options.contentType;
            if (!contentType && value && value.name) contentType = mime.lookup(value.name);
            if (!contentType && value && value.path) contentType = mime.lookup(value.path);
            if (!contentType && value && value.readable && hasOwn(value, 'httpVersion')) contentType = value.headers['content-type'];
            if (!contentType && (options.filepath || options.filename)) contentType = mime.lookup(options.filepath || options.filename);
            if (!contentType && value && 'object' == typeof value) contentType = FormData.DEFAULT_CONTENT_TYPE;
            return contentType;
        };
        FormData.prototype._multiPartFooter = function() {
            return (function(next) {
                var footer = FormData.LINE_BREAK;
                var lastPart = 0 === this._streams.length;
                if (lastPart) footer += this._lastBoundary();
                next(footer);
            }).bind(this);
        };
        FormData.prototype._lastBoundary = function() {
            return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
        };
        FormData.prototype.getHeaders = function(userHeaders) {
            var header;
            var formHeaders = {
                'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
            };
            for(header in userHeaders)if (hasOwn(userHeaders, header)) formHeaders[header.toLowerCase()] = userHeaders[header];
            return formHeaders;
        };
        FormData.prototype.setBoundary = function(boundary) {
            if ('string' != typeof boundary) throw new TypeError('FormData boundary must be a string');
            this._boundary = boundary;
        };
        FormData.prototype.getBoundary = function() {
            if (!this._boundary) this._generateBoundary();
            return this._boundary;
        };
        FormData.prototype.getBuffer = function() {
            var dataBuffer = new Buffer.alloc(0);
            var boundary = this.getBoundary();
            for(var i = 0, len = this._streams.length; i < len; i++)if ('function' != typeof this._streams[i]) {
                dataBuffer = Buffer.isBuffer(this._streams[i]) ? Buffer.concat([
                    dataBuffer,
                    this._streams[i]
                ]) : Buffer.concat([
                    dataBuffer,
                    Buffer.from(this._streams[i])
                ]);
                if ('string' != typeof this._streams[i] || this._streams[i].substring(2, boundary.length + 2) !== boundary) dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(FormData.LINE_BREAK)
                ]);
            }
            return Buffer.concat([
                dataBuffer,
                Buffer.from(this._lastBoundary())
            ]);
        };
        FormData.prototype._generateBoundary = function() {
            this._boundary = '--------------------------' + crypto.randomBytes(12).toString('hex');
        };
        FormData.prototype.getLengthSync = function() {
            var knownLength = this._overheadLength + this._valueLength;
            if (this._streams.length) knownLength += this._lastBoundary().length;
            if (!this.hasKnownLength()) this._error(new Error('Cannot calculate proper length in synchronous way.'));
            return knownLength;
        };
        FormData.prototype.hasKnownLength = function() {
            var hasKnownLength = true;
            if (this._valuesToMeasure.length) hasKnownLength = false;
            return hasKnownLength;
        };
        FormData.prototype.getLength = function(cb) {
            var knownLength = this._overheadLength + this._valueLength;
            if (this._streams.length) knownLength += this._lastBoundary().length;
            if (!this._valuesToMeasure.length) return void process.nextTick(cb.bind(this, null, knownLength));
            asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
                if (err) return void cb(err);
                values.forEach(function(length) {
                    knownLength += length;
                });
                cb(null, knownLength);
            });
        };
        FormData.prototype.submit = function(params, cb) {
            var request;
            var options;
            var defaults = {
                method: 'post'
            };
            if ('string' == typeof params) {
                params = parseUrl(params);
                options = populate({
                    port: params.port,
                    path: params.pathname,
                    host: params.hostname,
                    protocol: params.protocol
                }, defaults);
            } else {
                options = populate(params, defaults);
                if (!options.port) options.port = 'https:' === options.protocol ? 443 : 80;
            }
            options.headers = this.getHeaders(params.headers);
            request = 'https:' === options.protocol ? https.request(options) : http.request(options);
            this.getLength((function(err, length) {
                if (err && 'Unknown stream' !== err) return void this._error(err);
                if (length) request.setHeader('Content-Length', length);
                this.pipe(request);
                if (cb) {
                    var onResponse;
                    var callback = function(error, responce) {
                        request.removeListener('error', callback);
                        request.removeListener('response', onResponse);
                        return cb.call(this, error, responce);
                    };
                    onResponse = callback.bind(this, null);
                    request.on('error', callback);
                    request.on('response', onResponse);
                }
            }).bind(this));
            return request;
        };
        FormData.prototype._error = function(err) {
            if (!this.error) {
                this.error = err;
                this.pause();
                this.emit('error', err);
            }
        };
        FormData.prototype.toString = function() {
            return '[object FormData]';
        };
        setToStringTag(FormData, 'FormData');
        module.exports = FormData;
    },
    "../../../node_modules/.pnpm/form-data@4.0.4/node_modules/form-data/lib/populate.js" (module) {
        "use strict";
        module.exports = function(dst, src) {
            Object.keys(src).forEach(function(prop) {
                dst[prop] = dst[prop] || src[prop];
            });
            return dst;
        };
    },
    "../../../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js" (module) {
        "use strict";
        /*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = forwarded;
        function forwarded(req) {
            if (!req) throw new TypeError('argument req is required');
            var proxyAddrs = parse(req.headers['x-forwarded-for'] || '');
            var socketAddr = getSocketAddr(req);
            var addrs = [
                socketAddr
            ].concat(proxyAddrs);
            return addrs;
        }
        function getSocketAddr(req) {
            return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
        }
        function parse(header) {
            var end = header.length;
            var list = [];
            var start = header.length;
            for(var i = header.length - 1; i >= 0; i--)switch(header.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i;
                    break;
                case 0x2c:
                    if (start !== end) list.push(header.substring(start, end));
                    start = end = i;
                    break;
                default:
                    start = i;
                    break;
            }
            if (start !== end) list.push(header.substring(start, end));
            return list;
        }
    },
    "../../../node_modules/.pnpm/fresh@2.0.0/node_modules/fresh/index.js" (module) {
        "use strict";
        /*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
        module.exports = fresh;
        function fresh(reqHeaders, resHeaders) {
            var modifiedSince = reqHeaders['if-modified-since'];
            var noneMatch = reqHeaders['if-none-match'];
            if (!modifiedSince && !noneMatch) return false;
            var cacheControl = reqHeaders['cache-control'];
            if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) return false;
            if (noneMatch) {
                if ('*' === noneMatch) return true;
                var etag = resHeaders.etag;
                if (!etag) return false;
                var matches = parseTokenList(noneMatch);
                for(var i = 0; i < matches.length; i++){
                    var match = matches[i];
                    if (match === etag || match === 'W/' + etag || 'W/' + match === etag) return true;
                }
                return false;
            }
            if (modifiedSince) {
                var lastModified = resHeaders['last-modified'];
                var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
                if (modifiedStale) return false;
            }
            return true;
        }
        function parseHttpDate(date) {
            var timestamp = date && Date.parse(date);
            return 'number' == typeof timestamp ? timestamp : NaN;
        }
        function parseTokenList(str) {
            var end = 0;
            var list = [];
            var start = 0;
            for(var i = 0, len = str.length; i < len; i++)switch(str.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i + 1;
                    break;
                case 0x2c:
                    list.push(str.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
            list.push(str.substring(start, end));
            return list;
        }
    },
    "../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js" (module) {
        "use strict";
        var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
        var toStr = Object.prototype.toString;
        var max = Math.max;
        var funcType = '[object Function]';
        var concatty = function(a, b) {
            var arr = [];
            for(var i = 0; i < a.length; i += 1)arr[i] = a[i];
            for(var j = 0; j < b.length; j += 1)arr[j + a.length] = b[j];
            return arr;
        };
        var slicy = function(arrLike, offset) {
            var arr = [];
            for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1)arr[j] = arrLike[i];
            return arr;
        };
        var joiny = function(arr, joiner) {
            var str = '';
            for(var i = 0; i < arr.length; i += 1){
                str += arr[i];
                if (i + 1 < arr.length) str += joiner;
            }
            return str;
        };
        module.exports = function(that) {
            var target = this;
            if ('function' != typeof target || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
            var args = slicy(arguments, 1);
            var bound;
            var binder = function() {
                if (this instanceof bound) {
                    var result = target.apply(this, concatty(args, arguments));
                    if (Object(result) === result) return result;
                    return this;
                }
                return target.apply(that, concatty(args, arguments));
            };
            var boundLength = max(0, target.length - args.length);
            var boundArgs = [];
            for(var i = 0; i < boundLength; i++)boundArgs[i] = '$' + i;
            bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
            if (target.prototype) {
                var Empty = function() {};
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                Empty.prototype = null;
            }
            return bound;
        };
    },
    "../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var implementation = __webpack_require__("../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js");
        module.exports = Function.prototype.bind || implementation;
    },
    "../../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var undefined;
        var $Object = __webpack_require__("../../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");
        var $Error = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js");
        var $EvalError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js");
        var $RangeError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js");
        var $ReferenceError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js");
        var $SyntaxError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js");
        var $TypeError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $URIError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js");
        var abs = __webpack_require__("../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js");
        var floor = __webpack_require__("../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js");
        var max = __webpack_require__("../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js");
        var min = __webpack_require__("../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js");
        var pow = __webpack_require__("../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js");
        var round = __webpack_require__("../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js");
        var sign = __webpack_require__("../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js");
        var $Function = Function;
        var getEvalledConstructor = function(expressionSyntax) {
            try {
                return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
            } catch (e) {}
        };
        var $gOPD = __webpack_require__("../../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
        var $defineProperty = __webpack_require__("../../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");
        var throwTypeError = function() {
            throw new $TypeError();
        };
        var ThrowTypeError = $gOPD ? function() {
            try {
                arguments.callee;
                return throwTypeError;
            } catch (calleeThrows) {
                try {
                    return $gOPD(arguments, 'callee').get;
                } catch (gOPDthrows) {
                    return throwTypeError;
                }
            }
        }() : throwTypeError;
        var hasSymbols = __webpack_require__("../../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js")();
        var getProto = __webpack_require__("../../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");
        var $ObjectGPO = __webpack_require__("../../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");
        var $ReflectGPO = __webpack_require__("../../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");
        var $apply = __webpack_require__("../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
        var $call = __webpack_require__("../../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
        var needsEval = {};
        var TypedArray = "u" > typeof Uint8Array && getProto ? getProto(Uint8Array) : undefined;
        var INTRINSICS = {
            __proto__: null,
            '%AggregateError%': "u" < typeof AggregateError ? undefined : AggregateError,
            '%Array%': Array,
            '%ArrayBuffer%': "u" < typeof ArrayBuffer ? undefined : ArrayBuffer,
            '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
            '%AsyncFromSyncIteratorPrototype%': undefined,
            '%AsyncFunction%': needsEval,
            '%AsyncGenerator%': needsEval,
            '%AsyncGeneratorFunction%': needsEval,
            '%AsyncIteratorPrototype%': needsEval,
            '%Atomics%': "u" < typeof Atomics ? undefined : Atomics,
            '%BigInt%': "u" < typeof BigInt ? undefined : BigInt,
            '%BigInt64Array%': "u" < typeof BigInt64Array ? undefined : BigInt64Array,
            '%BigUint64Array%': "u" < typeof BigUint64Array ? undefined : BigUint64Array,
            '%Boolean%': Boolean,
            '%DataView%': "u" < typeof DataView ? undefined : DataView,
            '%Date%': Date,
            '%decodeURI%': decodeURI,
            '%decodeURIComponent%': decodeURIComponent,
            '%encodeURI%': encodeURI,
            '%encodeURIComponent%': encodeURIComponent,
            '%Error%': $Error,
            '%eval%': eval,
            '%EvalError%': $EvalError,
            '%Float16Array%': "u" < typeof Float16Array ? undefined : Float16Array,
            '%Float32Array%': "u" < typeof Float32Array ? undefined : Float32Array,
            '%Float64Array%': "u" < typeof Float64Array ? undefined : Float64Array,
            '%FinalizationRegistry%': "u" < typeof FinalizationRegistry ? undefined : FinalizationRegistry,
            '%Function%': $Function,
            '%GeneratorFunction%': needsEval,
            '%Int8Array%': "u" < typeof Int8Array ? undefined : Int8Array,
            '%Int16Array%': "u" < typeof Int16Array ? undefined : Int16Array,
            '%Int32Array%': "u" < typeof Int32Array ? undefined : Int32Array,
            '%isFinite%': isFinite,
            '%isNaN%': isNaN,
            '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
            '%JSON%': 'object' == typeof JSON ? JSON : undefined,
            '%Map%': "u" < typeof Map ? undefined : Map,
            '%MapIteratorPrototype%': "u" > typeof Map && hasSymbols && getProto ? getProto(new Map()[Symbol.iterator]()) : undefined,
            '%Math%': Math,
            '%Number%': Number,
            '%Object%': $Object,
            "%Object.getOwnPropertyDescriptor%": $gOPD,
            '%parseFloat%': parseFloat,
            '%parseInt%': parseInt,
            '%Promise%': "u" < typeof Promise ? undefined : Promise,
            '%Proxy%': "u" < typeof Proxy ? undefined : Proxy,
            '%RangeError%': $RangeError,
            '%ReferenceError%': $ReferenceError,
            '%Reflect%': "u" < typeof Reflect ? undefined : Reflect,
            '%RegExp%': RegExp,
            '%Set%': "u" < typeof Set ? undefined : Set,
            '%SetIteratorPrototype%': "u" > typeof Set && hasSymbols && getProto ? getProto(new Set()[Symbol.iterator]()) : undefined,
            '%SharedArrayBuffer%': "u" < typeof SharedArrayBuffer ? undefined : SharedArrayBuffer,
            '%String%': String,
            '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
            '%Symbol%': hasSymbols ? Symbol : undefined,
            '%SyntaxError%': $SyntaxError,
            '%ThrowTypeError%': ThrowTypeError,
            '%TypedArray%': TypedArray,
            '%TypeError%': $TypeError,
            '%Uint8Array%': "u" < typeof Uint8Array ? undefined : Uint8Array,
            '%Uint8ClampedArray%': "u" < typeof Uint8ClampedArray ? undefined : Uint8ClampedArray,
            '%Uint16Array%': "u" < typeof Uint16Array ? undefined : Uint16Array,
            '%Uint32Array%': "u" < typeof Uint32Array ? undefined : Uint32Array,
            '%URIError%': $URIError,
            '%WeakMap%': "u" < typeof WeakMap ? undefined : WeakMap,
            '%WeakRef%': "u" < typeof WeakRef ? undefined : WeakRef,
            '%WeakSet%': "u" < typeof WeakSet ? undefined : WeakSet,
            '%Function.prototype.call%': $call,
            '%Function.prototype.apply%': $apply,
            '%Object.defineProperty%': $defineProperty,
            '%Object.getPrototypeOf%': $ObjectGPO,
            '%Math.abs%': abs,
            '%Math.floor%': floor,
            '%Math.max%': max,
            '%Math.min%': min,
            '%Math.pow%': pow,
            '%Math.round%': round,
            '%Math.sign%': sign,
            '%Reflect.getPrototypeOf%': $ReflectGPO
        };
        if (getProto) try {
            null.error;
        } catch (e) {
            var errorProto = getProto(getProto(e));
            INTRINSICS['%Error.prototype%'] = errorProto;
        }
        var doEval = function doEval(name) {
            var value;
            if ('%AsyncFunction%' === name) value = getEvalledConstructor('async function () {}');
            else if ('%GeneratorFunction%' === name) value = getEvalledConstructor('function* () {}');
            else if ('%AsyncGeneratorFunction%' === name) value = getEvalledConstructor('async function* () {}');
            else if ('%AsyncGenerator%' === name) {
                var fn = doEval('%AsyncGeneratorFunction%');
                if (fn) value = fn.prototype;
            } else if ('%AsyncIteratorPrototype%' === name) {
                var gen = doEval('%AsyncGenerator%');
                if (gen && getProto) value = getProto(gen.prototype);
            }
            INTRINSICS[name] = value;
            return value;
        };
        var LEGACY_ALIASES = {
            __proto__: null,
            '%ArrayBufferPrototype%': [
                'ArrayBuffer',
                'prototype'
            ],
            '%ArrayPrototype%': [
                'Array',
                'prototype'
            ],
            '%ArrayProto_entries%': [
                'Array',
                'prototype',
                'entries'
            ],
            '%ArrayProto_forEach%': [
                'Array',
                'prototype',
                'forEach'
            ],
            '%ArrayProto_keys%': [
                'Array',
                'prototype',
                'keys'
            ],
            '%ArrayProto_values%': [
                'Array',
                'prototype',
                'values'
            ],
            '%AsyncFunctionPrototype%': [
                'AsyncFunction',
                'prototype'
            ],
            '%AsyncGenerator%': [
                'AsyncGeneratorFunction',
                'prototype'
            ],
            '%AsyncGeneratorPrototype%': [
                'AsyncGeneratorFunction',
                'prototype',
                'prototype'
            ],
            '%BooleanPrototype%': [
                'Boolean',
                'prototype'
            ],
            '%DataViewPrototype%': [
                'DataView',
                'prototype'
            ],
            '%DatePrototype%': [
                'Date',
                'prototype'
            ],
            '%ErrorPrototype%': [
                'Error',
                'prototype'
            ],
            '%EvalErrorPrototype%': [
                'EvalError',
                'prototype'
            ],
            '%Float32ArrayPrototype%': [
                'Float32Array',
                'prototype'
            ],
            '%Float64ArrayPrototype%': [
                'Float64Array',
                'prototype'
            ],
            '%FunctionPrototype%': [
                'Function',
                'prototype'
            ],
            '%Generator%': [
                'GeneratorFunction',
                'prototype'
            ],
            '%GeneratorPrototype%': [
                'GeneratorFunction',
                'prototype',
                'prototype'
            ],
            '%Int8ArrayPrototype%': [
                'Int8Array',
                'prototype'
            ],
            '%Int16ArrayPrototype%': [
                'Int16Array',
                'prototype'
            ],
            '%Int32ArrayPrototype%': [
                'Int32Array',
                'prototype'
            ],
            '%JSONParse%': [
                'JSON',
                'parse'
            ],
            '%JSONStringify%': [
                'JSON',
                'stringify'
            ],
            '%MapPrototype%': [
                'Map',
                'prototype'
            ],
            '%NumberPrototype%': [
                'Number',
                'prototype'
            ],
            '%ObjectPrototype%': [
                'Object',
                'prototype'
            ],
            '%ObjProto_toString%': [
                'Object',
                'prototype',
                'toString'
            ],
            '%ObjProto_valueOf%': [
                'Object',
                'prototype',
                'valueOf'
            ],
            '%PromisePrototype%': [
                'Promise',
                'prototype'
            ],
            '%PromiseProto_then%': [
                'Promise',
                'prototype',
                'then'
            ],
            '%Promise_all%': [
                'Promise',
                'all'
            ],
            '%Promise_reject%': [
                'Promise',
                'reject'
            ],
            '%Promise_resolve%': [
                'Promise',
                'resolve'
            ],
            '%RangeErrorPrototype%': [
                'RangeError',
                'prototype'
            ],
            '%ReferenceErrorPrototype%': [
                'ReferenceError',
                'prototype'
            ],
            '%RegExpPrototype%': [
                'RegExp',
                'prototype'
            ],
            '%SetPrototype%': [
                'Set',
                'prototype'
            ],
            '%SharedArrayBufferPrototype%': [
                'SharedArrayBuffer',
                'prototype'
            ],
            '%StringPrototype%': [
                'String',
                'prototype'
            ],
            '%SymbolPrototype%': [
                'Symbol',
                'prototype'
            ],
            '%SyntaxErrorPrototype%': [
                'SyntaxError',
                'prototype'
            ],
            '%TypedArrayPrototype%': [
                'TypedArray',
                'prototype'
            ],
            '%TypeErrorPrototype%': [
                'TypeError',
                'prototype'
            ],
            '%Uint8ArrayPrototype%': [
                'Uint8Array',
                'prototype'
            ],
            '%Uint8ClampedArrayPrototype%': [
                'Uint8ClampedArray',
                'prototype'
            ],
            '%Uint16ArrayPrototype%': [
                'Uint16Array',
                'prototype'
            ],
            '%Uint32ArrayPrototype%': [
                'Uint32Array',
                'prototype'
            ],
            '%URIErrorPrototype%': [
                'URIError',
                'prototype'
            ],
            '%WeakMapPrototype%': [
                'WeakMap',
                'prototype'
            ],
            '%WeakSetPrototype%': [
                'WeakSet',
                'prototype'
            ]
        };
        var bind = __webpack_require__("../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        var hasOwn = __webpack_require__("../../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
        var $concat = bind.call($call, Array.prototype.concat);
        var $spliceApply = bind.call($apply, Array.prototype.splice);
        var $replace = bind.call($call, String.prototype.replace);
        var $strSlice = bind.call($call, String.prototype.slice);
        var $exec = bind.call($call, RegExp.prototype.exec);
        var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
        var reEscapeChar = /\\(\\)?/g;
        var stringToPath = function(string) {
            var first = $strSlice(string, 0, 1);
            var last = $strSlice(string, -1);
            if ('%' === first && '%' !== last) throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
            if ('%' === last && '%' !== first) throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
            var result = [];
            $replace(string, rePropName, function(match, number, quote, subString) {
                result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
            });
            return result;
        };
        var getBaseIntrinsic = function(name, allowMissing) {
            var intrinsicName = name;
            var alias;
            if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                alias = LEGACY_ALIASES[intrinsicName];
                intrinsicName = '%' + alias[0] + '%';
            }
            if (hasOwn(INTRINSICS, intrinsicName)) {
                var value = INTRINSICS[intrinsicName];
                if (value === needsEval) value = doEval(intrinsicName);
                if (void 0 === value && !allowMissing) throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                return {
                    alias: alias,
                    name: intrinsicName,
                    value: value
                };
            }
            throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
        };
        module.exports = function(name, allowMissing) {
            if ('string' != typeof name || 0 === name.length) throw new $TypeError('intrinsic name must be a non-empty string');
            if (arguments.length > 1 && 'boolean' != typeof allowMissing) throw new $TypeError('"allowMissing" argument must be a boolean');
            if (null === $exec(/^%?[^%]*%?$/, name)) throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
            var parts = stringToPath(name);
            var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
            var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
            var intrinsicRealName = intrinsic.name;
            var value = intrinsic.value;
            var skipFurtherCaching = false;
            var alias = intrinsic.alias;
            if (alias) {
                intrinsicBaseName = alias[0];
                $spliceApply(parts, $concat([
                    0,
                    1
                ], alias));
            }
            for(var i = 1, isOwn = true; i < parts.length; i += 1){
                var part = parts[i];
                var first = $strSlice(part, 0, 1);
                var last = $strSlice(part, -1);
                if (('"' === first || "'" === first || '`' === first || '"' === last || "'" === last || '`' === last) && first !== last) throw new $SyntaxError('property names with quotes must have matching quotes');
                if ('constructor' === part || !isOwn) skipFurtherCaching = true;
                intrinsicBaseName += '.' + part;
                intrinsicRealName = '%' + intrinsicBaseName + '%';
                if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
                else if (null != value) {
                    if (!(part in value)) {
                        if (!allowMissing) throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                        return;
                    }
                    if ($gOPD && i + 1 >= parts.length) {
                        var desc = $gOPD(value, part);
                        isOwn = !!desc;
                        value = isOwn && 'get' in desc && !('originalValue' in desc.get) ? desc.get : value[part];
                    } else {
                        isOwn = hasOwn(value, part);
                        value = value[part];
                    }
                    if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
                }
            }
            return value;
        };
    },
    "../../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var $Object = __webpack_require__("../../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");
        module.exports = $Object.getPrototypeOf || null;
    },
    "../../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js" (module) {
        "use strict";
        module.exports = "u" > typeof Reflect && Reflect.getPrototypeOf || null;
    },
    "../../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var reflectGetProto = __webpack_require__("../../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");
        var originalGetProto = __webpack_require__("../../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");
        var getDunderProto = __webpack_require__("../../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js");
        module.exports = reflectGetProto ? function(O) {
            return reflectGetProto(O);
        } : originalGetProto ? function(O) {
            if (!O || 'object' != typeof O && 'function' != typeof O) throw new TypeError('getProto: not an object');
            return originalGetProto(O);
        } : getDunderProto ? function(O) {
            return getDunderProto(O);
        } : null;
    },
    "../../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js" (module) {
        "use strict";
        module.exports = Object.getOwnPropertyDescriptor;
    },
    "../../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var $gOPD = __webpack_require__("../../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js");
        if ($gOPD) try {
            $gOPD([], 'length');
        } catch (e) {
            $gOPD = null;
        }
        module.exports = $gOPD;
    },
    "../../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var origSymbol = "u" > typeof Symbol && Symbol;
        var hasSymbolSham = __webpack_require__("../../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");
        module.exports = function() {
            if ('function' != typeof origSymbol) return false;
            if ('function' != typeof Symbol) return false;
            if ('symbol' != typeof origSymbol('foo')) return false;
            if ('symbol' != typeof Symbol('bar')) return false;
            return hasSymbolSham();
        };
    },
    "../../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js" (module) {
        "use strict";
        module.exports = function() {
            if ('function' != typeof Symbol || 'function' != typeof Object.getOwnPropertySymbols) return false;
            if ('symbol' == typeof Symbol.iterator) return true;
            var obj = {};
            var sym = Symbol('test');
            var symObj = Object(sym);
            if ('string' == typeof sym) return false;
            if ('[object Symbol]' !== Object.prototype.toString.call(sym)) return false;
            if ('[object Symbol]' !== Object.prototype.toString.call(symObj)) return false;
            var symVal = 42;
            obj[sym] = symVal;
            for(var _ in obj)return false;
            if ('function' == typeof Object.keys && 0 !== Object.keys(obj).length) return false;
            if ('function' == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(obj).length) return false;
            var syms = Object.getOwnPropertySymbols(obj);
            if (1 !== syms.length || syms[0] !== sym) return false;
            if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
            if ('function' == typeof Object.getOwnPropertyDescriptor) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                if (descriptor.value !== symVal || true !== descriptor.enumerable) return false;
            }
            return true;
        };
    },
    "../../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var hasSymbols = __webpack_require__("../../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");
        module.exports = function() {
            return hasSymbols() && !!Symbol.toStringTag;
        };
    },
    "../../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var call = Function.prototype.call;
        var $hasOwn = Object.prototype.hasOwnProperty;
        var bind = __webpack_require__("../../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        module.exports = bind.call(call, $hasOwn);
    },
    "../../../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var deprecate = __webpack_require__("../../../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('http-errors');
        var setPrototypeOf = __webpack_require__("../../../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js");
        var statuses = __webpack_require__("../../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var inherits = __webpack_require__("../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js");
        var toIdentifier = __webpack_require__("../../../node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js");
        module.exports = createError;
        module.exports.HttpError = createHttpErrorConstructor();
        module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
        populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
        function codeClass(status) {
            return Number(String(status).charAt(0) + '00');
        }
        function createError() {
            var err;
            var msg;
            var status = 500;
            var props = {};
            for(var i = 0; i < arguments.length; i++){
                var arg = arguments[i];
                var type = typeof arg;
                if ('object' === type && arg instanceof Error) {
                    err = arg;
                    status = err.status || err.statusCode || status;
                } else if ('number' === type && 0 === i) status = arg;
                else if ('string' === type) msg = arg;
                else if ('object' === type) props = arg;
                else throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type);
            }
            if ('number' == typeof status && (status < 400 || status >= 600)) deprecate('non-error status code; use only 4xx or 5xx status codes');
            if ('number' != typeof status || !statuses.message[status] && (status < 400 || status >= 600)) status = 500;
            var HttpError = createError[status] || createError[codeClass(status)];
            if (!err) {
                err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
                Error.captureStackTrace(err, createError);
            }
            if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
                err.expose = status < 500;
                err.status = err.statusCode = status;
            }
            for(var key in props)if ('status' !== key && 'statusCode' !== key) err[key] = props[key];
            return err;
        }
        function createHttpErrorConstructor() {
            function HttpError() {
                throw new TypeError('cannot construct abstract class');
            }
            inherits(HttpError, Error);
            return HttpError;
        }
        function createClientErrorConstructor(HttpError, name, code) {
            var className = toClassName(name);
            function ClientError(message) {
                var msg = null != message ? message : statuses.message[code];
                var err = new Error(msg);
                Error.captureStackTrace(err, ClientError);
                setPrototypeOf(err, ClientError.prototype);
                Object.defineProperty(err, 'message', {
                    enumerable: true,
                    configurable: true,
                    value: msg,
                    writable: true
                });
                Object.defineProperty(err, 'name', {
                    enumerable: false,
                    configurable: true,
                    value: className,
                    writable: true
                });
                return err;
            }
            inherits(ClientError, HttpError);
            nameFunc(ClientError, className);
            ClientError.prototype.status = code;
            ClientError.prototype.statusCode = code;
            ClientError.prototype.expose = true;
            return ClientError;
        }
        function createIsHttpErrorFunction(HttpError) {
            return function(val) {
                if (!val || 'object' != typeof val) return false;
                if (val instanceof HttpError) return true;
                return val instanceof Error && 'boolean' == typeof val.expose && 'number' == typeof val.statusCode && val.status === val.statusCode;
            };
        }
        function createServerErrorConstructor(HttpError, name, code) {
            var className = toClassName(name);
            function ServerError(message) {
                var msg = null != message ? message : statuses.message[code];
                var err = new Error(msg);
                Error.captureStackTrace(err, ServerError);
                setPrototypeOf(err, ServerError.prototype);
                Object.defineProperty(err, 'message', {
                    enumerable: true,
                    configurable: true,
                    value: msg,
                    writable: true
                });
                Object.defineProperty(err, 'name', {
                    enumerable: false,
                    configurable: true,
                    value: className,
                    writable: true
                });
                return err;
            }
            inherits(ServerError, HttpError);
            nameFunc(ServerError, className);
            ServerError.prototype.status = code;
            ServerError.prototype.statusCode = code;
            ServerError.prototype.expose = false;
            return ServerError;
        }
        function nameFunc(func, name) {
            var desc = Object.getOwnPropertyDescriptor(func, 'name');
            if (desc && desc.configurable) {
                desc.value = name;
                Object.defineProperty(func, 'name', desc);
            }
        }
        function populateConstructorExports(exports1, codes, HttpError) {
            codes.forEach(function(code) {
                var CodeError;
                var name = toIdentifier(statuses.message[code]);
                switch(codeClass(code)){
                    case 400:
                        CodeError = createClientErrorConstructor(HttpError, name, code);
                        break;
                    case 500:
                        CodeError = createServerErrorConstructor(HttpError, name, code);
                        break;
                }
                if (CodeError) {
                    exports1[code] = CodeError;
                    exports1[name] = CodeError;
                }
            });
        }
        function toClassName(name) {
            return 'Error' !== name.substr(-5) ? name + 'Error' : name;
        }
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-codec.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1._dbcs = DBCSCodec;
        var UNASSIGNED = -1;
        var GB18030_CODE = -2;
        var SEQ_START = -10;
        var NODE_START = -1000;
        var UNASSIGNED_NODE = new Array(0x100);
        var DEF_CHAR = -1;
        for(var i = 0; i < 0x100; i++)UNASSIGNED_NODE[i] = UNASSIGNED;
        function DBCSCodec(codecOptions, iconv) {
            this.encodingName = codecOptions.encodingName;
            if (!codecOptions) throw new Error("DBCS codec is called without the data.");
            if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
            var mappingTable = codecOptions.table();
            this.decodeTables = [];
            this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
            this.decodeTableSeq = [];
            for(var i = 0; i < mappingTable.length; i++)this._addDecodeChunk(mappingTable[i]);
            if ("function" == typeof codecOptions.gb18030) {
                this.gb18030 = codecOptions.gb18030();
                var commonThirdByteNodeIdx = this.decodeTables.length;
                this.decodeTables.push(UNASSIGNED_NODE.slice(0));
                var commonFourthByteNodeIdx = this.decodeTables.length;
                this.decodeTables.push(UNASSIGNED_NODE.slice(0));
                var firstByteNode = this.decodeTables[0];
                for(var i = 0x81; i <= 0xFE; i++){
                    var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];
                    for(var j = 0x30; j <= 0x39; j++){
                        if (secondByteNode[j] === UNASSIGNED) secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
                        else if (secondByteNode[j] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 2");
                        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
                        for(var k = 0x81; k <= 0xFE; k++){
                            if (thirdByteNode[k] === UNASSIGNED) thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
                            else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) continue;
                            else if (thirdByteNode[k] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 3");
                            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
                            for(var l = 0x30; l <= 0x39; l++)if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;
                        }
                    }
                }
            }
            this.defaultCharUnicode = iconv.defaultCharUnicode;
            this.encodeTable = [];
            this.encodeTableSeq = [];
            var skipEncodeChars = {};
            if (codecOptions.encodeSkipVals) for(var i = 0; i < codecOptions.encodeSkipVals.length; i++){
                var val = codecOptions.encodeSkipVals[i];
                if ("number" == typeof val) skipEncodeChars[val] = true;
                else for(var j = val.from; j <= val.to; j++)skipEncodeChars[j] = true;
            }
            this._fillEncodeTable(0, 0, skipEncodeChars);
            if (codecOptions.encodeAdd) {
                for(var uChar in codecOptions.encodeAdd)if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
            }
            this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
            if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
            if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
        }
        DBCSCodec.prototype.encoder = DBCSEncoder;
        DBCSCodec.prototype.decoder = DBCSDecoder;
        DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
            var bytes = [];
            for(; addr > 0; addr >>>= 8)bytes.push(0xFF & addr);
            if (0 == bytes.length) bytes.push(0);
            var node = this.decodeTables[0];
            for(var i = bytes.length - 1; i > 0; i--){
                var val = node[bytes[i]];
                if (val == UNASSIGNED) {
                    node[bytes[i]] = NODE_START - this.decodeTables.length;
                    this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
                } else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
                else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
            }
            return node;
        };
        DBCSCodec.prototype._addDecodeChunk = function(chunk) {
            var curAddr = parseInt(chunk[0], 16);
            var writeTable = this._getDecodeTrieNode(curAddr);
            curAddr &= 0xFF;
            for(var k = 1; k < chunk.length; k++){
                var part = chunk[k];
                if ("string" == typeof part) for(var l = 0; l < part.length;){
                    var code = part.charCodeAt(l++);
                    if (code >= 0xD800 && code < 0xDC00) {
                        var codeTrail = part.charCodeAt(l++);
                        if (codeTrail >= 0xDC00 && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                        else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
                    } else if (code > 0x0FF0 && code <= 0x0FFF) {
                        var len = 0xFFF - code + 2;
                        var seq = [];
                        for(var m = 0; m < len; m++)seq.push(part.charCodeAt(l++));
                        writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                        this.decodeTableSeq.push(seq);
                    } else writeTable[curAddr++] = code;
                }
                else if ("number" == typeof part) {
                    var charCode = writeTable[curAddr - 1] + 1;
                    for(var l = 0; l < part; l++)writeTable[curAddr++] = charCode++;
                } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
            }
            if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
        };
        DBCSCodec.prototype._getEncodeBucket = function(uCode) {
            var high = uCode >> 8;
            if (void 0 === this.encodeTable[high]) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
            return this.encodeTable[high];
        };
        DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
            var bucket = this._getEncodeBucket(uCode);
            var low = 0xFF & uCode;
            if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
            else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
        };
        DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
            var uCode = seq[0];
            var bucket = this._getEncodeBucket(uCode);
            var low = 0xFF & uCode;
            var node;
            if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
            else {
                node = {};
                if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
                bucket[low] = SEQ_START - this.encodeTableSeq.length;
                this.encodeTableSeq.push(node);
            }
            for(var j = 1; j < seq.length - 1; j++){
                var oldVal = node[uCode];
                if ("object" == typeof oldVal) node = oldVal;
                else {
                    node = node[uCode] = {};
                    if (void 0 !== oldVal) node[DEF_CHAR] = oldVal;
                }
            }
            uCode = seq[seq.length - 1];
            node[uCode] = dbcsCode;
        };
        DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
            var node = this.decodeTables[nodeIdx];
            var hasValues = false;
            var subNodeEmpty = {};
            for(var i = 0; i < 0x100; i++){
                var uCode = node[i];
                var mbCode = prefix + i;
                if (!skipEncodeChars[mbCode]) {
                    if (uCode >= 0) {
                        this._setEncodeChar(uCode, mbCode);
                        hasValues = true;
                    } else if (uCode <= NODE_START) {
                        var subNodeIdx = NODE_START - uCode;
                        if (!subNodeEmpty[subNodeIdx]) {
                            var newPrefix = mbCode << 8 >>> 0;
                            if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;
                            else subNodeEmpty[subNodeIdx] = true;
                        }
                    } else if (uCode <= SEQ_START) {
                        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
                        hasValues = true;
                    }
                }
            }
            return hasValues;
        };
        function DBCSEncoder(options, codec) {
            this.leadSurrogate = -1;
            this.seqObj = void 0;
            this.encodeTable = codec.encodeTable;
            this.encodeTableSeq = codec.encodeTableSeq;
            this.defaultCharSingleByte = codec.defCharSB;
            this.gb18030 = codec.gb18030;
        }
        DBCSEncoder.prototype.write = function(str) {
            var newBuf = Buffer1.alloc(str.length * (this.gb18030 ? 4 : 3));
            var leadSurrogate = this.leadSurrogate;
            var seqObj = this.seqObj;
            var nextChar = -1;
            var i = 0;
            var j = 0;
            while(true){
                if (-1 === nextChar) {
                    if (i == str.length) break;
                    var uCode = str.charCodeAt(i++);
                } else {
                    var uCode = nextChar;
                    nextChar = -1;
                }
                if (uCode >= 0xD800 && uCode < 0xE000) if (uCode < 0xDC00) if (-1 === leadSurrogate) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    uCode = UNASSIGNED;
                }
                else if (-1 !== leadSurrogate) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else uCode = UNASSIGNED;
                else if (-1 !== leadSurrogate) {
                    nextChar = uCode;
                    uCode = UNASSIGNED;
                    leadSurrogate = -1;
                }
                var dbcsCode = UNASSIGNED;
                if (void 0 !== seqObj && uCode != UNASSIGNED) {
                    var resCode = seqObj[uCode];
                    if ("object" == typeof resCode) {
                        seqObj = resCode;
                        continue;
                    }
                    if ("number" == typeof resCode) dbcsCode = resCode;
                    else if (void 0 == resCode) {
                        resCode = seqObj[DEF_CHAR];
                        if (void 0 !== resCode) {
                            dbcsCode = resCode;
                            nextChar = uCode;
                        }
                    }
                    seqObj = void 0;
                } else if (uCode >= 0) {
                    var subtable = this.encodeTable[uCode >> 8];
                    if (void 0 !== subtable) dbcsCode = subtable[0xFF & uCode];
                    if (dbcsCode <= SEQ_START) {
                        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
                        continue;
                    }
                    if (dbcsCode == UNASSIGNED && this.gb18030) {
                        var idx = findIdx(this.gb18030.uChars, uCode);
                        if (-1 != idx) {
                            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
                            dbcsCode %= 12600;
                            newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
                            dbcsCode %= 1260;
                            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
                            dbcsCode %= 10;
                            newBuf[j++] = 0x30 + dbcsCode;
                            continue;
                        }
                    }
                }
                if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
                if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
                else if (dbcsCode < 0x10000) {
                    newBuf[j++] = dbcsCode >> 8;
                    newBuf[j++] = 0xFF & dbcsCode;
                } else if (dbcsCode < 0x1000000) {
                    newBuf[j++] = dbcsCode >> 16;
                    newBuf[j++] = dbcsCode >> 8 & 0xFF;
                    newBuf[j++] = 0xFF & dbcsCode;
                } else {
                    newBuf[j++] = dbcsCode >>> 24;
                    newBuf[j++] = dbcsCode >>> 16 & 0xFF;
                    newBuf[j++] = dbcsCode >>> 8 & 0xFF;
                    newBuf[j++] = 0xFF & dbcsCode;
                }
            }
            this.seqObj = seqObj;
            this.leadSurrogate = leadSurrogate;
            return newBuf.slice(0, j);
        };
        DBCSEncoder.prototype.end = function() {
            if (-1 === this.leadSurrogate && void 0 === this.seqObj) return;
            var newBuf = Buffer1.alloc(10);
            var j = 0;
            if (this.seqObj) {
                var dbcsCode = this.seqObj[DEF_CHAR];
                if (void 0 !== dbcsCode) if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
                else {
                    newBuf[j++] = dbcsCode >> 8;
                    newBuf[j++] = 0xFF & dbcsCode;
                }
                this.seqObj = void 0;
            }
            if (-1 !== this.leadSurrogate) {
                newBuf[j++] = this.defaultCharSingleByte;
                this.leadSurrogate = -1;
            }
            return newBuf.slice(0, j);
        };
        DBCSEncoder.prototype.findIdx = findIdx;
        function DBCSDecoder(options, codec) {
            this.nodeIdx = 0;
            this.prevBytes = [];
            this.decodeTables = codec.decodeTables;
            this.decodeTableSeq = codec.decodeTableSeq;
            this.defaultCharUnicode = codec.defaultCharUnicode;
            this.gb18030 = codec.gb18030;
        }
        DBCSDecoder.prototype.write = function(buf) {
            var newBuf = Buffer1.alloc(2 * buf.length);
            var nodeIdx = this.nodeIdx;
            var prevBytes = this.prevBytes;
            var prevOffset = this.prevBytes.length;
            var seqStart = -this.prevBytes.length;
            var uCode;
            for(var i = 0, j = 0; i < buf.length; i++){
                var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset];
                var uCode = this.decodeTables[nodeIdx][curByte];
                if (uCode >= 0) ;
                else if (uCode === UNASSIGNED) {
                    uCode = this.defaultCharUnicode.charCodeAt(0);
                    i = seqStart;
                } else if (uCode === GB18030_CODE) {
                    if (i >= 3) var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30);
                    else var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 + ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 + ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 + (curByte - 0x30);
                    var idx = findIdx(this.gb18030.gbChars, ptr);
                    uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
                } else if (uCode <= NODE_START) {
                    nodeIdx = NODE_START - uCode;
                    continue;
                } else if (uCode <= SEQ_START) {
                    var seq = this.decodeTableSeq[SEQ_START - uCode];
                    for(var k = 0; k < seq.length - 1; k++){
                        uCode = seq[k];
                        newBuf[j++] = 0xFF & uCode;
                        newBuf[j++] = uCode >> 8;
                    }
                    uCode = seq[seq.length - 1];
                } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
                if (uCode >= 0x10000) {
                    uCode -= 0x10000;
                    var uCodeLead = 0xD800 | uCode >> 10;
                    newBuf[j++] = 0xFF & uCodeLead;
                    newBuf[j++] = uCodeLead >> 8;
                    uCode = 0xDC00 | 0x3FF & uCode;
                }
                newBuf[j++] = 0xFF & uCode;
                newBuf[j++] = uCode >> 8;
                nodeIdx = 0;
                seqStart = i + 1;
            }
            this.nodeIdx = nodeIdx;
            this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
            return newBuf.slice(0, j).toString("ucs2");
        };
        DBCSDecoder.prototype.end = function() {
            var ret = "";
            while(this.prevBytes.length > 0){
                ret += this.defaultCharUnicode;
                var bytesArr = this.prevBytes.slice(1);
                this.prevBytes = [];
                this.nodeIdx = 0;
                if (bytesArr.length > 0) ret += this.write(bytesArr);
            }
            this.prevBytes = [];
            this.nodeIdx = 0;
            return ret;
        };
        function findIdx(table, val) {
            if (table[0] > val) return -1;
            var l = 0;
            var r = table.length;
            while(l < r - 1){
                var mid = l + (r - l + 1 >> 1);
                if (table[mid] <= val) l = mid;
                else r = mid;
            }
            return l;
        }
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-data.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        module.exports = {
            shiftjis: {
                type: "_dbcs",
                table: function() {
                    return __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/shiftjis.json");
                },
                encodeAdd: {
                    "\u00a5": 0x5C,
                    "\u203E": 0x7E
                },
                encodeSkipVals: [
                    {
                        from: 0xED40,
                        to: 0xF940
                    }
                ]
            },
            csshiftjis: "shiftjis",
            mskanji: "shiftjis",
            sjis: "shiftjis",
            windows31j: "shiftjis",
            ms31j: "shiftjis",
            xsjis: "shiftjis",
            windows932: "shiftjis",
            ms932: "shiftjis",
            932: "shiftjis",
            cp932: "shiftjis",
            eucjp: {
                type: "_dbcs",
                table: function() {
                    return __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/eucjp.json");
                },
                encodeAdd: {
                    "\u00a5": 0x5C,
                    "\u203E": 0x7E
                }
            },
            gb2312: "cp936",
            gb231280: "cp936",
            gb23121980: "cp936",
            csgb2312: "cp936",
            csiso58gb231280: "cp936",
            euccn: "cp936",
            windows936: "cp936",
            ms936: "cp936",
            936: "cp936",
            cp936: {
                type: "_dbcs",
                table: function() {
                    return __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp936.json");
                }
            },
            gbk: {
                type: "_dbcs",
                table: function() {
                    return __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp936.json").concat(__webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gbk-added.json"));
                }
            },
            xgbk: "gbk",
            isoir58: "gbk",
            gb18030: {
                type: "_dbcs",
                table: function() {
                    return __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp936.json").concat(__webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gbk-added.json"));
                },
                gb18030: function() {
                    return __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json");
                },
                encodeSkipVals: [
                    0x80
                ],
                encodeAdd: {
                    "": 0xA2E3
                }
            },
            chinese: "gb18030",
            windows949: "cp949",
            ms949: "cp949",
            949: "cp949",
            cp949: {
                type: "_dbcs",
                table: function() {
                    return __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp949.json");
                }
            },
            cseuckr: "cp949",
            csksc56011987: "cp949",
            euckr: "cp949",
            isoir149: "cp949",
            korean: "cp949",
            ksc56011987: "cp949",
            ksc56011989: "cp949",
            ksc5601: "cp949",
            windows950: "cp950",
            ms950: "cp950",
            950: "cp950",
            cp950: {
                type: "_dbcs",
                table: function() {
                    return __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp950.json");
                }
            },
            big5: "big5hkscs",
            big5hkscs: {
                type: "_dbcs",
                table: function() {
                    return __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp950.json").concat(__webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/big5-added.json"));
                },
                encodeSkipVals: [
                    0x8e69,
                    0x8e6f,
                    0x8e7e,
                    0x8eab,
                    0x8eb4,
                    0x8ecd,
                    0x8ed0,
                    0x8f57,
                    0x8f69,
                    0x8f6e,
                    0x8fcb,
                    0x8ffe,
                    0x906d,
                    0x907a,
                    0x90c4,
                    0x90dc,
                    0x90f1,
                    0x91bf,
                    0x92af,
                    0x92b0,
                    0x92b1,
                    0x92b2,
                    0x92d1,
                    0x9447,
                    0x94ca,
                    0x95d9,
                    0x96fc,
                    0x9975,
                    0x9b76,
                    0x9b78,
                    0x9b7b,
                    0x9bc6,
                    0x9bde,
                    0x9bec,
                    0x9bf6,
                    0x9c42,
                    0x9c53,
                    0x9c62,
                    0x9c68,
                    0x9c6b,
                    0x9c77,
                    0x9cbc,
                    0x9cbd,
                    0x9cd0,
                    0x9d57,
                    0x9d5a,
                    0x9dc4,
                    0x9def,
                    0x9dfb,
                    0x9ea9,
                    0x9eef,
                    0x9efd,
                    0x9f60,
                    0x9fcb,
                    0xa077,
                    0xa0dc,
                    0xa0df,
                    0x8fcc,
                    0x92c8,
                    0x9644,
                    0x96ed,
                    0xa2a4,
                    0xa2a5,
                    0xa2a7,
                    0xa2a6,
                    0xa2cc,
                    0xa2ce
                ]
            },
            cnbig5: "big5hkscs",
            csbig5: "big5hkscs",
            xxbig5: "big5hkscs"
        };
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/index.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var mergeModules = __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/helpers/merge-exports.js");
        var modules = [
            __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/internal.js"),
            __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf32.js"),
            __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf16.js"),
            __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf7.js"),
            __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-codec.js"),
            __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data.js"),
            __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data-generated.js"),
            __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-codec.js"),
            __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-data.js")
        ];
        for(var i = 0; i < modules.length; i++){
            var module = modules[i];
            mergeModules(exports1, module);
        }
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/internal.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        module.exports = {
            utf8: {
                type: "_internal",
                bomAware: true
            },
            cesu8: {
                type: "_internal",
                bomAware: true
            },
            unicode11utf8: "utf8",
            ucs2: {
                type: "_internal",
                bomAware: true
            },
            utf16le: "ucs2",
            binary: {
                type: "_internal"
            },
            base64: {
                type: "_internal"
            },
            hex: {
                type: "_internal"
            },
            _internal: InternalCodec
        };
        function InternalCodec(codecOptions, iconv) {
            this.enc = codecOptions.encodingName;
            this.bomAware = codecOptions.bomAware;
            if ("base64" === this.enc) this.encoder = InternalEncoderBase64;
            else if ("utf8" === this.enc) this.encoder = InternalEncoderUtf8;
            else if ("cesu8" === this.enc) {
                this.enc = "utf8";
                this.encoder = InternalEncoderCesu8;
                if ("" !== Buffer1.from("eda0bdedb2a9", "hex").toString()) {
                    this.decoder = InternalDecoderCesu8;
                    this.defaultCharUnicode = iconv.defaultCharUnicode;
                }
            }
        }
        InternalCodec.prototype.encoder = InternalEncoder;
        InternalCodec.prototype.decoder = InternalDecoder;
        var StringDecoder = __webpack_require__("string_decoder").StringDecoder;
        function InternalDecoder(options, codec) {
            this.decoder = new StringDecoder(codec.enc);
        }
        InternalDecoder.prototype.write = function(buf) {
            if (!Buffer1.isBuffer(buf)) buf = Buffer1.from(buf);
            return this.decoder.write(buf);
        };
        InternalDecoder.prototype.end = function() {
            return this.decoder.end();
        };
        function InternalEncoder(options, codec) {
            this.enc = codec.enc;
        }
        InternalEncoder.prototype.write = function(str) {
            return Buffer1.from(str, this.enc);
        };
        InternalEncoder.prototype.end = function() {};
        function InternalEncoderBase64(options, codec) {
            this.prevStr = "";
        }
        InternalEncoderBase64.prototype.write = function(str) {
            str = this.prevStr + str;
            var completeQuads = str.length - str.length % 4;
            this.prevStr = str.slice(completeQuads);
            str = str.slice(0, completeQuads);
            return Buffer1.from(str, "base64");
        };
        InternalEncoderBase64.prototype.end = function() {
            return Buffer1.from(this.prevStr, "base64");
        };
        function InternalEncoderCesu8(options, codec) {}
        InternalEncoderCesu8.prototype.write = function(str) {
            var buf = Buffer1.alloc(3 * str.length);
            var bufIdx = 0;
            for(var i = 0; i < str.length; i++){
                var charCode = str.charCodeAt(i);
                if (charCode < 0x80) buf[bufIdx++] = charCode;
                else if (charCode < 0x800) {
                    buf[bufIdx++] = 0xC0 + (charCode >>> 6);
                    buf[bufIdx++] = 0x80 + (0x3f & charCode);
                } else {
                    buf[bufIdx++] = 0xE0 + (charCode >>> 12);
                    buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
                    buf[bufIdx++] = 0x80 + (0x3f & charCode);
                }
            }
            return buf.slice(0, bufIdx);
        };
        InternalEncoderCesu8.prototype.end = function() {};
        function InternalDecoderCesu8(options, codec) {
            this.acc = 0;
            this.contBytes = 0;
            this.accBytes = 0;
            this.defaultCharUnicode = codec.defaultCharUnicode;
        }
        InternalDecoderCesu8.prototype.write = function(buf) {
            var acc = this.acc;
            var contBytes = this.contBytes;
            var accBytes = this.accBytes;
            var res = "";
            for(var i = 0; i < buf.length; i++){
                var curByte = buf[i];
                if ((0xC0 & curByte) !== 0x80) {
                    if (contBytes > 0) {
                        res += this.defaultCharUnicode;
                        contBytes = 0;
                    }
                    if (curByte < 0x80) res += String.fromCharCode(curByte);
                    else if (curByte < 0xE0) {
                        acc = 0x1F & curByte;
                        contBytes = 1;
                        accBytes = 1;
                    } else if (curByte < 0xF0) {
                        acc = 0x0F & curByte;
                        contBytes = 2;
                        accBytes = 1;
                    } else res += this.defaultCharUnicode;
                } else if (contBytes > 0) {
                    acc = acc << 6 | 0x3f & curByte;
                    contBytes--;
                    accBytes++;
                    if (0 === contBytes) if (2 === accBytes && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;
                    else if (3 === accBytes && acc < 0x800) res += this.defaultCharUnicode;
                    else res += String.fromCharCode(acc);
                } else res += this.defaultCharUnicode;
            }
            this.acc = acc;
            this.contBytes = contBytes;
            this.accBytes = accBytes;
            return res;
        };
        InternalDecoderCesu8.prototype.end = function() {
            var res = 0;
            if (this.contBytes > 0) res += this.defaultCharUnicode;
            return res;
        };
        function InternalEncoderUtf8(options, codec) {
            this.highSurrogate = "";
        }
        InternalEncoderUtf8.prototype.write = function(str) {
            if (this.highSurrogate) {
                str = this.highSurrogate + str;
                this.highSurrogate = "";
            }
            if (str.length > 0) {
                var charCode = str.charCodeAt(str.length - 1);
                if (charCode >= 0xd800 && charCode < 0xdc00) {
                    this.highSurrogate = str[str.length - 1];
                    str = str.slice(0, str.length - 1);
                }
            }
            return Buffer1.from(str, this.enc);
        };
        InternalEncoderUtf8.prototype.end = function() {
            if (this.highSurrogate) {
                var str = this.highSurrogate;
                this.highSurrogate = "";
                return Buffer1.from(str, this.enc);
            }
        };
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-codec.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1._sbcs = SBCSCodec;
        function SBCSCodec(codecOptions, iconv) {
            if (!codecOptions) throw new Error("SBCS codec is called without the data.");
            if (!codecOptions.chars || 128 !== codecOptions.chars.length && 256 !== codecOptions.chars.length) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
            if (128 === codecOptions.chars.length) {
                var asciiString = "";
                for(var i = 0; i < 128; i++)asciiString += String.fromCharCode(i);
                codecOptions.chars = asciiString + codecOptions.chars;
            }
            this.decodeBuf = Buffer1.from(codecOptions.chars, "ucs2");
            var encodeBuf = Buffer1.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
            for(var i = 0; i < codecOptions.chars.length; i++)encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
            this.encodeBuf = encodeBuf;
        }
        SBCSCodec.prototype.encoder = SBCSEncoder;
        SBCSCodec.prototype.decoder = SBCSDecoder;
        function SBCSEncoder(options, codec) {
            this.encodeBuf = codec.encodeBuf;
        }
        SBCSEncoder.prototype.write = function(str) {
            var buf = Buffer1.alloc(str.length);
            for(var i = 0; i < str.length; i++)buf[i] = this.encodeBuf[str.charCodeAt(i)];
            return buf;
        };
        SBCSEncoder.prototype.end = function() {};
        function SBCSDecoder(options, codec) {
            this.decodeBuf = codec.decodeBuf;
        }
        SBCSDecoder.prototype.write = function(buf) {
            var decodeBuf = this.decodeBuf;
            var newBuf = Buffer1.alloc(2 * buf.length);
            var idx1 = 0;
            var idx2 = 0;
            for(var i = 0; i < buf.length; i++){
                idx1 = 2 * buf[i];
                idx2 = 2 * i;
                newBuf[idx2] = decodeBuf[idx1];
                newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
            }
            return newBuf.toString("ucs2");
        };
        SBCSDecoder.prototype.end = function() {};
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data-generated.js" (module) {
        "use strict";
        module.exports = {
            437: "cp437",
            737: "cp737",
            775: "cp775",
            850: "cp850",
            852: "cp852",
            855: "cp855",
            856: "cp856",
            857: "cp857",
            858: "cp858",
            860: "cp860",
            861: "cp861",
            862: "cp862",
            863: "cp863",
            864: "cp864",
            865: "cp865",
            866: "cp866",
            869: "cp869",
            874: "windows874",
            922: "cp922",
            1046: "cp1046",
            1124: "cp1124",
            1125: "cp1125",
            1129: "cp1129",
            1133: "cp1133",
            1161: "cp1161",
            1162: "cp1162",
            1163: "cp1163",
            1250: "windows1250",
            1251: "windows1251",
            1252: "windows1252",
            1253: "windows1253",
            1254: "windows1254",
            1255: "windows1255",
            1256: "windows1256",
            1257: "windows1257",
            1258: "windows1258",
            28591: "iso88591",
            28592: "iso88592",
            28593: "iso88593",
            28594: "iso88594",
            28595: "iso88595",
            28596: "iso88596",
            28597: "iso88597",
            28598: "iso88598",
            28599: "iso88599",
            28600: "iso885910",
            28601: "iso885911",
            28603: "iso885913",
            28604: "iso885914",
            28605: "iso885915",
            28606: "iso885916",
            windows874: {
                type: "_sbcs",
                chars: ""
            },
            win874: "windows874",
            cp874: "windows874",
            windows1250: {
                type: "_sbcs",
                chars: ""
            },
            win1250: "windows1250",
            cp1250: "windows1250",
            windows1251: {
                type: "_sbcs",
                chars: ""
            },
            win1251: "windows1251",
            cp1251: "windows1251",
            windows1252: {
                type: "_sbcs",
                chars: ""
            },
            win1252: "windows1252",
            cp1252: "windows1252",
            windows1253: {
                type: "_sbcs",
                chars: ""
            },
            win1253: "windows1253",
            cp1253: "windows1253",
            windows1254: {
                type: "_sbcs",
                chars: ""
            },
            win1254: "windows1254",
            cp1254: "windows1254",
            windows1255: {
                type: "_sbcs",
                chars: ""
            },
            win1255: "windows1255",
            cp1255: "windows1255",
            windows1256: {
                type: "_sbcs",
                chars: ""
            },
            win1256: "windows1256",
            cp1256: "windows1256",
            windows1257: {
                type: "_sbcs",
                chars: ""
            },
            win1257: "windows1257",
            cp1257: "windows1257",
            windows1258: {
                type: "_sbcs",
                chars: ""
            },
            win1258: "windows1258",
            cp1258: "windows1258",
            iso88591: {
                type: "_sbcs",
                chars: ""
            },
            cp28591: "iso88591",
            iso88592: {
                type: "_sbcs",
                chars: ""
            },
            cp28592: "iso88592",
            iso88593: {
                type: "_sbcs",
                chars: ""
            },
            cp28593: "iso88593",
            iso88594: {
                type: "_sbcs",
                chars: ""
            },
            cp28594: "iso88594",
            iso88595: {
                type: "_sbcs",
                chars: ""
            },
            cp28595: "iso88595",
            iso88596: {
                type: "_sbcs",
                chars: ""
            },
            cp28596: "iso88596",
            iso88597: {
                type: "_sbcs",
                chars: ""
            },
            cp28597: "iso88597",
            iso88598: {
                type: "_sbcs",
                chars: ""
            },
            cp28598: "iso88598",
            iso88599: {
                type: "_sbcs",
                chars: ""
            },
            cp28599: "iso88599",
            iso885910: {
                type: "_sbcs",
                chars: ""
            },
            cp28600: "iso885910",
            iso885911: {
                type: "_sbcs",
                chars: ""
            },
            cp28601: "iso885911",
            iso885913: {
                type: "_sbcs",
                chars: ""
            },
            cp28603: "iso885913",
            iso885914: {
                type: "_sbcs",
                chars: ""
            },
            cp28604: "iso885914",
            iso885915: {
                type: "_sbcs",
                chars: ""
            },
            cp28605: "iso885915",
            iso885916: {
                type: "_sbcs",
                chars: ""
            },
            cp28606: "iso885916",
            cp437: {
                type: "_sbcs",
                chars: ""
            },
            ibm437: "cp437",
            csibm437: "cp437",
            cp737: {
                type: "_sbcs",
                chars: ""
            },
            ibm737: "cp737",
            csibm737: "cp737",
            cp775: {
                type: "_sbcs",
                chars: ""
            },
            ibm775: "cp775",
            csibm775: "cp775",
            cp850: {
                type: "_sbcs",
                chars: ""
            },
            ibm850: "cp850",
            csibm850: "cp850",
            cp852: {
                type: "_sbcs",
                chars: ""
            },
            ibm852: "cp852",
            csibm852: "cp852",
            cp855: {
                type: "_sbcs",
                chars: ""
            },
            ibm855: "cp855",
            csibm855: "cp855",
            cp856: {
                type: "_sbcs",
                chars: ""
            },
            ibm856: "cp856",
            csibm856: "cp856",
            cp857: {
                type: "_sbcs",
                chars: ""
            },
            ibm857: "cp857",
            csibm857: "cp857",
            cp858: {
                type: "_sbcs",
                chars: ""
            },
            ibm858: "cp858",
            csibm858: "cp858",
            cp860: {
                type: "_sbcs",
                chars: ""
            },
            ibm860: "cp860",
            csibm860: "cp860",
            cp861: {
                type: "_sbcs",
                chars: ""
            },
            ibm861: "cp861",
            csibm861: "cp861",
            cp862: {
                type: "_sbcs",
                chars: ""
            },
            ibm862: "cp862",
            csibm862: "cp862",
            cp863: {
                type: "_sbcs",
                chars: ""
            },
            ibm863: "cp863",
            csibm863: "cp863",
            cp864: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
            },
            ibm864: "cp864",
            csibm864: "cp864",
            cp865: {
                type: "_sbcs",
                chars: ""
            },
            ibm865: "cp865",
            csibm865: "cp865",
            cp866: {
                type: "_sbcs",
                chars: ""
            },
            ibm866: "cp866",
            csibm866: "cp866",
            cp869: {
                type: "_sbcs",
                chars: ""
            },
            ibm869: "cp869",
            csibm869: "cp869",
            cp922: {
                type: "_sbcs",
                chars: ""
            },
            ibm922: "cp922",
            csibm922: "cp922",
            cp1046: {
                type: "_sbcs",
                chars: ""
            },
            ibm1046: "cp1046",
            csibm1046: "cp1046",
            cp1124: {
                type: "_sbcs",
                chars: ""
            },
            ibm1124: "cp1124",
            csibm1124: "cp1124",
            cp1125: {
                type: "_sbcs",
                chars: ""
            },
            ibm1125: "cp1125",
            csibm1125: "cp1125",
            cp1129: {
                type: "_sbcs",
                chars: ""
            },
            ibm1129: "cp1129",
            csibm1129: "cp1129",
            cp1133: {
                type: "_sbcs",
                chars: ""
            },
            ibm1133: "cp1133",
            csibm1133: "cp1133",
            cp1161: {
                type: "_sbcs",
                chars: ""
            },
            ibm1161: "cp1161",
            csibm1161: "cp1161",
            cp1162: {
                type: "_sbcs",
                chars: ""
            },
            ibm1162: "cp1162",
            csibm1162: "cp1162",
            cp1163: {
                type: "_sbcs",
                chars: ""
            },
            ibm1163: "cp1163",
            csibm1163: "cp1163",
            maccroatian: {
                type: "_sbcs",
                chars: ""
            },
            maccyrillic: {
                type: "_sbcs",
                chars: ""
            },
            macgreek: {
                type: "_sbcs",
                chars: ""
            },
            maciceland: {
                type: "_sbcs",
                chars: ""
            },
            macroman: {
                type: "_sbcs",
                chars: ""
            },
            macromania: {
                type: "_sbcs",
                chars: ""
            },
            macthai: {
                type: "_sbcs",
                chars: ""
            },
            macturkish: {
                type: "_sbcs",
                chars: ""
            },
            macukraine: {
                type: "_sbcs",
                chars: ""
            },
            koi8r: {
                type: "_sbcs",
                chars: ""
            },
            koi8u: {
                type: "_sbcs",
                chars: ""
            },
            koi8ru: {
                type: "_sbcs",
                chars: ""
            },
            koi8t: {
                type: "_sbcs",
                chars: ""
            },
            armscii8: {
                type: "_sbcs",
                chars: ")(.,-"
            },
            rk1048: {
                type: "_sbcs",
                chars: ""
            },
            tcvn: {
                type: "_sbcs",
                chars: "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
            },
            georgianacademy: {
                type: "_sbcs",
                chars: ""
            },
            georgianps: {
                type: "_sbcs",
                chars: ""
            },
            pt154: {
                type: "_sbcs",
                chars: ""
            },
            viscii: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
            },
            iso646cn: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
            },
            iso646jp: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
            },
            hproman8: {
                type: "_sbcs",
                chars: ""
            },
            macintosh: {
                type: "_sbcs",
                chars: ""
            },
            ascii: {
                type: "_sbcs",
                chars: ""
            },
            tis620: {
                type: "_sbcs",
                chars: ""
            }
        };
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data.js" (module) {
        "use strict";
        module.exports = {
            10029: "maccenteuro",
            maccenteuro: {
                type: "_sbcs",
                chars: ""
            },
            808: "cp808",
            ibm808: "cp808",
            cp808: {
                type: "_sbcs",
                chars: ""
            },
            mik: {
                type: "_sbcs",
                chars: ""
            },
            cp720: {
                type: "_sbcs",
                chars: "\x80\x81\x84\x86\x8d\x8e\x8f\x90\u0651\u0652\u064b\u064c\u064d\u064e\u064f\u0650\u00a0"
            },
            ascii8bit: "ascii",
            usascii: "ascii",
            ansix34: "ascii",
            ansix341968: "ascii",
            ansix341986: "ascii",
            csascii: "ascii",
            cp367: "ascii",
            ibm367: "ascii",
            isoir6: "ascii",
            iso646us: "ascii",
            iso646irv: "ascii",
            us: "ascii",
            latin1: "iso88591",
            latin2: "iso88592",
            latin3: "iso88593",
            latin4: "iso88594",
            latin5: "iso88599",
            latin6: "iso885910",
            latin7: "iso885913",
            latin8: "iso885914",
            latin9: "iso885915",
            latin10: "iso885916",
            csisolatin1: "iso88591",
            csisolatin2: "iso88592",
            csisolatin3: "iso88593",
            csisolatin4: "iso88594",
            csisolatincyrillic: "iso88595",
            csisolatinarabic: "iso88596",
            csisolatingreek: "iso88597",
            csisolatinhebrew: "iso88598",
            csisolatin5: "iso88599",
            csisolatin6: "iso885910",
            l1: "iso88591",
            l2: "iso88592",
            l3: "iso88593",
            l4: "iso88594",
            l5: "iso88599",
            l6: "iso885910",
            l7: "iso885913",
            l8: "iso885914",
            l9: "iso885915",
            l10: "iso885916",
            isoir14: "iso646jp",
            isoir57: "iso646cn",
            isoir100: "iso88591",
            isoir101: "iso88592",
            isoir109: "iso88593",
            isoir110: "iso88594",
            isoir144: "iso88595",
            isoir127: "iso88596",
            isoir126: "iso88597",
            isoir138: "iso88598",
            isoir148: "iso88599",
            isoir157: "iso885910",
            isoir166: "tis620",
            isoir179: "iso885913",
            isoir199: "iso885914",
            isoir203: "iso885915",
            isoir226: "iso885916",
            cp819: "iso88591",
            ibm819: "iso88591",
            cyrillic: "iso88595",
            arabic: "iso88596",
            arabic8: "iso88596",
            ecma114: "iso88596",
            asmo708: "iso88596",
            greek: "iso88597",
            greek8: "iso88597",
            ecma118: "iso88597",
            elot928: "iso88597",
            hebrew: "iso88598",
            hebrew8: "iso88598",
            turkish: "iso88599",
            turkish8: "iso88599",
            thai: "iso885911",
            thai8: "iso885911",
            celtic: "iso885914",
            celtic8: "iso885914",
            isoceltic: "iso885914",
            tis6200: "tis620",
            tis62025291: "tis620",
            tis62025330: "tis620",
            10000: "macroman",
            10006: "macgreek",
            10007: "maccyrillic",
            10079: "maciceland",
            10081: "macturkish",
            cspc8codepage437: "cp437",
            cspc775baltic: "cp775",
            cspc850multilingual: "cp850",
            cspcp852: "cp852",
            cspc862latinhebrew: "cp862",
            cpgr: "cp869",
            msee: "cp1250",
            mscyrl: "cp1251",
            msansi: "cp1252",
            msgreek: "cp1253",
            msturk: "cp1254",
            mshebr: "cp1255",
            msarab: "cp1256",
            winbaltrim: "cp1257",
            cp20866: "koi8r",
            20866: "koi8r",
            ibm878: "koi8r",
            cskoi8r: "koi8r",
            cp21866: "koi8u",
            21866: "koi8u",
            ibm1168: "koi8u",
            strk10482002: "rk1048",
            tcvn5712: "tcvn",
            tcvn57121: "tcvn",
            gb198880: "iso646cn",
            cn: "iso646cn",
            csiso14jisc6220ro: "iso646jp",
            jisc62201969ro: "iso646jp",
            jp: "iso646jp",
            cshproman8: "hproman8",
            r8: "hproman8",
            roman8: "hproman8",
            xroman8: "hproman8",
            ibm1051: "hproman8",
            mac: "macintosh",
            csmacintosh: "macintosh"
        };
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf16.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1.utf16be = Utf16BECodec;
        function Utf16BECodec() {}
        Utf16BECodec.prototype.encoder = Utf16BEEncoder;
        Utf16BECodec.prototype.decoder = Utf16BEDecoder;
        Utf16BECodec.prototype.bomAware = true;
        function Utf16BEEncoder() {}
        Utf16BEEncoder.prototype.write = function(str) {
            var buf = Buffer1.from(str, "ucs2");
            for(var i = 0; i < buf.length; i += 2){
                var tmp = buf[i];
                buf[i] = buf[i + 1];
                buf[i + 1] = tmp;
            }
            return buf;
        };
        Utf16BEEncoder.prototype.end = function() {};
        function Utf16BEDecoder() {
            this.overflowByte = -1;
        }
        Utf16BEDecoder.prototype.write = function(buf) {
            if (0 == buf.length) return "";
            var buf2 = Buffer1.alloc(buf.length + 1);
            var i = 0;
            var j = 0;
            if (-1 !== this.overflowByte) {
                buf2[0] = buf[0];
                buf2[1] = this.overflowByte;
                i = 1;
                j = 2;
            }
            for(; i < buf.length - 1; i += 2, j += 2){
                buf2[j] = buf[i + 1];
                buf2[j + 1] = buf[i];
            }
            this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
            return buf2.slice(0, j).toString("ucs2");
        };
        Utf16BEDecoder.prototype.end = function() {
            this.overflowByte = -1;
        };
        exports1.utf16 = Utf16Codec;
        function Utf16Codec(codecOptions, iconv) {
            this.iconv = iconv;
        }
        Utf16Codec.prototype.encoder = Utf16Encoder;
        Utf16Codec.prototype.decoder = Utf16Decoder;
        function Utf16Encoder(options, codec) {
            options = options || {};
            if (void 0 === options.addBOM) options.addBOM = true;
            this.encoder = codec.iconv.getEncoder("utf-16le", options);
        }
        Utf16Encoder.prototype.write = function(str) {
            return this.encoder.write(str);
        };
        Utf16Encoder.prototype.end = function() {
            return this.encoder.end();
        };
        function Utf16Decoder(options, codec) {
            this.decoder = null;
            this.initialBufs = [];
            this.initialBufsLen = 0;
            this.options = options || {};
            this.iconv = codec.iconv;
        }
        Utf16Decoder.prototype.write = function(buf) {
            if (!this.decoder) {
                this.initialBufs.push(buf);
                this.initialBufsLen += buf.length;
                if (this.initialBufsLen < 16) return "";
                var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
                this.decoder = this.iconv.getDecoder(encoding, this.options);
                var resStr = "";
                for(var i = 0; i < this.initialBufs.length; i++)resStr += this.decoder.write(this.initialBufs[i]);
                this.initialBufs.length = this.initialBufsLen = 0;
                return resStr;
            }
            return this.decoder.write(buf);
        };
        Utf16Decoder.prototype.end = function() {
            if (!this.decoder) {
                var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
                this.decoder = this.iconv.getDecoder(encoding, this.options);
                var resStr = "";
                for(var i = 0; i < this.initialBufs.length; i++)resStr += this.decoder.write(this.initialBufs[i]);
                var trail = this.decoder.end();
                if (trail) resStr += trail;
                this.initialBufs.length = this.initialBufsLen = 0;
                return resStr;
            }
            return this.decoder.end();
        };
        function detectEncoding(bufs, defaultEncoding) {
            var b = [];
            var charsProcessed = 0;
            var asciiCharsLE = 0;
            var asciiCharsBE = 0;
            outerLoop: for(var i = 0; i < bufs.length; i++){
                var buf = bufs[i];
                for(var j = 0; j < buf.length; j++){
                    b.push(buf[j]);
                    if (2 === b.length) {
                        if (0 === charsProcessed) {
                            if (0xFF === b[0] && 0xFE === b[1]) return "utf-16le";
                            if (0xFE === b[0] && 0xFF === b[1]) return "utf-16be";
                        }
                        if (0 === b[0] && 0 !== b[1]) asciiCharsBE++;
                        if (0 !== b[0] && 0 === b[1]) asciiCharsLE++;
                        b.length = 0;
                        charsProcessed++;
                        if (charsProcessed >= 100) break outerLoop;
                    }
                }
            }
            if (asciiCharsBE > asciiCharsLE) return "utf-16be";
            if (asciiCharsBE < asciiCharsLE) return "utf-16le";
            return defaultEncoding || "utf-16le";
        }
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf32.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1._utf32 = Utf32Codec;
        function Utf32Codec(codecOptions, iconv) {
            this.iconv = iconv;
            this.bomAware = true;
            this.isLE = codecOptions.isLE;
        }
        exports1.utf32le = {
            type: "_utf32",
            isLE: true
        };
        exports1.utf32be = {
            type: "_utf32",
            isLE: false
        };
        exports1.ucs4le = "utf32le";
        exports1.ucs4be = "utf32be";
        Utf32Codec.prototype.encoder = Utf32Encoder;
        Utf32Codec.prototype.decoder = Utf32Decoder;
        function Utf32Encoder(options, codec) {
            this.isLE = codec.isLE;
            this.highSurrogate = 0;
        }
        Utf32Encoder.prototype.write = function(str) {
            var src = Buffer1.from(str, "ucs2");
            var dst = Buffer1.alloc(2 * src.length);
            var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
            var offset = 0;
            for(var i = 0; i < src.length; i += 2){
                var code = src.readUInt16LE(i);
                var isHighSurrogate = code >= 0xD800 && code < 0xDC00;
                var isLowSurrogate = code >= 0xDC00 && code < 0xE000;
                if (this.highSurrogate) if (isHighSurrogate || !isLowSurrogate) {
                    write32.call(dst, this.highSurrogate, offset);
                    offset += 4;
                } else {
                    var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;
                    write32.call(dst, codepoint, offset);
                    offset += 4;
                    this.highSurrogate = 0;
                    continue;
                }
                if (isHighSurrogate) this.highSurrogate = code;
                else {
                    write32.call(dst, code, offset);
                    offset += 4;
                    this.highSurrogate = 0;
                }
            }
            if (offset < dst.length) dst = dst.slice(0, offset);
            return dst;
        };
        Utf32Encoder.prototype.end = function() {
            if (!this.highSurrogate) return;
            var buf = Buffer1.alloc(4);
            if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);
            else buf.writeUInt32BE(this.highSurrogate, 0);
            this.highSurrogate = 0;
            return buf;
        };
        function Utf32Decoder(options, codec) {
            this.isLE = codec.isLE;
            this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
            this.overflow = [];
        }
        Utf32Decoder.prototype.write = function(src) {
            if (0 === src.length) return "";
            var i = 0;
            var codepoint = 0;
            var dst = Buffer1.alloc(src.length + 4);
            var offset = 0;
            var isLE = this.isLE;
            var overflow = this.overflow;
            var badChar = this.badChar;
            if (overflow.length > 0) {
                for(; i < src.length && overflow.length < 4; i++)overflow.push(src[i]);
                if (4 === overflow.length) {
                    codepoint = isLE ? overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24 : overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
                    overflow.length = 0;
                    offset = _writeCodepoint(dst, offset, codepoint, badChar);
                }
            }
            for(; i < src.length - 3; i += 4){
                codepoint = isLE ? src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24 : src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
                offset = _writeCodepoint(dst, offset, codepoint, badChar);
            }
            for(; i < src.length; i++)overflow.push(src[i]);
            return dst.slice(0, offset).toString("ucs2");
        };
        function _writeCodepoint(dst, offset, codepoint, badChar) {
            if (codepoint < 0 || codepoint > 0x10FFFF) codepoint = badChar;
            if (codepoint >= 0x10000) {
                codepoint -= 0x10000;
                var high = 0xD800 | codepoint >> 10;
                dst[offset++] = 0xff & high;
                dst[offset++] = high >> 8;
                var codepoint = 0xDC00 | 0x3FF & codepoint;
            }
            dst[offset++] = 0xff & codepoint;
            dst[offset++] = codepoint >> 8;
            return offset;
        }
        Utf32Decoder.prototype.end = function() {
            this.overflow.length = 0;
        };
        exports1.utf32 = Utf32AutoCodec;
        exports1.ucs4 = "utf32";
        function Utf32AutoCodec(options, iconv) {
            this.iconv = iconv;
        }
        Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
        Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
        function Utf32AutoEncoder(options, codec) {
            options = options || {};
            if (void 0 === options.addBOM) options.addBOM = true;
            this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
        }
        Utf32AutoEncoder.prototype.write = function(str) {
            return this.encoder.write(str);
        };
        Utf32AutoEncoder.prototype.end = function() {
            return this.encoder.end();
        };
        function Utf32AutoDecoder(options, codec) {
            this.decoder = null;
            this.initialBufs = [];
            this.initialBufsLen = 0;
            this.options = options || {};
            this.iconv = codec.iconv;
        }
        Utf32AutoDecoder.prototype.write = function(buf) {
            if (!this.decoder) {
                this.initialBufs.push(buf);
                this.initialBufsLen += buf.length;
                if (this.initialBufsLen < 32) return "";
                var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
                this.decoder = this.iconv.getDecoder(encoding, this.options);
                var resStr = "";
                for(var i = 0; i < this.initialBufs.length; i++)resStr += this.decoder.write(this.initialBufs[i]);
                this.initialBufs.length = this.initialBufsLen = 0;
                return resStr;
            }
            return this.decoder.write(buf);
        };
        Utf32AutoDecoder.prototype.end = function() {
            if (!this.decoder) {
                var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
                this.decoder = this.iconv.getDecoder(encoding, this.options);
                var resStr = "";
                for(var i = 0; i < this.initialBufs.length; i++)resStr += this.decoder.write(this.initialBufs[i]);
                var trail = this.decoder.end();
                if (trail) resStr += trail;
                this.initialBufs.length = this.initialBufsLen = 0;
                return resStr;
            }
            return this.decoder.end();
        };
        function detectEncoding(bufs, defaultEncoding) {
            var b = [];
            var charsProcessed = 0;
            var invalidLE = 0;
            var invalidBE = 0;
            var bmpCharsLE = 0;
            var bmpCharsBE = 0;
            outerLoop: for(var i = 0; i < bufs.length; i++){
                var buf = bufs[i];
                for(var j = 0; j < buf.length; j++){
                    b.push(buf[j]);
                    if (4 === b.length) {
                        if (0 === charsProcessed) {
                            if (0xFF === b[0] && 0xFE === b[1] && 0 === b[2] && 0 === b[3]) return "utf-32le";
                            if (0 === b[0] && 0 === b[1] && 0xFE === b[2] && 0xFF === b[3]) return "utf-32be";
                        }
                        if (0 !== b[0] || b[1] > 0x10) invalidBE++;
                        if (0 !== b[3] || b[2] > 0x10) invalidLE++;
                        if (0 === b[0] && 0 === b[1] && (0 !== b[2] || 0 !== b[3])) bmpCharsBE++;
                        if ((0 !== b[0] || 0 !== b[1]) && 0 === b[2] && 0 === b[3]) bmpCharsLE++;
                        b.length = 0;
                        charsProcessed++;
                        if (charsProcessed >= 100) break outerLoop;
                    }
                }
            }
            if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
            if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
            return defaultEncoding || "utf-32le";
        }
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf7.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1.utf7 = Utf7Codec;
        exports1.unicode11utf7 = "utf7";
        function Utf7Codec(codecOptions, iconv) {
            this.iconv = iconv;
        }
        Utf7Codec.prototype.encoder = Utf7Encoder;
        Utf7Codec.prototype.decoder = Utf7Decoder;
        Utf7Codec.prototype.bomAware = true;
        var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
        function Utf7Encoder(options, codec) {
            this.iconv = codec.iconv;
        }
        Utf7Encoder.prototype.write = function(str) {
            return Buffer1.from(str.replace(nonDirectChars, (function(chunk) {
                return "+" + ("+" === chunk ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
            }).bind(this)));
        };
        Utf7Encoder.prototype.end = function() {};
        function Utf7Decoder(options, codec) {
            this.iconv = codec.iconv;
            this.inBase64 = false;
            this.base64Accum = "";
        }
        var base64Regex = /[A-Za-z0-9\/+]/;
        var base64Chars = [];
        for(var i = 0; i < 256; i++)base64Chars[i] = base64Regex.test(String.fromCharCode(i));
        var plusChar = "+".charCodeAt(0);
        var minusChar = "-".charCodeAt(0);
        var andChar = "&".charCodeAt(0);
        Utf7Decoder.prototype.write = function(buf) {
            var res = "";
            var lastI = 0;
            var inBase64 = this.inBase64;
            var base64Accum = this.base64Accum;
            for(var i = 0; i < buf.length; i++)if (inBase64) {
                if (!base64Chars[buf[i]]) {
                    if (i == lastI && buf[i] == minusChar) res += "+";
                    else {
                        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
                        res += this.iconv.decode(Buffer1.from(b64str, "base64"), "utf16-be");
                    }
                    if (buf[i] != minusChar) i--;
                    lastI = i + 1;
                    inBase64 = false;
                    base64Accum = "";
                }
            } else if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii");
                lastI = i + 1;
                inBase64 = true;
            }
            if (inBase64) {
                var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
                var canBeDecoded = b64str.length - b64str.length % 8;
                base64Accum = b64str.slice(canBeDecoded);
                b64str = b64str.slice(0, canBeDecoded);
                res += this.iconv.decode(Buffer1.from(b64str, "base64"), "utf16-be");
            } else res += this.iconv.decode(buf.slice(lastI), "ascii");
            this.inBase64 = inBase64;
            this.base64Accum = base64Accum;
            return res;
        };
        Utf7Decoder.prototype.end = function() {
            var res = "";
            if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer1.from(this.base64Accum, "base64"), "utf16-be");
            this.inBase64 = false;
            this.base64Accum = "";
            return res;
        };
        exports1.utf7imap = Utf7IMAPCodec;
        function Utf7IMAPCodec(codecOptions, iconv) {
            this.iconv = iconv;
        }
        Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
        Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
        Utf7IMAPCodec.prototype.bomAware = true;
        function Utf7IMAPEncoder(options, codec) {
            this.iconv = codec.iconv;
            this.inBase64 = false;
            this.base64Accum = Buffer1.alloc(6);
            this.base64AccumIdx = 0;
        }
        Utf7IMAPEncoder.prototype.write = function(str) {
            var inBase64 = this.inBase64;
            var base64Accum = this.base64Accum;
            var base64AccumIdx = this.base64AccumIdx;
            var buf = Buffer1.alloc(5 * str.length + 10);
            var bufIdx = 0;
            for(var i = 0; i < str.length; i++){
                var uChar = str.charCodeAt(i);
                if (uChar >= 0x20 && uChar <= 0x7E) {
                    if (inBase64) {
                        if (base64AccumIdx > 0) {
                            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
                            base64AccumIdx = 0;
                        }
                        buf[bufIdx++] = minusChar;
                        inBase64 = false;
                    }
                    if (!inBase64) {
                        buf[bufIdx++] = uChar;
                        if (uChar === andChar) buf[bufIdx++] = minusChar;
                    }
                } else {
                    if (!inBase64) {
                        buf[bufIdx++] = andChar;
                        inBase64 = true;
                    }
                    if (inBase64) {
                        base64Accum[base64AccumIdx++] = uChar >> 8;
                        base64Accum[base64AccumIdx++] = 0xFF & uChar;
                        if (base64AccumIdx == base64Accum.length) {
                            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
                            base64AccumIdx = 0;
                        }
                    }
                }
            }
            this.inBase64 = inBase64;
            this.base64AccumIdx = base64AccumIdx;
            return buf.slice(0, bufIdx);
        };
        Utf7IMAPEncoder.prototype.end = function() {
            var buf = Buffer1.alloc(10);
            var bufIdx = 0;
            if (this.inBase64) {
                if (this.base64AccumIdx > 0) {
                    bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
                    this.base64AccumIdx = 0;
                }
                buf[bufIdx++] = minusChar;
                this.inBase64 = false;
            }
            return buf.slice(0, bufIdx);
        };
        function Utf7IMAPDecoder(options, codec) {
            this.iconv = codec.iconv;
            this.inBase64 = false;
            this.base64Accum = "";
        }
        var base64IMAPChars = base64Chars.slice();
        base64IMAPChars[",".charCodeAt(0)] = true;
        Utf7IMAPDecoder.prototype.write = function(buf) {
            var res = "";
            var lastI = 0;
            var inBase64 = this.inBase64;
            var base64Accum = this.base64Accum;
            for(var i = 0; i < buf.length; i++)if (inBase64) {
                if (!base64IMAPChars[buf[i]]) {
                    if (i == lastI && buf[i] == minusChar) res += "&";
                    else {
                        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, "/");
                        res += this.iconv.decode(Buffer1.from(b64str, "base64"), "utf16-be");
                    }
                    if (buf[i] != minusChar) i--;
                    lastI = i + 1;
                    inBase64 = false;
                    base64Accum = "";
                }
            } else if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii");
                lastI = i + 1;
                inBase64 = true;
            }
            if (inBase64) {
                var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
                var canBeDecoded = b64str.length - b64str.length % 8;
                base64Accum = b64str.slice(canBeDecoded);
                b64str = b64str.slice(0, canBeDecoded);
                res += this.iconv.decode(Buffer1.from(b64str, "base64"), "utf16-be");
            } else res += this.iconv.decode(buf.slice(lastI), "ascii");
            this.inBase64 = inBase64;
            this.base64Accum = base64Accum;
            return res;
        };
        Utf7IMAPDecoder.prototype.end = function() {
            var res = "";
            if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer1.from(this.base64Accum, "base64"), "utf16-be");
            this.inBase64 = false;
            this.base64Accum = "";
            return res;
        };
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/bom-handling.js" (__unused_rspack_module, exports1) {
        "use strict";
        var BOMChar = "\uFEFF";
        exports1.PrependBOM = PrependBOMWrapper;
        function PrependBOMWrapper(encoder, options) {
            this.encoder = encoder;
            this.addBOM = true;
        }
        PrependBOMWrapper.prototype.write = function(str) {
            if (this.addBOM) {
                str = BOMChar + str;
                this.addBOM = false;
            }
            return this.encoder.write(str);
        };
        PrependBOMWrapper.prototype.end = function() {
            return this.encoder.end();
        };
        exports1.StripBOM = StripBOMWrapper;
        function StripBOMWrapper(decoder, options) {
            this.decoder = decoder;
            this.pass = false;
            this.options = options || {};
        }
        StripBOMWrapper.prototype.write = function(buf) {
            var res = this.decoder.write(buf);
            if (this.pass || !res) return res;
            if (res[0] === BOMChar) {
                res = res.slice(1);
                if ("function" == typeof this.options.stripBOM) this.options.stripBOM();
            }
            this.pass = true;
            return res;
        };
        StripBOMWrapper.prototype.end = function() {
            return this.decoder.end();
        };
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/helpers/merge-exports.js" (module) {
        "use strict";
        var hasOwn = void 0 === Object.hasOwn ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn;
        function mergeModules(target, module) {
            for(var key in module)if (hasOwn(module, key)) target[key] = module[key];
        }
        module.exports = mergeModules;
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        var bomHandling = __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/bom-handling.js");
        var mergeModules = __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/helpers/merge-exports.js");
        var iconv = module.exports;
        iconv.encodings = null;
        iconv.defaultCharUnicode = "";
        iconv.defaultCharSingleByte = "?";
        iconv.encode = function(str, encoding, options) {
            str = "" + (str || "");
            var encoder = iconv.getEncoder(encoding, options);
            var res = encoder.write(str);
            var trail = encoder.end();
            return trail && trail.length > 0 ? Buffer1.concat([
                res,
                trail
            ]) : res;
        };
        iconv.decode = function(buf, encoding, options) {
            if ("string" == typeof buf) {
                if (!iconv.skipDecodeWarning) {
                    console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
                    iconv.skipDecodeWarning = true;
                }
                buf = Buffer1.from("" + (buf || ""), "binary");
            }
            var decoder = iconv.getDecoder(encoding, options);
            var res = decoder.write(buf);
            var trail = decoder.end();
            return trail ? res + trail : res;
        };
        iconv.encodingExists = function(enc) {
            try {
                iconv.getCodec(enc);
                return true;
            } catch (e) {
                return false;
            }
        };
        iconv.toEncoding = iconv.encode;
        iconv.fromEncoding = iconv.decode;
        iconv._codecDataCache = {
            __proto__: null
        };
        iconv.getCodec = function(encoding) {
            if (!iconv.encodings) {
                var raw = __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/index.js");
                iconv.encodings = {
                    __proto__: null
                };
                mergeModules(iconv.encodings, raw);
            }
            var enc = iconv._canonicalizeEncoding(encoding);
            var codecOptions = {};
            while(true){
                var codec = iconv._codecDataCache[enc];
                if (codec) return codec;
                var codecDef = iconv.encodings[enc];
                switch(typeof codecDef){
                    case "string":
                        enc = codecDef;
                        break;
                    case "object":
                        for(var key in codecDef)codecOptions[key] = codecDef[key];
                        if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                        enc = codecDef.type;
                        break;
                    case "function":
                        if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                        codec = new codecDef(codecOptions, iconv);
                        iconv._codecDataCache[codecOptions.encodingName] = codec;
                        return codec;
                    default:
                        throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
                }
            }
        };
        iconv._canonicalizeEncoding = function(encoding) {
            return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
        };
        iconv.getEncoder = function(encoding, options) {
            var codec = iconv.getCodec(encoding);
            var encoder = new codec.encoder(options, codec);
            if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
            return encoder;
        };
        iconv.getDecoder = function(encoding, options) {
            var codec = iconv.getCodec(encoding);
            var decoder = new codec.decoder(options, codec);
            if (codec.bomAware && !(options && false === options.stripBOM)) decoder = new bomHandling.StripBOM(decoder, options);
            return decoder;
        };
        iconv.enableStreamingAPI = function(streamModule) {
            if (iconv.supportsStreams) return;
            var streams = __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/streams.js")(streamModule);
            iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
            iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
            iconv.encodeStream = function(encoding, options) {
                return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
            };
            iconv.decodeStream = function(encoding, options) {
                return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
            };
            iconv.supportsStreams = true;
        };
        var streamModule;
        try {
            streamModule = __webpack_require__("stream");
        } catch (e) {}
        if (streamModule && streamModule.Transform) iconv.enableStreamingAPI(streamModule);
        else iconv.encodeStream = iconv.decodeStream = function() {
            throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
        };
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/streams.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        module.exports = function(streamModule) {
            var Transform = streamModule.Transform;
            function IconvLiteEncoderStream(conv, options) {
                this.conv = conv;
                options = options || {};
                options.decodeStrings = false;
                Transform.call(this, options);
            }
            IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
                constructor: {
                    value: IconvLiteEncoderStream
                }
            });
            IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
                if ("string" != typeof chunk) return done(new Error("Iconv encoding stream needs strings as its input."));
                try {
                    var res = this.conv.write(chunk);
                    if (res && res.length) this.push(res);
                    done();
                } catch (e) {
                    done(e);
                }
            };
            IconvLiteEncoderStream.prototype._flush = function(done) {
                try {
                    var res = this.conv.end();
                    if (res && res.length) this.push(res);
                    done();
                } catch (e) {
                    done(e);
                }
            };
            IconvLiteEncoderStream.prototype.collect = function(cb) {
                var chunks = [];
                this.on("error", cb);
                this.on("data", function(chunk) {
                    chunks.push(chunk);
                });
                this.on("end", function() {
                    cb(null, Buffer1.concat(chunks));
                });
                return this;
            };
            function IconvLiteDecoderStream(conv, options) {
                this.conv = conv;
                options = options || {};
                options.encoding = this.encoding = "utf8";
                Transform.call(this, options);
            }
            IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
                constructor: {
                    value: IconvLiteDecoderStream
                }
            });
            IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
                if (!Buffer1.isBuffer(chunk) && !(chunk instanceof Uint8Array)) return done(new Error("Iconv decoding stream needs buffers as its input."));
                try {
                    var res = this.conv.write(chunk);
                    if (res && res.length) this.push(res, this.encoding);
                    done();
                } catch (e) {
                    done(e);
                }
            };
            IconvLiteDecoderStream.prototype._flush = function(done) {
                try {
                    var res = this.conv.end();
                    if (res && res.length) this.push(res, this.encoding);
                    done();
                } catch (e) {
                    done(e);
                }
            };
            IconvLiteDecoderStream.prototype.collect = function(cb) {
                var res = "";
                this.on("error", cb);
                this.on("data", function(chunk) {
                    res += chunk;
                });
                this.on("end", function() {
                    cb(null, res);
                });
                return this;
            };
            return {
                IconvLiteEncoderStream: IconvLiteEncoderStream,
                IconvLiteDecoderStream: IconvLiteDecoderStream
            };
        };
    },
    "../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js" (module, __unused_rspack_exports, __webpack_require__) {
        try {
            var util = __webpack_require__("util");
            if ('function' != typeof util.inherits) throw '';
            module.exports = util.inherits;
        } catch (e) {
            module.exports = __webpack_require__("../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
        }
    },
    "../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js" (module) {
        if ('function' == typeof Object.create) module.exports = function(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            }
        };
        else module.exports = function(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            }
        };
    },
    "../../../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js" (module, __unused_rspack_exports, __webpack_require__) {
        module = __webpack_require__.nmd(module);
        (function() {
            var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
            ipaddr = {};
            root = this;
            if (null !== module && module.exports) module.exports = ipaddr;
            else root['ipaddr'] = ipaddr;
            matchCIDR = function(first, second, partSize, cidrBits) {
                var part, shift;
                if (first.length !== second.length) throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
                part = 0;
                while(cidrBits > 0){
                    shift = partSize - cidrBits;
                    if (shift < 0) shift = 0;
                    if (first[part] >> shift !== second[part] >> shift) return false;
                    cidrBits -= partSize;
                    part += 1;
                }
                return true;
            };
            ipaddr.subnetMatch = function(address, rangeList, defaultName) {
                var k, len, rangeName, rangeSubnets, subnet;
                if (null == defaultName) defaultName = 'unicast';
                for(rangeName in rangeList){
                    rangeSubnets = rangeList[rangeName];
                    if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) rangeSubnets = [
                        rangeSubnets
                    ];
                    for(k = 0, len = rangeSubnets.length; k < len; k++){
                        subnet = rangeSubnets[k];
                        if (address.kind() === subnet[0].kind()) {
                            if (address.match.apply(address, subnet)) return rangeName;
                        }
                    }
                }
                return defaultName;
            };
            ipaddr.IPv4 = function() {
                function IPv4(octets) {
                    var k, len, octet;
                    if (4 !== octets.length) throw new Error("ipaddr: ipv4 octet count should be 4");
                    for(k = 0, len = octets.length; k < len; k++){
                        octet = octets[k];
                        if (!(0 <= octet && octet <= 255)) throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
                    }
                    this.octets = octets;
                }
                IPv4.prototype.kind = function() {
                    return 'ipv4';
                };
                IPv4.prototype.toString = function() {
                    return this.octets.join(".");
                };
                IPv4.prototype.toNormalizedString = function() {
                    return this.toString();
                };
                IPv4.prototype.toByteArray = function() {
                    return this.octets.slice(0);
                };
                IPv4.prototype.match = function(other, cidrRange) {
                    var ref;
                    if (void 0 === cidrRange) ref = other, other = ref[0], cidrRange = ref[1];
                    if ('ipv4' !== other.kind()) throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
                    return matchCIDR(this.octets, other.octets, 8, cidrRange);
                };
                IPv4.prototype.SpecialRanges = {
                    unspecified: [
                        [
                            new IPv4([
                                0,
                                0,
                                0,
                                0
                            ]),
                            8
                        ]
                    ],
                    broadcast: [
                        [
                            new IPv4([
                                255,
                                255,
                                255,
                                255
                            ]),
                            32
                        ]
                    ],
                    multicast: [
                        [
                            new IPv4([
                                224,
                                0,
                                0,
                                0
                            ]),
                            4
                        ]
                    ],
                    linkLocal: [
                        [
                            new IPv4([
                                169,
                                254,
                                0,
                                0
                            ]),
                            16
                        ]
                    ],
                    loopback: [
                        [
                            new IPv4([
                                127,
                                0,
                                0,
                                0
                            ]),
                            8
                        ]
                    ],
                    carrierGradeNat: [
                        [
                            new IPv4([
                                100,
                                64,
                                0,
                                0
                            ]),
                            10
                        ]
                    ],
                    private: [
                        [
                            new IPv4([
                                10,
                                0,
                                0,
                                0
                            ]),
                            8
                        ],
                        [
                            new IPv4([
                                172,
                                16,
                                0,
                                0
                            ]),
                            12
                        ],
                        [
                            new IPv4([
                                192,
                                168,
                                0,
                                0
                            ]),
                            16
                        ]
                    ],
                    reserved: [
                        [
                            new IPv4([
                                192,
                                0,
                                0,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                192,
                                0,
                                2,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                192,
                                88,
                                99,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                198,
                                51,
                                100,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                203,
                                0,
                                113,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                240,
                                0,
                                0,
                                0
                            ]),
                            4
                        ]
                    ]
                };
                IPv4.prototype.range = function() {
                    return ipaddr.subnetMatch(this, this.SpecialRanges);
                };
                IPv4.prototype.toIPv4MappedAddress = function() {
                    return ipaddr.IPv6.parse("::ffff:" + this.toString());
                };
                IPv4.prototype.prefixLengthFromSubnetMask = function() {
                    var cidr, i, k, octet, stop, zeros, zerotable;
                    zerotable = {
                        0: 8,
                        128: 7,
                        192: 6,
                        224: 5,
                        240: 4,
                        248: 3,
                        252: 2,
                        254: 1,
                        255: 0
                    };
                    cidr = 0;
                    stop = false;
                    for(i = k = 3; k >= 0; i = k += -1){
                        octet = this.octets[i];
                        if (!(octet in zerotable)) return null;
                        zeros = zerotable[octet];
                        if (stop && 0 !== zeros) return null;
                        if (8 !== zeros) stop = true;
                        cidr += zeros;
                    }
                    return 32 - cidr;
                };
                return IPv4;
            }();
            ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
            ipv4Regexes = {
                fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
                longValue: new RegExp("^" + ipv4Part + "$", 'i')
            };
            ipaddr.IPv4.parser = function(string) {
                var match, parseIntAuto, part, shift, value;
                parseIntAuto = function(string) {
                    if ("0" === string[0] && "x" !== string[1]) return parseInt(string, 8);
                    return parseInt(string);
                };
                if (match = string.match(ipv4Regexes.fourOctet)) return function() {
                    var k, len, ref, results;
                    ref = match.slice(1, 6);
                    results = [];
                    for(k = 0, len = ref.length; k < len; k++){
                        part = ref[k];
                        results.push(parseIntAuto(part));
                    }
                    return results;
                }();
                if (!(match = string.match(ipv4Regexes.longValue))) return null;
                value = parseIntAuto(match[1]);
                if (value > 0xffffffff || value < 0) throw new Error("ipaddr: address outside defined range");
                return (function() {
                    var k, results;
                    results = [];
                    for(shift = k = 0; k <= 24; shift = k += 8)results.push(value >> shift & 0xff);
                    return results;
                })().reverse();
            };
            ipaddr.IPv6 = function() {
                function IPv6(parts, zoneId) {
                    var i, k, l, len, part, ref;
                    if (16 === parts.length) {
                        this.parts = [];
                        for(i = k = 0; k <= 14; i = k += 2)this.parts.push(parts[i] << 8 | parts[i + 1]);
                    } else if (8 === parts.length) this.parts = parts;
                    else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
                    ref = this.parts;
                    for(l = 0, len = ref.length; l < len; l++){
                        part = ref[l];
                        if (!(0 <= part && part <= 0xffff)) throw new Error("ipaddr: ipv6 part should fit in 16 bits");
                    }
                    if (zoneId) this.zoneId = zoneId;
                }
                IPv6.prototype.kind = function() {
                    return 'ipv6';
                };
                IPv6.prototype.toString = function() {
                    return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
                };
                IPv6.prototype.toRFC5952String = function() {
                    var bestMatchIndex, bestMatchLength, match, regex, string;
                    regex = /((^|:)(0(:|$)){2,})/g;
                    string = this.toNormalizedString();
                    bestMatchIndex = 0;
                    bestMatchLength = -1;
                    while(match = regex.exec(string))if (match[0].length > bestMatchLength) {
                        bestMatchIndex = match.index;
                        bestMatchLength = match[0].length;
                    }
                    if (bestMatchLength < 0) return string;
                    return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
                };
                IPv6.prototype.toByteArray = function() {
                    var bytes, k, len, part, ref;
                    bytes = [];
                    ref = this.parts;
                    for(k = 0, len = ref.length; k < len; k++){
                        part = ref[k];
                        bytes.push(part >> 8);
                        bytes.push(0xff & part);
                    }
                    return bytes;
                };
                IPv6.prototype.toNormalizedString = function() {
                    var addr, part, suffix;
                    addr = (function() {
                        var k, len, ref, results;
                        ref = this.parts;
                        results = [];
                        for(k = 0, len = ref.length; k < len; k++){
                            part = ref[k];
                            results.push(part.toString(16));
                        }
                        return results;
                    }).call(this).join(":");
                    suffix = '';
                    if (this.zoneId) suffix = '%' + this.zoneId;
                    return addr + suffix;
                };
                IPv6.prototype.toFixedLengthString = function() {
                    var addr, part, suffix;
                    addr = (function() {
                        var k, len, ref, results;
                        ref = this.parts;
                        results = [];
                        for(k = 0, len = ref.length; k < len; k++){
                            part = ref[k];
                            results.push(part.toString(16).padStart(4, '0'));
                        }
                        return results;
                    }).call(this).join(":");
                    suffix = '';
                    if (this.zoneId) suffix = '%' + this.zoneId;
                    return addr + suffix;
                };
                IPv6.prototype.match = function(other, cidrRange) {
                    var ref;
                    if (void 0 === cidrRange) ref = other, other = ref[0], cidrRange = ref[1];
                    if ('ipv6' !== other.kind()) throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
                    return matchCIDR(this.parts, other.parts, 16, cidrRange);
                };
                IPv6.prototype.SpecialRanges = {
                    unspecified: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        128
                    ],
                    linkLocal: [
                        new IPv6([
                            0xfe80,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        10
                    ],
                    multicast: [
                        new IPv6([
                            0xff00,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        8
                    ],
                    loopback: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]),
                        128
                    ],
                    uniqueLocal: [
                        new IPv6([
                            0xfc00,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        7
                    ],
                    ipv4Mapped: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0,
                            0xffff,
                            0,
                            0
                        ]),
                        96
                    ],
                    rfc6145: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0xffff,
                            0,
                            0,
                            0
                        ]),
                        96
                    ],
                    rfc6052: [
                        new IPv6([
                            0x64,
                            0xff9b,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        96
                    ],
                    '6to4': [
                        new IPv6([
                            0x2002,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        16
                    ],
                    teredo: [
                        new IPv6([
                            0x2001,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        32
                    ],
                    reserved: [
                        [
                            new IPv6([
                                0x2001,
                                0xdb8,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
                            ]),
                            32
                        ]
                    ]
                };
                IPv6.prototype.range = function() {
                    return ipaddr.subnetMatch(this, this.SpecialRanges);
                };
                IPv6.prototype.isIPv4MappedAddress = function() {
                    return 'ipv4Mapped' === this.range();
                };
                IPv6.prototype.toIPv4Address = function() {
                    var high, low, ref;
                    if (!this.isIPv4MappedAddress()) throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
                    ref = this.parts.slice(-2), high = ref[0], low = ref[1];
                    return new ipaddr.IPv4([
                        high >> 8,
                        0xff & high,
                        low >> 8,
                        0xff & low
                    ]);
                };
                IPv6.prototype.prefixLengthFromSubnetMask = function() {
                    var cidr, i, k, part, stop, zeros, zerotable;
                    zerotable = {
                        0: 16,
                        32768: 15,
                        49152: 14,
                        57344: 13,
                        61440: 12,
                        63488: 11,
                        64512: 10,
                        65024: 9,
                        65280: 8,
                        65408: 7,
                        65472: 6,
                        65504: 5,
                        65520: 4,
                        65528: 3,
                        65532: 2,
                        65534: 1,
                        65535: 0
                    };
                    cidr = 0;
                    stop = false;
                    for(i = k = 7; k >= 0; i = k += -1){
                        part = this.parts[i];
                        if (!(part in zerotable)) return null;
                        zeros = zerotable[part];
                        if (stop && 0 !== zeros) return null;
                        if (16 !== zeros) stop = true;
                        cidr += zeros;
                    }
                    return 128 - cidr;
                };
                return IPv6;
            }();
            ipv6Part = "(?:[0-9a-f]+::?)+";
            zoneIndex = "%[0-9a-z]{1,}";
            ipv6Regexes = {
                zoneIndex: new RegExp(zoneIndex, 'i'),
                native: new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
                transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + "\\." + ipv4Part + "(" + zoneIndex + ")?$", 'i')
            };
            expandIPv6 = function(string, parts) {
                var colonCount, lastColon, part, replacement, replacementCount, zoneId;
                if (string.indexOf('::') !== string.lastIndexOf('::')) return null;
                zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
                if (zoneId) {
                    zoneId = zoneId.substring(1);
                    string = string.replace(/%.+$/, '');
                }
                colonCount = 0;
                lastColon = -1;
                while((lastColon = string.indexOf(':', lastColon + 1)) >= 0)colonCount++;
                if ('::' === string.substr(0, 2)) colonCount--;
                if ('::' === string.substr(-2, 2)) colonCount--;
                if (colonCount > parts) return null;
                replacementCount = parts - colonCount;
                replacement = ':';
                while(replacementCount--)replacement += '0:';
                string = string.replace('::', replacement);
                if (':' === string[0]) string = string.slice(1);
                if (':' === string[string.length - 1]) string = string.slice(0, -1);
                parts = function() {
                    var k, len, ref, results;
                    ref = string.split(":");
                    results = [];
                    for(k = 0, len = ref.length; k < len; k++){
                        part = ref[k];
                        results.push(parseInt(part, 16));
                    }
                    return results;
                }();
                return {
                    parts: parts,
                    zoneId: zoneId
                };
            };
            ipaddr.IPv6.parser = function(string) {
                var addr, k, len, match, octet, octets, zoneId;
                if (ipv6Regexes['native'].test(string)) return expandIPv6(string, 8);
                if (match = string.match(ipv6Regexes['transitional'])) {
                    zoneId = match[6] || '';
                    addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
                    if (addr.parts) {
                        octets = [
                            parseInt(match[2]),
                            parseInt(match[3]),
                            parseInt(match[4]),
                            parseInt(match[5])
                        ];
                        for(k = 0, len = octets.length; k < len; k++){
                            octet = octets[k];
                            if (!(0 <= octet && octet <= 255)) return null;
                        }
                        addr.parts.push(octets[0] << 8 | octets[1]);
                        addr.parts.push(octets[2] << 8 | octets[3]);
                        return {
                            parts: addr.parts,
                            zoneId: addr.zoneId
                        };
                    }
                }
                return null;
            };
            ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
                return null !== this.parser(string);
            };
            ipaddr.IPv4.isValid = function(string) {
                try {
                    new this(this.parser(string));
                    return true;
                } catch (error1) {
                    return false;
                }
            };
            ipaddr.IPv4.isValidFourPartDecimal = function(string) {
                if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) return true;
                return false;
            };
            ipaddr.IPv6.isValid = function(string) {
                var addr;
                if ("string" == typeof string && -1 === string.indexOf(":")) return false;
                try {
                    addr = this.parser(string);
                    new this(addr.parts, addr.zoneId);
                    return true;
                } catch (error1) {
                    return false;
                }
            };
            ipaddr.IPv4.parse = function(string) {
                var parts;
                parts = this.parser(string);
                if (null === parts) throw new Error("ipaddr: string is not formatted like ip address");
                return new this(parts);
            };
            ipaddr.IPv6.parse = function(string) {
                var addr;
                addr = this.parser(string);
                if (null === addr.parts) throw new Error("ipaddr: string is not formatted like ip address");
                return new this(addr.parts, addr.zoneId);
            };
            ipaddr.IPv4.parseCIDR = function(string) {
                var maskLength, match, parsed;
                if (match = string.match(/^(.+)\/(\d+)$/)) {
                    maskLength = parseInt(match[2]);
                    if (maskLength >= 0 && maskLength <= 32) {
                        parsed = [
                            this.parse(match[1]),
                            maskLength
                        ];
                        Object.defineProperty(parsed, 'toString', {
                            value: function() {
                                return this.join('/');
                            }
                        });
                        return parsed;
                    }
                }
                throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
            };
            ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
                var filledOctetCount, j, octets;
                prefix = parseInt(prefix);
                if (prefix < 0 || prefix > 32) throw new Error('ipaddr: invalid IPv4 prefix length');
                octets = [
                    0,
                    0,
                    0,
                    0
                ];
                j = 0;
                filledOctetCount = Math.floor(prefix / 8);
                while(j < filledOctetCount){
                    octets[j] = 255;
                    j++;
                }
                if (filledOctetCount < 4) octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
                return new this(octets);
            };
            ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
                var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
                try {
                    cidr = this.parseCIDR(string);
                    ipInterfaceOctets = cidr[0].toByteArray();
                    subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
                    octets = [];
                    i = 0;
                    while(i < 4){
                        octets.push(parseInt(ipInterfaceOctets[i], 10) | 255 ^ parseInt(subnetMaskOctets[i], 10));
                        i++;
                    }
                    return new this(octets);
                } catch (error1) {
                    throw new Error('ipaddr: the address does not have IPv4 CIDR format');
                }
            };
            ipaddr.IPv4.networkAddressFromCIDR = function(string) {
                var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
                try {
                    cidr = this.parseCIDR(string);
                    ipInterfaceOctets = cidr[0].toByteArray();
                    subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
                    octets = [];
                    i = 0;
                    while(i < 4){
                        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
                        i++;
                    }
                    return new this(octets);
                } catch (error1) {
                    throw new Error('ipaddr: the address does not have IPv4 CIDR format');
                }
            };
            ipaddr.IPv6.parseCIDR = function(string) {
                var maskLength, match, parsed;
                if (match = string.match(/^(.+)\/(\d+)$/)) {
                    maskLength = parseInt(match[2]);
                    if (maskLength >= 0 && maskLength <= 128) {
                        parsed = [
                            this.parse(match[1]),
                            maskLength
                        ];
                        Object.defineProperty(parsed, 'toString', {
                            value: function() {
                                return this.join('/');
                            }
                        });
                        return parsed;
                    }
                }
                throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
            };
            ipaddr.isValid = function(string) {
                return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
            };
            ipaddr.parse = function(string) {
                if (ipaddr.IPv6.isValid(string)) return ipaddr.IPv6.parse(string);
                if (ipaddr.IPv4.isValid(string)) return ipaddr.IPv4.parse(string);
                throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
            };
            ipaddr.parseCIDR = function(string) {
                try {
                    return ipaddr.IPv6.parseCIDR(string);
                } catch (error1) {
                    try {
                        return ipaddr.IPv4.parseCIDR(string);
                    } catch (error1) {
                        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
                    }
                }
            };
            ipaddr.fromByteArray = function(bytes) {
                var length;
                length = bytes.length;
                if (4 === length) return new ipaddr.IPv4(bytes);
                if (16 === length) return new ipaddr.IPv6(bytes);
                throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
            };
            ipaddr.process = function(string) {
                var addr;
                addr = this.parse(string);
                if ('ipv6' === addr.kind() && addr.isIPv4MappedAddress()) return addr.toIPv4Address();
                return addr;
            };
        }).call(this);
    },
    "../../../node_modules/.pnpm/is-promise@4.0.0/node_modules/is-promise/index.js" (module) {
        module.exports = isPromise;
        module.exports["default"] = isPromise;
        function isPromise(obj) {
            return !!obj && ('object' == typeof obj || 'function' == typeof obj) && 'function' == typeof obj.then;
        }
    },
    "../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js" (module) {
        "use strict";
        module.exports = Math.abs;
    },
    "../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js" (module) {
        "use strict";
        module.exports = Math.floor;
    },
    "../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js" (module) {
        "use strict";
        module.exports = Number.isNaN || function(a) {
            return a !== a;
        };
    },
    "../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js" (module) {
        "use strict";
        module.exports = Math.max;
    },
    "../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js" (module) {
        "use strict";
        module.exports = Math.min;
    },
    "../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js" (module) {
        "use strict";
        module.exports = Math.pow;
    },
    "../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js" (module) {
        "use strict";
        module.exports = Math.round;
    },
    "../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var $isNaN = __webpack_require__("../../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js");
        module.exports = function(number) {
            if ($isNaN(number) || 0 === number) return number;
            return number < 0 ? -1 : 1;
        };
    },
    "../../../node_modules/.pnpm/media-typer@1.1.0/node_modules/media-typer/index.js" (__unused_rspack_module, exports1) {
        "use strict";
        /*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
        var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
        var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
        exports1.format = format;
        exports1.parse = parse;
        exports1.test = test;
        function format(obj) {
            if (!obj || 'object' != typeof obj) throw new TypeError('argument obj is required');
            var subtype = obj.subtype;
            var suffix = obj.suffix;
            var type = obj.type;
            if (!type || !TYPE_NAME_REGEXP.test(type)) throw new TypeError('invalid type');
            if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) throw new TypeError('invalid subtype');
            var string = type + '/' + subtype;
            if (suffix) {
                if (!TYPE_NAME_REGEXP.test(suffix)) throw new TypeError('invalid suffix');
                string += '+' + suffix;
            }
            return string;
        }
        function test(string) {
            if (!string) throw new TypeError('argument string is required');
            if ('string' != typeof string) throw new TypeError('argument string is required to be a string');
            return TYPE_REGEXP.test(string.toLowerCase());
        }
        function parse(string) {
            if (!string) throw new TypeError('argument string is required');
            if ('string' != typeof string) throw new TypeError('argument string is required to be a string');
            var match = TYPE_REGEXP.exec(string.toLowerCase());
            if (!match) throw new TypeError('invalid media type');
            var type = match[1];
            var subtype = match[2];
            var suffix;
            var index = subtype.lastIndexOf('+');
            if (-1 !== index) {
                suffix = subtype.substr(index + 1);
                subtype = subtype.substr(0, index);
            }
            return new MediaType(type, subtype, suffix);
        }
        function MediaType(type, subtype, suffix) {
            this.type = type;
            this.subtype = subtype;
            this.suffix = suffix;
        }
    },
    "../../../node_modules/.pnpm/merge-descriptors@2.0.0/node_modules/merge-descriptors/index.js" (module) {
        "use strict";
        function mergeDescriptors(destination, source, overwrite = true) {
            if (!destination) throw new TypeError('The `destination` argument is required.');
            if (!source) throw new TypeError('The `source` argument is required.');
            for (const name of Object.getOwnPropertyNames(source)){
                if (!overwrite && Object.hasOwn(destination, name)) continue;
                const descriptor = Object.getOwnPropertyDescriptor(source, name);
                Object.defineProperty(destination, name, descriptor);
            }
            return destination;
        }
        module.exports = mergeDescriptors;
    },
    "../../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        /*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = __webpack_require__("../../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json");
    },
    "../../../node_modules/.pnpm/mime-db@1.54.0/node_modules/mime-db/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        /*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = __webpack_require__("../../../node_modules/.pnpm/mime-db@1.54.0/node_modules/mime-db/db.json");
    },
    "../../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var db = __webpack_require__("../../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js");
        var extname = __webpack_require__("path").extname;
        var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
        var TEXT_TYPE_REGEXP = /^text\//i;
        exports1.charset = charset;
        exports1.charsets = {
            lookup: charset
        };
        exports1.contentType = contentType;
        exports1.extension = extension;
        exports1.extensions = Object.create(null);
        exports1.lookup = lookup;
        exports1.types = Object.create(null);
        populateMaps(exports1.extensions, exports1.types);
        function charset(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var mime = match && db[match[1].toLowerCase()];
            if (mime && mime.charset) return mime.charset;
            if (match && TEXT_TYPE_REGEXP.test(match[1])) return 'UTF-8';
            return false;
        }
        function contentType(str) {
            if (!str || 'string' != typeof str) return false;
            var mime = -1 === str.indexOf('/') ? exports1.lookup(str) : str;
            if (!mime) return false;
            if (-1 === mime.indexOf('charset')) {
                var charset = exports1.charset(mime);
                if (charset) mime += '; charset=' + charset.toLowerCase();
            }
            return mime;
        }
        function extension(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var exts = match && exports1.extensions[match[1].toLowerCase()];
            if (!exts || !exts.length) return false;
            return exts[0];
        }
        function lookup(path) {
            if (!path || 'string' != typeof path) return false;
            var extension = extname('x.' + path).toLowerCase().substr(1);
            if (!extension) return false;
            return exports1.types[extension] || false;
        }
        function populateMaps(extensions, types) {
            var preference = [
                'nginx',
                'apache',
                void 0,
                'iana'
            ];
            Object.keys(db).forEach(function(type) {
                var mime = db[type];
                var exts = mime.extensions;
                if (!exts || !exts.length) return;
                extensions[type] = exts;
                for(var i = 0; i < exts.length; i++){
                    var extension = exts[i];
                    if (types[extension]) {
                        var from = preference.indexOf(db[types[extension]].source);
                        var to = preference.indexOf(mime.source);
                        if ('application/octet-stream' !== types[extension] && (from > to || from === to && 'application/' === types[extension].substr(0, 12))) continue;
                    }
                    types[extension] = type;
                }
            });
        }
    },
    "../../../node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/index.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var db = __webpack_require__("../../../node_modules/.pnpm/mime-db@1.54.0/node_modules/mime-db/index.js");
        var extname = __webpack_require__("path").extname;
        var mimeScore = __webpack_require__("../../../node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/mimeScore.js");
        var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
        var TEXT_TYPE_REGEXP = /^text\//i;
        exports1.charset = charset;
        exports1.charsets = {
            lookup: charset
        };
        exports1.contentType = contentType;
        exports1.extension = extension;
        exports1.extensions = Object.create(null);
        exports1.lookup = lookup;
        exports1.types = Object.create(null);
        exports1._extensionConflicts = [];
        populateMaps(exports1.extensions, exports1.types);
        function charset(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var mime = match && db[match[1].toLowerCase()];
            if (mime && mime.charset) return mime.charset;
            if (match && TEXT_TYPE_REGEXP.test(match[1])) return 'UTF-8';
            return false;
        }
        function contentType(str) {
            if (!str || 'string' != typeof str) return false;
            var mime = -1 === str.indexOf('/') ? exports1.lookup(str) : str;
            if (!mime) return false;
            if (-1 === mime.indexOf('charset')) {
                var charset = exports1.charset(mime);
                if (charset) mime += '; charset=' + charset.toLowerCase();
            }
            return mime;
        }
        function extension(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var exts = match && exports1.extensions[match[1].toLowerCase()];
            if (!exts || !exts.length) return false;
            return exts[0];
        }
        function lookup(path) {
            if (!path || 'string' != typeof path) return false;
            var extension = extname('x.' + path).toLowerCase().slice(1);
            if (!extension) return false;
            return exports1.types[extension] || false;
        }
        function populateMaps(extensions, types) {
            Object.keys(db).forEach(function(type) {
                var mime = db[type];
                var exts = mime.extensions;
                if (!exts || !exts.length) return;
                extensions[type] = exts;
                for(var i = 0; i < exts.length; i++){
                    var extension = exts[i];
                    types[extension] = _preferredType(extension, types[extension], type);
                    const legacyType = _preferredTypeLegacy(extension, types[extension], type);
                    if (legacyType !== types[extension]) exports1._extensionConflicts.push([
                        extension,
                        legacyType,
                        types[extension]
                    ]);
                }
            });
        }
        function _preferredType(ext, type0, type1) {
            var score0 = type0 ? mimeScore(type0, db[type0].source) : 0;
            var score1 = type1 ? mimeScore(type1, db[type1].source) : 0;
            return score0 > score1 ? type0 : type1;
        }
        function _preferredTypeLegacy(ext, type0, type1) {
            var SOURCE_RANK = [
                'nginx',
                'apache',
                void 0,
                'iana'
            ];
            var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
            var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
            if ('application/octet-stream' !== exports1.types[extension] && (score0 > score1 || score0 === score1 && exports1.types[extension]?.slice(0, 12) === 'application/')) return type0;
            return score0 > score1 ? type0 : type1;
        }
    },
    "../../../node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/mimeScore.js" (module) {
        var FACET_SCORES = {
            'prs.': 100,
            'x-': 200,
            'x.': 300,
            'vnd.': 400,
            default: 900
        };
        var SOURCE_SCORES = {
            nginx: 10,
            apache: 20,
            iana: 40,
            default: 30
        };
        var TYPE_SCORES = {
            application: 1,
            font: 2,
            default: 0
        };
        module.exports = function(mimeType, source = 'default') {
            if ('application/octet-stream' === mimeType) return 0;
            const [type, subtype] = mimeType.split('/');
            const facet = subtype.replace(/(\.|x-).*/, '$1');
            const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
            const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
            const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default;
            const lengthScore = 1 - mimeType.length / 100;
            return facetScore + sourceScore + typeScore + lengthScore;
        };
    },
    "../../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js" (module, __unused_rspack_exports, __webpack_require__) {
        module.exports = minimatch;
        minimatch.Minimatch = Minimatch;
        var path = function() {
            try {
                return __webpack_require__("path");
            } catch (e) {}
        }() || {
            sep: '/'
        };
        minimatch.sep = path.sep;
        var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
        var expand = __webpack_require__("../../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js");
        var plTypes = {
            '!': {
                open: '(?:(?!(?:',
                close: '))[^/]*?)'
            },
            '?': {
                open: '(?:',
                close: ')?'
            },
            '+': {
                open: '(?:',
                close: ')+'
            },
            '*': {
                open: '(?:',
                close: ')*'
            },
            '@': {
                open: '(?:',
                close: ')'
            }
        };
        var qmark = '[^/]';
        var star = qmark + '*?';
        var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';
        var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';
        var reSpecials = charSet('().*{}+?[]^$\\!');
        function charSet(s) {
            return s.split('').reduce(function(set, c) {
                set[c] = true;
                return set;
            }, {});
        }
        var slashSplit = /\/+/;
        minimatch.filter = filter;
        function filter(pattern, options) {
            options = options || {};
            return function(p, i, list) {
                return minimatch(p, pattern, options);
            };
        }
        function ext(a, b) {
            b = b || {};
            var t = {};
            Object.keys(a).forEach(function(k) {
                t[k] = a[k];
            });
            Object.keys(b).forEach(function(k) {
                t[k] = b[k];
            });
            return t;
        }
        minimatch.defaults = function(def) {
            if (!def || 'object' != typeof def || !Object.keys(def).length) return minimatch;
            var orig = minimatch;
            var m = function(p, pattern, options) {
                return orig(p, pattern, ext(def, options));
            };
            m.Minimatch = function(pattern, options) {
                return new orig.Minimatch(pattern, ext(def, options));
            };
            m.Minimatch.defaults = function(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            };
            m.filter = function(pattern, options) {
                return orig.filter(pattern, ext(def, options));
            };
            m.defaults = function(options) {
                return orig.defaults(ext(def, options));
            };
            m.makeRe = function(pattern, options) {
                return orig.makeRe(pattern, ext(def, options));
            };
            m.braceExpand = function(pattern, options) {
                return orig.braceExpand(pattern, ext(def, options));
            };
            m.match = function(list, pattern, options) {
                return orig.match(list, pattern, ext(def, options));
            };
            return m;
        };
        Minimatch.defaults = function(def) {
            return minimatch.defaults(def).Minimatch;
        };
        function minimatch(p, pattern, options) {
            assertValidPattern(pattern);
            if (!options) options = {};
            if (!options.nocomment && '#' === pattern.charAt(0)) return false;
            return new Minimatch(pattern, options).match(p);
        }
        function Minimatch(pattern, options) {
            if (!(this instanceof Minimatch)) return new Minimatch(pattern, options);
            assertValidPattern(pattern);
            if (!options) options = {};
            pattern = pattern.trim();
            if (!options.allowWindowsEscape && '/' !== path.sep) pattern = pattern.split(path.sep).join('/');
            this.options = options;
            this.set = [];
            this.pattern = pattern;
            this.regexp = null;
            this.negate = false;
            this.comment = false;
            this.empty = false;
            this.partial = !!options.partial;
            this.make();
        }
        Minimatch.prototype.debug = function() {};
        Minimatch.prototype.make = make;
        function make() {
            var pattern = this.pattern;
            var options = this.options;
            if (!options.nocomment && '#' === pattern.charAt(0)) {
                this.comment = true;
                return;
            }
            if (!pattern) {
                this.empty = true;
                return;
            }
            this.parseNegate();
            var set = this.globSet = this.braceExpand();
            if (options.debug) this.debug = function() {
                console.error.apply(console, arguments);
            };
            this.debug(this.pattern, set);
            set = this.globParts = set.map(function(s) {
                return s.split(slashSplit);
            });
            this.debug(this.pattern, set);
            set = set.map(function(s, si, set) {
                return s.map(this.parse, this);
            }, this);
            this.debug(this.pattern, set);
            set = set.filter(function(s) {
                return -1 === s.indexOf(false);
            });
            this.debug(this.pattern, set);
            this.set = set;
        }
        Minimatch.prototype.parseNegate = parseNegate;
        function parseNegate() {
            var pattern = this.pattern;
            var negate = false;
            var options = this.options;
            var negateOffset = 0;
            if (options.nonegate) return;
            for(var i = 0, l = pattern.length; i < l && '!' === pattern.charAt(i); i++){
                negate = !negate;
                negateOffset++;
            }
            if (negateOffset) this.pattern = pattern.substr(negateOffset);
            this.negate = negate;
        }
        minimatch.braceExpand = function(pattern, options) {
            return braceExpand(pattern, options);
        };
        Minimatch.prototype.braceExpand = braceExpand;
        function braceExpand(pattern, options) {
            if (!options) options = this instanceof Minimatch ? this.options : {};
            pattern = void 0 === pattern ? this.pattern : pattern;
            assertValidPattern(pattern);
            if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) return [
                pattern
            ];
            return expand(pattern);
        }
        var MAX_PATTERN_LENGTH = 65536;
        var assertValidPattern = function(pattern) {
            if ('string' != typeof pattern) throw new TypeError('invalid pattern');
            if (pattern.length > MAX_PATTERN_LENGTH) throw new TypeError('pattern is too long');
        };
        Minimatch.prototype.parse = parse;
        var SUBPARSE = {};
        function parse(pattern, isSub) {
            assertValidPattern(pattern);
            var options = this.options;
            if ('**' === pattern) if (!options.noglobstar) return GLOBSTAR;
            else pattern = '*';
            if ('' === pattern) return '';
            var re = '';
            var hasMagic = !!options.nocase;
            var escaping = false;
            var patternListStack = [];
            var negativeLists = [];
            var stateChar;
            var inClass = false;
            var reClassStart = -1;
            var classStart = -1;
            var patternStart = '.' === pattern.charAt(0) ? '' : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
            var self1 = this;
            function clearStateChar() {
                if (stateChar) {
                    switch(stateChar){
                        case '*':
                            re += star;
                            hasMagic = true;
                            break;
                        case '?':
                            re += qmark;
                            hasMagic = true;
                            break;
                        default:
                            re += '\\' + stateChar;
                            break;
                    }
                    self1.debug('clearStateChar %j %j', stateChar, re);
                    stateChar = false;
                }
            }
            for(var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++){
                this.debug('%s\t%s %s %j', pattern, i, re, c);
                if (escaping && reSpecials[c]) {
                    re += '\\' + c;
                    escaping = false;
                    continue;
                }
                switch(c){
                    case '/':
                        return false;
                    case '\\':
                        clearStateChar();
                        escaping = true;
                        continue;
                    case '?':
                    case '*':
                    case '+':
                    case '@':
                    case '!':
                        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);
                        if (inClass) {
                            this.debug('  in class');
                            if ('!' === c && i === classStart + 1) c = '^';
                            re += c;
                            continue;
                        }
                        self1.debug('call clearStateChar %j', stateChar);
                        clearStateChar();
                        stateChar = c;
                        if (options.noext) clearStateChar();
                        continue;
                    case '(':
                        if (inClass) {
                            re += '(';
                            continue;
                        }
                        if (!stateChar) {
                            re += '\\(';
                            continue;
                        }
                        patternListStack.push({
                            type: stateChar,
                            start: i - 1,
                            reStart: re.length,
                            open: plTypes[stateChar].open,
                            close: plTypes[stateChar].close
                        });
                        re += '!' === stateChar ? '(?:(?!(?:' : '(?:';
                        this.debug('plType %j %j', stateChar, re);
                        stateChar = false;
                        continue;
                    case ')':
                        if (inClass || !patternListStack.length) {
                            re += '\\)';
                            continue;
                        }
                        clearStateChar();
                        hasMagic = true;
                        var pl = patternListStack.pop();
                        re += pl.close;
                        if ('!' === pl.type) negativeLists.push(pl);
                        pl.reEnd = re.length;
                        continue;
                    case '|':
                        if (inClass || !patternListStack.length || escaping) {
                            re += '\\|';
                            escaping = false;
                            continue;
                        }
                        clearStateChar();
                        re += '|';
                        continue;
                    case '[':
                        clearStateChar();
                        if (inClass) {
                            re += '\\' + c;
                            continue;
                        }
                        inClass = true;
                        classStart = i;
                        reClassStart = re.length;
                        re += c;
                        continue;
                    case ']':
                        if (i === classStart + 1 || !inClass) {
                            re += '\\' + c;
                            escaping = false;
                            continue;
                        }
                        var cs = pattern.substring(classStart + 1, i);
                        try {
                            RegExp('[' + cs + ']');
                        } catch (er) {
                            var sp = this.parse(cs, SUBPARSE);
                            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
                            hasMagic = hasMagic || sp[1];
                            inClass = false;
                            continue;
                        }
                        hasMagic = true;
                        inClass = false;
                        re += c;
                        continue;
                    default:
                        clearStateChar();
                        if (escaping) escaping = false;
                        else if (reSpecials[c] && !('^' === c && inClass)) re += '\\';
                        re += c;
                }
            }
            if (inClass) {
                cs = pattern.substr(classStart + 1);
                sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + '\\[' + sp[0];
                hasMagic = hasMagic || sp[1];
            }
            for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){
                var tail = re.slice(pl.reStart + pl.open.length);
                this.debug('setting tail', re, pl);
                tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
                    if (!$2) $2 = '\\';
                    return $1 + $1 + $2 + '|';
                });
                this.debug('tail=%j\n   %s', tail, tail, pl, re);
                var t = '*' === pl.type ? star : '?' === pl.type ? qmark : '\\' + pl.type;
                hasMagic = true;
                re = re.slice(0, pl.reStart) + t + '\\(' + tail;
            }
            clearStateChar();
            if (escaping) re += '\\\\';
            var addPatternStart = false;
            switch(re.charAt(0)){
                case '[':
                case '.':
                case '(':
                    addPatternStart = true;
            }
            for(var n = negativeLists.length - 1; n > -1; n--){
                var nl = negativeLists[n];
                var nlBefore = re.slice(0, nl.reStart);
                var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
                var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
                var nlAfter = re.slice(nl.reEnd);
                nlLast += nlAfter;
                var openParensBefore = nlBefore.split('(').length - 1;
                var cleanAfter = nlAfter;
                for(i = 0; i < openParensBefore; i++)cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
                nlAfter = cleanAfter;
                var dollar = '';
                if ('' === nlAfter && isSub !== SUBPARSE) dollar = '$';
                var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
                re = newRe;
            }
            if ('' !== re && hasMagic) re = '(?=.)' + re;
            if (addPatternStart) re = patternStart + re;
            if (isSub === SUBPARSE) return [
                re,
                hasMagic
            ];
            if (!hasMagic) return globUnescape(pattern);
            var flags = options.nocase ? 'i' : '';
            try {
                var regExp = new RegExp('^' + re + '$', flags);
            } catch (er) {
                return new RegExp('$.');
            }
            regExp._glob = pattern;
            regExp._src = re;
            return regExp;
        }
        minimatch.makeRe = function(pattern, options) {
            return new Minimatch(pattern, options || {}).makeRe();
        };
        Minimatch.prototype.makeRe = makeRe;
        function makeRe() {
            if (this.regexp || false === this.regexp) return this.regexp;
            var set = this.set;
            if (!set.length) {
                this.regexp = false;
                return this.regexp;
            }
            var options = this.options;
            var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
            var flags = options.nocase ? 'i' : '';
            var re = set.map(function(pattern) {
                return pattern.map(function(p) {
                    return p === GLOBSTAR ? twoStar : 'string' == typeof p ? regExpEscape(p) : p._src;
                }).join('\\\/');
            }).join('|');
            re = '^(?:' + re + ')$';
            if (this.negate) re = '^(?!' + re + ').*$';
            try {
                this.regexp = new RegExp(re, flags);
            } catch (ex) {
                this.regexp = false;
            }
            return this.regexp;
        }
        minimatch.match = function(list, pattern, options) {
            options = options || {};
            var mm = new Minimatch(pattern, options);
            list = list.filter(function(f) {
                return mm.match(f);
            });
            if (mm.options.nonull && !list.length) list.push(pattern);
            return list;
        };
        Minimatch.prototype.match = function(f, partial) {
            if (void 0 === partial) partial = this.partial;
            this.debug('match', f, this.pattern);
            if (this.comment) return false;
            if (this.empty) return '' === f;
            if ('/' === f && partial) return true;
            var options = this.options;
            if ('/' !== path.sep) f = f.split(path.sep).join('/');
            f = f.split(slashSplit);
            this.debug(this.pattern, 'split', f);
            var set = this.set;
            this.debug(this.pattern, 'set', set);
            var filename;
            var i;
            for(i = f.length - 1; i >= 0; i--){
                filename = f[i];
                if (filename) break;
            }
            for(i = 0; i < set.length; i++){
                var pattern = set[i];
                var file = f;
                if (options.matchBase && 1 === pattern.length) file = [
                    filename
                ];
                var hit = this.matchOne(file, pattern, partial);
                if (hit) {
                    if (options.flipNegate) return true;
                    return !this.negate;
                }
            }
            if (options.flipNegate) return false;
            return this.negate;
        };
        Minimatch.prototype.matchOne = function(file, pattern, partial) {
            var options = this.options;
            this.debug('matchOne', {
                this: this,
                file: file,
                pattern: pattern
            });
            this.debug('matchOne', file.length, pattern.length);
            for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){
                this.debug('matchOne loop');
                var p = pattern[pi];
                var f = file[fi];
                this.debug(pattern, p, f);
                if (false === p) return false;
                if (p === GLOBSTAR) {
                    this.debug('GLOBSTAR', [
                        pattern,
                        p,
                        f
                    ]);
                    var fr = fi;
                    var pr = pi + 1;
                    if (pr === pl) {
                        this.debug('** at the end');
                        for(; fi < fl; fi++)if ('.' === file[fi] || '..' === file[fi] || !options.dot && '.' === file[fi].charAt(0)) return false;
                        return true;
                    }
                    while(fr < fl){
                        var swallowee = file[fr];
                        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                            this.debug('globstar found match!', fr, fl, swallowee);
                            return true;
                        }
                        if ('.' === swallowee || '..' === swallowee || !options.dot && '.' === swallowee.charAt(0)) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                    if (partial) {
                        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                        if (fr === fl) return true;
                    }
                    return false;
                }
                var hit;
                if ('string' == typeof p) {
                    hit = f === p;
                    this.debug('string match', p, f, hit);
                } else {
                    hit = f.match(p);
                    this.debug('pattern match', p, f, hit);
                }
                if (!hit) return false;
            }
            if (fi === fl && pi === pl) return true;
            if (fi === fl) return partial;
            if (pi === pl) return fi === fl - 1 && '' === file[fi];
            throw new Error('wtf?');
        };
        function globUnescape(s) {
            return s.replace(/\\(.)/g, '$1');
        }
        function regExpEscape(s) {
            return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        }
    },
    "../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js" (module) {
        var s = 1000;
        var m = 60 * s;
        var h = 60 * m;
        var d = 24 * h;
        var w = 7 * d;
        var y = 365.25 * d;
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if ('string' === type && val.length > 0) return parse(val);
            if ('number' === type && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
            throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
        };
        function parse(str) {
            str = String(str);
            if (str.length > 100) return;
            var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
            if (!match) return;
            var n = parseFloat(match[1]);
            var type = (match[2] || 'ms').toLowerCase();
            switch(type){
                case 'years':
                case 'year':
                case 'yrs':
                case 'yr':
                case 'y':
                    return n * y;
                case 'weeks':
                case 'week':
                case 'w':
                    return n * w;
                case 'days':
                case 'day':
                case 'd':
                    return n * d;
                case 'hours':
                case 'hour':
                case 'hrs':
                case 'hr':
                case 'h':
                    return n * h;
                case 'minutes':
                case 'minute':
                case 'mins':
                case 'min':
                case 'm':
                    return n * m;
                case 'seconds':
                case 'second':
                case 'secs':
                case 'sec':
                case 's':
                    return n * s;
                case 'milliseconds':
                case 'millisecond':
                case 'msecs':
                case 'msec':
                case 'ms':
                    return n;
                default:
                    return;
            }
        }
        function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) return Math.round(ms / d) + 'd';
            if (msAbs >= h) return Math.round(ms / h) + 'h';
            if (msAbs >= m) return Math.round(ms / m) + 'm';
            if (msAbs >= s) return Math.round(ms / s) + 's';
            return ms + 'ms';
        }
        function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) return plural(ms, msAbs, d, 'day');
            if (msAbs >= h) return plural(ms, msAbs, h, 'hour');
            if (msAbs >= m) return plural(ms, msAbs, m, 'minute');
            if (msAbs >= s) return plural(ms, msAbs, s, 'second');
            return ms + ' ms';
        }
        function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= 1.5 * n;
            return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
        }
    },
    "../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var preferredCharsets = __webpack_require__("../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/lib/charset.js");
        var preferredEncodings = __webpack_require__("../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/lib/encoding.js");
        var preferredLanguages = __webpack_require__("../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/lib/language.js");
        var preferredMediaTypes = __webpack_require__("../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/lib/mediaType.js");
        module.exports = Negotiator;
        module.exports.Negotiator = Negotiator;
        function Negotiator(request) {
            if (!(this instanceof Negotiator)) return new Negotiator(request);
            this.request = request;
        }
        Negotiator.prototype.charset = function(available) {
            var set = this.charsets(available);
            return set && set[0];
        };
        Negotiator.prototype.charsets = function(available) {
            return preferredCharsets(this.request.headers['accept-charset'], available);
        };
        Negotiator.prototype.encoding = function(available, opts) {
            var set = this.encodings(available, opts);
            return set && set[0];
        };
        Negotiator.prototype.encodings = function(available, options) {
            var opts = options || {};
            return preferredEncodings(this.request.headers['accept-encoding'], available, opts.preferred);
        };
        Negotiator.prototype.language = function(available) {
            var set = this.languages(available);
            return set && set[0];
        };
        Negotiator.prototype.languages = function(available) {
            return preferredLanguages(this.request.headers['accept-language'], available);
        };
        Negotiator.prototype.mediaType = function(available) {
            var set = this.mediaTypes(available);
            return set && set[0];
        };
        Negotiator.prototype.mediaTypes = function(available) {
            return preferredMediaTypes(this.request.headers.accept, available);
        };
        Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
        Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
        Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
        Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
        Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
        Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
        Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
        Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
    },
    "../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/lib/charset.js" (module) {
        "use strict";
        module.exports = preferredCharsets;
        module.exports.preferredCharsets = preferredCharsets;
        var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        function parseAcceptCharset(accept) {
            var accepts = accept.split(',');
            for(var i = 0, j = 0; i < accepts.length; i++){
                var charset = parseCharset(accepts[i].trim(), i);
                if (charset) accepts[j++] = charset;
            }
            accepts.length = j;
            return accepts;
        }
        function parseCharset(str, i) {
            var match = simpleCharsetRegExp.exec(str);
            if (!match) return null;
            var charset = match[1];
            var q = 1;
            if (match[2]) {
                var params = match[2].split(';');
                for(var j = 0; j < params.length; j++){
                    var p = params[j].trim().split('=');
                    if ('q' === p[0]) {
                        q = parseFloat(p[1]);
                        break;
                    }
                }
            }
            return {
                charset: charset,
                q: q,
                i: i
            };
        }
        function getCharsetPriority(charset, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(charset, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(charset, spec, index) {
            var s = 0;
            if (spec.charset.toLowerCase() === charset.toLowerCase()) s |= 1;
            else if ('*' !== spec.charset) return null;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredCharsets(accept, provided) {
            var accepts = parseAcceptCharset(void 0 === accept ? '*' : accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
            var priorities = provided.map(function(type, index) {
                return getCharsetPriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullCharset(spec) {
            return spec.charset;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
    },
    "../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/lib/encoding.js" (module) {
        "use strict";
        module.exports = preferredEncodings;
        module.exports.preferredEncodings = preferredEncodings;
        var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        function parseAcceptEncoding(accept) {
            var accepts = accept.split(',');
            var hasIdentity = false;
            var minQuality = 1;
            for(var i = 0, j = 0; i < accepts.length; i++){
                var encoding = parseEncoding(accepts[i].trim(), i);
                if (encoding) {
                    accepts[j++] = encoding;
                    hasIdentity = hasIdentity || specify('identity', encoding);
                    minQuality = Math.min(minQuality, encoding.q || 1);
                }
            }
            if (!hasIdentity) accepts[j++] = {
                encoding: 'identity',
                q: minQuality,
                i: i
            };
            accepts.length = j;
            return accepts;
        }
        function parseEncoding(str, i) {
            var match = simpleEncodingRegExp.exec(str);
            if (!match) return null;
            var encoding = match[1];
            var q = 1;
            if (match[2]) {
                var params = match[2].split(';');
                for(var j = 0; j < params.length; j++){
                    var p = params[j].trim().split('=');
                    if ('q' === p[0]) {
                        q = parseFloat(p[1]);
                        break;
                    }
                }
            }
            return {
                encoding: encoding,
                q: q,
                i: i
            };
        }
        function getEncodingPriority(encoding, accepted, index) {
            var priority = {
                encoding: encoding,
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(encoding, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(encoding, spec, index) {
            var s = 0;
            if (spec.encoding.toLowerCase() === encoding.toLowerCase()) s |= 1;
            else if ('*' !== spec.encoding) return null;
            return {
                encoding: encoding,
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredEncodings(accept, provided, preferred) {
            var accepts = parseAcceptEncoding(accept || '');
            var comparator = preferred ? function(a, b) {
                if (a.q !== b.q) return b.q - a.q;
                var aPreferred = preferred.indexOf(a.encoding);
                var bPreferred = preferred.indexOf(b.encoding);
                if (-1 === aPreferred && -1 === bPreferred) return b.s - a.s || a.o - b.o || a.i - b.i;
                if (-1 !== aPreferred && -1 !== bPreferred) return aPreferred - bPreferred;
                return -1 === aPreferred ? 1 : -1;
            } : compareSpecs;
            if (!provided) return accepts.filter(isQuality).sort(comparator).map(getFullEncoding);
            var priorities = provided.map(function(type, index) {
                return getEncodingPriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(comparator).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
        }
        function getFullEncoding(spec) {
            return spec.encoding;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
    },
    "../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/lib/language.js" (module) {
        "use strict";
        module.exports = preferredLanguages;
        module.exports.preferredLanguages = preferredLanguages;
        var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
        function parseAcceptLanguage(accept) {
            var accepts = accept.split(',');
            for(var i = 0, j = 0; i < accepts.length; i++){
                var language = parseLanguage(accepts[i].trim(), i);
                if (language) accepts[j++] = language;
            }
            accepts.length = j;
            return accepts;
        }
        function parseLanguage(str, i) {
            var match = simpleLanguageRegExp.exec(str);
            if (!match) return null;
            var prefix = match[1];
            var suffix = match[2];
            var full = prefix;
            if (suffix) full += "-" + suffix;
            var q = 1;
            if (match[3]) {
                var params = match[3].split(';');
                for(var j = 0; j < params.length; j++){
                    var p = params[j].split('=');
                    if ('q' === p[0]) q = parseFloat(p[1]);
                }
            }
            return {
                prefix: prefix,
                suffix: suffix,
                q: q,
                i: i,
                full: full
            };
        }
        function getLanguagePriority(language, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(language, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(language, spec, index) {
            var p = parseLanguage(language);
            if (!p) return null;
            var s = 0;
            if (spec.full.toLowerCase() === p.full.toLowerCase()) s |= 4;
            else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) s |= 2;
            else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) s |= 1;
            else if ('*' !== spec.full) return null;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredLanguages(accept, provided) {
            var accepts = parseAcceptLanguage(void 0 === accept ? '*' : accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
            var priorities = provided.map(function(type, index) {
                return getLanguagePriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullLanguage(spec) {
            return spec.full;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
    },
    "../../../node_modules/.pnpm/negotiator@1.0.0/node_modules/negotiator/lib/mediaType.js" (module) {
        "use strict";
        module.exports = preferredMediaTypes;
        module.exports.preferredMediaTypes = preferredMediaTypes;
        var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
        function parseAccept(accept) {
            var accepts = splitMediaTypes(accept);
            for(var i = 0, j = 0; i < accepts.length; i++){
                var mediaType = parseMediaType(accepts[i].trim(), i);
                if (mediaType) accepts[j++] = mediaType;
            }
            accepts.length = j;
            return accepts;
        }
        function parseMediaType(str, i) {
            var match = simpleMediaTypeRegExp.exec(str);
            if (!match) return null;
            var params = Object.create(null);
            var q = 1;
            var subtype = match[2];
            var type = match[1];
            if (match[3]) {
                var kvps = splitParameters(match[3]).map(splitKeyValuePair);
                for(var j = 0; j < kvps.length; j++){
                    var pair = kvps[j];
                    var key = pair[0].toLowerCase();
                    var val = pair[1];
                    var value = val && '"' === val[0] && '"' === val[val.length - 1] ? val.slice(1, -1) : val;
                    if ('q' === key) {
                        q = parseFloat(value);
                        break;
                    }
                    params[key] = value;
                }
            }
            return {
                type: type,
                subtype: subtype,
                params: params,
                q: q,
                i: i
            };
        }
        function getMediaTypePriority(type, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(type, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(type, spec, index) {
            var p = parseMediaType(type);
            var s = 0;
            if (!p) return null;
            if (spec.type.toLowerCase() == p.type.toLowerCase()) s |= 4;
            else if ('*' != spec.type) return null;
            if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) s |= 2;
            else if ('*' != spec.subtype) return null;
            var keys = Object.keys(spec.params);
            if (keys.length > 0) if (!keys.every(function(k) {
                return '*' == spec.params[k] || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
            })) return null;
            else s |= 1;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredMediaTypes(accept, provided) {
            var accepts = parseAccept(void 0 === accept ? '*/*' : accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
            var priorities = provided.map(function(type, index) {
                return getMediaTypePriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullType(spec) {
            return spec.type + '/' + spec.subtype;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
        function quoteCount(string) {
            var count = 0;
            var index = 0;
            while(-1 !== (index = string.indexOf('"', index))){
                count++;
                index++;
            }
            return count;
        }
        function splitKeyValuePair(str) {
            var index = str.indexOf('=');
            var key;
            var val;
            if (-1 === index) key = str;
            else {
                key = str.slice(0, index);
                val = str.slice(index + 1);
            }
            return [
                key,
                val
            ];
        }
        function splitMediaTypes(accept) {
            var accepts = accept.split(',');
            for(var i = 1, j = 0; i < accepts.length; i++)if (quoteCount(accepts[j]) % 2 == 0) accepts[++j] = accepts[i];
            else accepts[j] += ',' + accepts[i];
            accepts.length = j + 1;
            return accepts;
        }
        function splitParameters(str) {
            var parameters = str.split(';');
            for(var i = 1, j = 0; i < parameters.length; i++)if (quoteCount(parameters[j]) % 2 == 0) parameters[++j] = parameters[i];
            else parameters[j] += ';' + parameters[i];
            parameters.length = j + 1;
            for(var i = 0; i < parameters.length; i++)parameters[i] = parameters[i].trim();
            return parameters;
        }
    },
    "../../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        var hasMap = 'function' == typeof Map && Map.prototype;
        var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
        var mapSize = hasMap && mapSizeDescriptor && 'function' == typeof mapSizeDescriptor.get ? mapSizeDescriptor.get : null;
        var mapForEach = hasMap && Map.prototype.forEach;
        var hasSet = 'function' == typeof Set && Set.prototype;
        var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
        var setSize = hasSet && setSizeDescriptor && 'function' == typeof setSizeDescriptor.get ? setSizeDescriptor.get : null;
        var setForEach = hasSet && Set.prototype.forEach;
        var hasWeakMap = 'function' == typeof WeakMap && WeakMap.prototype;
        var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
        var hasWeakSet = 'function' == typeof WeakSet && WeakSet.prototype;
        var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
        var hasWeakRef = 'function' == typeof WeakRef && WeakRef.prototype;
        var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
        var booleanValueOf = Boolean.prototype.valueOf;
        var objectToString = Object.prototype.toString;
        var functionToString = Function.prototype.toString;
        var $match = String.prototype.match;
        var $slice = String.prototype.slice;
        var $replace = String.prototype.replace;
        var $toUpperCase = String.prototype.toUpperCase;
        var $toLowerCase = String.prototype.toLowerCase;
        var $test = RegExp.prototype.test;
        var $concat = Array.prototype.concat;
        var $join = Array.prototype.join;
        var $arrSlice = Array.prototype.slice;
        var $floor = Math.floor;
        var bigIntValueOf = 'function' == typeof BigInt ? BigInt.prototype.valueOf : null;
        var gOPS = Object.getOwnPropertySymbols;
        var symToString = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? Symbol.prototype.toString : null;
        var hasShammedSymbols = 'function' == typeof Symbol && 'object' == typeof Symbol.iterator;
        var toStringTag = 'function' == typeof Symbol && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var gPO = ('function' == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
            return O.__proto__;
        } : null);
        function addNumericSeparator(num, str) {
            if (num === 1 / 0 || num === -1 / 0 || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) return str;
            var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
            if ('number' == typeof num) {
                var int = num < 0 ? -$floor(-num) : $floor(num);
                if (int !== num) {
                    var intStr = String(int);
                    var dec = $slice.call(str, intStr.length + 1);
                    return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
                }
            }
            return $replace.call(str, sepRegex, '$&_');
        }
        var utilInspect = __webpack_require__("../../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js");
        var inspectCustom = utilInspect.custom;
        var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
        var quotes = {
            __proto__: null,
            double: '"',
            single: "'"
        };
        var quoteREs = {
            __proto__: null,
            double: /(["\\])/g,
            single: /(['\\])/g
        };
        module.exports = function inspect_(obj, options, depth, seen) {
            var opts = options || {};
            if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
            if (has(opts, 'maxStringLength') && ('number' == typeof opts.maxStringLength ? opts.maxStringLength < 0 && opts.maxStringLength !== 1 / 0 : null !== opts.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
            if ('boolean' != typeof customInspect && 'symbol' !== customInspect) throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
            if (has(opts, 'indent') && null !== opts.indent && '\t' !== opts.indent && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
            if (has(opts, 'numericSeparator') && 'boolean' != typeof opts.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
            var numericSeparator = opts.numericSeparator;
            if (void 0 === obj) return 'undefined';
            if (null === obj) return 'null';
            if ('boolean' == typeof obj) return obj ? 'true' : 'false';
            if ('string' == typeof obj) return inspectString(obj, opts);
            if ('number' == typeof obj) {
                if (0 === obj) return 1 / 0 / obj > 0 ? '0' : '-0';
                var str = String(obj);
                return numericSeparator ? addNumericSeparator(obj, str) : str;
            }
            if ('bigint' == typeof obj) {
                var bigIntStr = String(obj) + 'n';
                return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
            }
            var maxDepth = void 0 === opts.depth ? 5 : opts.depth;
            if (void 0 === depth) depth = 0;
            if (depth >= maxDepth && maxDepth > 0 && 'object' == typeof obj) return isArray(obj) ? '[Array]' : '[Object]';
            var indent = getIndent(opts, depth);
            if (void 0 === seen) seen = [];
            else if (indexOf(seen, obj) >= 0) return '[Circular]';
            function inspect(value, from, noIndent) {
                if (from) {
                    seen = $arrSlice.call(seen);
                    seen.push(from);
                }
                if (noIndent) {
                    var newOpts = {
                        depth: opts.depth
                    };
                    if (has(opts, 'quoteStyle')) newOpts.quoteStyle = opts.quoteStyle;
                    return inspect_(value, newOpts, depth + 1, seen);
                }
                return inspect_(value, opts, depth + 1, seen);
            }
            if ('function' == typeof obj && !isRegExp(obj)) {
                var name = nameOf(obj);
                var keys = arrObjKeys(obj, inspect);
                return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
            }
            if (isSymbol(obj)) {
                var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
                return 'object' != typeof obj || hasShammedSymbols ? symString : markBoxed(symString);
            }
            if (isElement(obj)) {
                var s = '<' + $toLowerCase.call(String(obj.nodeName));
                var attrs = obj.attributes || [];
                for(var i = 0; i < attrs.length; i++)s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
                s += '>';
                if (obj.childNodes && obj.childNodes.length) s += '...';
                s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
                return s;
            }
            if (isArray(obj)) {
                if (0 === obj.length) return '[]';
                var xs = arrObjKeys(obj, inspect);
                if (indent && !singleLineValues(xs)) return '[' + indentedJoin(xs, indent) + ']';
                return '[ ' + $join.call(xs, ', ') + ' ]';
            }
            if (isError(obj)) {
                var parts = arrObjKeys(obj, inspect);
                if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
                if (0 === parts.length) return '[' + String(obj) + ']';
                return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
            }
            if ('object' == typeof obj && customInspect) {
                if (inspectSymbol && 'function' == typeof obj[inspectSymbol] && utilInspect) return utilInspect(obj, {
                    depth: maxDepth - depth
                });
                else if ('symbol' !== customInspect && 'function' == typeof obj.inspect) return obj.inspect();
            }
            if (isMap(obj)) {
                var mapParts = [];
                if (mapForEach) mapForEach.call(obj, function(value, key) {
                    mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
                });
                return collectionOf('Map', mapSize.call(obj), mapParts, indent);
            }
            if (isSet(obj)) {
                var setParts = [];
                if (setForEach) setForEach.call(obj, function(value) {
                    setParts.push(inspect(value, obj));
                });
                return collectionOf('Set', setSize.call(obj), setParts, indent);
            }
            if (isWeakMap(obj)) return weakCollectionOf('WeakMap');
            if (isWeakSet(obj)) return weakCollectionOf('WeakSet');
            if (isWeakRef(obj)) return weakCollectionOf('WeakRef');
            if (isNumber(obj)) return markBoxed(inspect(Number(obj)));
            if (isBigInt(obj)) return markBoxed(inspect(bigIntValueOf.call(obj)));
            if (isBoolean(obj)) return markBoxed(booleanValueOf.call(obj));
            if (isString(obj)) return markBoxed(inspect(String(obj)));
            if ("u" > typeof window && obj === window) return '{ [object Window] }';
            if ("u" > typeof globalThis && obj === globalThis || "u" > typeof global && obj === global) return '{ [object globalThis] }';
            if (!isDate(obj) && !isRegExp(obj)) {
                var ys = arrObjKeys(obj, inspect);
                var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
                var protoTag = obj instanceof Object ? '' : 'null prototype';
                var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
                var constructorTag = isPlainObject || 'function' != typeof obj.constructor ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
                var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
                if (0 === ys.length) return tag + '{}';
                if (indent) return tag + '{' + indentedJoin(ys, indent) + '}';
                return tag + '{ ' + $join.call(ys, ', ') + ' }';
            }
            return String(obj);
        };
        function wrapQuotes(s, defaultStyle, opts) {
            var style = opts.quoteStyle || defaultStyle;
            var quoteChar = quotes[style];
            return quoteChar + s + quoteChar;
        }
        function quote(s) {
            return $replace.call(String(s), /"/g, '&quot;');
        }
        function canTrustToString(obj) {
            return !toStringTag || !('object' == typeof obj && (toStringTag in obj || void 0 !== obj[toStringTag]));
        }
        function isArray(obj) {
            return '[object Array]' === toStr(obj) && canTrustToString(obj);
        }
        function isDate(obj) {
            return '[object Date]' === toStr(obj) && canTrustToString(obj);
        }
        function isRegExp(obj) {
            return '[object RegExp]' === toStr(obj) && canTrustToString(obj);
        }
        function isError(obj) {
            return '[object Error]' === toStr(obj) && canTrustToString(obj);
        }
        function isString(obj) {
            return '[object String]' === toStr(obj) && canTrustToString(obj);
        }
        function isNumber(obj) {
            return '[object Number]' === toStr(obj) && canTrustToString(obj);
        }
        function isBoolean(obj) {
            return '[object Boolean]' === toStr(obj) && canTrustToString(obj);
        }
        function isSymbol(obj) {
            if (hasShammedSymbols) return obj && 'object' == typeof obj && obj instanceof Symbol;
            if ('symbol' == typeof obj) return true;
            if (!obj || 'object' != typeof obj || !symToString) return false;
            try {
                symToString.call(obj);
                return true;
            } catch (e) {}
            return false;
        }
        function isBigInt(obj) {
            if (!obj || 'object' != typeof obj || !bigIntValueOf) return false;
            try {
                bigIntValueOf.call(obj);
                return true;
            } catch (e) {}
            return false;
        }
        var hasOwn = Object.prototype.hasOwnProperty || function(key) {
            return key in this;
        };
        function has(obj, key) {
            return hasOwn.call(obj, key);
        }
        function toStr(obj) {
            return objectToString.call(obj);
        }
        function nameOf(f) {
            if (f.name) return f.name;
            var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
            if (m) return m[1];
            return null;
        }
        function indexOf(xs, x) {
            if (xs.indexOf) return xs.indexOf(x);
            for(var i = 0, l = xs.length; i < l; i++)if (xs[i] === x) return i;
            return -1;
        }
        function isMap(x) {
            if (!mapSize || !x || 'object' != typeof x) return false;
            try {
                mapSize.call(x);
                try {
                    setSize.call(x);
                } catch (s) {
                    return true;
                }
                return x instanceof Map;
            } catch (e) {}
            return false;
        }
        function isWeakMap(x) {
            if (!weakMapHas || !x || 'object' != typeof x) return false;
            try {
                weakMapHas.call(x, weakMapHas);
                try {
                    weakSetHas.call(x, weakSetHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakMap;
            } catch (e) {}
            return false;
        }
        function isWeakRef(x) {
            if (!weakRefDeref || !x || 'object' != typeof x) return false;
            try {
                weakRefDeref.call(x);
                return true;
            } catch (e) {}
            return false;
        }
        function isSet(x) {
            if (!setSize || !x || 'object' != typeof x) return false;
            try {
                setSize.call(x);
                try {
                    mapSize.call(x);
                } catch (m) {
                    return true;
                }
                return x instanceof Set;
            } catch (e) {}
            return false;
        }
        function isWeakSet(x) {
            if (!weakSetHas || !x || 'object' != typeof x) return false;
            try {
                weakSetHas.call(x, weakSetHas);
                try {
                    weakMapHas.call(x, weakMapHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakSet;
            } catch (e) {}
            return false;
        }
        function isElement(x) {
            if (!x || 'object' != typeof x) return false;
            if ("u" > typeof HTMLElement && x instanceof HTMLElement) return true;
            return 'string' == typeof x.nodeName && 'function' == typeof x.getAttribute;
        }
        function inspectString(str, opts) {
            if (str.length > opts.maxStringLength) {
                var remaining = str.length - opts.maxStringLength;
                var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
                return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
            }
            var quoteRE = quoteREs[opts.quoteStyle || 'single'];
            quoteRE.lastIndex = 0;
            var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
            return wrapQuotes(s, 'single', opts);
        }
        function lowbyte(c) {
            var n = c.charCodeAt(0);
            var x = {
                8: 'b',
                9: 't',
                10: 'n',
                12: 'f',
                13: 'r'
            }[n];
            if (x) return '\\' + x;
            return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
        }
        function markBoxed(str) {
            return 'Object(' + str + ')';
        }
        function weakCollectionOf(type) {
            return type + ' { ? }';
        }
        function collectionOf(type, size, entries, indent) {
            var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
            return type + ' (' + size + ') {' + joinedEntries + '}';
        }
        function singleLineValues(xs) {
            for(var i = 0; i < xs.length; i++)if (indexOf(xs[i], '\n') >= 0) return false;
            return true;
        }
        function getIndent(opts, depth) {
            var baseIndent;
            if ('\t' === opts.indent) baseIndent = '\t';
            else {
                if ('number' != typeof opts.indent || !(opts.indent > 0)) return null;
                baseIndent = $join.call(Array(opts.indent + 1), ' ');
            }
            return {
                base: baseIndent,
                prev: $join.call(Array(depth + 1), baseIndent)
            };
        }
        function indentedJoin(xs, indent) {
            if (0 === xs.length) return '';
            var lineJoiner = '\n' + indent.prev + indent.base;
            return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
        }
        function arrObjKeys(obj, inspect) {
            var isArr = isArray(obj);
            var xs = [];
            if (isArr) {
                xs.length = obj.length;
                for(var i = 0; i < obj.length; i++)xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
            }
            var syms = 'function' == typeof gOPS ? gOPS(obj) : [];
            var symMap;
            if (hasShammedSymbols) {
                symMap = {};
                for(var k = 0; k < syms.length; k++)symMap['$' + syms[k]] = syms[k];
            }
            for(var key in obj)if (has(obj, key)) {
                if (!isArr || String(Number(key)) !== key || !(key < obj.length)) if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) continue;
                else if ($test.call(/[^\w$]/, key)) xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
                else xs.push(key + ': ' + inspect(obj[key], obj));
            }
            if ('function' == typeof gOPS) {
                for(var j = 0; j < syms.length; j++)if (isEnumerable.call(obj, syms[j])) xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
            return xs;
        }
    },
    "../../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js" (module, __unused_rspack_exports, __webpack_require__) {
        module.exports = __webpack_require__("util").inspect;
    },
    "../../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = onFinished;
        module.exports.isFinished = isFinished;
        var asyncHooks = tryRequireAsyncHooks();
        var first = __webpack_require__("../../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js");
        var defer = 'function' == typeof setImmediate ? setImmediate : function(fn) {
            process.nextTick(fn.bind.apply(fn, arguments));
        };
        function onFinished(msg, listener) {
            if (false !== isFinished(msg)) {
                defer(listener, null, msg);
                return msg;
            }
            attachListener(msg, wrap(listener));
            return msg;
        }
        function isFinished(msg) {
            var socket = msg.socket;
            if ('boolean' == typeof msg.finished) return Boolean(msg.finished || socket && !socket.writable);
            if ('boolean' == typeof msg.complete) return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
        }
        function attachFinishedListener(msg, callback) {
            var eeMsg;
            var eeSocket;
            var finished = false;
            function onFinish(error) {
                eeMsg.cancel();
                eeSocket.cancel();
                finished = true;
                callback(error);
            }
            eeMsg = eeSocket = first([
                [
                    msg,
                    'end',
                    'finish'
                ]
            ], onFinish);
            function onSocket(socket) {
                msg.removeListener('socket', onSocket);
                if (finished) return;
                if (eeMsg !== eeSocket) return;
                eeSocket = first([
                    [
                        socket,
                        'error',
                        'close'
                    ]
                ], onFinish);
            }
            if (msg.socket) return void onSocket(msg.socket);
            msg.on('socket', onSocket);
            if (void 0 === msg.socket) patchAssignSocket(msg, onSocket);
        }
        function attachListener(msg, listener) {
            var attached = msg.__onFinished;
            if (!attached || !attached.queue) {
                attached = msg.__onFinished = createListener(msg);
                attachFinishedListener(msg, attached);
            }
            attached.queue.push(listener);
        }
        function createListener(msg) {
            function listener(err) {
                if (msg.__onFinished === listener) msg.__onFinished = null;
                if (!listener.queue) return;
                var queue = listener.queue;
                listener.queue = null;
                for(var i = 0; i < queue.length; i++)queue[i](err, msg);
            }
            listener.queue = [];
            return listener;
        }
        function patchAssignSocket(res, callback) {
            var assignSocket = res.assignSocket;
            if ('function' != typeof assignSocket) return;
            res.assignSocket = function(socket) {
                assignSocket.call(this, socket);
                callback(socket);
            };
        }
        function tryRequireAsyncHooks() {
            try {
                return __webpack_require__("async_hooks");
            } catch (e) {
                return {};
            }
        }
        function wrap(fn) {
            var res;
            if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
            if (!res || !res.runInAsyncScope) return fn;
            return res.runInAsyncScope.bind(res, fn, null);
        }
    },
    "../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js" (module, __unused_rspack_exports, __webpack_require__) {
        var wrappy = __webpack_require__("../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js");
        module.exports = wrappy(once);
        module.exports.strict = wrappy(onceStrict);
        once.proto = once(function() {
            Object.defineProperty(Function.prototype, 'once', {
                value: function() {
                    return once(this);
                },
                configurable: true
            });
            Object.defineProperty(Function.prototype, 'onceStrict', {
                value: function() {
                    return onceStrict(this);
                },
                configurable: true
            });
        });
        function once(fn) {
            var f = function() {
                if (f.called) return f.value;
                f.called = true;
                return f.value = fn.apply(this, arguments);
            };
            f.called = false;
            return f;
        }
        function onceStrict(fn) {
            var f = function() {
                if (f.called) throw new Error(f.onceError);
                f.called = true;
                return f.value = fn.apply(this, arguments);
            };
            var name = fn.name || 'Function wrapped with `once`';
            f.onceError = name + " shouldn't be called more than once";
            f.called = false;
            return f;
        }
    },
    "../../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var url = __webpack_require__("url");
        var parse = url.parse;
        var Url = url.Url;
        module.exports = parseurl;
        module.exports.original = originalurl;
        function parseurl(req) {
            var url = req.url;
            if (void 0 === url) return;
            var parsed = req._parsedUrl;
            if (fresh(url, parsed)) return parsed;
            parsed = fastparse(url);
            parsed._raw = url;
            return req._parsedUrl = parsed;
        }
        function originalurl(req) {
            var url = req.originalUrl;
            if ('string' != typeof url) return parseurl(req);
            var parsed = req._parsedOriginalUrl;
            if (fresh(url, parsed)) return parsed;
            parsed = fastparse(url);
            parsed._raw = url;
            return req._parsedOriginalUrl = parsed;
        }
        function fastparse(str) {
            if ('string' != typeof str || 0x2f !== str.charCodeAt(0)) return parse(str);
            var pathname = str;
            var query = null;
            var search = null;
            for(var i = 1; i < str.length; i++)switch(str.charCodeAt(i)){
                case 0x3f:
                    if (null === search) {
                        pathname = str.substring(0, i);
                        query = str.substring(i + 1);
                        search = str.substring(i);
                    }
                    break;
                case 0x09:
                case 0x0a:
                case 0x0c:
                case 0x0d:
                case 0x20:
                case 0x23:
                case 0xa0:
                case 0xfeff:
                    return parse(str);
            }
            var url = void 0 !== Url ? new Url() : {};
            url.path = str;
            url.href = str;
            url.pathname = pathname;
            if (null !== search) {
                url.query = query;
                url.search = search;
            }
            return url;
        }
        function fresh(url, parsedUrl) {
            return 'object' == typeof parsedUrl && null !== parsedUrl && (void 0 === Url || parsedUrl instanceof Url) && parsedUrl._raw === url;
        }
    },
    "../../../node_modules/.pnpm/path-to-regexp@8.3.0/node_modules/path-to-regexp/dist/index.js" (__unused_rspack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.PathError = exports1.TokenData = void 0;
        exports1.parse = parse;
        exports1.compile = compile;
        exports1.match = match;
        exports1.pathToRegexp = pathToRegexp;
        exports1.stringify = stringify;
        const DEFAULT_DELIMITER = "/";
        const NOOP_VALUE = (value)=>value;
        const ID_START = /^[$_\p{ID_Start}]$/u;
        const ID_CONTINUE = /^[$\u200c\u200d\p{ID_Continue}]$/u;
        const SIMPLE_TOKENS = {
            "{": "{",
            "}": "}",
            "(": "(",
            ")": ")",
            "[": "[",
            "]": "]",
            "+": "+",
            "?": "?",
            "!": "!"
        };
        function escapeText(str) {
            return str.replace(/[{}()\[\]+?!:*\\]/g, "\\$&");
        }
        function escape1(str) {
            return str.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&");
        }
        class TokenData {
            constructor(tokens, originalPath){
                this.tokens = tokens;
                this.originalPath = originalPath;
            }
        }
        exports1.TokenData = TokenData;
        class PathError extends TypeError {
            constructor(message, originalPath){
                let text = message;
                if (originalPath) text += `: ${originalPath}`;
                text += "; visit https://git.new/pathToRegexpError for info";
                super(text);
                this.originalPath = originalPath;
            }
        }
        exports1.PathError = PathError;
        function parse(str, options = {}) {
            const { encodePath = NOOP_VALUE } = options;
            const chars = [
                ...str
            ];
            const tokens = [];
            let index = 0;
            let pos = 0;
            function name() {
                let value = "";
                if (ID_START.test(chars[index])) do value += chars[index++];
                while (ID_CONTINUE.test(chars[index]));
                else if ('"' === chars[index]) {
                    let quoteStart = index;
                    while(index++ < chars.length){
                        if ('"' === chars[index]) {
                            index++;
                            quoteStart = 0;
                            break;
                        }
                        if ("\\" === chars[index]) index++;
                        value += chars[index];
                    }
                    if (quoteStart) throw new PathError(`Unterminated quote at index ${quoteStart}`, str);
                }
                if (!value) throw new PathError(`Missing parameter name at index ${index}`, str);
                return value;
            }
            while(index < chars.length){
                const value = chars[index];
                const type = SIMPLE_TOKENS[value];
                if (type) tokens.push({
                    type,
                    index: index++,
                    value
                });
                else if ("\\" === value) tokens.push({
                    type: "escape",
                    index: index++,
                    value: chars[index++]
                });
                else if (":" === value) tokens.push({
                    type: "param",
                    index: index++,
                    value: name()
                });
                else if ("*" === value) tokens.push({
                    type: "wildcard",
                    index: index++,
                    value: name()
                });
                else tokens.push({
                    type: "char",
                    index: index++,
                    value
                });
            }
            tokens.push({
                type: "end",
                index,
                value: ""
            });
            function consumeUntil(endType) {
                const output = [];
                while(true){
                    const token = tokens[pos++];
                    if (token.type === endType) break;
                    if ("char" === token.type || "escape" === token.type) {
                        let path = token.value;
                        let cur = tokens[pos];
                        while("char" === cur.type || "escape" === cur.type){
                            path += cur.value;
                            cur = tokens[++pos];
                        }
                        output.push({
                            type: "text",
                            value: encodePath(path)
                        });
                        continue;
                    }
                    if ("param" === token.type || "wildcard" === token.type) {
                        output.push({
                            type: token.type,
                            name: token.value
                        });
                        continue;
                    }
                    if ("{" === token.type) {
                        output.push({
                            type: "group",
                            tokens: consumeUntil("}")
                        });
                        continue;
                    }
                    throw new PathError(`Unexpected ${token.type} at index ${token.index}, expected ${endType}`, str);
                }
                return output;
            }
            return new TokenData(consumeUntil("end"), str);
        }
        function compile(path, options = {}) {
            const { encode = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
            const data = "object" == typeof path ? path : parse(path, options);
            const fn = tokensToFunction(data.tokens, delimiter, encode);
            return function(params = {}) {
                const [path, ...missing] = fn(params);
                if (missing.length) throw new TypeError(`Missing parameters: ${missing.join(", ")}`);
                return path;
            };
        }
        function tokensToFunction(tokens, delimiter, encode) {
            const encoders = tokens.map((token)=>tokenToFunction(token, delimiter, encode));
            return (data)=>{
                const result = [
                    ""
                ];
                for (const encoder of encoders){
                    const [value, ...extras] = encoder(data);
                    result[0] += value;
                    result.push(...extras);
                }
                return result;
            };
        }
        function tokenToFunction(token, delimiter, encode) {
            if ("text" === token.type) return ()=>[
                    token.value
                ];
            if ("group" === token.type) {
                const fn = tokensToFunction(token.tokens, delimiter, encode);
                return (data)=>{
                    const [value, ...missing] = fn(data);
                    if (!missing.length) return [
                        value
                    ];
                    return [
                        ""
                    ];
                };
            }
            const encodeValue = encode || NOOP_VALUE;
            if ("wildcard" === token.type && false !== encode) return (data)=>{
                const value = data[token.name];
                if (null == value) return [
                    "",
                    token.name
                ];
                if (!Array.isArray(value) || 0 === value.length) throw new TypeError(`Expected "${token.name}" to be a non-empty array`);
                return [
                    value.map((value, index)=>{
                        if ("string" != typeof value) throw new TypeError(`Expected "${token.name}/${index}" to be a string`);
                        return encodeValue(value);
                    }).join(delimiter)
                ];
            };
            return (data)=>{
                const value = data[token.name];
                if (null == value) return [
                    "",
                    token.name
                ];
                if ("string" != typeof value) throw new TypeError(`Expected "${token.name}" to be a string`);
                return [
                    encodeValue(value)
                ];
            };
        }
        function match(path, options = {}) {
            const { decode = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
            const { regexp, keys } = pathToRegexp(path, options);
            const decoders = keys.map((key)=>{
                if (false === decode) return NOOP_VALUE;
                if ("param" === key.type) return decode;
                return (value)=>value.split(delimiter).map(decode);
            });
            return function(input) {
                const m = regexp.exec(input);
                if (!m) return false;
                const path = m[0];
                const params = Object.create(null);
                for(let i = 1; i < m.length; i++){
                    if (void 0 === m[i]) continue;
                    const key = keys[i - 1];
                    const decoder = decoders[i - 1];
                    params[key.name] = decoder(m[i]);
                }
                return {
                    path,
                    params
                };
            };
        }
        function pathToRegexp(path, options = {}) {
            const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true } = options;
            const keys = [];
            const flags = sensitive ? "" : "i";
            const sources = [];
            for (const input of pathsToArray(path, [])){
                const data = "object" == typeof input ? input : parse(input, options);
                for (const tokens of flatten(data.tokens, 0, []))sources.push(toRegExpSource(tokens, delimiter, keys, data.originalPath));
            }
            let pattern = `^(?:${sources.join("|")})`;
            if (trailing) pattern += `(?:${escape1(delimiter)}$)?`;
            pattern += end ? "$" : `(?=${escape1(delimiter)}|$)`;
            const regexp = new RegExp(pattern, flags);
            return {
                regexp,
                keys
            };
        }
        function pathsToArray(paths, init) {
            if (Array.isArray(paths)) for (const p of paths)pathsToArray(p, init);
            else init.push(paths);
            return init;
        }
        function* flatten(tokens, index, init) {
            if (index === tokens.length) return yield init;
            const token = tokens[index];
            if ("group" === token.type) for (const seq of flatten(token.tokens, 0, init.slice()))yield* flatten(tokens, index + 1, seq);
            else init.push(token);
            yield* flatten(tokens, index + 1, init);
        }
        function toRegExpSource(tokens, delimiter, keys, originalPath) {
            let result = "";
            let backtrack = "";
            let isSafeSegmentParam = true;
            for (const token of tokens){
                if ("text" === token.type) {
                    result += escape1(token.value);
                    backtrack += token.value;
                    isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));
                    continue;
                }
                if ("param" === token.type || "wildcard" === token.type) {
                    if (!isSafeSegmentParam && !backtrack) throw new PathError(`Missing text before "${token.name}" ${token.type}`, originalPath);
                    if ("param" === token.type) result += `(${negate(delimiter, isSafeSegmentParam ? "" : backtrack)}+)`;
                    else result += "([\\s\\S]+)";
                    keys.push(token);
                    backtrack = "";
                    isSafeSegmentParam = false;
                    continue;
                }
            }
            return result;
        }
        function negate(delimiter, backtrack) {
            if (backtrack.length < 2) {
                if (delimiter.length < 2) return `[^${escape1(delimiter + backtrack)}]`;
                return `(?:(?!${escape1(delimiter)})[^${escape1(backtrack)}])`;
            }
            if (delimiter.length < 2) return `(?:(?!${escape1(backtrack)})[^${escape1(delimiter)}])`;
            return `(?:(?!${escape1(backtrack)}|${escape1(delimiter)})[\\s\\S])`;
        }
        function stringifyTokens(tokens) {
            let value = "";
            let i = 0;
            function name(value) {
                const isSafe = isNameSafe(value) && isNextNameSafe(tokens[i]);
                return isSafe ? value : JSON.stringify(value);
            }
            while(i < tokens.length){
                const token = tokens[i++];
                if ("text" === token.type) {
                    value += escapeText(token.value);
                    continue;
                }
                if ("group" === token.type) {
                    value += `{${stringifyTokens(token.tokens)}}`;
                    continue;
                }
                if ("param" === token.type) {
                    value += `:${name(token.name)}`;
                    continue;
                }
                if ("wildcard" === token.type) {
                    value += `*${name(token.name)}`;
                    continue;
                }
                throw new TypeError(`Unknown token type: ${token.type}`);
            }
            return value;
        }
        function stringify(data) {
            return stringifyTokens(data.tokens);
        }
        function isNameSafe(name) {
            const [first, ...rest] = name;
            return ID_START.test(first) && rest.every((char)=>ID_CONTINUE.test(char));
        }
        function isNextNameSafe(token) {
            if (token && "text" === token.type) return !ID_CONTINUE.test(token.value[0]);
            return true;
        }
    },
    "../../../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = proxyaddr;
        module.exports.all = alladdrs;
        module.exports.compile = compile;
        var forwarded = __webpack_require__("../../../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js");
        var ipaddr = __webpack_require__("../../../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js");
        var DIGIT_REGEXP = /^[0-9]+$/;
        var isip = ipaddr.isValid;
        var parseip = ipaddr.parse;
        var IP_RANGES = {
            linklocal: [
                '169.254.0.0/16',
                'fe80::/10'
            ],
            loopback: [
                '127.0.0.1/8',
                '::1/128'
            ],
            uniquelocal: [
                '10.0.0.0/8',
                '172.16.0.0/12',
                '192.168.0.0/16',
                'fc00::/7'
            ]
        };
        function alladdrs(req, trust) {
            var addrs = forwarded(req);
            if (!trust) return addrs;
            if ('function' != typeof trust) trust = compile(trust);
            for(var i = 0; i < addrs.length - 1; i++)if (!trust(addrs[i], i)) addrs.length = i + 1;
            return addrs;
        }
        function compile(val) {
            if (!val) throw new TypeError('argument is required');
            var trust;
            if ('string' == typeof val) trust = [
                val
            ];
            else if (Array.isArray(val)) trust = val.slice();
            else throw new TypeError('unsupported trust argument');
            for(var i = 0; i < trust.length; i++){
                val = trust[i];
                if (Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
                    val = IP_RANGES[val];
                    trust.splice.apply(trust, [
                        i,
                        1
                    ].concat(val));
                    i += val.length - 1;
                }
            }
            return compileTrust(compileRangeSubnets(trust));
        }
        function compileRangeSubnets(arr) {
            var rangeSubnets = new Array(arr.length);
            for(var i = 0; i < arr.length; i++)rangeSubnets[i] = parseipNotation(arr[i]);
            return rangeSubnets;
        }
        function compileTrust(rangeSubnets) {
            var len = rangeSubnets.length;
            return 0 === len ? trustNone : 1 === len ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
        }
        function parseipNotation(note) {
            var pos = note.lastIndexOf('/');
            var str = -1 !== pos ? note.substring(0, pos) : note;
            if (!isip(str)) throw new TypeError('invalid IP address: ' + str);
            var ip = parseip(str);
            if (-1 === pos && 'ipv6' === ip.kind() && ip.isIPv4MappedAddress()) ip = ip.toIPv4Address();
            var max = 'ipv6' === ip.kind() ? 128 : 32;
            var range = -1 !== pos ? note.substring(pos + 1, note.length) : null;
            range = null === range ? max : DIGIT_REGEXP.test(range) ? parseInt(range, 10) : 'ipv4' === ip.kind() && isip(range) ? parseNetmask(range) : null;
            if (range <= 0 || range > max) throw new TypeError('invalid range on address: ' + note);
            return [
                ip,
                range
            ];
        }
        function parseNetmask(netmask) {
            var ip = parseip(netmask);
            var kind = ip.kind();
            return 'ipv4' === kind ? ip.prefixLengthFromSubnetMask() : null;
        }
        function proxyaddr(req, trust) {
            if (!req) throw new TypeError('req argument is required');
            if (!trust) throw new TypeError('trust argument is required');
            var addrs = alladdrs(req, trust);
            var addr = addrs[addrs.length - 1];
            return addr;
        }
        function trustNone() {
            return false;
        }
        function trustMulti(subnets) {
            return function(addr) {
                if (!isip(addr)) return false;
                var ip = parseip(addr);
                var ipconv;
                var kind = ip.kind();
                for(var i = 0; i < subnets.length; i++){
                    var subnet = subnets[i];
                    var subnetip = subnet[0];
                    var subnetkind = subnetip.kind();
                    var subnetrange = subnet[1];
                    var trusted = ip;
                    if (kind !== subnetkind) {
                        if ('ipv4' === subnetkind && !ip.isIPv4MappedAddress()) continue;
                        if (!ipconv) ipconv = 'ipv4' === subnetkind ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
                        trusted = ipconv;
                    }
                    if (trusted.match(subnetip, subnetrange)) return true;
                }
                return false;
            };
        }
        function trustSingle(subnet) {
            var subnetip = subnet[0];
            var subnetkind = subnetip.kind();
            var subnetisipv4 = 'ipv4' === subnetkind;
            var subnetrange = subnet[1];
            return function(addr) {
                if (!isip(addr)) return false;
                var ip = parseip(addr);
                var kind = ip.kind();
                if (kind !== subnetkind) {
                    if (subnetisipv4 && !ip.isIPv4MappedAddress()) return false;
                    ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
                }
                return ip.match(subnetip, subnetrange);
            };
        }
    },
    "../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/formats.js" (module) {
        "use strict";
        var replace = String.prototype.replace;
        var percentTwenties = /%20/g;
        var Format = {
            RFC1738: 'RFC1738',
            RFC3986: 'RFC3986'
        };
        module.exports = {
            default: Format.RFC3986,
            formatters: {
                RFC1738: function(value) {
                    return replace.call(value, percentTwenties, '+');
                },
                RFC3986: function(value) {
                    return String(value);
                }
            },
            RFC1738: Format.RFC1738,
            RFC3986: Format.RFC3986
        };
    },
    "../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var stringify = __webpack_require__("../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/stringify.js");
        var parse = __webpack_require__("../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/parse.js");
        var formats = __webpack_require__("../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/formats.js");
        module.exports = {
            formats: formats,
            parse: parse,
            stringify: stringify
        };
    },
    "../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/parse.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__("../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/utils.js");
        var has = Object.prototype.hasOwnProperty;
        var isArray = Array.isArray;
        var defaults = {
            allowDots: false,
            allowEmptyArrays: false,
            allowPrototypes: false,
            allowSparse: false,
            arrayLimit: 20,
            charset: 'utf-8',
            charsetSentinel: false,
            comma: false,
            decodeDotInKeys: false,
            decoder: utils.decode,
            delimiter: '&',
            depth: 5,
            duplicates: 'combine',
            ignoreQueryPrefix: false,
            interpretNumericEntities: false,
            parameterLimit: 1000,
            parseArrays: true,
            plainObjects: false,
            strictDepth: false,
            strictNullHandling: false,
            throwOnLimitExceeded: false
        };
        var interpretNumericEntities = function(str) {
            return str.replace(/&#(\d+);/g, function($0, numberStr) {
                return String.fromCharCode(parseInt(numberStr, 10));
            });
        };
        var parseArrayValue = function(val, options, currentArrayLength) {
            if (val && 'string' == typeof val && options.comma && val.indexOf(',') > -1) return val.split(',');
            if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (1 === options.arrayLimit ? '' : 's') + ' allowed in an array.');
            return val;
        };
        var isoSentinel = 'utf8=%26%2310003%3B';
        var charsetSentinel = 'utf8=%E2%9C%93';
        var parseValues = function(str, options) {
            var obj = {
                __proto__: null
            };
            var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
            cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
            var limit = options.parameterLimit === 1 / 0 ? void 0 : options.parameterLimit;
            var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit + 1 : limit);
            if (options.throwOnLimitExceeded && parts.length > limit) throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (1 === limit ? '' : 's') + ' allowed.');
            var skipIndex = -1;
            var i;
            var charset = options.charset;
            if (options.charsetSentinel) {
                for(i = 0; i < parts.length; ++i)if (0 === parts[i].indexOf('utf8=')) {
                    if (parts[i] === charsetSentinel) charset = 'utf-8';
                    else if (parts[i] === isoSentinel) charset = 'iso-8859-1';
                    skipIndex = i;
                    i = parts.length;
                }
            }
            for(i = 0; i < parts.length; ++i)if (i !== skipIndex) {
                var part = parts[i];
                var bracketEqualsPos = part.indexOf(']=');
                var pos = -1 === bracketEqualsPos ? part.indexOf('=') : bracketEqualsPos + 1;
                var key;
                var val;
                if (-1 === pos) {
                    key = options.decoder(part, defaults.decoder, charset, 'key');
                    val = options.strictNullHandling ? null : '';
                } else {
                    key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
                    if (null !== key) val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray(obj[key]) ? obj[key].length : 0), function(encodedVal) {
                        return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                    });
                }
                if (val && options.interpretNumericEntities && 'iso-8859-1' === charset) val = interpretNumericEntities(String(val));
                if (part.indexOf('[]=') > -1) val = isArray(val) ? [
                    val
                ] : val;
                if (null !== key) {
                    var existing = has.call(obj, key);
                    if (existing && 'combine' === options.duplicates) obj[key] = utils.combine(obj[key], val, options.arrayLimit, options.plainObjects);
                    else if (!existing || 'last' === options.duplicates) obj[key] = val;
                }
            }
            return obj;
        };
        var parseObject = function(chain, val, options, valuesParsed) {
            var currentArrayLength = 0;
            if (chain.length > 0 && '[]' === chain[chain.length - 1]) {
                var parentKey = chain.slice(0, -1).join('');
                currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
            }
            var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
            for(var i = chain.length - 1; i >= 0; --i){
                var obj;
                var root = chain[i];
                if ('[]' === root && options.parseArrays) obj = utils.isOverflow(leaf) ? leaf : options.allowEmptyArrays && ('' === leaf || options.strictNullHandling && null === leaf) ? [] : utils.combine([], leaf, options.arrayLimit, options.plainObjects);
                else {
                    obj = options.plainObjects ? {
                        __proto__: null
                    } : {};
                    var cleanRoot = '[' === root.charAt(0) && ']' === root.charAt(root.length - 1) ? root.slice(1, -1) : root;
                    var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
                    var index = parseInt(decodedRoot, 10);
                    if (options.parseArrays || '' !== decodedRoot) {
                        if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                            obj = [];
                            obj[index] = leaf;
                        } else if ('__proto__' !== decodedRoot) obj[decodedRoot] = leaf;
                    } else obj = {
                        0: leaf
                    };
                }
                leaf = obj;
            }
            return leaf;
        };
        var splitKeyIntoSegments = function(givenKey, options) {
            var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
            if (options.depth <= 0) {
                if (!options.plainObjects && has.call(Object.prototype, key)) {
                    if (!options.allowPrototypes) return;
                }
                return [
                    key
                ];
            }
            var brackets = /(\[[^[\]]*])/;
            var child = /(\[[^[\]]*])/g;
            var segment = brackets.exec(key);
            var parent = segment ? key.slice(0, segment.index) : key;
            var keys = [];
            if (parent) {
                if (!options.plainObjects && has.call(Object.prototype, parent)) {
                    if (!options.allowPrototypes) return;
                }
                keys.push(parent);
            }
            var i = 0;
            while(null !== (segment = child.exec(key)) && i < options.depth){
                i += 1;
                var segmentContent = segment[1].slice(1, -1);
                if (!options.plainObjects && has.call(Object.prototype, segmentContent)) {
                    if (!options.allowPrototypes) return;
                }
                keys.push(segment[1]);
            }
            if (segment) {
                if (true === options.strictDepth) throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
                keys.push('[' + key.slice(segment.index) + ']');
            }
            return keys;
        };
        var parseKeys = function(givenKey, val, options, valuesParsed) {
            if (!givenKey) return;
            var keys = splitKeyIntoSegments(givenKey, options);
            if (!keys) return;
            return parseObject(keys, val, options, valuesParsed);
        };
        var normalizeParseOptions = function(opts) {
            if (!opts) return defaults;
            if (void 0 !== opts.allowEmptyArrays && 'boolean' != typeof opts.allowEmptyArrays) throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
            if (void 0 !== opts.decodeDotInKeys && 'boolean' != typeof opts.decodeDotInKeys) throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
            if (null !== opts.decoder && void 0 !== opts.decoder && 'function' != typeof opts.decoder) throw new TypeError('Decoder has to be a function.');
            if (void 0 !== opts.charset && 'utf-8' !== opts.charset && 'iso-8859-1' !== opts.charset) throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
            if (void 0 !== opts.throwOnLimitExceeded && 'boolean' != typeof opts.throwOnLimitExceeded) throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
            var charset = void 0 === opts.charset ? defaults.charset : opts.charset;
            var duplicates = void 0 === opts.duplicates ? defaults.duplicates : opts.duplicates;
            if ('combine' !== duplicates && 'first' !== duplicates && 'last' !== duplicates) throw new TypeError('The duplicates option must be either combine, first, or last');
            var allowDots = void 0 === opts.allowDots ? true === opts.decodeDotInKeys ? true : defaults.allowDots : !!opts.allowDots;
            return {
                allowDots: allowDots,
                allowEmptyArrays: 'boolean' == typeof opts.allowEmptyArrays ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
                allowPrototypes: 'boolean' == typeof opts.allowPrototypes ? opts.allowPrototypes : defaults.allowPrototypes,
                allowSparse: 'boolean' == typeof opts.allowSparse ? opts.allowSparse : defaults.allowSparse,
                arrayLimit: 'number' == typeof opts.arrayLimit ? opts.arrayLimit : defaults.arrayLimit,
                charset: charset,
                charsetSentinel: 'boolean' == typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel,
                comma: 'boolean' == typeof opts.comma ? opts.comma : defaults.comma,
                decodeDotInKeys: 'boolean' == typeof opts.decodeDotInKeys ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
                decoder: 'function' == typeof opts.decoder ? opts.decoder : defaults.decoder,
                delimiter: 'string' == typeof opts.delimiter || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
                depth: 'number' == typeof opts.depth || false === opts.depth ? +opts.depth : defaults.depth,
                duplicates: duplicates,
                ignoreQueryPrefix: true === opts.ignoreQueryPrefix,
                interpretNumericEntities: 'boolean' == typeof opts.interpretNumericEntities ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
                parameterLimit: 'number' == typeof opts.parameterLimit ? opts.parameterLimit : defaults.parameterLimit,
                parseArrays: false !== opts.parseArrays,
                plainObjects: 'boolean' == typeof opts.plainObjects ? opts.plainObjects : defaults.plainObjects,
                strictDepth: 'boolean' == typeof opts.strictDepth ? !!opts.strictDepth : defaults.strictDepth,
                strictNullHandling: 'boolean' == typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling,
                throwOnLimitExceeded: 'boolean' == typeof opts.throwOnLimitExceeded ? opts.throwOnLimitExceeded : false
            };
        };
        module.exports = function(str, opts) {
            var options = normalizeParseOptions(opts);
            if ('' === str || null == str) return options.plainObjects ? {
                __proto__: null
            } : {};
            var tempObj = 'string' == typeof str ? parseValues(str, options) : str;
            var obj = options.plainObjects ? {
                __proto__: null
            } : {};
            var keys = Object.keys(tempObj);
            for(var i = 0; i < keys.length; ++i){
                var key = keys[i];
                var newObj = parseKeys(key, tempObj[key], options, 'string' == typeof str);
                obj = utils.merge(obj, newObj, options);
            }
            if (true === options.allowSparse) return obj;
            return utils.compact(obj);
        };
    },
    "../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/stringify.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var getSideChannel = __webpack_require__("../../../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js");
        var utils = __webpack_require__("../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/utils.js");
        var formats = __webpack_require__("../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/formats.js");
        var has = Object.prototype.hasOwnProperty;
        var arrayPrefixGenerators = {
            brackets: function(prefix) {
                return prefix + '[]';
            },
            comma: 'comma',
            indices: function(prefix, key) {
                return prefix + '[' + key + ']';
            },
            repeat: function(prefix) {
                return prefix;
            }
        };
        var isArray = Array.isArray;
        var push = Array.prototype.push;
        var pushToArray = function(arr, valueOrArray) {
            push.apply(arr, isArray(valueOrArray) ? valueOrArray : [
                valueOrArray
            ]);
        };
        var toISO = Date.prototype.toISOString;
        var defaultFormat = formats['default'];
        var defaults = {
            addQueryPrefix: false,
            allowDots: false,
            allowEmptyArrays: false,
            arrayFormat: 'indices',
            charset: 'utf-8',
            charsetSentinel: false,
            commaRoundTrip: false,
            delimiter: '&',
            encode: true,
            encodeDotInKeys: false,
            encoder: utils.encode,
            encodeValuesOnly: false,
            filter: void 0,
            format: defaultFormat,
            formatter: formats.formatters[defaultFormat],
            indices: false,
            serializeDate: function(date) {
                return toISO.call(date);
            },
            skipNulls: false,
            strictNullHandling: false
        };
        var isNonNullishPrimitive = function(v) {
            return 'string' == typeof v || 'number' == typeof v || 'boolean' == typeof v || 'symbol' == typeof v || 'bigint' == typeof v;
        };
        var sentinel = {};
        var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
            var obj = object;
            var tmpSc = sideChannel;
            var step = 0;
            var findFlag = false;
            while(void 0 !== (tmpSc = tmpSc.get(sentinel)) && !findFlag){
                var pos = tmpSc.get(object);
                step += 1;
                if (void 0 !== pos) if (pos === step) throw new RangeError('Cyclic object value');
                else findFlag = true;
                if (void 0 === tmpSc.get(sentinel)) step = 0;
            }
            if ('function' == typeof filter) obj = filter(prefix, obj);
            else if (obj instanceof Date) obj = serializeDate(obj);
            else if ('comma' === generateArrayPrefix && isArray(obj)) obj = utils.maybeMap(obj, function(value) {
                if (value instanceof Date) return serializeDate(value);
                return value;
            });
            if (null === obj) {
                if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
                obj = '';
            }
            if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
                if (encoder) {
                    var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
                    return [
                        formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))
                    ];
                }
                return [
                    formatter(prefix) + '=' + formatter(String(obj))
                ];
            }
            var values = [];
            if (void 0 === obj) return values;
            var objKeys;
            if ('comma' === generateArrayPrefix && isArray(obj)) {
                if (encodeValuesOnly && encoder) obj = utils.maybeMap(obj, encoder);
                objKeys = [
                    {
                        value: obj.length > 0 ? obj.join(',') || null : void 0
                    }
                ];
            } else if (isArray(filter)) objKeys = filter;
            else {
                var keys = Object.keys(obj);
                objKeys = sort ? keys.sort(sort) : keys;
            }
            var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);
            var adjustedPrefix = commaRoundTrip && isArray(obj) && 1 === obj.length ? encodedPrefix + '[]' : encodedPrefix;
            if (allowEmptyArrays && isArray(obj) && 0 === obj.length) return adjustedPrefix + '[]';
            for(var j = 0; j < objKeys.length; ++j){
                var key = objKeys[j];
                var value = 'object' == typeof key && key && void 0 !== key.value ? key.value : obj[key];
                if (!skipNulls || null !== value) {
                    var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
                    var keyPrefix = isArray(obj) ? 'function' == typeof generateArrayPrefix ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
                    sideChannel.set(object, step);
                    var valueSideChannel = getSideChannel();
                    valueSideChannel.set(sentinel, sideChannel);
                    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, 'comma' === generateArrayPrefix && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
                }
            }
            return values;
        };
        var normalizeStringifyOptions = function(opts) {
            if (!opts) return defaults;
            if (void 0 !== opts.allowEmptyArrays && 'boolean' != typeof opts.allowEmptyArrays) throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
            if (void 0 !== opts.encodeDotInKeys && 'boolean' != typeof opts.encodeDotInKeys) throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
            if (null !== opts.encoder && void 0 !== opts.encoder && 'function' != typeof opts.encoder) throw new TypeError('Encoder has to be a function.');
            var charset = opts.charset || defaults.charset;
            if (void 0 !== opts.charset && 'utf-8' !== opts.charset && 'iso-8859-1' !== opts.charset) throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
            var format = formats['default'];
            if (void 0 !== opts.format) {
                if (!has.call(formats.formatters, opts.format)) throw new TypeError('Unknown format option provided.');
                format = opts.format;
            }
            var formatter = formats.formatters[format];
            var filter = defaults.filter;
            if ('function' == typeof opts.filter || isArray(opts.filter)) filter = opts.filter;
            var arrayFormat;
            arrayFormat = opts.arrayFormat in arrayPrefixGenerators ? opts.arrayFormat : 'indices' in opts ? opts.indices ? 'indices' : 'repeat' : defaults.arrayFormat;
            if ('commaRoundTrip' in opts && 'boolean' != typeof opts.commaRoundTrip) throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
            var allowDots = void 0 === opts.allowDots ? true === opts.encodeDotInKeys ? true : defaults.allowDots : !!opts.allowDots;
            return {
                addQueryPrefix: 'boolean' == typeof opts.addQueryPrefix ? opts.addQueryPrefix : defaults.addQueryPrefix,
                allowDots: allowDots,
                allowEmptyArrays: 'boolean' == typeof opts.allowEmptyArrays ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
                arrayFormat: arrayFormat,
                charset: charset,
                charsetSentinel: 'boolean' == typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel,
                commaRoundTrip: !!opts.commaRoundTrip,
                delimiter: void 0 === opts.delimiter ? defaults.delimiter : opts.delimiter,
                encode: 'boolean' == typeof opts.encode ? opts.encode : defaults.encode,
                encodeDotInKeys: 'boolean' == typeof opts.encodeDotInKeys ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
                encoder: 'function' == typeof opts.encoder ? opts.encoder : defaults.encoder,
                encodeValuesOnly: 'boolean' == typeof opts.encodeValuesOnly ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
                filter: filter,
                format: format,
                formatter: formatter,
                serializeDate: 'function' == typeof opts.serializeDate ? opts.serializeDate : defaults.serializeDate,
                skipNulls: 'boolean' == typeof opts.skipNulls ? opts.skipNulls : defaults.skipNulls,
                sort: 'function' == typeof opts.sort ? opts.sort : null,
                strictNullHandling: 'boolean' == typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling
            };
        };
        module.exports = function(object, opts) {
            var obj = object;
            var options = normalizeStringifyOptions(opts);
            var objKeys;
            var filter;
            if ('function' == typeof options.filter) {
                filter = options.filter;
                obj = filter('', obj);
            } else if (isArray(options.filter)) {
                filter = options.filter;
                objKeys = filter;
            }
            var keys = [];
            if ('object' != typeof obj || null === obj) return '';
            var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
            var commaRoundTrip = 'comma' === generateArrayPrefix && options.commaRoundTrip;
            if (!objKeys) objKeys = Object.keys(obj);
            if (options.sort) objKeys.sort(options.sort);
            var sideChannel = getSideChannel();
            for(var i = 0; i < objKeys.length; ++i){
                var key = objKeys[i];
                var value = obj[key];
                if (!options.skipNulls || null !== value) pushToArray(keys, stringify(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
            }
            var joined = keys.join(options.delimiter);
            var prefix = true === options.addQueryPrefix ? '?' : '';
            if (options.charsetSentinel) if ('iso-8859-1' === options.charset) prefix += 'utf8=%26%2310003%3B&';
            else prefix += 'utf8=%E2%9C%93&';
            return joined.length > 0 ? prefix + joined : '';
        };
    },
    "../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/utils.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var formats = __webpack_require__("../../../node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/formats.js");
        var getSideChannel = __webpack_require__("../../../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js");
        var has = Object.prototype.hasOwnProperty;
        var isArray = Array.isArray;
        var overflowChannel = getSideChannel();
        var markOverflow = function(obj, maxIndex) {
            overflowChannel.set(obj, maxIndex);
            return obj;
        };
        var isOverflow = function(obj) {
            return overflowChannel.has(obj);
        };
        var getMaxIndex = function(obj) {
            return overflowChannel.get(obj);
        };
        var setMaxIndex = function(obj, maxIndex) {
            overflowChannel.set(obj, maxIndex);
        };
        var hexTable = function() {
            var array = [];
            for(var i = 0; i < 256; ++i)array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
            return array;
        }();
        var compactQueue = function(queue) {
            while(queue.length > 1){
                var item = queue.pop();
                var obj = item.obj[item.prop];
                if (isArray(obj)) {
                    var compacted = [];
                    for(var j = 0; j < obj.length; ++j)if (void 0 !== obj[j]) compacted.push(obj[j]);
                    item.obj[item.prop] = compacted;
                }
            }
        };
        var arrayToObject = function(source, options) {
            var obj = options && options.plainObjects ? {
                __proto__: null
            } : {};
            for(var i = 0; i < source.length; ++i)if (void 0 !== source[i]) obj[i] = source[i];
            return obj;
        };
        var merge = function merge(target, source, options) {
            if (!source) return target;
            if ('object' != typeof source && 'function' != typeof source) {
                if (isArray(target)) target.push(source);
                else if (!target || 'object' != typeof target) return [
                    target,
                    source
                ];
                else if (isOverflow(target)) {
                    var newIndex = getMaxIndex(target) + 1;
                    target[newIndex] = source;
                    setMaxIndex(target, newIndex);
                } else if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) target[source] = true;
                return target;
            }
            if (!target || 'object' != typeof target) {
                if (isOverflow(source)) {
                    var sourceKeys = Object.keys(source);
                    var result = options && options.plainObjects ? {
                        __proto__: null,
                        0: target
                    } : {
                        0: target
                    };
                    for(var m = 0; m < sourceKeys.length; m++){
                        var oldKey = parseInt(sourceKeys[m], 10);
                        result[oldKey + 1] = source[sourceKeys[m]];
                    }
                    return markOverflow(result, getMaxIndex(source) + 1);
                }
                return [
                    target
                ].concat(source);
            }
            var mergeTarget = target;
            if (isArray(target) && !isArray(source)) mergeTarget = arrayToObject(target, options);
            if (isArray(target) && isArray(source)) {
                source.forEach(function(item, i) {
                    if (has.call(target, i)) {
                        var targetItem = target[i];
                        if (targetItem && 'object' == typeof targetItem && item && 'object' == typeof item) target[i] = merge(targetItem, item, options);
                        else target.push(item);
                    } else target[i] = item;
                });
                return target;
            }
            return Object.keys(source).reduce(function(acc, key) {
                var value = source[key];
                if (has.call(acc, key)) acc[key] = merge(acc[key], value, options);
                else acc[key] = value;
                return acc;
            }, mergeTarget);
        };
        var assign = function(target, source) {
            return Object.keys(source).reduce(function(acc, key) {
                acc[key] = source[key];
                return acc;
            }, target);
        };
        var decode = function(str, defaultDecoder, charset) {
            var strWithoutPlus = str.replace(/\+/g, ' ');
            if ('iso-8859-1' === charset) return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
            try {
                return decodeURIComponent(strWithoutPlus);
            } catch (e) {
                return strWithoutPlus;
            }
        };
        var limit = 1024;
        var encode = function(str, defaultEncoder, charset, kind, format) {
            if (0 === str.length) return str;
            var string = str;
            if ('symbol' == typeof str) string = Symbol.prototype.toString.call(str);
            else if ('string' != typeof str) string = String(str);
            if ('iso-8859-1' === charset) return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
                return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
            });
            var out = '';
            for(var j = 0; j < string.length; j += limit){
                var segment = string.length >= limit ? string.slice(j, j + limit) : string;
                var arr = [];
                for(var i = 0; i < segment.length; ++i){
                    var c = segment.charCodeAt(i);
                    if (0x2D === c || 0x2E === c || 0x5F === c || 0x7E === c || c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A || format === formats.RFC1738 && (0x28 === c || 0x29 === c)) {
                        arr[arr.length] = segment.charAt(i);
                        continue;
                    }
                    if (c < 0x80) {
                        arr[arr.length] = hexTable[c];
                        continue;
                    }
                    if (c < 0x800) {
                        arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | 0x3F & c];
                        continue;
                    }
                    if (c < 0xD800 || c >= 0xE000) {
                        arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | 0x3F & c];
                        continue;
                    }
                    i += 1;
                    c = 0x10000 + ((0x3FF & c) << 10 | 0x3FF & segment.charCodeAt(i));
                    arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | 0x3F & c];
                }
                out += arr.join('');
            }
            return out;
        };
        var compact = function(value) {
            var queue = [
                {
                    obj: {
                        o: value
                    },
                    prop: 'o'
                }
            ];
            var refs = [];
            for(var i = 0; i < queue.length; ++i){
                var item = queue[i];
                var obj = item.obj[item.prop];
                var keys = Object.keys(obj);
                for(var j = 0; j < keys.length; ++j){
                    var key = keys[j];
                    var val = obj[key];
                    if ('object' == typeof val && null !== val && -1 === refs.indexOf(val)) {
                        queue.push({
                            obj: obj,
                            prop: key
                        });
                        refs.push(val);
                    }
                }
            }
            compactQueue(queue);
            return value;
        };
        var isRegExp = function(obj) {
            return '[object RegExp]' === Object.prototype.toString.call(obj);
        };
        var isBuffer = function(obj) {
            if (!obj || 'object' != typeof obj) return false;
            return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
        };
        var combine = function(a, b, arrayLimit, plainObjects) {
            if (isOverflow(a)) {
                var newIndex = getMaxIndex(a) + 1;
                a[newIndex] = b;
                setMaxIndex(a, newIndex);
                return a;
            }
            var result = [].concat(a, b);
            if (result.length > arrayLimit) return markOverflow(arrayToObject(result, {
                plainObjects: plainObjects
            }), result.length - 1);
            return result;
        };
        var maybeMap = function(val, fn) {
            if (isArray(val)) {
                var mapped = [];
                for(var i = 0; i < val.length; i += 1)mapped.push(fn(val[i]));
                return mapped;
            }
            return fn(val);
        };
        module.exports = {
            arrayToObject: arrayToObject,
            assign: assign,
            combine: combine,
            compact: compact,
            decode: decode,
            encode: encode,
            isBuffer: isBuffer,
            isOverflow: isOverflow,
            isRegExp: isRegExp,
            maybeMap: maybeMap,
            merge: merge
        };
    },
    "../../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js" (module) {
        "use strict";
        /*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = rangeParser;
        function rangeParser(size, str, options) {
            if ('string' != typeof str) throw new TypeError('argument str must be a string');
            var index = str.indexOf('=');
            if (-1 === index) return -2;
            var arr = str.slice(index + 1).split(',');
            var ranges = [];
            ranges.type = str.slice(0, index);
            for(var i = 0; i < arr.length; i++){
                var range = arr[i].split('-');
                var start = parseInt(range[0], 10);
                var end = parseInt(range[1], 10);
                if (isNaN(start)) {
                    start = size - end;
                    end = size - 1;
                } else if (isNaN(end)) end = size - 1;
                if (end > size - 1) end = size - 1;
                if (!(isNaN(start) || isNaN(end)) && !(start > end) && !(start < 0)) ranges.push({
                    start: start,
                    end: end
                });
            }
            if (ranges.length < 1) return -1;
            return options && options.combine ? combineRanges(ranges) : ranges;
        }
        function combineRanges(ranges) {
            var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
            for(var j = 0, i = 1; i < ordered.length; i++){
                var range = ordered[i];
                var current = ordered[j];
                if (range.start > current.end + 1) ordered[++j] = range;
                else if (range.end > current.end) {
                    current.end = range.end;
                    current.index = Math.min(current.index, range.index);
                }
            }
            ordered.length = j + 1;
            var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
            combined.type = ranges.type;
            return combined;
        }
        function mapWithIndex(range, index) {
            return {
                start: range.start,
                end: range.end,
                index: index
            };
        }
        function mapWithoutIndex(range) {
            return {
                start: range.start,
                end: range.end
            };
        }
        function sortByRangeIndex(a, b) {
            return a.index - b.index;
        }
        function sortByRangeStart(a, b) {
            return a.start - b.start;
        }
    },
    "../../../node_modules/.pnpm/raw-body@3.0.1/node_modules/raw-body/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var asyncHooks = tryRequireAsyncHooks();
        var bytes = __webpack_require__("../../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var createError = __webpack_require__("../../../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var iconv = __webpack_require__("../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/index.js");
        var unpipe = __webpack_require__("../../../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js");
        module.exports = getRawBody;
        var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
        function getDecoder(encoding) {
            if (!encoding) return null;
            try {
                return iconv.getDecoder(encoding);
            } catch (e) {
                if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
                throw createError(415, 'specified encoding unsupported', {
                    encoding: encoding,
                    type: 'encoding.unsupported'
                });
            }
        }
        function getRawBody(stream, options, callback) {
            var done = callback;
            var opts = options || {};
            if (void 0 === stream) throw new TypeError('argument stream is required');
            if ('object' != typeof stream || null === stream || 'function' != typeof stream.on) throw new TypeError('argument stream must be a stream');
            if (true === options || 'string' == typeof options) opts = {
                encoding: options
            };
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            if (void 0 !== done && 'function' != typeof done) throw new TypeError('argument callback must be a function');
            if (!done && !global.Promise) throw new TypeError('argument callback is required');
            var encoding = true !== opts.encoding ? opts.encoding : 'utf-8';
            var limit = bytes.parse(opts.limit);
            var length = null == opts.length || isNaN(opts.length) ? null : parseInt(opts.length, 10);
            if (done) return readStream(stream, encoding, length, limit, wrap(done));
            return new Promise(function(resolve, reject) {
                readStream(stream, encoding, length, limit, function(err, buf) {
                    if (err) return reject(err);
                    resolve(buf);
                });
            });
        }
        function halt(stream) {
            unpipe(stream);
            if ('function' == typeof stream.pause) stream.pause();
        }
        function readStream(stream, encoding, length, limit, callback) {
            var complete = false;
            var sync = true;
            if (null !== limit && null !== length && length > limit) return done(createError(413, 'request entity too large', {
                expected: length,
                length: length,
                limit: limit,
                type: 'entity.too.large'
            }));
            var state = stream._readableState;
            if (stream._decoder || state && (state.encoding || state.decoder)) return done(createError(500, 'stream encoding should not be set', {
                type: 'stream.encoding.set'
            }));
            if (void 0 !== stream.readable && !stream.readable) return done(createError(500, 'stream is not readable', {
                type: 'stream.not.readable'
            }));
            var received = 0;
            var decoder;
            try {
                decoder = getDecoder(encoding);
            } catch (err) {
                return done(err);
            }
            var buffer = decoder ? '' : [];
            stream.on('aborted', onAborted);
            stream.on('close', cleanup);
            stream.on('data', onData);
            stream.on('end', onEnd);
            stream.on('error', onEnd);
            sync = false;
            function done() {
                var args = new Array(arguments.length);
                for(var i = 0; i < args.length; i++)args[i] = arguments[i];
                complete = true;
                if (sync) process.nextTick(invokeCallback);
                else invokeCallback();
                function invokeCallback() {
                    cleanup();
                    if (args[0]) halt(stream);
                    callback.apply(null, args);
                }
            }
            function onAborted() {
                if (complete) return;
                done(createError(400, 'request aborted', {
                    code: 'ECONNABORTED',
                    expected: length,
                    length: length,
                    received: received,
                    type: 'request.aborted'
                }));
            }
            function onData(chunk) {
                if (complete) return;
                received += chunk.length;
                if (null !== limit && received > limit) done(createError(413, 'request entity too large', {
                    limit: limit,
                    received: received,
                    type: 'entity.too.large'
                }));
                else if (decoder) buffer += decoder.write(chunk);
                else buffer.push(chunk);
            }
            function onEnd(err) {
                if (complete) return;
                if (err) return done(err);
                if (null !== length && received !== length) done(createError(400, 'request size did not match content length', {
                    expected: length,
                    length: length,
                    received: received,
                    type: 'request.size.invalid'
                }));
                else {
                    var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);
                    done(null, string);
                }
            }
            function cleanup() {
                buffer = null;
                stream.removeListener('aborted', onAborted);
                stream.removeListener('data', onData);
                stream.removeListener('end', onEnd);
                stream.removeListener('error', onEnd);
                stream.removeListener('close', cleanup);
            }
        }
        function tryRequireAsyncHooks() {
            try {
                return __webpack_require__("async_hooks");
            } catch (e) {
                return {};
            }
        }
        function wrap(fn) {
            var res;
            if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
            if (!res || !res.runInAsyncScope) return fn;
            return res.runInAsyncScope.bind(res, fn, null);
        }
    },
    "../../../node_modules/.pnpm/router@2.2.0/node_modules/router/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ const isPromise = __webpack_require__("../../../node_modules/.pnpm/is-promise@4.0.0/node_modules/is-promise/index.js");
        const Layer = __webpack_require__("../../../node_modules/.pnpm/router@2.2.0/node_modules/router/lib/layer.js");
        const { METHODS } = __webpack_require__("node:http");
        const parseUrl = __webpack_require__("../../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        const Route = __webpack_require__("../../../node_modules/.pnpm/router@2.2.0/node_modules/router/lib/route.js");
        const debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js")('router');
        const deprecate = __webpack_require__("../../../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('router');
        const slice = Array.prototype.slice;
        const flatten = Array.prototype.flat;
        const methods = METHODS.map((method)=>method.toLowerCase());
        module.exports = Router;
        module.exports.Route = Route;
        function Router(options) {
            if (!(this instanceof Router)) return new Router(options);
            const opts = options || {};
            function router(req, res, next) {
                router.handle(req, res, next);
            }
            Object.setPrototypeOf(router, this);
            router.caseSensitive = opts.caseSensitive;
            router.mergeParams = opts.mergeParams;
            router.params = {};
            router.strict = opts.strict;
            router.stack = [];
            return router;
        }
        Router.prototype = function() {};
        Router.prototype.param = function(name, fn) {
            if (!name) throw new TypeError('argument name is required');
            if ('string' != typeof name) throw new TypeError('argument name must be a string');
            if (!fn) throw new TypeError('argument fn is required');
            if ('function' != typeof fn) throw new TypeError('argument fn must be a function');
            let params = this.params[name];
            if (!params) params = this.params[name] = [];
            params.push(fn);
            return this;
        };
        Router.prototype.handle = function(req, res, callback) {
            if (!callback) throw new TypeError('argument callback is required');
            debug('dispatching %s %s', req.method, req.url);
            let idx = 0;
            let methods;
            const protohost = getProtohost(req.url) || '';
            let removed = '';
            const self1 = this;
            let slashAdded = false;
            let sync = 0;
            const paramcalled = {};
            const stack = this.stack;
            const parentParams = req.params;
            const parentUrl = req.baseUrl || '';
            let done = restore(callback, req, 'baseUrl', 'next', 'params');
            req.next = next;
            if ('OPTIONS' === req.method) {
                methods = [];
                done = wrap(done, generateOptionsResponder(res, methods));
            }
            req.baseUrl = parentUrl;
            req.originalUrl = req.originalUrl || req.url;
            next();
            function next(err) {
                let layerError = 'route' === err ? null : err;
                if (slashAdded) {
                    req.url = req.url.slice(1);
                    slashAdded = false;
                }
                if (0 !== removed.length) {
                    req.baseUrl = parentUrl;
                    req.url = protohost + removed + req.url.slice(protohost.length);
                    removed = '';
                }
                if ('router' === layerError) return void setImmediate(done, null);
                if (idx >= stack.length) return void setImmediate(done, layerError);
                if (++sync > 100) return setImmediate(next, err);
                const path = getPathname(req);
                if (null == path) return done(layerError);
                let layer;
                let match;
                let route;
                while(true !== match && idx < stack.length){
                    layer = stack[idx++];
                    match = matchLayer(layer, path);
                    route = layer.route;
                    if ('boolean' != typeof match) layerError = layerError || match;
                    if (true !== match) continue;
                    if (!route) continue;
                    if (layerError) {
                        match = false;
                        continue;
                    }
                    const method = req.method;
                    const hasMethod = route._handlesMethod(method);
                    if (!hasMethod && 'OPTIONS' === method && methods) methods.push.apply(methods, route._methods());
                    if (!hasMethod && 'HEAD' !== method) match = false;
                }
                if (true !== match) return done(layerError);
                if (route) req.route = route;
                req.params = self1.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
                const layerPath = layer.path;
                processParams(self1.params, layer, paramcalled, req, res, function(err) {
                    if (err) next(layerError || err);
                    else if (route) layer.handleRequest(req, res, next);
                    else trimPrefix(layer, layerError, layerPath, path);
                    sync = 0;
                });
            }
            function trimPrefix(layer, layerError, layerPath, path) {
                if (0 !== layerPath.length) {
                    if (layerPath !== path.substring(0, layerPath.length)) return void next(layerError);
                    const c = path[layerPath.length];
                    if (c && '/' !== c) return void next(layerError);
                    debug('trim prefix (%s) from url %s', layerPath, req.url);
                    removed = layerPath;
                    req.url = protohost + req.url.slice(protohost.length + removed.length);
                    if (!protohost && '/' !== req.url[0]) {
                        req.url = '/' + req.url;
                        slashAdded = true;
                    }
                    req.baseUrl = parentUrl + ('/' === removed[removed.length - 1] ? removed.substring(0, removed.length - 1) : removed);
                }
                debug('%s %s : %s', layer.name, layerPath, req.originalUrl);
                if (layerError) layer.handleError(layerError, req, res, next);
                else layer.handleRequest(req, res, next);
            }
        };
        Router.prototype.use = function(handler) {
            let offset = 0;
            let path = '/';
            if ('function' != typeof handler) {
                let arg = handler;
                while(Array.isArray(arg) && 0 !== arg.length)arg = arg[0];
                if ('function' != typeof arg) {
                    offset = 1;
                    path = handler;
                }
            }
            const callbacks = flatten.call(slice.call(arguments, offset), 1 / 0);
            if (0 === callbacks.length) throw new TypeError('argument handler is required');
            for(let i = 0; i < callbacks.length; i++){
                const fn = callbacks[i];
                if ('function' != typeof fn) throw new TypeError('argument handler must be a function');
                debug('use %o %s', path, fn.name || '<anonymous>');
                const layer = new Layer(path, {
                    sensitive: this.caseSensitive,
                    strict: false,
                    end: false
                }, fn);
                layer.route = void 0;
                this.stack.push(layer);
            }
            return this;
        };
        Router.prototype.route = function(path) {
            const route = new Route(path);
            const layer = new Layer(path, {
                sensitive: this.caseSensitive,
                strict: this.strict,
                end: true
            }, handle);
            function handle(req, res, next) {
                route.dispatch(req, res, next);
            }
            layer.route = route;
            this.stack.push(layer);
            return route;
        };
        methods.concat('all').forEach(function(method) {
            Router.prototype[method] = function(path) {
                const route = this.route(path);
                route[method].apply(route, slice.call(arguments, 1));
                return this;
            };
        });
        function generateOptionsResponder(res, methods) {
            return function(fn, err) {
                if (err || 0 === methods.length) return fn(err);
                trySendOptionsResponse(res, methods, fn);
            };
        }
        function getPathname(req) {
            try {
                return parseUrl(req).pathname;
            } catch (err) {
                return;
            }
        }
        function getProtohost(url) {
            if ('string' != typeof url || 0 === url.length || '/' === url[0]) return;
            const searchIndex = url.indexOf('?');
            const pathLength = -1 !== searchIndex ? searchIndex : url.length;
            const fqdnIndex = url.substring(0, pathLength).indexOf('://');
            return -1 !== fqdnIndex ? url.substring(0, url.indexOf('/', 3 + fqdnIndex)) : void 0;
        }
        function matchLayer(layer, path) {
            try {
                return layer.match(path);
            } catch (err) {
                return err;
            }
        }
        function mergeParams(params, parent) {
            if ('object' != typeof parent || !parent) return params;
            const obj = Object.assign({}, parent);
            if (!(0 in params) || !(0 in parent)) return Object.assign(obj, params);
            let i = 0;
            let o = 0;
            while(i in params)i++;
            while(o in parent)o++;
            for(i--; i >= 0; i--){
                params[i + o] = params[i];
                if (i < o) delete params[i];
            }
            return Object.assign(obj, params);
        }
        function processParams(params, layer, called, req, res, done) {
            const keys = layer.keys;
            if (!keys || 0 === keys.length) return done();
            let i = 0;
            let paramIndex = 0;
            let key;
            let paramVal;
            let paramCallbacks;
            let paramCalled;
            function param(err) {
                if (err) return done(err);
                if (i >= keys.length) return done();
                paramIndex = 0;
                key = keys[i++];
                paramVal = req.params[key];
                paramCallbacks = params[key];
                paramCalled = called[key];
                if (void 0 === paramVal || !paramCallbacks) return param();
                if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && 'route' !== paramCalled.error)) {
                    req.params[key] = paramCalled.value;
                    return param(paramCalled.error);
                }
                called[key] = paramCalled = {
                    error: null,
                    match: paramVal,
                    value: paramVal
                };
                paramCallback();
            }
            function paramCallback(err) {
                const fn = paramCallbacks[paramIndex++];
                paramCalled.value = req.params[key];
                if (err) {
                    paramCalled.error = err;
                    param(err);
                    return;
                }
                if (!fn) return param();
                try {
                    const ret = fn(req, res, paramCallback, paramVal, key);
                    if (isPromise(ret)) {
                        if (!(ret instanceof Promise)) deprecate('parameters that are Promise-like are deprecated, use a native Promise instead');
                        ret.then(null, function(error) {
                            paramCallback(error || new Error('Rejected promise'));
                        });
                    }
                } catch (e) {
                    paramCallback(e);
                }
            }
            param();
        }
        function restore(fn, obj) {
            const props = new Array(arguments.length - 2);
            const vals = new Array(arguments.length - 2);
            for(let i = 0; i < props.length; i++){
                props[i] = arguments[i + 2];
                vals[i] = obj[props[i]];
            }
            return function() {
                for(let i = 0; i < props.length; i++)obj[props[i]] = vals[i];
                return fn.apply(this, arguments);
            };
        }
        function sendOptionsResponse(res, methods) {
            const options = Object.create(null);
            for(let i = 0; i < methods.length; i++)options[methods[i]] = true;
            const allow = Object.keys(options).sort().join(', ');
            res.setHeader('Allow', allow);
            res.setHeader('Content-Length', Buffer.byteLength(allow));
            res.setHeader('Content-Type', 'text/plain');
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.end(allow);
        }
        function trySendOptionsResponse(res, methods, next) {
            try {
                sendOptionsResponse(res, methods);
            } catch (err) {
                next(err);
            }
        }
        function wrap(old, fn) {
            return function() {
                const args = new Array(arguments.length + 1);
                args[0] = old;
                for(let i = 0, len = arguments.length; i < len; i++)args[i + 1] = arguments[i];
                fn.apply(this, args);
            };
        }
    },
    "../../../node_modules/.pnpm/router@2.2.0/node_modules/router/lib/layer.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ const isPromise = __webpack_require__("../../../node_modules/.pnpm/is-promise@4.0.0/node_modules/is-promise/index.js");
        const pathRegexp = __webpack_require__("../../../node_modules/.pnpm/path-to-regexp@8.3.0/node_modules/path-to-regexp/dist/index.js");
        const debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js")('router:layer');
        const deprecate = __webpack_require__("../../../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('router');
        const TRAILING_SLASH_REGEXP = /\/+$/;
        const MATCHING_GROUP_REGEXP = /\((?:\?<(.*?)>)?(?!\?)/g;
        module.exports = Layer;
        function Layer(path, options, fn) {
            if (!(this instanceof Layer)) return new Layer(path, options, fn);
            debug('new %o', path);
            const opts = options || {};
            this.handle = fn;
            this.keys = [];
            this.name = fn.name || '<anonymous>';
            this.params = void 0;
            this.path = void 0;
            this.slash = '/' === path && false === opts.end;
            function matcher(_path) {
                if (_path instanceof RegExp) {
                    const keys = [];
                    let name = 0;
                    let m;
                    while(m = MATCHING_GROUP_REGEXP.exec(_path.source))keys.push({
                        name: m[1] || name++,
                        offset: m.index
                    });
                    return function(p) {
                        const match = _path.exec(p);
                        if (!match) return false;
                        const params = {};
                        for(let i = 1; i < match.length; i++){
                            const key = keys[i - 1];
                            const prop = key.name;
                            const val = decodeParam(match[i]);
                            if (void 0 !== val) params[prop] = val;
                        }
                        return {
                            params,
                            path: match[0]
                        };
                    };
                }
                return pathRegexp.match(opts.strict ? _path : loosen(_path), {
                    sensitive: opts.sensitive,
                    end: opts.end,
                    trailing: !opts.strict,
                    decode: decodeParam
                });
            }
            this.matchers = Array.isArray(path) ? path.map(matcher) : [
                matcher(path)
            ];
        }
        Layer.prototype.handleError = function(error, req, res, next) {
            const fn = this.handle;
            if (4 !== fn.length) return next(error);
            try {
                const ret = fn(error, req, res, next);
                if (isPromise(ret)) {
                    if (!(ret instanceof Promise)) deprecate('handlers that are Promise-like are deprecated, use a native Promise instead');
                    ret.then(null, function(error) {
                        next(error || new Error('Rejected promise'));
                    });
                }
            } catch (err) {
                next(err);
            }
        };
        Layer.prototype.handleRequest = function(req, res, next) {
            const fn = this.handle;
            if (fn.length > 3) return next();
            try {
                const ret = fn(req, res, next);
                if (isPromise(ret)) {
                    if (!(ret instanceof Promise)) deprecate('handlers that are Promise-like are deprecated, use a native Promise instead');
                    ret.then(null, function(error) {
                        next(error || new Error('Rejected promise'));
                    });
                }
            } catch (err) {
                next(err);
            }
        };
        Layer.prototype.match = function(path) {
            let match;
            if (null != path) {
                if (this.slash) {
                    this.params = {};
                    this.path = '';
                    return true;
                }
                let i = 0;
                while(!match && i < this.matchers.length){
                    match = this.matchers[i](path);
                    i++;
                }
            }
            if (!match) {
                this.params = void 0;
                this.path = void 0;
                return false;
            }
            this.params = match.params;
            this.path = match.path;
            this.keys = Object.keys(match.params);
            return true;
        };
        function decodeParam(val) {
            if ('string' != typeof val || 0 === val.length) return val;
            try {
                return decodeURIComponent(val);
            } catch (err) {
                if (err instanceof URIError) {
                    err.message = 'Failed to decode param \'' + val + '\'';
                    err.status = 400;
                }
                throw err;
            }
        }
        function loosen(path) {
            if (path instanceof RegExp || '/' === path) return path;
            return Array.isArray(path) ? path.map(function(p) {
                return loosen(p);
            }) : String(path).replace(TRAILING_SLASH_REGEXP, '');
        }
    },
    "../../../node_modules/.pnpm/router@2.2.0/node_modules/router/lib/route.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ const debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js")('router:route');
        const Layer = __webpack_require__("../../../node_modules/.pnpm/router@2.2.0/node_modules/router/lib/layer.js");
        const { METHODS } = __webpack_require__("node:http");
        const slice = Array.prototype.slice;
        const flatten = Array.prototype.flat;
        const methods = METHODS.map((method)=>method.toLowerCase());
        module.exports = Route;
        function Route(path) {
            debug('new %o', path);
            this.path = path;
            this.stack = [];
            this.methods = Object.create(null);
        }
        Route.prototype._handlesMethod = function(method) {
            if (this.methods._all) return true;
            let name = 'string' == typeof method ? method.toLowerCase() : method;
            if ('head' === name && !this.methods.head) name = 'get';
            return Boolean(this.methods[name]);
        };
        Route.prototype._methods = function() {
            const methods = Object.keys(this.methods);
            if (this.methods.get && !this.methods.head) methods.push('head');
            for(let i = 0; i < methods.length; i++)methods[i] = methods[i].toUpperCase();
            return methods;
        };
        Route.prototype.dispatch = function(req, res, done) {
            let idx = 0;
            const stack = this.stack;
            let sync = 0;
            if (0 === stack.length) return done();
            let method = 'string' == typeof req.method ? req.method.toLowerCase() : req.method;
            if ('head' === method && !this.methods.head) method = 'get';
            req.route = this;
            next();
            function next(err) {
                if (err && 'route' === err) return done();
                if (err && 'router' === err) return done(err);
                if (idx >= stack.length) return done(err);
                if (++sync > 100) return setImmediate(next, err);
                let layer;
                let match;
                while(true !== match && idx < stack.length){
                    layer = stack[idx++];
                    match = !layer.method || layer.method === method;
                }
                if (true !== match) return done(err);
                if (err) layer.handleError(err, req, res, next);
                else layer.handleRequest(req, res, next);
                sync = 0;
            }
        };
        Route.prototype.all = function(handler) {
            const callbacks = flatten.call(slice.call(arguments), 1 / 0);
            if (0 === callbacks.length) throw new TypeError('argument handler is required');
            for(let i = 0; i < callbacks.length; i++){
                const fn = callbacks[i];
                if ('function' != typeof fn) throw new TypeError('argument handler must be a function');
                const layer = Layer('/', {}, fn);
                layer.method = void 0;
                this.methods._all = true;
                this.stack.push(layer);
            }
            return this;
        };
        methods.forEach(function(method) {
            Route.prototype[method] = function(handler) {
                const callbacks = flatten.call(slice.call(arguments), 1 / 0);
                if (0 === callbacks.length) throw new TypeError('argument handler is required');
                for(let i = 0; i < callbacks.length; i++){
                    const fn = callbacks[i];
                    if ('function' != typeof fn) throw new TypeError('argument handler must be a function');
                    debug('%s %s', method, this.path);
                    const layer = Layer('/', {}, fn);
                    layer.method = method;
                    this.methods[method] = true;
                    this.stack.push(layer);
                }
                return this;
            };
        });
    },
    "../../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js" (module, exports1, __webpack_require__) {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var buffer = __webpack_require__("buffer");
        var Buffer1 = buffer.Buffer;
        function copyProps(src, dst) {
            for(var key in src)dst[key] = src[key];
        }
        if (Buffer1.from && Buffer1.alloc && Buffer1.allocUnsafe && Buffer1.allocUnsafeSlow) module.exports = buffer;
        else {
            copyProps(buffer, exports1);
            exports1.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer1(arg, encodingOrOffset, length);
        }
        SafeBuffer.prototype = Object.create(Buffer1.prototype);
        copyProps(Buffer1, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
            if ('number' == typeof arg) throw new TypeError('Argument must not be a number');
            return Buffer1(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
            if ('number' != typeof size) throw new TypeError('Argument must be a number');
            var buf = Buffer1(size);
            if (void 0 !== fill) if ('string' == typeof encoding) buf.fill(fill, encoding);
            else buf.fill(fill);
            else buf.fill(0);
            return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
            if ('number' != typeof size) throw new TypeError('Argument must be a number');
            return Buffer1(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
            if ('number' != typeof size) throw new TypeError('Argument must be a number');
            return buffer.SlowBuffer(size);
        };
    },
    "../../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var buffer = __webpack_require__("buffer");
        var Buffer1 = buffer.Buffer;
        var safer = {};
        var key;
        for(key in buffer)if (buffer.hasOwnProperty(key)) {
            if ('SlowBuffer' !== key && 'Buffer' !== key) safer[key] = buffer[key];
        }
        var Safer = safer.Buffer = {};
        for(key in Buffer1)if (Buffer1.hasOwnProperty(key)) {
            if ('allocUnsafe' !== key && 'allocUnsafeSlow' !== key) Safer[key] = Buffer1[key];
        }
        safer.Buffer.prototype = Buffer1.prototype;
        if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
            if ('number' == typeof value) throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
            if (value && void 0 === value.length) throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
            return Buffer1(value, encodingOrOffset, length);
        };
        if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
            if ('number' != typeof size) throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
            if (size < 0 || size >= 2 * 1073741824) throw new RangeError('The value "' + size + '" is invalid for option "size"');
            var buf = Buffer1(size);
            if (fill && 0 !== fill.length) if ('string' == typeof encoding) buf.fill(fill, encoding);
            else buf.fill(fill);
            else buf.fill(0);
            return buf;
        };
        if (!safer.kStringMaxLength) try {
            safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
        } catch (e) {}
        if (!safer.constants) {
            safer.constants = {
                MAX_LENGTH: safer.kMaxLength
            };
            if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
        }
        module.exports = safer;
    },
    "../../../node_modules/.pnpm/sax@1.2.4/node_modules/sax/lib/sax.js" (__unused_rspack_module, exports1, __webpack_require__) {
        (function(sax) {
            sax.parser = function(strict, opt) {
                return new SAXParser(strict, opt);
            };
            sax.SAXParser = SAXParser;
            sax.SAXStream = SAXStream;
            sax.createStream = createStream;
            sax.MAX_BUFFER_LENGTH = 65536;
            var buffers = [
                'comment',
                'sgmlDecl',
                'textNode',
                'tagName',
                'doctype',
                'procInstName',
                'procInstBody',
                'entity',
                'attribName',
                'attribValue',
                'cdata',
                "script"
            ];
            sax.EVENTS = [
                'text',
                'processinginstruction',
                'sgmldeclaration',
                'doctype',
                'comment',
                'opentagstart',
                'attribute',
                'opentag',
                'closetag',
                'opencdata',
                'cdata',
                'closecdata',
                'error',
                'end',
                'ready',
                "script",
                'opennamespace',
                'closenamespace'
            ];
            function SAXParser(strict, opt) {
                if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
                var parser = this;
                clearBuffers(parser);
                parser.q = parser.c = '';
                parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
                parser.opt = opt || {};
                parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
                parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
                parser.tags = [];
                parser.closed = parser.closedRoot = parser.sawRoot = false;
                parser.tag = parser.error = null;
                parser.strict = !!strict;
                parser.noscript = !!(strict || parser.opt.noscript);
                parser.state = S.BEGIN;
                parser.strictEntities = parser.opt.strictEntities;
                parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
                parser.attribList = [];
                if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
                parser.trackPosition = false !== parser.opt.position;
                if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
                emit(parser, 'onready');
            }
            if (!Object.create) Object.create = function(o) {
                function F() {}
                F.prototype = o;
                var newf = new F();
                return newf;
            };
            if (!Object.keys) Object.keys = function(o) {
                var a = [];
                for(var i in o)if (o.hasOwnProperty(i)) a.push(i);
                return a;
            };
            function checkBufferLength(parser) {
                var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
                var maxActual = 0;
                for(var i = 0, l = buffers.length; i < l; i++){
                    var len = parser[buffers[i]].length;
                    if (len > maxAllowed) switch(buffers[i]){
                        case 'textNode':
                            closeText(parser);
                            break;
                        case 'cdata':
                            emitNode(parser, 'oncdata', parser.cdata);
                            parser.cdata = '';
                            break;
                        case "script":
                            emitNode(parser, "onscript", parser.script);
                            parser.script = '';
                            break;
                        default:
                            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
                    }
                    maxActual = Math.max(maxActual, len);
                }
                var m = sax.MAX_BUFFER_LENGTH - maxActual;
                parser.bufferCheckPosition = m + parser.position;
            }
            function clearBuffers(parser) {
                for(var i = 0, l = buffers.length; i < l; i++)parser[buffers[i]] = '';
            }
            function flushBuffers(parser) {
                closeText(parser);
                if ('' !== parser.cdata) {
                    emitNode(parser, 'oncdata', parser.cdata);
                    parser.cdata = '';
                }
                if ('' !== parser.script) {
                    emitNode(parser, "onscript", parser.script);
                    parser.script = '';
                }
            }
            SAXParser.prototype = {
                end: function() {
                    end(this);
                },
                write: write,
                resume: function() {
                    this.error = null;
                    return this;
                },
                close: function() {
                    return this.write(null);
                },
                flush: function() {
                    flushBuffers(this);
                }
            };
            var Stream;
            try {
                Stream = __webpack_require__("stream").Stream;
            } catch (ex) {
                Stream = function() {};
            }
            var streamWraps = sax.EVENTS.filter(function(ev) {
                return 'error' !== ev && 'end' !== ev;
            });
            function createStream(strict, opt) {
                return new SAXStream(strict, opt);
            }
            function SAXStream(strict, opt) {
                if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
                Stream.apply(this);
                this._parser = new SAXParser(strict, opt);
                this.writable = true;
                this.readable = true;
                var me = this;
                this._parser.onend = function() {
                    me.emit('end');
                };
                this._parser.onerror = function(er) {
                    me.emit('error', er);
                    me._parser.error = null;
                };
                this._decoder = null;
                streamWraps.forEach(function(ev) {
                    Object.defineProperty(me, 'on' + ev, {
                        get: function() {
                            return me._parser['on' + ev];
                        },
                        set: function(h) {
                            if (!h) {
                                me.removeAllListeners(ev);
                                me._parser['on' + ev] = h;
                                return h;
                            }
                            me.on(ev, h);
                        },
                        enumerable: true,
                        configurable: false
                    });
                });
            }
            SAXStream.prototype = Object.create(Stream.prototype, {
                constructor: {
                    value: SAXStream
                }
            });
            SAXStream.prototype.write = function(data) {
                if ('function' == typeof Buffer && 'function' == typeof Buffer.isBuffer && Buffer.isBuffer(data)) {
                    if (!this._decoder) {
                        var SD = __webpack_require__("string_decoder").StringDecoder;
                        this._decoder = new SD('utf8');
                    }
                    data = this._decoder.write(data);
                }
                this._parser.write(data.toString());
                this.emit('data', data);
                return true;
            };
            SAXStream.prototype.end = function(chunk) {
                if (chunk && chunk.length) this.write(chunk);
                this._parser.end();
                return true;
            };
            SAXStream.prototype.on = function(ev, handler) {
                var me = this;
                if (!me._parser['on' + ev] && -1 !== streamWraps.indexOf(ev)) me._parser['on' + ev] = function() {
                    var args = 1 === arguments.length ? [
                        arguments[0]
                    ] : Array.apply(null, arguments);
                    args.splice(0, 0, ev);
                    me.emit.apply(me, args);
                };
                return Stream.prototype.on.call(me, ev, handler);
            };
            var CDATA = '[CDATA[';
            var DOCTYPE = 'DOCTYPE';
            var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
            var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
            var rootNS = {
                xml: XML_NAMESPACE,
                xmlns: XMLNS_NAMESPACE
            };
            var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
            var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
            function isWhitespace(c) {
                return ' ' === c || '\n' === c || '\r' === c || '\t' === c;
            }
            function isQuote(c) {
                return '"' === c || '\'' === c;
            }
            function isAttribEnd(c) {
                return '>' === c || isWhitespace(c);
            }
            function isMatch(regex, c) {
                return regex.test(c);
            }
            function notMatch(regex, c) {
                return !isMatch(regex, c);
            }
            var S = 0;
            sax.STATE = {
                BEGIN: S++,
                BEGIN_WHITESPACE: S++,
                TEXT: S++,
                TEXT_ENTITY: S++,
                OPEN_WAKA: S++,
                SGML_DECL: S++,
                SGML_DECL_QUOTED: S++,
                DOCTYPE: S++,
                DOCTYPE_QUOTED: S++,
                DOCTYPE_DTD: S++,
                DOCTYPE_DTD_QUOTED: S++,
                COMMENT_STARTING: S++,
                COMMENT: S++,
                COMMENT_ENDING: S++,
                COMMENT_ENDED: S++,
                CDATA: S++,
                CDATA_ENDING: S++,
                CDATA_ENDING_2: S++,
                PROC_INST: S++,
                PROC_INST_BODY: S++,
                PROC_INST_ENDING: S++,
                OPEN_TAG: S++,
                OPEN_TAG_SLASH: S++,
                ATTRIB: S++,
                ATTRIB_NAME: S++,
                ATTRIB_NAME_SAW_WHITE: S++,
                ATTRIB_VALUE: S++,
                ATTRIB_VALUE_QUOTED: S++,
                ATTRIB_VALUE_CLOSED: S++,
                ATTRIB_VALUE_UNQUOTED: S++,
                ATTRIB_VALUE_ENTITY_Q: S++,
                ATTRIB_VALUE_ENTITY_U: S++,
                CLOSE_TAG: S++,
                CLOSE_TAG_SAW_WHITE: S++,
                SCRIPT: S++,
                SCRIPT_ENDING: S++
            };
            sax.XML_ENTITIES = {
                amp: '&',
                gt: '>',
                lt: '<',
                quot: '"',
                apos: "'"
            };
            sax.ENTITIES = {
                amp: '&',
                gt: '>',
                lt: '<',
                quot: '"',
                apos: "'",
                AElig: 198,
                Aacute: 193,
                Acirc: 194,
                Agrave: 192,
                Aring: 197,
                Atilde: 195,
                Auml: 196,
                Ccedil: 199,
                ETH: 208,
                Eacute: 201,
                Ecirc: 202,
                Egrave: 200,
                Euml: 203,
                Iacute: 205,
                Icirc: 206,
                Igrave: 204,
                Iuml: 207,
                Ntilde: 209,
                Oacute: 211,
                Ocirc: 212,
                Ograve: 210,
                Oslash: 216,
                Otilde: 213,
                Ouml: 214,
                THORN: 222,
                Uacute: 218,
                Ucirc: 219,
                Ugrave: 217,
                Uuml: 220,
                Yacute: 221,
                aacute: 225,
                acirc: 226,
                aelig: 230,
                agrave: 224,
                aring: 229,
                atilde: 227,
                auml: 228,
                ccedil: 231,
                eacute: 233,
                ecirc: 234,
                egrave: 232,
                eth: 240,
                euml: 235,
                iacute: 237,
                icirc: 238,
                igrave: 236,
                iuml: 239,
                ntilde: 241,
                oacute: 243,
                ocirc: 244,
                ograve: 242,
                oslash: 248,
                otilde: 245,
                ouml: 246,
                szlig: 223,
                thorn: 254,
                uacute: 250,
                ucirc: 251,
                ugrave: 249,
                uuml: 252,
                yacute: 253,
                yuml: 255,
                copy: 169,
                reg: 174,
                nbsp: 160,
                iexcl: 161,
                cent: 162,
                pound: 163,
                curren: 164,
                yen: 165,
                brvbar: 166,
                sect: 167,
                uml: 168,
                ordf: 170,
                laquo: 171,
                not: 172,
                shy: 173,
                macr: 175,
                deg: 176,
                plusmn: 177,
                sup1: 185,
                sup2: 178,
                sup3: 179,
                acute: 180,
                micro: 181,
                para: 182,
                middot: 183,
                cedil: 184,
                ordm: 186,
                raquo: 187,
                frac14: 188,
                frac12: 189,
                frac34: 190,
                iquest: 191,
                times: 215,
                divide: 247,
                OElig: 338,
                oelig: 339,
                Scaron: 352,
                scaron: 353,
                Yuml: 376,
                fnof: 402,
                circ: 710,
                tilde: 732,
                Alpha: 913,
                Beta: 914,
                Gamma: 915,
                Delta: 916,
                Epsilon: 917,
                Zeta: 918,
                Eta: 919,
                Theta: 920,
                Iota: 921,
                Kappa: 922,
                Lambda: 923,
                Mu: 924,
                Nu: 925,
                Xi: 926,
                Omicron: 927,
                Pi: 928,
                Rho: 929,
                Sigma: 931,
                Tau: 932,
                Upsilon: 933,
                Phi: 934,
                Chi: 935,
                Psi: 936,
                Omega: 937,
                alpha: 945,
                beta: 946,
                gamma: 947,
                delta: 948,
                epsilon: 949,
                zeta: 950,
                eta: 951,
                theta: 952,
                iota: 953,
                kappa: 954,
                lambda: 955,
                mu: 956,
                nu: 957,
                xi: 958,
                omicron: 959,
                pi: 960,
                rho: 961,
                sigmaf: 962,
                sigma: 963,
                tau: 964,
                upsilon: 965,
                phi: 966,
                chi: 967,
                psi: 968,
                omega: 969,
                thetasym: 977,
                upsih: 978,
                piv: 982,
                ensp: 8194,
                emsp: 8195,
                thinsp: 8201,
                zwnj: 8204,
                zwj: 8205,
                lrm: 8206,
                rlm: 8207,
                ndash: 8211,
                mdash: 8212,
                lsquo: 8216,
                rsquo: 8217,
                sbquo: 8218,
                ldquo: 8220,
                rdquo: 8221,
                bdquo: 8222,
                dagger: 8224,
                Dagger: 8225,
                bull: 8226,
                hellip: 8230,
                permil: 8240,
                prime: 8242,
                Prime: 8243,
                lsaquo: 8249,
                rsaquo: 8250,
                oline: 8254,
                frasl: 8260,
                euro: 8364,
                image: 8465,
                weierp: 8472,
                real: 8476,
                trade: 8482,
                alefsym: 8501,
                larr: 8592,
                uarr: 8593,
                rarr: 8594,
                darr: 8595,
                harr: 8596,
                crarr: 8629,
                lArr: 8656,
                uArr: 8657,
                rArr: 8658,
                dArr: 8659,
                hArr: 8660,
                forall: 8704,
                part: 8706,
                exist: 8707,
                empty: 8709,
                nabla: 8711,
                isin: 8712,
                notin: 8713,
                ni: 8715,
                prod: 8719,
                sum: 8721,
                minus: 8722,
                lowast: 8727,
                radic: 8730,
                prop: 8733,
                infin: 8734,
                ang: 8736,
                and: 8743,
                or: 8744,
                cap: 8745,
                cup: 8746,
                int: 8747,
                there4: 8756,
                sim: 8764,
                cong: 8773,
                asymp: 8776,
                ne: 8800,
                equiv: 8801,
                le: 8804,
                ge: 8805,
                sub: 8834,
                sup: 8835,
                nsub: 8836,
                sube: 8838,
                supe: 8839,
                oplus: 8853,
                otimes: 8855,
                perp: 8869,
                sdot: 8901,
                lceil: 8968,
                rceil: 8969,
                lfloor: 8970,
                rfloor: 8971,
                lang: 9001,
                rang: 9002,
                loz: 9674,
                spades: 9824,
                clubs: 9827,
                hearts: 9829,
                diams: 9830
            };
            Object.keys(sax.ENTITIES).forEach(function(key) {
                var e = sax.ENTITIES[key];
                var s = 'number' == typeof e ? String.fromCharCode(e) : e;
                sax.ENTITIES[key] = s;
            });
            for(var s in sax.STATE)sax.STATE[sax.STATE[s]] = s;
            S = sax.STATE;
            function emit(parser, event, data) {
                parser[event] && parser[event](data);
            }
            function emitNode(parser, nodeType, data) {
                if (parser.textNode) closeText(parser);
                emit(parser, nodeType, data);
            }
            function closeText(parser) {
                parser.textNode = textopts(parser.opt, parser.textNode);
                if (parser.textNode) emit(parser, 'ontext', parser.textNode);
                parser.textNode = '';
            }
            function textopts(opt, text) {
                if (opt.trim) text = text.trim();
                if (opt.normalize) text = text.replace(/\s+/g, ' ');
                return text;
            }
            function error(parser, er) {
                closeText(parser);
                if (parser.trackPosition) er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
                er = new Error(er);
                parser.error = er;
                emit(parser, 'onerror', er);
                return parser;
            }
            function end(parser) {
                if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
                if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) error(parser, 'Unexpected end');
                closeText(parser);
                parser.c = '';
                parser.closed = true;
                emit(parser, 'onend');
                SAXParser.call(parser, parser.strict, parser.opt);
                return parser;
            }
            function strictFail(parser, message) {
                if ('object' != typeof parser || !(parser instanceof SAXParser)) throw new Error('bad call to strictFail');
                if (parser.strict) error(parser, message);
            }
            function newTag(parser) {
                if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
                var parent = parser.tags[parser.tags.length - 1] || parser;
                var tag = parser.tag = {
                    name: parser.tagName,
                    attributes: {}
                };
                if (parser.opt.xmlns) tag.ns = parent.ns;
                parser.attribList.length = 0;
                emitNode(parser, 'onopentagstart', tag);
            }
            function qname(name, attribute) {
                var i = name.indexOf(':');
                var qualName = i < 0 ? [
                    '',
                    name
                ] : name.split(':');
                var prefix = qualName[0];
                var local = qualName[1];
                if (attribute && 'xmlns' === name) {
                    prefix = 'xmlns';
                    local = '';
                }
                return {
                    prefix: prefix,
                    local: local
                };
            }
            function attrib(parser) {
                if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
                if (-1 !== parser.attribList.indexOf(parser.attribName) || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                    parser.attribName = parser.attribValue = '';
                    return;
                }
                if (parser.opt.xmlns) {
                    var qn = qname(parser.attribName, true);
                    var prefix = qn.prefix;
                    var local = qn.local;
                    if ('xmlns' === prefix) if ('xml' === local && parser.attribValue !== XML_NAMESPACE) strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + "\nActual: " + parser.attribValue);
                    else if ('xmlns' === local && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
                    else {
                        var tag = parser.tag;
                        var parent = parser.tags[parser.tags.length - 1] || parser;
                        if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
                        tag.ns[local] = parser.attribValue;
                    }
                    parser.attribList.push([
                        parser.attribName,
                        parser.attribValue
                    ]);
                } else {
                    parser.tag.attributes[parser.attribName] = parser.attribValue;
                    emitNode(parser, 'onattribute', {
                        name: parser.attribName,
                        value: parser.attribValue
                    });
                }
                parser.attribName = parser.attribValue = '';
            }
            function openTag(parser, selfClosing) {
                if (parser.opt.xmlns) {
                    var tag = parser.tag;
                    var qn = qname(parser.tagName);
                    tag.prefix = qn.prefix;
                    tag.local = qn.local;
                    tag.uri = tag.ns[qn.prefix] || '';
                    if (tag.prefix && !tag.uri) {
                        strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
                        tag.uri = qn.prefix;
                    }
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p) {
                        emitNode(parser, 'onopennamespace', {
                            prefix: p,
                            uri: tag.ns[p]
                        });
                    });
                    for(var i = 0, l = parser.attribList.length; i < l; i++){
                        var nv = parser.attribList[i];
                        var name = nv[0];
                        var value = nv[1];
                        var qualName = qname(name, true);
                        var prefix = qualName.prefix;
                        var local = qualName.local;
                        var uri = '' === prefix ? '' : tag.ns[prefix] || '';
                        var a = {
                            name: name,
                            value: value,
                            prefix: prefix,
                            local: local,
                            uri: uri
                        };
                        if (prefix && 'xmlns' !== prefix && !uri) {
                            strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
                            a.uri = prefix;
                        }
                        parser.tag.attributes[name] = a;
                        emitNode(parser, 'onattribute', a);
                    }
                    parser.attribList.length = 0;
                }
                parser.tag.isSelfClosing = !!selfClosing;
                parser.sawRoot = true;
                parser.tags.push(parser.tag);
                emitNode(parser, 'onopentag', parser.tag);
                if (!selfClosing) {
                    if (parser.noscript || "script" !== parser.tagName.toLowerCase()) parser.state = S.TEXT;
                    else parser.state = S.SCRIPT;
                    parser.tag = null;
                    parser.tagName = '';
                }
                parser.attribName = parser.attribValue = '';
                parser.attribList.length = 0;
            }
            function closeTag(parser) {
                if (!parser.tagName) {
                    strictFail(parser, 'Weird empty close tag.');
                    parser.textNode += '</>';
                    parser.state = S.TEXT;
                    return;
                }
                if (parser.script) {
                    if ("script" !== parser.tagName) {
                        parser.script += '</' + parser.tagName + '>';
                        parser.tagName = '';
                        parser.state = S.SCRIPT;
                        return;
                    }
                    emitNode(parser, "onscript", parser.script);
                    parser.script = '';
                }
                var t = parser.tags.length;
                var tagName = parser.tagName;
                if (!parser.strict) tagName = tagName[parser.looseCase]();
                var closeTo = tagName;
                while(t--){
                    var close = parser.tags[t];
                    if (close.name !== closeTo) strictFail(parser, 'Unexpected close tag');
                    else break;
                }
                if (t < 0) {
                    strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
                    parser.textNode += '</' + parser.tagName + '>';
                    parser.state = S.TEXT;
                    return;
                }
                parser.tagName = tagName;
                var s = parser.tags.length;
                while(s-- > t){
                    var tag = parser.tag = parser.tags.pop();
                    parser.tagName = parser.tag.name;
                    emitNode(parser, 'onclosetag', parser.tagName);
                    var x = {};
                    for(var i in tag.ns)x[i] = tag.ns[i];
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (parser.opt.xmlns && tag.ns !== parent.ns) Object.keys(tag.ns).forEach(function(p) {
                        var n = tag.ns[p];
                        emitNode(parser, 'onclosenamespace', {
                            prefix: p,
                            uri: n
                        });
                    });
                }
                if (0 === t) parser.closedRoot = true;
                parser.tagName = parser.attribValue = parser.attribName = '';
                parser.attribList.length = 0;
                parser.state = S.TEXT;
            }
            function parseEntity(parser) {
                var entity = parser.entity;
                var entityLC = entity.toLowerCase();
                var num;
                var numStr = '';
                if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
                if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
                entity = entityLC;
                if ('#' === entity.charAt(0)) if ('x' === entity.charAt(1)) {
                    entity = entity.slice(2);
                    num = parseInt(entity, 16);
                    numStr = num.toString(16);
                } else {
                    entity = entity.slice(1);
                    num = parseInt(entity, 10);
                    numStr = num.toString(10);
                }
                entity = entity.replace(/^0+/, '');
                if (isNaN(num) || numStr.toLowerCase() !== entity) {
                    strictFail(parser, 'Invalid character entity');
                    return '&' + parser.entity + ';';
                }
                return String.fromCodePoint(num);
            }
            function beginWhiteSpace(parser, c) {
                if ('<' === c) {
                    parser.state = S.OPEN_WAKA;
                    parser.startTagPosition = parser.position;
                } else if (!isWhitespace(c)) {
                    strictFail(parser, 'Non-whitespace before first tag.');
                    parser.textNode = c;
                    parser.state = S.TEXT;
                }
            }
            function charAt(chunk, i) {
                var result = '';
                if (i < chunk.length) result = chunk.charAt(i);
                return result;
            }
            function write(chunk) {
                var parser = this;
                if (this.error) throw this.error;
                if (parser.closed) return error(parser, 'Cannot write after close. Assign an onready handler.');
                if (null === chunk) return end(parser);
                if ('object' == typeof chunk) chunk = chunk.toString();
                var i = 0;
                var c = '';
                while(true){
                    c = charAt(chunk, i++);
                    parser.c = c;
                    if (!c) break;
                    if (parser.trackPosition) {
                        parser.position++;
                        if ('\n' === c) {
                            parser.line++;
                            parser.column = 0;
                        } else parser.column++;
                    }
                    switch(parser.state){
                        case S.BEGIN:
                            parser.state = S.BEGIN_WHITESPACE;
                            if ('\uFEFF' === c) continue;
                            beginWhiteSpace(parser, c);
                            continue;
                        case S.BEGIN_WHITESPACE:
                            beginWhiteSpace(parser, c);
                            continue;
                        case S.TEXT:
                            if (parser.sawRoot && !parser.closedRoot) {
                                var starti = i - 1;
                                while(c && '<' !== c && '&' !== c){
                                    c = charAt(chunk, i++);
                                    if (c && parser.trackPosition) {
                                        parser.position++;
                                        if ('\n' === c) {
                                            parser.line++;
                                            parser.column = 0;
                                        } else parser.column++;
                                    }
                                }
                                parser.textNode += chunk.substring(starti, i - 1);
                            }
                            if ('<' !== c || parser.sawRoot && parser.closedRoot && !parser.strict) {
                                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, 'Text data outside of root node.');
                                if ('&' === c) parser.state = S.TEXT_ENTITY;
                                else parser.textNode += c;
                            } else {
                                parser.state = S.OPEN_WAKA;
                                parser.startTagPosition = parser.position;
                            }
                            continue;
                        case S.SCRIPT:
                            if ('<' === c) parser.state = S.SCRIPT_ENDING;
                            else parser.script += c;
                            continue;
                        case S.SCRIPT_ENDING:
                            if ('/' === c) parser.state = S.CLOSE_TAG;
                            else {
                                parser.script += '<' + c;
                                parser.state = S.SCRIPT;
                            }
                            continue;
                        case S.OPEN_WAKA:
                            if ('!' === c) {
                                parser.state = S.SGML_DECL;
                                parser.sgmlDecl = '';
                            } else if (isWhitespace(c)) ;
                            else if (isMatch(nameStart, c)) {
                                parser.state = S.OPEN_TAG;
                                parser.tagName = c;
                            } else if ('/' === c) {
                                parser.state = S.CLOSE_TAG;
                                parser.tagName = '';
                            } else if ('?' === c) {
                                parser.state = S.PROC_INST;
                                parser.procInstName = parser.procInstBody = '';
                            } else {
                                strictFail(parser, 'Unencoded <');
                                if (parser.startTagPosition + 1 < parser.position) {
                                    var pad = parser.position - parser.startTagPosition;
                                    c = new Array(pad).join(' ') + c;
                                }
                                parser.textNode += '<' + c;
                                parser.state = S.TEXT;
                            }
                            continue;
                        case S.SGML_DECL:
                            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                                emitNode(parser, 'onopencdata');
                                parser.state = S.CDATA;
                                parser.sgmlDecl = '';
                                parser.cdata = '';
                            } else if (parser.sgmlDecl + c === '--') {
                                parser.state = S.COMMENT;
                                parser.comment = '';
                                parser.sgmlDecl = '';
                            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                                parser.state = S.DOCTYPE;
                                if (parser.doctype || parser.sawRoot) strictFail(parser, 'Inappropriately located doctype declaration');
                                parser.doctype = '';
                                parser.sgmlDecl = '';
                            } else if ('>' === c) {
                                emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                                parser.sgmlDecl = '';
                                parser.state = S.TEXT;
                            } else if (isQuote(c)) {
                                parser.state = S.SGML_DECL_QUOTED;
                                parser.sgmlDecl += c;
                            } else parser.sgmlDecl += c;
                            continue;
                        case S.SGML_DECL_QUOTED:
                            if (c === parser.q) {
                                parser.state = S.SGML_DECL;
                                parser.q = '';
                            }
                            parser.sgmlDecl += c;
                            continue;
                        case S.DOCTYPE:
                            if ('>' === c) {
                                parser.state = S.TEXT;
                                emitNode(parser, 'ondoctype', parser.doctype);
                                parser.doctype = true;
                            } else {
                                parser.doctype += c;
                                if ('[' === c) parser.state = S.DOCTYPE_DTD;
                                else if (isQuote(c)) {
                                    parser.state = S.DOCTYPE_QUOTED;
                                    parser.q = c;
                                }
                            }
                            continue;
                        case S.DOCTYPE_QUOTED:
                            parser.doctype += c;
                            if (c === parser.q) {
                                parser.q = '';
                                parser.state = S.DOCTYPE;
                            }
                            continue;
                        case S.DOCTYPE_DTD:
                            parser.doctype += c;
                            if (']' === c) parser.state = S.DOCTYPE;
                            else if (isQuote(c)) {
                                parser.state = S.DOCTYPE_DTD_QUOTED;
                                parser.q = c;
                            }
                            continue;
                        case S.DOCTYPE_DTD_QUOTED:
                            parser.doctype += c;
                            if (c === parser.q) {
                                parser.state = S.DOCTYPE_DTD;
                                parser.q = '';
                            }
                            continue;
                        case S.COMMENT:
                            if ('-' === c) parser.state = S.COMMENT_ENDING;
                            else parser.comment += c;
                            continue;
                        case S.COMMENT_ENDING:
                            if ('-' === c) {
                                parser.state = S.COMMENT_ENDED;
                                parser.comment = textopts(parser.opt, parser.comment);
                                if (parser.comment) emitNode(parser, 'oncomment', parser.comment);
                                parser.comment = '';
                            } else {
                                parser.comment += '-' + c;
                                parser.state = S.COMMENT;
                            }
                            continue;
                        case S.COMMENT_ENDED:
                            if ('>' !== c) {
                                strictFail(parser, 'Malformed comment');
                                parser.comment += '--' + c;
                                parser.state = S.COMMENT;
                            } else parser.state = S.TEXT;
                            continue;
                        case S.CDATA:
                            if (']' === c) parser.state = S.CDATA_ENDING;
                            else parser.cdata += c;
                            continue;
                        case S.CDATA_ENDING:
                            if (']' === c) parser.state = S.CDATA_ENDING_2;
                            else {
                                parser.cdata += ']' + c;
                                parser.state = S.CDATA;
                            }
                            continue;
                        case S.CDATA_ENDING_2:
                            if ('>' === c) {
                                if (parser.cdata) emitNode(parser, 'oncdata', parser.cdata);
                                emitNode(parser, 'onclosecdata');
                                parser.cdata = '';
                                parser.state = S.TEXT;
                            } else if (']' === c) parser.cdata += ']';
                            else {
                                parser.cdata += ']]' + c;
                                parser.state = S.CDATA;
                            }
                            continue;
                        case S.PROC_INST:
                            if ('?' === c) parser.state = S.PROC_INST_ENDING;
                            else if (isWhitespace(c)) parser.state = S.PROC_INST_BODY;
                            else parser.procInstName += c;
                            continue;
                        case S.PROC_INST_BODY:
                            if (!parser.procInstBody && isWhitespace(c)) ;
                            else if ('?' === c) parser.state = S.PROC_INST_ENDING;
                            else parser.procInstBody += c;
                            continue;
                        case S.PROC_INST_ENDING:
                            if ('>' === c) {
                                emitNode(parser, 'onprocessinginstruction', {
                                    name: parser.procInstName,
                                    body: parser.procInstBody
                                });
                                parser.procInstName = parser.procInstBody = '';
                                parser.state = S.TEXT;
                            } else {
                                parser.procInstBody += '?' + c;
                                parser.state = S.PROC_INST_BODY;
                            }
                            continue;
                        case S.OPEN_TAG:
                            if (isMatch(nameBody, c)) parser.tagName += c;
                            else {
                                newTag(parser);
                                if ('>' === c) openTag(parser);
                                else if ('/' === c) parser.state = S.OPEN_TAG_SLASH;
                                else {
                                    if (!isWhitespace(c)) strictFail(parser, 'Invalid character in tag name');
                                    parser.state = S.ATTRIB;
                                }
                            }
                            continue;
                        case S.OPEN_TAG_SLASH:
                            if ('>' === c) {
                                openTag(parser, true);
                                closeTag(parser);
                            } else {
                                strictFail(parser, 'Forward-slash in opening tag not followed by >');
                                parser.state = S.ATTRIB;
                            }
                            continue;
                        case S.ATTRIB:
                            if (isWhitespace(c)) ;
                            else if ('>' === c) openTag(parser);
                            else if ('/' === c) parser.state = S.OPEN_TAG_SLASH;
                            else if (isMatch(nameStart, c)) {
                                parser.attribName = c;
                                parser.attribValue = '';
                                parser.state = S.ATTRIB_NAME;
                            } else strictFail(parser, 'Invalid attribute name');
                            continue;
                        case S.ATTRIB_NAME:
                            if ('=' === c) parser.state = S.ATTRIB_VALUE;
                            else if ('>' === c) {
                                strictFail(parser, 'Attribute without value');
                                parser.attribValue = parser.attribName;
                                attrib(parser);
                                openTag(parser);
                            } else if (isWhitespace(c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;
                            else if (isMatch(nameBody, c)) parser.attribName += c;
                            else strictFail(parser, 'Invalid attribute name');
                            continue;
                        case S.ATTRIB_NAME_SAW_WHITE:
                            if ('=' === c) parser.state = S.ATTRIB_VALUE;
                            else {
                                if (isWhitespace(c)) continue;
                                strictFail(parser, 'Attribute without value');
                                parser.tag.attributes[parser.attribName] = '';
                                parser.attribValue = '';
                                emitNode(parser, 'onattribute', {
                                    name: parser.attribName,
                                    value: ''
                                });
                                parser.attribName = '';
                                if ('>' === c) openTag(parser);
                                else if (isMatch(nameStart, c)) {
                                    parser.attribName = c;
                                    parser.state = S.ATTRIB_NAME;
                                } else {
                                    strictFail(parser, 'Invalid attribute name');
                                    parser.state = S.ATTRIB;
                                }
                            }
                            continue;
                        case S.ATTRIB_VALUE:
                            if (isWhitespace(c)) ;
                            else if (isQuote(c)) {
                                parser.q = c;
                                parser.state = S.ATTRIB_VALUE_QUOTED;
                            } else {
                                strictFail(parser, 'Unquoted attribute value');
                                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                                parser.attribValue = c;
                            }
                            continue;
                        case S.ATTRIB_VALUE_QUOTED:
                            if (c !== parser.q) {
                                if ('&' === c) parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                                else parser.attribValue += c;
                                continue;
                            }
                            attrib(parser);
                            parser.q = '';
                            parser.state = S.ATTRIB_VALUE_CLOSED;
                            continue;
                        case S.ATTRIB_VALUE_CLOSED:
                            if (isWhitespace(c)) parser.state = S.ATTRIB;
                            else if ('>' === c) openTag(parser);
                            else if ('/' === c) parser.state = S.OPEN_TAG_SLASH;
                            else if (isMatch(nameStart, c)) {
                                strictFail(parser, 'No whitespace between attributes');
                                parser.attribName = c;
                                parser.attribValue = '';
                                parser.state = S.ATTRIB_NAME;
                            } else strictFail(parser, 'Invalid attribute name');
                            continue;
                        case S.ATTRIB_VALUE_UNQUOTED:
                            if (!isAttribEnd(c)) {
                                if ('&' === c) parser.state = S.ATTRIB_VALUE_ENTITY_U;
                                else parser.attribValue += c;
                                continue;
                            }
                            attrib(parser);
                            if ('>' === c) openTag(parser);
                            else parser.state = S.ATTRIB;
                            continue;
                        case S.CLOSE_TAG:
                            if (parser.tagName) if ('>' === c) closeTag(parser);
                            else if (isMatch(nameBody, c)) parser.tagName += c;
                            else if (parser.script) {
                                parser.script += '</' + parser.tagName;
                                parser.tagName = '';
                                parser.state = S.SCRIPT;
                            } else {
                                if (!isWhitespace(c)) strictFail(parser, 'Invalid tagname in closing tag');
                                parser.state = S.CLOSE_TAG_SAW_WHITE;
                            }
                            else if (isWhitespace(c)) ;
                            else if (notMatch(nameStart, c)) if (parser.script) {
                                parser.script += '</' + c;
                                parser.state = S.SCRIPT;
                            } else strictFail(parser, 'Invalid tagname in closing tag.');
                            else parser.tagName = c;
                            continue;
                        case S.CLOSE_TAG_SAW_WHITE:
                            if (isWhitespace(c)) continue;
                            if ('>' === c) closeTag(parser);
                            else strictFail(parser, 'Invalid characters in closing tag');
                            continue;
                        case S.TEXT_ENTITY:
                        case S.ATTRIB_VALUE_ENTITY_Q:
                        case S.ATTRIB_VALUE_ENTITY_U:
                            var returnState;
                            var buffer;
                            switch(parser.state){
                                case S.TEXT_ENTITY:
                                    returnState = S.TEXT;
                                    buffer = 'textNode';
                                    break;
                                case S.ATTRIB_VALUE_ENTITY_Q:
                                    returnState = S.ATTRIB_VALUE_QUOTED;
                                    buffer = 'attribValue';
                                    break;
                                case S.ATTRIB_VALUE_ENTITY_U:
                                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                                    buffer = 'attribValue';
                                    break;
                            }
                            if (';' === c) {
                                parser[buffer] += parseEntity(parser);
                                parser.entity = '';
                                parser.state = returnState;
                            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) parser.entity += c;
                            else {
                                strictFail(parser, 'Invalid character in entity name');
                                parser[buffer] += '&' + parser.entity + c;
                                parser.entity = '';
                                parser.state = returnState;
                            }
                            continue;
                        default:
                            throw new Error(parser, 'Unknown state: ' + parser.state);
                    }
                }
                if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
                return parser;
            }
            /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ if (!String.fromCodePoint) (function() {
                var stringFromCharCode = String.fromCharCode;
                var floor = Math.floor;
                var fromCodePoint = function() {
                    var MAX_SIZE = 0x4000;
                    var codeUnits = [];
                    var highSurrogate;
                    var lowSurrogate;
                    var index = -1;
                    var length = arguments.length;
                    if (!length) return '';
                    var result = '';
                    while(++index < length){
                        var codePoint = Number(arguments[index]);
                        if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) !== codePoint) throw RangeError('Invalid code point: ' + codePoint);
                        if (codePoint <= 0xFFFF) codeUnits.push(codePoint);
                        else {
                            codePoint -= 0x10000;
                            highSurrogate = (codePoint >> 10) + 0xD800;
                            lowSurrogate = codePoint % 0x400 + 0xDC00;
                            codeUnits.push(highSurrogate, lowSurrogate);
                        }
                        if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                            result += stringFromCharCode.apply(null, codeUnits);
                            codeUnits.length = 0;
                        }
                    }
                    return result;
                };
                if (Object.defineProperty) Object.defineProperty(String, 'fromCodePoint', {
                    value: fromCodePoint,
                    configurable: true,
                    writable: true
                });
                else String.fromCodePoint = fromCodePoint;
            })();
        })(exports1);
    },
    "../../../node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js" (module, exports1) {
        exports1 = module.exports = SemVer;
        var debug;
        debug = 'object' == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift('SEMVER');
            console.log.apply(console, args);
        } : function() {};
        exports1.SEMVER_SPEC_VERSION = '2.0.0';
        var MAX_LENGTH = 256;
        var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        var MAX_SAFE_COMPONENT_LENGTH = 16;
        var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
        var re = exports1.re = [];
        var safeRe = exports1.safeRe = [];
        var src = exports1.src = [];
        var t = exports1.tokens = {};
        var R = 0;
        function tok(n) {
            t[n] = R++;
        }
        var LETTERDASHNUMBER = '[a-zA-Z0-9-]';
        var safeRegexReplacements = [
            [
                '\\s',
                1
            ],
            [
                '\\d',
                MAX_LENGTH
            ],
            [
                LETTERDASHNUMBER,
                MAX_SAFE_BUILD_LENGTH
            ]
        ];
        function makeSafeRe(value) {
            for(var i = 0; i < safeRegexReplacements.length; i++){
                var token = safeRegexReplacements[i][0];
                var max = safeRegexReplacements[i][1];
                value = value.split(token + '*').join(token + '{0,' + max + '}').split(token + '+').join(token + '{1,' + max + '}');
            }
            return value;
        }
        tok('NUMERICIDENTIFIER');
        src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
        tok('NUMERICIDENTIFIERLOOSE');
        src[t.NUMERICIDENTIFIERLOOSE] = '\\d+';
        tok('NONNUMERICIDENTIFIER');
        src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-]' + LETTERDASHNUMBER + '*';
        tok('MAINVERSION');
        src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ')';
        tok('MAINVERSIONLOOSE');
        src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ')';
        tok('PRERELEASEIDENTIFIER');
        src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
        tok('PRERELEASEIDENTIFIERLOOSE');
        src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
        tok('PRERELEASE');
        src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
        tok('PRERELEASELOOSE');
        src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
        tok('BUILDIDENTIFIER');
        src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + '+';
        tok('BUILD');
        src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
        tok('FULL');
        tok('FULLPLAIN');
        src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
        src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
        tok('LOOSEPLAIN');
        src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
        tok('LOOSE');
        src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
        tok('GTLT');
        src[t.GTLT] = '((?:<|>)?=?)';
        tok('XRANGEIDENTIFIERLOOSE');
        src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
        tok('XRANGEIDENTIFIER');
        src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
        tok('XRANGEPLAIN');
        src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ')?' + src[t.BUILD] + "?)?)?";
        tok('XRANGEPLAINLOOSE');
        src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + "?)?)?";
        tok('XRANGE');
        src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
        tok('XRANGELOOSE');
        src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
        tok('COERCE');
        src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
        tok('COERCERTL');
        re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
        safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), 'g');
        tok('LONETILDE');
        src[t.LONETILDE] = '(?:~>?)';
        tok('TILDETRIM');
        src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
        re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
        safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), 'g');
        var tildeTrimReplace = '$1~';
        tok('TILDE');
        src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
        tok('TILDELOOSE');
        src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
        tok('LONECARET');
        src[t.LONECARET] = '(?:\\^)';
        tok('CARETTRIM');
        src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
        re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
        safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), 'g');
        var caretTrimReplace = '$1^';
        tok('CARET');
        src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
        tok('CARETLOOSE');
        src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
        tok('COMPARATORLOOSE');
        src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
        tok('COMPARATOR');
        src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
        tok('COMPARATORTRIM');
        src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
        re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
        safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), 'g');
        var comparatorTrimReplace = '$1$2$3';
        tok('HYPHENRANGE');
        src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
        tok('HYPHENRANGELOOSE');
        src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
        tok('STAR');
        src[t.STAR] = '(<|>)?=?\\s*\\*';
        for(var i = 0; i < R; i++){
            debug(i, src[i]);
            if (!re[i]) {
                re[i] = new RegExp(src[i]);
                safeRe[i] = new RegExp(makeSafeRe(src[i]));
            }
        }
        exports1.parse = parse;
        function parse(version, options) {
            if (!options || 'object' != typeof options) options = {
                loose: !!options,
                includePrerelease: false
            };
            if (version instanceof SemVer) return version;
            if ('string' != typeof version) return null;
            if (version.length > MAX_LENGTH) return null;
            var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
            if (!r.test(version)) return null;
            try {
                return new SemVer(version, options);
            } catch (er) {
                return null;
            }
        }
        exports1.valid = valid;
        function valid(version, options) {
            var v = parse(version, options);
            return v ? v.version : null;
        }
        exports1.clean = clean;
        function clean(version, options) {
            var s = parse(version.trim().replace(/^[=v]+/, ''), options);
            return s ? s.version : null;
        }
        exports1.SemVer = SemVer;
        function SemVer(version, options) {
            if (!options || 'object' != typeof options) options = {
                loose: !!options,
                includePrerelease: false
            };
            if (version instanceof SemVer) if (version.loose === options.loose) return version;
            else version = version.version;
            else if ('string' != typeof version) throw new TypeError('Invalid Version: ' + version);
            if (version.length > MAX_LENGTH) throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
            if (!(this instanceof SemVer)) return new SemVer(version, options);
            debug('SemVer', version, options);
            this.options = options;
            this.loose = !!options.loose;
            var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
            if (!m) throw new TypeError('Invalid Version: ' + version);
            this.raw = version;
            this.major = +m[1];
            this.minor = +m[2];
            this.patch = +m[3];
            if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');
            if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');
            if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');
            if (m[4]) this.prerelease = m[4].split('.').map(function(id) {
                if (/^[0-9]+$/.test(id)) {
                    var num = +id;
                    if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
                }
                return id;
            });
            else this.prerelease = [];
            this.build = m[5] ? m[5].split('.') : [];
            this.format();
        }
        SemVer.prototype.format = function() {
            this.version = this.major + '.' + this.minor + '.' + this.patch;
            if (this.prerelease.length) this.version += '-' + this.prerelease.join('.');
            return this.version;
        };
        SemVer.prototype.toString = function() {
            return this.version;
        };
        SemVer.prototype.compare = function(other) {
            debug('SemVer.compare', this.version, this.options, other);
            if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
            return this.compareMain(other) || this.comparePre(other);
        };
        SemVer.prototype.compareMain = function(other) {
            if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
            return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        };
        SemVer.prototype.comparePre = function(other) {
            if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
            if (this.prerelease.length && !other.prerelease.length) return -1;
            if (!this.prerelease.length && other.prerelease.length) return 1;
            if (!this.prerelease.length && !other.prerelease.length) return 0;
            var i = 0;
            do {
                var a = this.prerelease[i];
                var b = other.prerelease[i];
                debug('prerelease compare', i, a, b);
                if (void 0 === a && void 0 === b) return 0;
                if (void 0 === b) return 1;
                if (void 0 === a) return -1;
                else if (a === b) continue;
                else return compareIdentifiers(a, b);
            }while (++i);
        };
        SemVer.prototype.compareBuild = function(other) {
            if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
            var i = 0;
            do {
                var a = this.build[i];
                var b = other.build[i];
                debug('prerelease compare', i, a, b);
                if (void 0 === a && void 0 === b) return 0;
                if (void 0 === b) return 1;
                if (void 0 === a) return -1;
                else if (a === b) continue;
                else return compareIdentifiers(a, b);
            }while (++i);
        };
        SemVer.prototype.inc = function(release, identifier) {
            switch(release){
                case 'premajor':
                    this.prerelease.length = 0;
                    this.patch = 0;
                    this.minor = 0;
                    this.major++;
                    this.inc('pre', identifier);
                    break;
                case 'preminor':
                    this.prerelease.length = 0;
                    this.patch = 0;
                    this.minor++;
                    this.inc('pre', identifier);
                    break;
                case 'prepatch':
                    this.prerelease.length = 0;
                    this.inc('patch', identifier);
                    this.inc('pre', identifier);
                    break;
                case 'prerelease':
                    if (0 === this.prerelease.length) this.inc('patch', identifier);
                    this.inc('pre', identifier);
                    break;
                case 'major':
                    if (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) this.major++;
                    this.minor = 0;
                    this.patch = 0;
                    this.prerelease = [];
                    break;
                case 'minor':
                    if (0 !== this.patch || 0 === this.prerelease.length) this.minor++;
                    this.patch = 0;
                    this.prerelease = [];
                    break;
                case 'patch':
                    if (0 === this.prerelease.length) this.patch++;
                    this.prerelease = [];
                    break;
                case 'pre':
                    if (0 === this.prerelease.length) this.prerelease = [
                        0
                    ];
                    else {
                        var i = this.prerelease.length;
                        while(--i >= 0)if ('number' == typeof this.prerelease[i]) {
                            this.prerelease[i]++;
                            i = -2;
                        }
                        if (-1 === i) this.prerelease.push(0);
                    }
                    if (identifier) if (this.prerelease[0] === identifier) {
                        if (isNaN(this.prerelease[1])) this.prerelease = [
                            identifier,
                            0
                        ];
                    } else this.prerelease = [
                        identifier,
                        0
                    ];
                    break;
                default:
                    throw new Error('invalid increment argument: ' + release);
            }
            this.format();
            this.raw = this.version;
            return this;
        };
        exports1.inc = inc;
        function inc(version, release, loose, identifier) {
            if ('string' == typeof loose) {
                identifier = loose;
                loose = void 0;
            }
            try {
                return new SemVer(version, loose).inc(release, identifier).version;
            } catch (er) {
                return null;
            }
        }
        exports1.diff = diff;
        function diff(version1, version2) {
            if (eq(version1, version2)) return null;
            var v1 = parse(version1);
            var v2 = parse(version2);
            var prefix = '';
            if (v1.prerelease.length || v2.prerelease.length) {
                prefix = 'pre';
                var defaultResult = 'prerelease';
            }
            for(var key in v1)if ('major' === key || 'minor' === key || 'patch' === key) {
                if (v1[key] !== v2[key]) return prefix + key;
            }
            return defaultResult;
        }
        exports1.compareIdentifiers = compareIdentifiers;
        var numeric = /^[0-9]+$/;
        function compareIdentifiers(a, b) {
            var anum = numeric.test(a);
            var bnum = numeric.test(b);
            if (anum && bnum) {
                a *= 1;
                b *= 1;
            }
            return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        }
        exports1.rcompareIdentifiers = rcompareIdentifiers;
        function rcompareIdentifiers(a, b) {
            return compareIdentifiers(b, a);
        }
        exports1.major = major;
        function major(a, loose) {
            return new SemVer(a, loose).major;
        }
        exports1.minor = minor;
        function minor(a, loose) {
            return new SemVer(a, loose).minor;
        }
        exports1.patch = patch;
        function patch(a, loose) {
            return new SemVer(a, loose).patch;
        }
        exports1.compare = compare;
        function compare(a, b, loose) {
            return new SemVer(a, loose).compare(new SemVer(b, loose));
        }
        exports1.compareLoose = compareLoose;
        function compareLoose(a, b) {
            return compare(a, b, true);
        }
        exports1.compareBuild = compareBuild;
        function compareBuild(a, b, loose) {
            var versionA = new SemVer(a, loose);
            var versionB = new SemVer(b, loose);
            return versionA.compare(versionB) || versionA.compareBuild(versionB);
        }
        exports1.rcompare = rcompare;
        function rcompare(a, b, loose) {
            return compare(b, a, loose);
        }
        exports1.sort = sort;
        function sort(list, loose) {
            return list.sort(function(a, b) {
                return exports1.compareBuild(a, b, loose);
            });
        }
        exports1.rsort = rsort;
        function rsort(list, loose) {
            return list.sort(function(a, b) {
                return exports1.compareBuild(b, a, loose);
            });
        }
        exports1.gt = gt;
        function gt(a, b, loose) {
            return compare(a, b, loose) > 0;
        }
        exports1.lt = lt;
        function lt(a, b, loose) {
            return compare(a, b, loose) < 0;
        }
        exports1.eq = eq;
        function eq(a, b, loose) {
            return 0 === compare(a, b, loose);
        }
        exports1.neq = neq;
        function neq(a, b, loose) {
            return 0 !== compare(a, b, loose);
        }
        exports1.gte = gte;
        function gte(a, b, loose) {
            return compare(a, b, loose) >= 0;
        }
        exports1.lte = lte;
        function lte(a, b, loose) {
            return compare(a, b, loose) <= 0;
        }
        exports1.cmp = cmp;
        function cmp(a, op, b, loose) {
            switch(op){
                case '===':
                    if ('object' == typeof a) a = a.version;
                    if ('object' == typeof b) b = b.version;
                    return a === b;
                case '!==':
                    if ('object' == typeof a) a = a.version;
                    if ('object' == typeof b) b = b.version;
                    return a !== b;
                case '':
                case '=':
                case '==':
                    return eq(a, b, loose);
                case '!=':
                    return neq(a, b, loose);
                case '>':
                    return gt(a, b, loose);
                case '>=':
                    return gte(a, b, loose);
                case '<':
                    return lt(a, b, loose);
                case '<=':
                    return lte(a, b, loose);
                default:
                    throw new TypeError('Invalid operator: ' + op);
            }
        }
        exports1.Comparator = Comparator;
        function Comparator(comp, options) {
            if (!options || 'object' != typeof options) options = {
                loose: !!options,
                includePrerelease: false
            };
            if (comp instanceof Comparator) if (!!options.loose === comp.loose) return comp;
            else comp = comp.value;
            if (!(this instanceof Comparator)) return new Comparator(comp, options);
            comp = comp.trim().split(/\s+/).join(' ');
            debug('comparator', comp, options);
            this.options = options;
            this.loose = !!options.loose;
            this.parse(comp);
            if (this.semver === ANY) this.value = '';
            else this.value = this.operator + this.semver.version;
            debug('comp', this);
        }
        var ANY = {};
        Comparator.prototype.parse = function(comp) {
            var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
            var m = comp.match(r);
            if (!m) throw new TypeError('Invalid comparator: ' + comp);
            this.operator = void 0 !== m[1] ? m[1] : '';
            if ('=' === this.operator) this.operator = '';
            if (m[2]) this.semver = new SemVer(m[2], this.options.loose);
            else this.semver = ANY;
        };
        Comparator.prototype.toString = function() {
            return this.value;
        };
        Comparator.prototype.test = function(version) {
            debug('Comparator.test', version, this.options.loose);
            if (this.semver === ANY || version === ANY) return true;
            if ('string' == typeof version) try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
            return cmp(version, this.operator, this.semver, this.options);
        };
        Comparator.prototype.intersects = function(comp, options) {
            if (!(comp instanceof Comparator)) throw new TypeError('a Comparator is required');
            if (!options || 'object' != typeof options) options = {
                loose: !!options,
                includePrerelease: false
            };
            var rangeTmp;
            if ('' === this.operator) {
                if ('' === this.value) return true;
                rangeTmp = new Range(comp.value, options);
                return satisfies(this.value, rangeTmp, options);
            }
            if ('' === comp.operator) {
                if ('' === comp.value) return true;
                rangeTmp = new Range(this.value, options);
                return satisfies(comp.semver, rangeTmp, options);
            }
            var sameDirectionIncreasing = ('>=' === this.operator || '>' === this.operator) && ('>=' === comp.operator || '>' === comp.operator);
            var sameDirectionDecreasing = ('<=' === this.operator || '<' === this.operator) && ('<=' === comp.operator || '<' === comp.operator);
            var sameSemVer = this.semver.version === comp.semver.version;
            var differentDirectionsInclusive = ('>=' === this.operator || '<=' === this.operator) && ('>=' === comp.operator || '<=' === comp.operator);
            var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && ('>=' === this.operator || '>' === this.operator) && ('<=' === comp.operator || '<' === comp.operator);
            var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && ('<=' === this.operator || '<' === this.operator) && ('>=' === comp.operator || '>' === comp.operator);
            return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        };
        exports1.Range = Range;
        function Range(range, options) {
            if (!options || 'object' != typeof options) options = {
                loose: !!options,
                includePrerelease: false
            };
            if (range instanceof Range) if (!!options.loose === range.loose && !!options.includePrerelease === range.includePrerelease) return range;
            else return new Range(range.raw, options);
            if (range instanceof Comparator) return new Range(range.value, options);
            if (!(this instanceof Range)) return new Range(range, options);
            this.options = options;
            this.loose = !!options.loose;
            this.includePrerelease = !!options.includePrerelease;
            this.raw = range.trim().split(/\s+/).join(' ');
            this.set = this.raw.split('||').map(function(range) {
                return this.parseRange(range.trim());
            }, this).filter(function(c) {
                return c.length;
            });
            if (!this.set.length) throw new TypeError('Invalid SemVer Range: ' + this.raw);
            this.format();
        }
        Range.prototype.format = function() {
            this.range = this.set.map(function(comps) {
                return comps.join(' ').trim();
            }).join('||').trim();
            return this.range;
        };
        Range.prototype.toString = function() {
            return this.range;
        };
        Range.prototype.parseRange = function(range) {
            var loose = this.options.loose;
            var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
            range = range.replace(hr, hyphenReplace);
            debug('hyphen replace', range);
            range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
            debug('comparator trim', range, safeRe[t.COMPARATORTRIM]);
            range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
            range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
            range = range.split(/\s+/).join(' ');
            var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
            var set = range.split(' ').map(function(comp) {
                return parseComparator(comp, this.options);
            }, this).join(' ').split(/\s+/);
            if (this.options.loose) set = set.filter(function(comp) {
                return !!comp.match(compRe);
            });
            set = set.map(function(comp) {
                return new Comparator(comp, this.options);
            }, this);
            return set;
        };
        Range.prototype.intersects = function(range, options) {
            if (!(range instanceof Range)) throw new TypeError('a Range is required');
            return this.set.some(function(thisComparators) {
                return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
                    return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
                        return rangeComparators.every(function(rangeComparator) {
                            return thisComparator.intersects(rangeComparator, options);
                        });
                    });
                });
            });
        };
        function isSatisfiable(comparators, options) {
            var result = true;
            var remainingComparators = comparators.slice();
            var testComparator = remainingComparators.pop();
            while(result && remainingComparators.length){
                result = remainingComparators.every(function(otherComparator) {
                    return testComparator.intersects(otherComparator, options);
                });
                testComparator = remainingComparators.pop();
            }
            return result;
        }
        exports1.toComparators = toComparators;
        function toComparators(range, options) {
            return new Range(range, options).set.map(function(comp) {
                return comp.map(function(c) {
                    return c.value;
                }).join(' ').trim().split(' ');
            });
        }
        function parseComparator(comp, options) {
            debug('comp', comp, options);
            comp = replaceCarets(comp, options);
            debug('caret', comp);
            comp = replaceTildes(comp, options);
            debug('tildes', comp);
            comp = replaceXRanges(comp, options);
            debug('xrange', comp);
            comp = replaceStars(comp, options);
            debug('stars', comp);
            return comp;
        }
        function isX(id) {
            return !id || 'x' === id.toLowerCase() || '*' === id;
        }
        function replaceTildes(comp, options) {
            return comp.trim().split(/\s+/).map(function(comp) {
                return replaceTilde(comp, options);
            }).join(' ');
        }
        function replaceTilde(comp, options) {
            var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
            return comp.replace(r, function(_, M, m, p, pr) {
                debug('tilde', comp, _, M, m, p, pr);
                var ret;
                if (isX(M)) ret = '';
                else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
                else if (isX(p)) ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
                else if (pr) {
                    debug('replaceTilde pr', pr);
                    ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
                } else ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
                debug('tilde return', ret);
                return ret;
            });
        }
        function replaceCarets(comp, options) {
            return comp.trim().split(/\s+/).map(function(comp) {
                return replaceCaret(comp, options);
            }).join(' ');
        }
        function replaceCaret(comp, options) {
            debug('caret', comp, options);
            var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
            return comp.replace(r, function(_, M, m, p, pr) {
                debug('caret', comp, _, M, m, p, pr);
                var ret;
                if (isX(M)) ret = '';
                else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
                else if (isX(p)) ret = '0' === M ? '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0' : '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
                else if (pr) {
                    debug('replaceCaret pr', pr);
                    ret = '0' === M ? '0' === m ? '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1) : '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0' : '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
                } else {
                    debug('no pr');
                    ret = '0' === M ? '0' === m ? '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1) : '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0' : '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
                }
                debug('caret return', ret);
                return ret;
            });
        }
        function replaceXRanges(comp, options) {
            debug('replaceXRanges', comp, options);
            return comp.split(/\s+/).map(function(comp) {
                return replaceXRange(comp, options);
            }).join(' ');
        }
        function replaceXRange(comp, options) {
            comp = comp.trim();
            var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
            return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
                debug('xRange', comp, ret, gtlt, M, m, p, pr);
                var xM = isX(M);
                var xm = xM || isX(m);
                var xp = xm || isX(p);
                var anyX = xp;
                if ('=' === gtlt && anyX) gtlt = '';
                pr = options.includePrerelease ? '-0' : '';
                if (xM) ret = '>' === gtlt || '<' === gtlt ? '<0.0.0-0' : '*';
                else if (gtlt && anyX) {
                    if (xm) m = 0;
                    p = 0;
                    if ('>' === gtlt) {
                        gtlt = '>=';
                        if (xm) {
                            M = +M + 1;
                            m = 0;
                            p = 0;
                        } else {
                            m = +m + 1;
                            p = 0;
                        }
                    } else if ('<=' === gtlt) {
                        gtlt = '<';
                        if (xm) M = +M + 1;
                        else m = +m + 1;
                    }
                    ret = gtlt + M + '.' + m + '.' + p + pr;
                } else if (xm) ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
                else if (xp) ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
                debug('xRange return', ret);
                return ret;
            });
        }
        function replaceStars(comp, options) {
            debug('replaceStars', comp, options);
            return comp.trim().replace(safeRe[t.STAR], '');
        }
        function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
            from = isX(fM) ? '' : isX(fm) ? '>=' + fM + '.0.0' : isX(fp) ? '>=' + fM + '.' + fm + '.0' : '>=' + from;
            to = isX(tM) ? '' : isX(tm) ? '<' + (+tM + 1) + '.0.0' : isX(tp) ? '<' + tM + '.' + (+tm + 1) + '.0' : tpr ? '<=' + tM + '.' + tm + '.' + tp + '-' + tpr : '<=' + to;
            return (from + ' ' + to).trim();
        }
        Range.prototype.test = function(version) {
            if (!version) return false;
            if ('string' == typeof version) try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
            for(var i = 0; i < this.set.length; i++)if (testSet(this.set[i], version, this.options)) return true;
            return false;
        };
        function testSet(set, version, options) {
            for(var i = 0; i < set.length; i++)if (!set[i].test(version)) return false;
            if (version.prerelease.length && !options.includePrerelease) {
                for(i = 0; i < set.length; i++){
                    debug(set[i].semver);
                    if (set[i].semver !== ANY) {
                        if (set[i].semver.prerelease.length > 0) {
                            var allowed = set[i].semver;
                            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
                        }
                    }
                }
                return false;
            }
            return true;
        }
        exports1.satisfies = satisfies;
        function satisfies(version, range, options) {
            try {
                range = new Range(range, options);
            } catch (er) {
                return false;
            }
            return range.test(version);
        }
        exports1.maxSatisfying = maxSatisfying;
        function maxSatisfying(versions, range, options) {
            var max = null;
            var maxSV = null;
            try {
                var rangeObj = new Range(range, options);
            } catch (er) {
                return null;
            }
            versions.forEach(function(v) {
                if (rangeObj.test(v)) {
                    if (!max || -1 === maxSV.compare(v)) {
                        max = v;
                        maxSV = new SemVer(max, options);
                    }
                }
            });
            return max;
        }
        exports1.minSatisfying = minSatisfying;
        function minSatisfying(versions, range, options) {
            var min = null;
            var minSV = null;
            try {
                var rangeObj = new Range(range, options);
            } catch (er) {
                return null;
            }
            versions.forEach(function(v) {
                if (rangeObj.test(v)) {
                    if (!min || 1 === minSV.compare(v)) {
                        min = v;
                        minSV = new SemVer(min, options);
                    }
                }
            });
            return min;
        }
        exports1.minVersion = minVersion;
        function minVersion(range, loose) {
            range = new Range(range, loose);
            var minver = new SemVer('0.0.0');
            if (range.test(minver)) return minver;
            minver = new SemVer('0.0.0-0');
            if (range.test(minver)) return minver;
            minver = null;
            for(var i = 0; i < range.set.length; ++i){
                var comparators = range.set[i];
                comparators.forEach(function(comparator) {
                    var compver = new SemVer(comparator.semver.version);
                    switch(comparator.operator){
                        case '>':
                            if (0 === compver.prerelease.length) compver.patch++;
                            else compver.prerelease.push(0);
                            compver.raw = compver.format();
                        case '':
                        case '>=':
                            if (!minver || gt(minver, compver)) minver = compver;
                            break;
                        case '<':
                        case '<=':
                            break;
                        default:
                            throw new Error('Unexpected operation: ' + comparator.operator);
                    }
                });
            }
            if (minver && range.test(minver)) return minver;
            return null;
        }
        exports1.validRange = validRange;
        function validRange(range, options) {
            try {
                return new Range(range, options).range || '*';
            } catch (er) {
                return null;
            }
        }
        exports1.ltr = ltr;
        function ltr(version, range, options) {
            return outside(version, range, '<', options);
        }
        exports1.gtr = gtr;
        function gtr(version, range, options) {
            return outside(version, range, '>', options);
        }
        exports1.outside = outside;
        function outside(version, range, hilo, options) {
            version = new SemVer(version, options);
            range = new Range(range, options);
            var gtfn, ltefn, ltfn, comp, ecomp;
            switch(hilo){
                case '>':
                    gtfn = gt;
                    ltefn = lte;
                    ltfn = lt;
                    comp = '>';
                    ecomp = '>=';
                    break;
                case '<':
                    gtfn = lt;
                    ltefn = gte;
                    ltfn = gt;
                    comp = '<';
                    ecomp = '<=';
                    break;
                default:
                    throw new TypeError('Must provide a hilo val of "<" or ">"');
            }
            if (satisfies(version, range, options)) return false;
            for(var i = 0; i < range.set.length; ++i){
                var comparators = range.set[i];
                var high = null;
                var low = null;
                comparators.forEach(function(comparator) {
                    if (comparator.semver === ANY) comparator = new Comparator('>=0.0.0');
                    high = high || comparator;
                    low = low || comparator;
                    if (gtfn(comparator.semver, high.semver, options)) high = comparator;
                    else if (ltfn(comparator.semver, low.semver, options)) low = comparator;
                });
                if (high.operator === comp || high.operator === ecomp) return false;
                if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return false;
                if (low.operator === ecomp && ltfn(version, low.semver)) return false;
            }
            return true;
        }
        exports1.prerelease = prerelease;
        function prerelease(version, options) {
            var parsed = parse(version, options);
            return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        }
        exports1.intersects = intersects;
        function intersects(r1, r2, options) {
            r1 = new Range(r1, options);
            r2 = new Range(r2, options);
            return r1.intersects(r2);
        }
        exports1.coerce = coerce;
        function coerce(version, options) {
            if (version instanceof SemVer) return version;
            if ('number' == typeof version) version = String(version);
            if ('string' != typeof version) return null;
            options = options || {};
            var match = null;
            if (options.rtl) {
                var next;
                while((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)){
                    if (!match || next.index + next[0].length !== match.index + match[0].length) match = next;
                    safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
                }
                safeRe[t.COERCERTL].lastIndex = -1;
            } else match = version.match(safeRe[t.COERCE]);
            if (null === match) return null;
            return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
        }
    },
    "../../../node_modules/.pnpm/send@1.2.0/node_modules/send/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var createError = __webpack_require__("../../../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var debug = __webpack_require__("../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js")('send');
        var encodeUrl = __webpack_require__("../../../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var etag = __webpack_require__("../../../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js");
        var fresh = __webpack_require__("../../../node_modules/.pnpm/fresh@2.0.0/node_modules/fresh/index.js");
        var fs = __webpack_require__("fs");
        var mime = __webpack_require__("../../../node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/index.js");
        var ms = __webpack_require__("../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js");
        var onFinished = __webpack_require__("../../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var parseRange = __webpack_require__("../../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js");
        var path = __webpack_require__("path");
        var statuses = __webpack_require__("../../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var Stream = __webpack_require__("stream");
        var util = __webpack_require__("util");
        var extname = path.extname;
        var join = path.join;
        var normalize = path.normalize;
        var resolve = path.resolve;
        var sep = path.sep;
        var BYTES_RANGE_REGEXP = /^ *bytes=/;
        var MAX_MAXAGE = 31536000000;
        var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
        module.exports = send;
        function send(req, path, options) {
            return new SendStream(req, path, options);
        }
        function SendStream(req, path, options) {
            Stream.call(this);
            var opts = options || {};
            this.options = opts;
            this.path = path;
            this.req = req;
            this._acceptRanges = void 0 !== opts.acceptRanges ? Boolean(opts.acceptRanges) : true;
            this._cacheControl = void 0 !== opts.cacheControl ? Boolean(opts.cacheControl) : true;
            this._etag = void 0 !== opts.etag ? Boolean(opts.etag) : true;
            this._dotfiles = void 0 !== opts.dotfiles ? opts.dotfiles : 'ignore';
            if ('ignore' !== this._dotfiles && 'allow' !== this._dotfiles && 'deny' !== this._dotfiles) throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
            this._extensions = void 0 !== opts.extensions ? normalizeList(opts.extensions, 'extensions option') : [];
            this._immutable = void 0 !== opts.immutable ? Boolean(opts.immutable) : false;
            this._index = void 0 !== opts.index ? normalizeList(opts.index, 'index option') : [
                'index.html'
            ];
            this._lastModified = void 0 !== opts.lastModified ? Boolean(opts.lastModified) : true;
            this._maxage = opts.maxAge || opts.maxage;
            this._maxage = 'string' == typeof this._maxage ? ms(this._maxage) : Number(this._maxage);
            this._maxage = isNaN(this._maxage) ? 0 : Math.min(Math.max(0, this._maxage), MAX_MAXAGE);
            this._root = opts.root ? resolve(opts.root) : null;
        }
        util.inherits(SendStream, Stream);
        SendStream.prototype.error = function(status, err) {
            if (hasListeners(this, 'error')) return this.emit('error', createHttpError(status, err));
            var res = this.res;
            var msg = statuses.message[status] || String(status);
            var doc = createHtmlDocument('Error', escapeHtml(msg));
            clearHeaders(res);
            if (err && err.headers) setHeaders(res, err.headers);
            res.statusCode = status;
            res.setHeader('Content-Type', 'text/html; charset=UTF-8');
            res.setHeader('Content-Length', Buffer.byteLength(doc));
            res.setHeader('Content-Security-Policy', "default-src 'none'");
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.end(doc);
        };
        SendStream.prototype.hasTrailingSlash = function() {
            return '/' === this.path[this.path.length - 1];
        };
        SendStream.prototype.isConditionalGET = function() {
            return this.req.headers['if-match'] || this.req.headers['if-unmodified-since'] || this.req.headers['if-none-match'] || this.req.headers['if-modified-since'];
        };
        SendStream.prototype.isPreconditionFailure = function() {
            var req = this.req;
            var res = this.res;
            var match = req.headers['if-match'];
            if (match) {
                var etag = res.getHeader('ETag');
                return !etag || '*' !== match && parseTokenList(match).every(function(match) {
                    return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag;
                });
            }
            var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since']);
            if (!isNaN(unmodifiedSince)) {
                var lastModified = parseHttpDate(res.getHeader('Last-Modified'));
                return isNaN(lastModified) || lastModified > unmodifiedSince;
            }
            return false;
        };
        SendStream.prototype.removeContentHeaderFields = function() {
            var res = this.res;
            res.removeHeader('Content-Encoding');
            res.removeHeader('Content-Language');
            res.removeHeader('Content-Length');
            res.removeHeader('Content-Range');
            res.removeHeader('Content-Type');
        };
        SendStream.prototype.notModified = function() {
            var res = this.res;
            debug('not modified');
            this.removeContentHeaderFields();
            res.statusCode = 304;
            res.end();
        };
        SendStream.prototype.headersAlreadySent = function() {
            var err = new Error('Can\'t set headers after they are sent.');
            debug('headers already sent');
            this.error(500, err);
        };
        SendStream.prototype.isCachable = function() {
            var statusCode = this.res.statusCode;
            return statusCode >= 200 && statusCode < 300 || 304 === statusCode;
        };
        SendStream.prototype.onStatError = function(error) {
            switch(error.code){
                case 'ENAMETOOLONG':
                case 'ENOENT':
                case 'ENOTDIR':
                    this.error(404, error);
                    break;
                default:
                    this.error(500, error);
                    break;
            }
        };
        SendStream.prototype.isFresh = function() {
            return fresh(this.req.headers, {
                etag: this.res.getHeader('ETag'),
                'last-modified': this.res.getHeader('Last-Modified')
            });
        };
        SendStream.prototype.isRangeFresh = function() {
            var ifRange = this.req.headers['if-range'];
            if (!ifRange) return true;
            if (-1 !== ifRange.indexOf('"')) {
                var etag = this.res.getHeader('ETag');
                return Boolean(etag && -1 !== ifRange.indexOf(etag));
            }
            var lastModified = this.res.getHeader('Last-Modified');
            return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
        };
        SendStream.prototype.redirect = function(path) {
            var res = this.res;
            if (hasListeners(this, 'directory')) return void this.emit('directory', res, path);
            if (this.hasTrailingSlash()) return void this.error(403);
            var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'));
            var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));
            res.statusCode = 301;
            res.setHeader('Content-Type', 'text/html; charset=UTF-8');
            res.setHeader('Content-Length', Buffer.byteLength(doc));
            res.setHeader('Content-Security-Policy', "default-src 'none'");
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.setHeader('Location', loc);
            res.end(doc);
        };
        SendStream.prototype.pipe = function(res) {
            var root = this._root;
            this.res = res;
            var path = decode(this.path);
            if (-1 === path) {
                this.error(400);
                return res;
            }
            if (~path.indexOf('\0')) {
                this.error(400);
                return res;
            }
            var parts;
            if (null !== root) {
                if (path) path = normalize('.' + sep + path);
                if (UP_PATH_REGEXP.test(path)) {
                    debug('malicious path "%s"', path);
                    this.error(403);
                    return res;
                }
                parts = path.split(sep);
                path = normalize(join(root, path));
            } else {
                if (UP_PATH_REGEXP.test(path)) {
                    debug('malicious path "%s"', path);
                    this.error(403);
                    return res;
                }
                parts = normalize(path).split(sep);
                path = resolve(path);
            }
            if (containsDotFile(parts)) {
                debug('%s dotfile "%s"', this._dotfiles, path);
                switch(this._dotfiles){
                    case 'allow':
                        break;
                    case 'deny':
                        this.error(403);
                        return res;
                    case 'ignore':
                    default:
                        this.error(404);
                        return res;
                }
            }
            if (this._index.length && this.hasTrailingSlash()) {
                this.sendIndex(path);
                return res;
            }
            this.sendFile(path);
            return res;
        };
        SendStream.prototype.send = function(path, stat) {
            var len = stat.size;
            var options = this.options;
            var opts = {};
            var res = this.res;
            var req = this.req;
            var ranges = req.headers.range;
            var offset = options.start || 0;
            if (res.headersSent) return void this.headersAlreadySent();
            debug('pipe "%s"', path);
            this.setHeader(path, stat);
            this.type(path);
            if (this.isConditionalGET()) {
                if (this.isPreconditionFailure()) return void this.error(412);
                if (this.isCachable() && this.isFresh()) return void this.notModified();
            }
            len = Math.max(0, len - offset);
            if (void 0 !== options.end) {
                var bytes = options.end - offset + 1;
                if (len > bytes) len = bytes;
            }
            if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
                ranges = parseRange(len, ranges, {
                    combine: true
                });
                if (!this.isRangeFresh()) {
                    debug('range stale');
                    ranges = -2;
                }
                if (-1 === ranges) {
                    debug('range unsatisfiable');
                    res.setHeader('Content-Range', contentRange('bytes', len));
                    return this.error(416, {
                        headers: {
                            'Content-Range': res.getHeader('Content-Range')
                        }
                    });
                }
                if (-2 !== ranges && 1 === ranges.length) {
                    debug('range %j', ranges);
                    res.statusCode = 206;
                    res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]));
                    offset += ranges[0].start;
                    len = ranges[0].end - ranges[0].start + 1;
                }
            }
            for(var prop in options)opts[prop] = options[prop];
            opts.start = offset;
            opts.end = Math.max(offset, offset + len - 1);
            res.setHeader('Content-Length', len);
            if ('HEAD' === req.method) return void res.end();
            this.stream(path, opts);
        };
        SendStream.prototype.sendFile = function(path) {
            var i = 0;
            var self1 = this;
            debug('stat "%s"', path);
            fs.stat(path, function(err, stat) {
                var pathEndsWithSep = path[path.length - 1] === sep;
                if (err && 'ENOENT' === err.code && !extname(path) && !pathEndsWithSep) return next(err);
                if (err) return self1.onStatError(err);
                if (stat.isDirectory()) return self1.redirect(path);
                if (pathEndsWithSep) return self1.error(404);
                self1.emit('file', path, stat);
                self1.send(path, stat);
            });
            function next(err) {
                if (self1._extensions.length <= i) return err ? self1.onStatError(err) : self1.error(404);
                var p = path + '.' + self1._extensions[i++];
                debug('stat "%s"', p);
                fs.stat(p, function(err, stat) {
                    if (err) return next(err);
                    if (stat.isDirectory()) return next();
                    self1.emit('file', p, stat);
                    self1.send(p, stat);
                });
            }
        };
        SendStream.prototype.sendIndex = function(path) {
            var i = -1;
            var self1 = this;
            function next(err) {
                if (++i >= self1._index.length) {
                    if (err) return self1.onStatError(err);
                    return self1.error(404);
                }
                var p = join(path, self1._index[i]);
                debug('stat "%s"', p);
                fs.stat(p, function(err, stat) {
                    if (err) return next(err);
                    if (stat.isDirectory()) return next();
                    self1.emit('file', p, stat);
                    self1.send(p, stat);
                });
            }
            next();
        };
        SendStream.prototype.stream = function(path, options) {
            var self1 = this;
            var res = this.res;
            var stream = fs.createReadStream(path, options);
            this.emit('stream', stream);
            stream.pipe(res);
            function cleanup() {
                stream.destroy();
            }
            onFinished(res, cleanup);
            stream.on('error', function(err) {
                cleanup();
                self1.onStatError(err);
            });
            stream.on('end', function() {
                self1.emit('end');
            });
        };
        SendStream.prototype.type = function(path) {
            var res = this.res;
            if (res.getHeader('Content-Type')) return;
            var ext = extname(path);
            var type = mime.contentType(ext) || 'application/octet-stream';
            debug('content-type %s', type);
            res.setHeader('Content-Type', type);
        };
        SendStream.prototype.setHeader = function(path, stat) {
            var res = this.res;
            this.emit('headers', res, path, stat);
            if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
                debug('accept ranges');
                res.setHeader('Accept-Ranges', 'bytes');
            }
            if (this._cacheControl && !res.getHeader('Cache-Control')) {
                var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000);
                if (this._immutable) cacheControl += ', immutable';
                debug('cache-control %s', cacheControl);
                res.setHeader('Cache-Control', cacheControl);
            }
            if (this._lastModified && !res.getHeader('Last-Modified')) {
                var modified = stat.mtime.toUTCString();
                debug('modified %s', modified);
                res.setHeader('Last-Modified', modified);
            }
            if (this._etag && !res.getHeader('ETag')) {
                var val = etag(stat);
                debug('etag %s', val);
                res.setHeader('ETag', val);
            }
        };
        function clearHeaders(res) {
            for (const header of res.getHeaderNames())res.removeHeader(header);
        }
        function collapseLeadingSlashes(str) {
            for(var i = 0; i < str.length && '/' === str[i]; i++);
            return i > 1 ? '/' + str.substr(i) : str;
        }
        function containsDotFile(parts) {
            for(var i = 0; i < parts.length; i++){
                var part = parts[i];
                if (part.length > 1 && '.' === part[0]) return true;
            }
            return false;
        }
        function contentRange(type, size, range) {
            return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size;
        }
        function createHtmlDocument(title, body) {
            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
        }
        function createHttpError(status, err) {
            if (!err) return createError(status);
            return err instanceof Error ? createError(status, err, {
                expose: false
            }) : createError(status, err);
        }
        function decode(path) {
            try {
                return decodeURIComponent(path);
            } catch (err) {
                return -1;
            }
        }
        function hasListeners(emitter, type) {
            var count = 'function' != typeof emitter.listenerCount ? emitter.listeners(type).length : emitter.listenerCount(type);
            return count > 0;
        }
        function normalizeList(val, name) {
            var list = [].concat(val || []);
            for(var i = 0; i < list.length; i++)if ('string' != typeof list[i]) throw new TypeError(name + ' must be array of strings or false');
            return list;
        }
        function parseHttpDate(date) {
            var timestamp = date && Date.parse(date);
            return 'number' == typeof timestamp ? timestamp : NaN;
        }
        function parseTokenList(str) {
            var end = 0;
            var list = [];
            var start = 0;
            for(var i = 0, len = str.length; i < len; i++)switch(str.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i + 1;
                    break;
                case 0x2c:
                    if (start !== end) list.push(str.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
            if (start !== end) list.push(str.substring(start, end));
            return list;
        }
        function setHeaders(res, headers) {
            var keys = Object.keys(headers);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                res.setHeader(key, headers[key]);
            }
        }
    },
    "../../../node_modules/.pnpm/serve-static@2.2.0/node_modules/serve-static/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var encodeUrl = __webpack_require__("../../../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var parseUrl = __webpack_require__("../../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var resolve = __webpack_require__("path").resolve;
        var send = __webpack_require__("../../../node_modules/.pnpm/send@1.2.0/node_modules/send/index.js");
        var url = __webpack_require__("url");
        module.exports = serveStatic;
        function serveStatic(root, options) {
            if (!root) throw new TypeError('root path required');
            if ('string' != typeof root) throw new TypeError('root path must be a string');
            var opts = Object.create(options || null);
            var fallthrough = false !== opts.fallthrough;
            var redirect = false !== opts.redirect;
            var setHeaders = opts.setHeaders;
            if (setHeaders && 'function' != typeof setHeaders) throw new TypeError('option setHeaders must be function');
            opts.maxage = opts.maxage || opts.maxAge || 0;
            opts.root = resolve(root);
            var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
            return function(req, res, next) {
                if ('GET' !== req.method && 'HEAD' !== req.method) {
                    if (fallthrough) return next();
                    res.statusCode = 405;
                    res.setHeader('Allow', 'GET, HEAD');
                    res.setHeader('Content-Length', '0');
                    res.end();
                    return;
                }
                var forwardError = !fallthrough;
                var originalUrl = parseUrl.original(req);
                var path = parseUrl(req).pathname;
                if ('/' === path && '/' !== originalUrl.pathname.substr(-1)) path = '';
                var stream = send(req, path, opts);
                stream.on('directory', onDirectory);
                if (setHeaders) stream.on('headers', setHeaders);
                if (fallthrough) stream.on('file', function() {
                    forwardError = true;
                });
                stream.on('error', function(err) {
                    if (forwardError || !(err.statusCode < 500)) return void next(err);
                    next();
                });
                stream.pipe(res);
            };
        }
        function collapseLeadingSlashes(str) {
            for(var i = 0; i < str.length && 0x2f === str.charCodeAt(i); i++);
            return i > 1 ? '/' + str.substr(i) : str;
        }
        function createHtmlDocument(title, body) {
            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
        }
        function createNotFoundDirectoryListener() {
            return function() {
                this.error(404);
            };
        }
        function createRedirectDirectoryListener() {
            return function(res) {
                if (this.hasTrailingSlash()) return void this.error(404);
                var originalUrl = parseUrl.original(this.req);
                originalUrl.path = null;
                originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/');
                var loc = encodeUrl(url.format(originalUrl));
                var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));
                res.statusCode = 301;
                res.setHeader('Content-Type', 'text/html; charset=UTF-8');
                res.setHeader('Content-Length', Buffer.byteLength(doc));
                res.setHeader('Content-Security-Policy', "default-src 'none'");
                res.setHeader('X-Content-Type-Options', 'nosniff');
                res.setHeader('Location', loc);
                res.end(doc);
            };
        }
    },
    "../../../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js" (module) {
        "use strict";
        module.exports = Object.setPrototypeOf || (({
            __proto__: []
        }) instanceof Array ? setProtoOf : mixinProperties);
        function setProtoOf(obj, proto) {
            obj.__proto__ = proto;
            return obj;
        }
        function mixinProperties(obj, proto) {
            for(var prop in proto)if (!Object.prototype.hasOwnProperty.call(obj, prop)) obj[prop] = proto[prop];
            return obj;
        }
    },
    "../../../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var inspect = __webpack_require__("../../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var $TypeError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var listGetNode = function(list, key, isDelete) {
            var prev = list;
            var curr;
            for(; null != (curr = prev.next); prev = curr)if (curr.key === key) {
                prev.next = curr.next;
                if (!isDelete) {
                    curr.next = list.next;
                    list.next = curr;
                }
                return curr;
            }
        };
        var listGet = function(objects, key) {
            if (!objects) return;
            var node = listGetNode(objects, key);
            return node && node.value;
        };
        var listSet = function(objects, key, value) {
            var node = listGetNode(objects, key);
            if (node) node.value = value;
            else objects.next = {
                key: key,
                next: objects.next,
                value: value
            };
        };
        var listHas = function(objects, key) {
            if (!objects) return false;
            return !!listGetNode(objects, key);
        };
        var listDelete = function(objects, key) {
            if (objects) return listGetNode(objects, key, true);
        };
        module.exports = function() {
            var $o;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    var root = $o && $o.next;
                    var deletedNode = listDelete($o, key);
                    if (deletedNode && root && root === deletedNode) $o = void 0;
                    return !!deletedNode;
                },
                get: function(key) {
                    return listGet($o, key);
                },
                has: function(key) {
                    return listHas($o, key);
                },
                set: function(key, value) {
                    if (!$o) $o = {
                        next: void 0
                    };
                    listSet($o, key, value);
                }
            };
            return channel;
        };
    },
    "../../../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var callBound = __webpack_require__("../../../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
        var inspect = __webpack_require__("../../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var $TypeError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $Map = GetIntrinsic('%Map%', true);
        var $mapGet = callBound('Map.prototype.get', true);
        var $mapSet = callBound('Map.prototype.set', true);
        var $mapHas = callBound('Map.prototype.has', true);
        var $mapDelete = callBound('Map.prototype.delete', true);
        var $mapSize = callBound('Map.prototype.size', true);
        module.exports = !!$Map && function() {
            var $m;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    if ($m) {
                        var result = $mapDelete($m, key);
                        if (0 === $mapSize($m)) $m = void 0;
                        return result;
                    }
                    return false;
                },
                get: function(key) {
                    if ($m) return $mapGet($m, key);
                },
                has: function(key) {
                    if ($m) return $mapHas($m, key);
                    return false;
                },
                set: function(key, value) {
                    if (!$m) $m = new $Map();
                    $mapSet($m, key, value);
                }
            };
            return channel;
        };
    },
    "../../../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var callBound = __webpack_require__("../../../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
        var inspect = __webpack_require__("../../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var getSideChannelMap = __webpack_require__("../../../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js");
        var $TypeError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $WeakMap = GetIntrinsic('%WeakMap%', true);
        var $weakMapGet = callBound('WeakMap.prototype.get', true);
        var $weakMapSet = callBound('WeakMap.prototype.set', true);
        var $weakMapHas = callBound('WeakMap.prototype.has', true);
        var $weakMapDelete = callBound('WeakMap.prototype.delete', true);
        module.exports = $WeakMap ? function() {
            var $wm;
            var $m;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if ($wm) return $weakMapDelete($wm, key);
                    } else if (getSideChannelMap) {
                        if ($m) return $m['delete'](key);
                    }
                    return false;
                },
                get: function(key) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if ($wm) return $weakMapGet($wm, key);
                    }
                    return $m && $m.get(key);
                },
                has: function(key) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if ($wm) return $weakMapHas($wm, key);
                    }
                    return !!$m && $m.has(key);
                },
                set: function(key, value) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if (!$wm) $wm = new $WeakMap();
                        $weakMapSet($wm, key, value);
                    } else if (getSideChannelMap) {
                        if (!$m) $m = getSideChannelMap();
                        $m.set(key, value);
                    }
                }
            };
            return channel;
        } : getSideChannelMap;
    },
    "../../../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var $TypeError = __webpack_require__("../../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var inspect = __webpack_require__("../../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var getSideChannelList = __webpack_require__("../../../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js");
        var getSideChannelMap = __webpack_require__("../../../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js");
        var getSideChannelWeakMap = __webpack_require__("../../../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js");
        var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
        module.exports = function() {
            var $channelData;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    return !!$channelData && $channelData['delete'](key);
                },
                get: function(key) {
                    return $channelData && $channelData.get(key);
                },
                has: function(key) {
                    return !!$channelData && $channelData.has(key);
                },
                set: function(key, value) {
                    if (!$channelData) $channelData = makeChannel();
                    $channelData.set(key, value);
                }
            };
            return channel;
        };
    },
    "../../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var codes = __webpack_require__("../../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json");
        module.exports = status;
        status.message = codes;
        status.code = createMessageToStatusCodeMap(codes);
        status.codes = createStatusCodeList(codes);
        status.redirect = {
            300: true,
            301: true,
            302: true,
            303: true,
            305: true,
            307: true,
            308: true
        };
        status.empty = {
            204: true,
            205: true,
            304: true
        };
        status.retry = {
            502: true,
            503: true,
            504: true
        };
        function createMessageToStatusCodeMap(codes) {
            var map = {};
            Object.keys(codes).forEach(function(code) {
                var message = codes[code];
                var status = Number(code);
                map[message.toLowerCase()] = status;
            });
            return map;
        }
        function createStatusCodeList(codes) {
            return Object.keys(codes).map(function(code) {
                return Number(code);
            });
        }
        function getStatusCode(message) {
            var msg = message.toLowerCase();
            if (!Object.prototype.hasOwnProperty.call(status.code, msg)) throw new Error('invalid status message: "' + message + '"');
            return status.code[msg];
        }
        function getStatusMessage(code) {
            if (!Object.prototype.hasOwnProperty.call(status.message, code)) throw new Error('invalid status code: ' + code);
            return status.message[code];
        }
        function status(code) {
            if ('number' == typeof code) return getStatusMessage(code);
            if ('string' != typeof code) throw new TypeError('code must be a number or string');
            var n = parseInt(code, 10);
            if (!isNaN(n)) return getStatusMessage(n);
            return getStatusCode(code);
        }
    },
    "../../../node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js" (module) {
        "use strict";
        /*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = toIdentifier;
        function toIdentifier(str) {
            return str.split(' ').map(function(token) {
                return token.slice(0, 1).toUpperCase() + token.slice(1);
            }).join('').replace(/[^ _0-9a-z]/gi, '');
        }
    },
    "../../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        var punycode = __webpack_require__("punycode");
        var mappingTable = __webpack_require__("../../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json");
        var PROCESSING_OPTIONS = {
            TRANSITIONAL: 0,
            NONTRANSITIONAL: 1
        };
        function normalize(str) {
            return str.split('\u0000').map(function(s) {
                return s.normalize('NFC');
            }).join('\u0000');
        }
        function findStatus(val) {
            var start = 0;
            var end = mappingTable.length - 1;
            while(start <= end){
                var mid = Math.floor((start + end) / 2);
                var target = mappingTable[mid];
                if (target[0][0] <= val && target[0][1] >= val) return target;
                if (target[0][0] > val) end = mid - 1;
                else start = mid + 1;
            }
            return null;
        }
        var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        function countSymbols(string) {
            return string.replace(regexAstralSymbols, '_').length;
        }
        function mapChars(domain_name, useSTD3, processing_option) {
            var hasError = false;
            var processed = "";
            var len = countSymbols(domain_name);
            for(var i = 0; i < len; ++i){
                var codePoint = domain_name.codePointAt(i);
                var status = findStatus(codePoint);
                switch(status[1]){
                    case "disallowed":
                        hasError = true;
                        processed += String.fromCodePoint(codePoint);
                        break;
                    case "ignored":
                        break;
                    case "mapped":
                        processed += String.fromCodePoint.apply(String, status[2]);
                        break;
                    case "deviation":
                        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) processed += String.fromCodePoint.apply(String, status[2]);
                        else processed += String.fromCodePoint(codePoint);
                        break;
                    case "valid":
                        processed += String.fromCodePoint(codePoint);
                        break;
                    case "disallowed_STD3_mapped":
                        if (useSTD3) {
                            hasError = true;
                            processed += String.fromCodePoint(codePoint);
                        } else processed += String.fromCodePoint.apply(String, status[2]);
                        break;
                    case "disallowed_STD3_valid":
                        if (useSTD3) hasError = true;
                        processed += String.fromCodePoint(codePoint);
                        break;
                }
            }
            return {
                string: processed,
                error: hasError
            };
        }
        var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
        function validateLabel(label, processing_option) {
            if ("xn--" === label.substr(0, 4)) {
                label = punycode.toUnicode(label);
                PROCESSING_OPTIONS.NONTRANSITIONAL;
            }
            var error = false;
            if (normalize(label) !== label || "-" === label[3] && "-" === label[4] || "-" === label[0] || "-" === label[label.length - 1] || -1 !== label.indexOf(".") || 0 === label.search(combiningMarksRegex)) error = true;
            var len = countSymbols(label);
            for(var i = 0; i < len; ++i){
                var status = findStatus(label.codePointAt(i));
                if (processing === PROCESSING_OPTIONS.TRANSITIONAL && "valid" !== status[1] || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && "valid" !== status[1] && "deviation" !== status[1]) {
                    error = true;
                    break;
                }
            }
            return {
                label: label,
                error: error
            };
        }
        function processing(domain_name, useSTD3, processing_option) {
            var result = mapChars(domain_name, useSTD3, processing_option);
            result.string = normalize(result.string);
            var labels = result.string.split(".");
            for(var i = 0; i < labels.length; ++i)try {
                var validation = validateLabel(labels[i]);
                labels[i] = validation.label;
                result.error = result.error || validation.error;
            } catch (e) {
                result.error = true;
            }
            return {
                string: labels.join("."),
                error: result.error
            };
        }
        module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
            var result = processing(domain_name, useSTD3, processing_option);
            var labels = result.string.split(".");
            labels = labels.map(function(l) {
                try {
                    return punycode.toASCII(l);
                } catch (e) {
                    result.error = true;
                    return l;
                }
            });
            if (verifyDnsLength) {
                var total = labels.slice(0, labels.length - 1).join(".").length;
                if (total.length > 253 || 0 === total.length) result.error = true;
                for(var i = 0; i < labels.length; ++i)if (labels.length > 63 || 0 === labels.length) {
                    result.error = true;
                    break;
                }
            }
            if (result.error) return null;
            return labels.join(".");
        };
        module.exports.toUnicode = function(domain_name, useSTD3) {
            var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
            return {
                domain: result.string,
                error: result.error
            };
        };
        module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
    },
    "../../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        module.exports = __webpack_require__("../../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js");
    },
    "../../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        __webpack_require__("net");
        var tls = __webpack_require__("tls");
        var http = __webpack_require__("http");
        var https = __webpack_require__("https");
        var events = __webpack_require__("events");
        __webpack_require__("assert");
        var util = __webpack_require__("util");
        exports1.httpOverHttp = httpOverHttp;
        exports1.httpsOverHttp = httpsOverHttp;
        exports1.httpOverHttps = httpOverHttps;
        exports1.httpsOverHttps = httpsOverHttps;
        function httpOverHttp(options) {
            var agent = new TunnelingAgent(options);
            agent.request = http.request;
            return agent;
        }
        function httpsOverHttp(options) {
            var agent = new TunnelingAgent(options);
            agent.request = http.request;
            agent.createSocket = createSecureSocket;
            agent.defaultPort = 443;
            return agent;
        }
        function httpOverHttps(options) {
            var agent = new TunnelingAgent(options);
            agent.request = https.request;
            return agent;
        }
        function httpsOverHttps(options) {
            var agent = new TunnelingAgent(options);
            agent.request = https.request;
            agent.createSocket = createSecureSocket;
            agent.defaultPort = 443;
            return agent;
        }
        function TunnelingAgent(options) {
            var self1 = this;
            self1.options = options || {};
            self1.proxyOptions = self1.options.proxy || {};
            self1.maxSockets = self1.options.maxSockets || http.Agent.defaultMaxSockets;
            self1.requests = [];
            self1.sockets = [];
            self1.on('free', function(socket, host, port, localAddress) {
                var options = toOptions(host, port, localAddress);
                for(var i = 0, len = self1.requests.length; i < len; ++i){
                    var pending = self1.requests[i];
                    if (pending.host === options.host && pending.port === options.port) {
                        self1.requests.splice(i, 1);
                        pending.request.onSocket(socket);
                        return;
                    }
                }
                socket.destroy();
                self1.removeSocket(socket);
            });
        }
        util.inherits(TunnelingAgent, events.EventEmitter);
        TunnelingAgent.prototype.addRequest = function(req, host, port, localAddress) {
            var self1 = this;
            var options = mergeOptions({
                request: req
            }, self1.options, toOptions(host, port, localAddress));
            if (self1.sockets.length >= this.maxSockets) return void self1.requests.push(options);
            self1.createSocket(options, function(socket) {
                socket.on('free', onFree);
                socket.on('close', onCloseOrRemove);
                socket.on('agentRemove', onCloseOrRemove);
                req.onSocket(socket);
                function onFree() {
                    self1.emit('free', socket, options);
                }
                function onCloseOrRemove(err) {
                    self1.removeSocket(socket);
                    socket.removeListener('free', onFree);
                    socket.removeListener('close', onCloseOrRemove);
                    socket.removeListener('agentRemove', onCloseOrRemove);
                }
            });
        };
        TunnelingAgent.prototype.createSocket = function(options, cb) {
            var self1 = this;
            var placeholder = {};
            self1.sockets.push(placeholder);
            var connectOptions = mergeOptions({}, self1.proxyOptions, {
                method: 'CONNECT',
                path: options.host + ':' + options.port,
                agent: false,
                headers: {
                    host: options.host + ':' + options.port
                }
            });
            if (options.localAddress) connectOptions.localAddress = options.localAddress;
            if (connectOptions.proxyAuth) {
                connectOptions.headers = connectOptions.headers || {};
                connectOptions.headers['Proxy-Authorization'] = 'Basic ' + new Buffer(connectOptions.proxyAuth).toString('base64');
            }
            debug('making CONNECT request');
            var connectReq = self1.request(connectOptions);
            connectReq.useChunkedEncodingByDefault = false;
            connectReq.once('response', onResponse);
            connectReq.once('upgrade', onUpgrade);
            connectReq.once('connect', onConnect);
            connectReq.once('error', onError);
            connectReq.end();
            function onResponse(res) {
                res.upgrade = true;
            }
            function onUpgrade(res, socket, head) {
                process.nextTick(function() {
                    onConnect(res, socket, head);
                });
            }
            function onConnect(res, socket, head) {
                connectReq.removeAllListeners();
                socket.removeAllListeners();
                if (200 !== res.statusCode) {
                    debug('tunneling socket could not be established, statusCode=%d', res.statusCode);
                    socket.destroy();
                    var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
                    error.code = 'ECONNRESET';
                    options.request.emit('error', error);
                    self1.removeSocket(placeholder);
                    return;
                }
                if (head.length > 0) {
                    debug('got illegal response body from proxy');
                    socket.destroy();
                    var error = new Error('got illegal response body from proxy');
                    error.code = 'ECONNRESET';
                    options.request.emit('error', error);
                    self1.removeSocket(placeholder);
                    return;
                }
                debug('tunneling connection has established');
                self1.sockets[self1.sockets.indexOf(placeholder)] = socket;
                return cb(socket);
            }
            function onError(cause) {
                connectReq.removeAllListeners();
                debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack);
                var error = new Error("tunneling socket could not be established, cause=" + cause.message);
                error.code = 'ECONNRESET';
                options.request.emit('error', error);
                self1.removeSocket(placeholder);
            }
        };
        TunnelingAgent.prototype.removeSocket = function(socket) {
            var pos = this.sockets.indexOf(socket);
            if (-1 === pos) return;
            this.sockets.splice(pos, 1);
            var pending = this.requests.shift();
            if (pending) this.createSocket(pending, function(socket) {
                pending.request.onSocket(socket);
            });
        };
        function createSecureSocket(options, cb) {
            var self1 = this;
            TunnelingAgent.prototype.createSocket.call(self1, options, function(socket) {
                var hostHeader = options.request.getHeader('host');
                var tlsOptions = mergeOptions({}, self1.options, {
                    socket: socket,
                    servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
                });
                var secureSocket = tls.connect(0, tlsOptions);
                self1.sockets[self1.sockets.indexOf(socket)] = secureSocket;
                cb(secureSocket);
            });
        }
        function toOptions(host, port, localAddress) {
            if ('string' == typeof host) return {
                host: host,
                port: port,
                localAddress: localAddress
            };
            return host;
        }
        function mergeOptions(target) {
            for(var i = 1, len = arguments.length; i < len; ++i){
                var overrides = arguments[i];
                if ('object' == typeof overrides) {
                    var keys = Object.keys(overrides);
                    for(var j = 0, keyLen = keys.length; j < keyLen; ++j){
                        var k = keys[j];
                        if (void 0 !== overrides[k]) target[k] = overrides[k];
                    }
                }
            }
            return target;
        }
        var debug;
        debug = process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG) ? function() {
            var args = Array.prototype.slice.call(arguments);
            if ('string' == typeof args[0]) args[0] = 'TUNNEL: ' + args[0];
            else args.unshift('TUNNEL:');
            console.error.apply(console, args);
        } : function() {};
        exports1.debug = debug;
    },
    "../../../node_modules/.pnpm/type-is@2.0.1/node_modules/type-is/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        /*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var contentType = __webpack_require__("../../../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var mime = __webpack_require__("../../../node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/index.js");
        var typer = __webpack_require__("../../../node_modules/.pnpm/media-typer@1.1.0/node_modules/media-typer/index.js");
        module.exports = typeofrequest;
        module.exports.is = typeis;
        module.exports.hasBody = hasbody;
        module.exports.normalize = normalize;
        module.exports.match = mimeMatch;
        function typeis(value, types_) {
            var i;
            var types = types_;
            var val = tryNormalizeType(value);
            if (!val) return false;
            if (types && !Array.isArray(types)) {
                types = new Array(arguments.length - 1);
                for(i = 0; i < types.length; i++)types[i] = arguments[i + 1];
            }
            if (!types || !types.length) return val;
            var type;
            for(i = 0; i < types.length; i++)if (mimeMatch(normalize(type = types[i]), val)) return '+' === type[0] || -1 !== type.indexOf('*') ? val : type;
            return false;
        }
        function hasbody(req) {
            return void 0 !== req.headers['transfer-encoding'] || !isNaN(req.headers['content-length']);
        }
        function typeofrequest(req, types_) {
            if (!hasbody(req)) return null;
            var types = arguments.length > 2 ? Array.prototype.slice.call(arguments, 1) : types_;
            var value = req.headers['content-type'];
            return typeis(value, types);
        }
        function normalize(type) {
            if ('string' != typeof type) return false;
            switch(type){
                case 'urlencoded':
                    return 'application/x-www-form-urlencoded';
                case 'multipart':
                    return 'multipart/*';
            }
            if ('+' === type[0]) return '*/*' + type;
            return -1 === type.indexOf('/') ? mime.lookup(type) : type;
        }
        function mimeMatch(expected, actual) {
            if (false === expected) return false;
            var actualParts = actual.split('/');
            var expectedParts = expected.split('/');
            if (2 !== actualParts.length || 2 !== expectedParts.length) return false;
            if ('*' !== expectedParts[0] && expectedParts[0] !== actualParts[0]) return false;
            if ('*+' === expectedParts[1].slice(0, 2)) return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length);
            if ('*' !== expectedParts[1] && expectedParts[1] !== actualParts[1]) return false;
            return true;
        }
        function normalizeType(value) {
            var type = contentType.parse(value).type;
            return typer.test(type) ? type : null;
        }
        function tryNormalizeType(value) {
            try {
                return value ? normalizeType(value) : null;
            } catch (err) {
                return null;
            }
        }
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const Client = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js");
        const Dispatcher = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher.js");
        const errors = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const Pool = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js");
        const BalancedPool = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/balanced-pool.js");
        const Agent = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/agent.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { InvalidArgumentError } = errors;
        const api = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/index.js");
        const buildConnector = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js");
        const MockClient = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-client.js");
        const MockAgent = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-agent.js");
        const MockPool = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-pool.js");
        const mockErrors = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-errors.js");
        const ProxyAgent = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/proxy-agent.js");
        const RetryHandler = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RetryHandler.js");
        const { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js");
        const DecoratorHandler = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/DecoratorHandler.js");
        const RedirectHandler = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RedirectHandler.js");
        const createRedirectInterceptor = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/interceptor/redirectInterceptor.js");
        let hasCrypto;
        try {
            __webpack_require__("crypto");
            hasCrypto = true;
        } catch  {
            hasCrypto = false;
        }
        Object.assign(Dispatcher.prototype, api);
        module.exports.Dispatcher = Dispatcher;
        module.exports.Client = Client;
        module.exports.Pool = Pool;
        module.exports.BalancedPool = BalancedPool;
        module.exports.Agent = Agent;
        module.exports.ProxyAgent = ProxyAgent;
        module.exports.RetryHandler = RetryHandler;
        module.exports.DecoratorHandler = DecoratorHandler;
        module.exports.RedirectHandler = RedirectHandler;
        module.exports.createRedirectInterceptor = createRedirectInterceptor;
        module.exports.buildConnector = buildConnector;
        module.exports.errors = errors;
        function makeDispatcher(fn) {
            return (url, opts, handler)=>{
                if ('function' == typeof opts) {
                    handler = opts;
                    opts = null;
                }
                if (!url || 'string' != typeof url && 'object' != typeof url && !(url instanceof URL)) throw new InvalidArgumentError('invalid url');
                if (null != opts && 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                if (opts && null != opts.path) {
                    if ('string' != typeof opts.path) throw new InvalidArgumentError('invalid opts.path');
                    let path = opts.path;
                    if (!opts.path.startsWith('/')) path = `/${path}`;
                    url = new URL(util.parseOrigin(url).origin + path);
                } else {
                    if (!opts) opts = 'object' == typeof url ? url : {};
                    url = util.parseURL(url);
                }
                const { agent, dispatcher = getGlobalDispatcher() } = opts;
                if (agent) throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?');
                return fn.call(dispatcher, {
                    ...opts,
                    origin: url.origin,
                    path: url.search ? `${url.pathname}${url.search}` : url.pathname,
                    method: opts.method || (opts.body ? 'PUT' : 'GET')
                }, handler);
            };
        }
        module.exports.setGlobalDispatcher = setGlobalDispatcher;
        module.exports.getGlobalDispatcher = getGlobalDispatcher;
        if (util.nodeMajor > 16 || 16 === util.nodeMajor && util.nodeMinor >= 8) {
            let fetchImpl = null;
            module.exports.fetch = async function(resource) {
                if (!fetchImpl) fetchImpl = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/index.js").fetch;
                try {
                    return await fetchImpl(...arguments);
                } catch (err) {
                    if ('object' == typeof err) Error.captureStackTrace(err, this);
                    throw err;
                }
            };
            module.exports.Headers = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js").Headers;
            module.exports.Response = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/response.js").Response;
            module.exports.Request = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/request.js").Request;
            module.exports.FormData = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/formdata.js").FormData;
            module.exports.File = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/file.js").File;
            module.exports.FileReader = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/filereader.js").FileReader;
            const { setGlobalOrigin, getGlobalOrigin } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js");
            module.exports.setGlobalOrigin = setGlobalOrigin;
            module.exports.getGlobalOrigin = getGlobalOrigin;
            const { CacheStorage } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cachestorage.js");
            const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/symbols.js");
            module.exports.caches = new CacheStorage(kConstruct);
        }
        if (util.nodeMajor >= 16) {
            const { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/index.js");
            module.exports.deleteCookie = deleteCookie;
            module.exports.getCookies = getCookies;
            module.exports.getSetCookies = getSetCookies;
            module.exports.setCookie = setCookie;
            const { parseMIMEType, serializeAMimeType } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
            module.exports.parseMIMEType = parseMIMEType;
            module.exports.serializeAMimeType = serializeAMimeType;
        }
        if (util.nodeMajor >= 18 && hasCrypto) {
            const { WebSocket } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/websocket.js");
            module.exports.WebSocket = WebSocket;
        }
        module.exports.request = makeDispatcher(api.request);
        module.exports.stream = makeDispatcher(api.stream);
        module.exports.pipeline = makeDispatcher(api.pipeline);
        module.exports.connect = makeDispatcher(api.connect);
        module.exports.upgrade = makeDispatcher(api.upgrade);
        module.exports.MockClient = MockClient;
        module.exports.MockPool = MockPool;
        module.exports.MockAgent = MockAgent;
        module.exports.mockErrors = mockErrors;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/agent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const DispatcherBase = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher-base.js");
        const Pool = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js");
        const Client = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const createRedirectInterceptor = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/interceptor/redirectInterceptor.js");
        const { WeakRef: WeakRef1, FinalizationRegistry: FinalizationRegistry1 } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/compat/dispatcher-weakref.js")();
        const kOnConnect = Symbol('onConnect');
        const kOnDisconnect = Symbol('onDisconnect');
        const kOnConnectionError = Symbol('onConnectionError');
        const kMaxRedirections = Symbol('maxRedirections');
        const kOnDrain = Symbol('onDrain');
        const kFactory = Symbol('factory');
        const kFinalizer = Symbol('finalizer');
        const kOptions = Symbol('options');
        function defaultFactory(origin, opts) {
            return opts && 1 === opts.connections ? new Client(origin, opts) : new Pool(origin, opts);
        }
        class Agent extends DispatcherBase {
            constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}){
                super();
                if ('function' != typeof factory) throw new InvalidArgumentError('factory must be a function.');
                if (null != connect && 'function' != typeof connect && 'object' != typeof connect) throw new InvalidArgumentError('connect must be a function or an object');
                if (!Number.isInteger(maxRedirections) || maxRedirections < 0) throw new InvalidArgumentError('maxRedirections must be a positive number');
                if (connect && 'function' != typeof connect) connect = {
                    ...connect
                };
                this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [
                    createRedirectInterceptor({
                        maxRedirections
                    })
                ];
                this[kOptions] = {
                    ...util.deepClone(options),
                    connect
                };
                this[kOptions].interceptors = options.interceptors ? {
                    ...options.interceptors
                } : void 0;
                this[kMaxRedirections] = maxRedirections;
                this[kFactory] = factory;
                this[kClients] = new Map();
                this[kFinalizer] = new FinalizationRegistry1((key)=>{
                    const ref = this[kClients].get(key);
                    if (void 0 !== ref && void 0 === ref.deref()) this[kClients].delete(key);
                });
                const agent = this;
                this[kOnDrain] = (origin, targets)=>{
                    agent.emit('drain', origin, [
                        agent,
                        ...targets
                    ]);
                };
                this[kOnConnect] = (origin, targets)=>{
                    agent.emit('connect', origin, [
                        agent,
                        ...targets
                    ]);
                };
                this[kOnDisconnect] = (origin, targets, err)=>{
                    agent.emit('disconnect', origin, [
                        agent,
                        ...targets
                    ], err);
                };
                this[kOnConnectionError] = (origin, targets, err)=>{
                    agent.emit('connectionError', origin, [
                        agent,
                        ...targets
                    ], err);
                };
            }
            get [kRunning]() {
                let ret = 0;
                for (const ref of this[kClients].values()){
                    const client = ref.deref();
                    if (client) ret += client[kRunning];
                }
                return ret;
            }
            [kDispatch](opts, handler) {
                let key;
                if (opts.origin && ('string' == typeof opts.origin || opts.origin instanceof URL)) key = String(opts.origin);
                else throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');
                const ref = this[kClients].get(key);
                let dispatcher = ref ? ref.deref() : null;
                if (!dispatcher) {
                    dispatcher = this[kFactory](opts.origin, this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);
                    this[kClients].set(key, new WeakRef1(dispatcher));
                    this[kFinalizer].register(dispatcher, key);
                }
                return dispatcher.dispatch(opts, handler);
            }
            async [kClose]() {
                const closePromises = [];
                for (const ref of this[kClients].values()){
                    const client = ref.deref();
                    if (client) closePromises.push(client.close());
                }
                await Promise.all(closePromises);
            }
            async [kDestroy](err) {
                const destroyPromises = [];
                for (const ref of this[kClients].values()){
                    const client = ref.deref();
                    if (client) destroyPromises.push(client.destroy(err));
                }
                await Promise.all(destroyPromises);
            }
        }
        module.exports = Agent;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js" (module, __unused_rspack_exports, __webpack_require__) {
        const { addAbortListener } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { RequestAbortedError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const kListener = Symbol('kListener');
        const kSignal = Symbol('kSignal');
        function abort(self1) {
            if (self1.abort) self1.abort();
            else self1.onError(new RequestAbortedError());
        }
        function addSignal(self1, signal) {
            self1[kSignal] = null;
            self1[kListener] = null;
            if (!signal) return;
            if (signal.aborted) return void abort(self1);
            self1[kSignal] = signal;
            self1[kListener] = ()=>{
                abort(self1);
            };
            addAbortListener(self1[kSignal], self1[kListener]);
        }
        function removeSignal(self1) {
            if (!self1[kSignal]) return;
            if ('removeEventListener' in self1[kSignal]) self1[kSignal].removeEventListener('abort', self1[kListener]);
            else self1[kSignal].removeListener('abort', self1[kListener]);
            self1[kSignal] = null;
            self1[kListener] = null;
        }
        module.exports = {
            addSignal,
            removeSignal
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-connect.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { AsyncResource } = __webpack_require__("async_hooks");
        const { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { addSignal, removeSignal } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js");
        class ConnectHandler extends AsyncResource {
            constructor(opts, callback){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                const { signal, opaque, responseHeaders } = opts;
                if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                super('UNDICI_CONNECT');
                this.opaque = opaque || null;
                this.responseHeaders = responseHeaders || null;
                this.callback = callback;
                this.abort = null;
                addSignal(this, signal);
            }
            onConnect(abort, context) {
                if (!this.callback) throw new RequestAbortedError();
                this.abort = abort;
                this.context = context;
            }
            onHeaders() {
                throw new SocketError('bad connect', null);
            }
            onUpgrade(statusCode, rawHeaders, socket) {
                const { callback, opaque, context } = this;
                removeSignal(this);
                this.callback = null;
                let headers = rawHeaders;
                if (null != headers) headers = 'raw' === this.responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                this.runInAsyncScope(callback, null, null, {
                    statusCode,
                    headers,
                    socket,
                    opaque,
                    context
                });
            }
            onError(err) {
                const { callback, opaque } = this;
                removeSignal(this);
                if (callback) {
                    this.callback = null;
                    queueMicrotask(()=>{
                        this.runInAsyncScope(callback, null, err, {
                            opaque
                        });
                    });
                }
            }
        }
        function connect(opts, callback) {
            if (void 0 === callback) return new Promise((resolve, reject)=>{
                connect.call(this, opts, (err, data)=>err ? reject(err) : resolve(data));
            });
            try {
                const connectHandler = new ConnectHandler(opts, callback);
                this.dispatch({
                    ...opts,
                    method: 'CONNECT'
                }, connectHandler);
            } catch (err) {
                if ('function' != typeof callback) throw err;
                const opaque = opts && opts.opaque;
                queueMicrotask(()=>callback(err, {
                        opaque
                    }));
            }
        }
        module.exports = connect;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-pipeline.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Readable, Duplex, PassThrough } = __webpack_require__("stream");
        const { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { AsyncResource } = __webpack_require__("async_hooks");
        const { addSignal, removeSignal } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js");
        const assert = __webpack_require__("assert");
        const kResume = Symbol('resume');
        class PipelineRequest extends Readable {
            constructor(){
                super({
                    autoDestroy: true
                });
                this[kResume] = null;
            }
            _read() {
                const { [kResume]: resume } = this;
                if (resume) {
                    this[kResume] = null;
                    resume();
                }
            }
            _destroy(err, callback) {
                this._read();
                callback(err);
            }
        }
        class PipelineResponse extends Readable {
            constructor(resume){
                super({
                    autoDestroy: true
                });
                this[kResume] = resume;
            }
            _read() {
                this[kResume]();
            }
            _destroy(err, callback) {
                if (!err && !this._readableState.endEmitted) err = new RequestAbortedError();
                callback(err);
            }
        }
        class PipelineHandler extends AsyncResource {
            constructor(opts, handler){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                if ('function' != typeof handler) throw new InvalidArgumentError('invalid handler');
                const { signal, method, opaque, onInfo, responseHeaders } = opts;
                if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                if ('CONNECT' === method) throw new InvalidArgumentError('invalid method');
                if (onInfo && 'function' != typeof onInfo) throw new InvalidArgumentError('invalid onInfo callback');
                super('UNDICI_PIPELINE');
                this.opaque = opaque || null;
                this.responseHeaders = responseHeaders || null;
                this.handler = handler;
                this.abort = null;
                this.context = null;
                this.onInfo = onInfo || null;
                this.req = new PipelineRequest().on('error', util.nop);
                this.ret = new Duplex({
                    readableObjectMode: opts.objectMode,
                    autoDestroy: true,
                    read: ()=>{
                        const { body } = this;
                        if (body && body.resume) body.resume();
                    },
                    write: (chunk, encoding, callback)=>{
                        const { req } = this;
                        if (req.push(chunk, encoding) || req._readableState.destroyed) callback();
                        else req[kResume] = callback;
                    },
                    destroy: (err, callback)=>{
                        const { body, req, res, ret, abort } = this;
                        if (!err && !ret._readableState.endEmitted) err = new RequestAbortedError();
                        if (abort && err) abort();
                        util.destroy(body, err);
                        util.destroy(req, err);
                        util.destroy(res, err);
                        removeSignal(this);
                        callback(err);
                    }
                }).on('prefinish', ()=>{
                    const { req } = this;
                    req.push(null);
                });
                this.res = null;
                addSignal(this, signal);
            }
            onConnect(abort, context) {
                const { ret, res } = this;
                assert(!res, 'pipeline cannot be retried');
                if (ret.destroyed) throw new RequestAbortedError();
                this.abort = abort;
                this.context = context;
            }
            onHeaders(statusCode, rawHeaders, resume) {
                const { opaque, handler, context } = this;
                if (statusCode < 200) {
                    if (this.onInfo) {
                        const headers = 'raw' === this.responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                        this.onInfo({
                            statusCode,
                            headers
                        });
                    }
                    return;
                }
                this.res = new PipelineResponse(resume);
                let body;
                try {
                    this.handler = null;
                    const headers = 'raw' === this.responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                    body = this.runInAsyncScope(handler, null, {
                        statusCode,
                        headers,
                        opaque,
                        body: this.res,
                        context
                    });
                } catch (err) {
                    this.res.on('error', util.nop);
                    throw err;
                }
                if (!body || 'function' != typeof body.on) throw new InvalidReturnValueError('expected Readable');
                body.on('data', (chunk)=>{
                    const { ret, body } = this;
                    if (!ret.push(chunk) && body.pause) body.pause();
                }).on('error', (err)=>{
                    const { ret } = this;
                    util.destroy(ret, err);
                }).on('end', ()=>{
                    const { ret } = this;
                    ret.push(null);
                }).on('close', ()=>{
                    const { ret } = this;
                    if (!ret._readableState.ended) util.destroy(ret, new RequestAbortedError());
                });
                this.body = body;
            }
            onData(chunk) {
                const { res } = this;
                return res.push(chunk);
            }
            onComplete(trailers) {
                const { res } = this;
                res.push(null);
            }
            onError(err) {
                const { ret } = this;
                this.handler = null;
                util.destroy(ret, err);
            }
        }
        function pipeline(opts, handler) {
            try {
                const pipelineHandler = new PipelineHandler(opts, handler);
                this.dispatch({
                    ...opts,
                    body: pipelineHandler.req
                }, pipelineHandler);
                return pipelineHandler.ret;
            } catch (err) {
                return new PassThrough().destroy(err);
            }
        }
        module.exports = pipeline;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-request.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const Readable = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/readable.js");
        const { InvalidArgumentError, RequestAbortedError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { getResolveErrorBodyCallback } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/util.js");
        const { AsyncResource } = __webpack_require__("async_hooks");
        const { addSignal, removeSignal } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js");
        class RequestHandler extends AsyncResource {
            constructor(opts, callback){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
                try {
                    if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                    if (highWaterMark && ('number' != typeof highWaterMark || highWaterMark < 0)) throw new InvalidArgumentError('invalid highWaterMark');
                    if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                    if ('CONNECT' === method) throw new InvalidArgumentError('invalid method');
                    if (onInfo && 'function' != typeof onInfo) throw new InvalidArgumentError('invalid onInfo callback');
                    super('UNDICI_REQUEST');
                } catch (err) {
                    if (util.isStream(body)) util.destroy(body.on('error', util.nop), err);
                    throw err;
                }
                this.responseHeaders = responseHeaders || null;
                this.opaque = opaque || null;
                this.callback = callback;
                this.res = null;
                this.abort = null;
                this.body = body;
                this.trailers = {};
                this.context = null;
                this.onInfo = onInfo || null;
                this.throwOnError = throwOnError;
                this.highWaterMark = highWaterMark;
                if (util.isStream(body)) body.on('error', (err)=>{
                    this.onError(err);
                });
                addSignal(this, signal);
            }
            onConnect(abort, context) {
                if (!this.callback) throw new RequestAbortedError();
                this.abort = abort;
                this.context = context;
            }
            onHeaders(statusCode, rawHeaders, resume, statusMessage) {
                const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
                const headers = 'raw' === responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                if (statusCode < 200) {
                    if (this.onInfo) this.onInfo({
                        statusCode,
                        headers
                    });
                    return;
                }
                const parsedHeaders = 'raw' === responseHeaders ? util.parseHeaders(rawHeaders) : headers;
                const contentType = parsedHeaders['content-type'];
                const body = new Readable({
                    resume,
                    abort,
                    contentType,
                    highWaterMark
                });
                this.callback = null;
                this.res = body;
                if (null !== callback) if (this.throwOnError && statusCode >= 400) this.runInAsyncScope(getResolveErrorBodyCallback, null, {
                    callback,
                    body,
                    contentType,
                    statusCode,
                    statusMessage,
                    headers
                });
                else this.runInAsyncScope(callback, null, null, {
                    statusCode,
                    headers,
                    trailers: this.trailers,
                    opaque,
                    body,
                    context
                });
            }
            onData(chunk) {
                const { res } = this;
                return res.push(chunk);
            }
            onComplete(trailers) {
                const { res } = this;
                removeSignal(this);
                util.parseHeaders(trailers, this.trailers);
                res.push(null);
            }
            onError(err) {
                const { res, callback, body, opaque } = this;
                removeSignal(this);
                if (callback) {
                    this.callback = null;
                    queueMicrotask(()=>{
                        this.runInAsyncScope(callback, null, err, {
                            opaque
                        });
                    });
                }
                if (res) {
                    this.res = null;
                    queueMicrotask(()=>{
                        util.destroy(res, err);
                    });
                }
                if (body) {
                    this.body = null;
                    util.destroy(body, err);
                }
            }
        }
        function request(opts, callback) {
            if (void 0 === callback) return new Promise((resolve, reject)=>{
                request.call(this, opts, (err, data)=>err ? reject(err) : resolve(data));
            });
            try {
                this.dispatch(opts, new RequestHandler(opts, callback));
            } catch (err) {
                if ('function' != typeof callback) throw err;
                const opaque = opts && opts.opaque;
                queueMicrotask(()=>callback(err, {
                        opaque
                    }));
            }
        }
        module.exports = request;
        module.exports.RequestHandler = RequestHandler;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-stream.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { finished, PassThrough } = __webpack_require__("stream");
        const { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { getResolveErrorBodyCallback } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/util.js");
        const { AsyncResource } = __webpack_require__("async_hooks");
        const { addSignal, removeSignal } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js");
        class StreamHandler extends AsyncResource {
            constructor(opts, factory, callback){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
                try {
                    if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                    if ('function' != typeof factory) throw new InvalidArgumentError('invalid factory');
                    if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                    if ('CONNECT' === method) throw new InvalidArgumentError('invalid method');
                    if (onInfo && 'function' != typeof onInfo) throw new InvalidArgumentError('invalid onInfo callback');
                    super('UNDICI_STREAM');
                } catch (err) {
                    if (util.isStream(body)) util.destroy(body.on('error', util.nop), err);
                    throw err;
                }
                this.responseHeaders = responseHeaders || null;
                this.opaque = opaque || null;
                this.factory = factory;
                this.callback = callback;
                this.res = null;
                this.abort = null;
                this.context = null;
                this.trailers = null;
                this.body = body;
                this.onInfo = onInfo || null;
                this.throwOnError = throwOnError || false;
                if (util.isStream(body)) body.on('error', (err)=>{
                    this.onError(err);
                });
                addSignal(this, signal);
            }
            onConnect(abort, context) {
                if (!this.callback) throw new RequestAbortedError();
                this.abort = abort;
                this.context = context;
            }
            onHeaders(statusCode, rawHeaders, resume, statusMessage) {
                const { factory, opaque, context, callback, responseHeaders } = this;
                const headers = 'raw' === responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                if (statusCode < 200) {
                    if (this.onInfo) this.onInfo({
                        statusCode,
                        headers
                    });
                    return;
                }
                this.factory = null;
                let res;
                if (this.throwOnError && statusCode >= 400) {
                    const parsedHeaders = 'raw' === responseHeaders ? util.parseHeaders(rawHeaders) : headers;
                    const contentType = parsedHeaders['content-type'];
                    res = new PassThrough();
                    this.callback = null;
                    this.runInAsyncScope(getResolveErrorBodyCallback, null, {
                        callback,
                        body: res,
                        contentType,
                        statusCode,
                        statusMessage,
                        headers
                    });
                } else {
                    if (null === factory) return;
                    res = this.runInAsyncScope(factory, null, {
                        statusCode,
                        headers,
                        opaque,
                        context
                    });
                    if (!res || 'function' != typeof res.write || 'function' != typeof res.end || 'function' != typeof res.on) throw new InvalidReturnValueError('expected Writable');
                    finished(res, {
                        readable: false
                    }, (err)=>{
                        const { callback, res, opaque, trailers, abort } = this;
                        this.res = null;
                        if (err || !res.readable) util.destroy(res, err);
                        this.callback = null;
                        this.runInAsyncScope(callback, null, err || null, {
                            opaque,
                            trailers
                        });
                        if (err) abort();
                    });
                }
                res.on('drain', resume);
                this.res = res;
                const needDrain = void 0 !== res.writableNeedDrain ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
                return true !== needDrain;
            }
            onData(chunk) {
                const { res } = this;
                return res ? res.write(chunk) : true;
            }
            onComplete(trailers) {
                const { res } = this;
                removeSignal(this);
                if (!res) return;
                this.trailers = util.parseHeaders(trailers);
                res.end();
            }
            onError(err) {
                const { res, callback, opaque, body } = this;
                removeSignal(this);
                this.factory = null;
                if (res) {
                    this.res = null;
                    util.destroy(res, err);
                } else if (callback) {
                    this.callback = null;
                    queueMicrotask(()=>{
                        this.runInAsyncScope(callback, null, err, {
                            opaque
                        });
                    });
                }
                if (body) {
                    this.body = null;
                    util.destroy(body, err);
                }
            }
        }
        function stream(opts, factory, callback) {
            if (void 0 === callback) return new Promise((resolve, reject)=>{
                stream.call(this, opts, factory, (err, data)=>err ? reject(err) : resolve(data));
            });
            try {
                this.dispatch(opts, new StreamHandler(opts, factory, callback));
            } catch (err) {
                if ('function' != typeof callback) throw err;
                const opaque = opts && opts.opaque;
                queueMicrotask(()=>callback(err, {
                        opaque
                    }));
            }
        }
        module.exports = stream;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-upgrade.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const { AsyncResource } = __webpack_require__("async_hooks");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { addSignal, removeSignal } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js");
        const assert = __webpack_require__("assert");
        class UpgradeHandler extends AsyncResource {
            constructor(opts, callback){
                if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('invalid opts');
                if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                const { signal, opaque, responseHeaders } = opts;
                if (signal && 'function' != typeof signal.on && 'function' != typeof signal.addEventListener) throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');
                super('UNDICI_UPGRADE');
                this.responseHeaders = responseHeaders || null;
                this.opaque = opaque || null;
                this.callback = callback;
                this.abort = null;
                this.context = null;
                addSignal(this, signal);
            }
            onConnect(abort, context) {
                if (!this.callback) throw new RequestAbortedError();
                this.abort = abort;
                this.context = null;
            }
            onHeaders() {
                throw new SocketError('bad upgrade', null);
            }
            onUpgrade(statusCode, rawHeaders, socket) {
                const { callback, opaque, context } = this;
                assert.strictEqual(statusCode, 101);
                removeSignal(this);
                this.callback = null;
                const headers = 'raw' === this.responseHeaders ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
                this.runInAsyncScope(callback, null, null, {
                    headers,
                    socket,
                    opaque,
                    context
                });
            }
            onError(err) {
                const { callback, opaque } = this;
                removeSignal(this);
                if (callback) {
                    this.callback = null;
                    queueMicrotask(()=>{
                        this.runInAsyncScope(callback, null, err, {
                            opaque
                        });
                    });
                }
            }
        }
        function upgrade(opts, callback) {
            if (void 0 === callback) return new Promise((resolve, reject)=>{
                upgrade.call(this, opts, (err, data)=>err ? reject(err) : resolve(data));
            });
            try {
                const upgradeHandler = new UpgradeHandler(opts, callback);
                this.dispatch({
                    ...opts,
                    method: opts.method || 'GET',
                    upgrade: opts.protocol || 'Websocket'
                }, upgradeHandler);
            } catch (err) {
                if ('function' != typeof callback) throw err;
                const opaque = opts && opts.opaque;
                queueMicrotask(()=>callback(err, {
                        opaque
                    }));
            }
        }
        module.exports = upgrade;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        module.exports.request = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-request.js");
        module.exports.stream = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-stream.js");
        module.exports.pipeline = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-pipeline.js");
        module.exports.upgrade = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-upgrade.js");
        module.exports.connect = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-connect.js");
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/readable.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("assert");
        const { Readable } = __webpack_require__("stream");
        const { RequestAbortedError, NotSupportedError, InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { ReadableStreamFrom, toUSVString } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        let Blob1;
        const kConsume = Symbol('kConsume');
        const kReading = Symbol('kReading');
        const kBody = Symbol('kBody');
        const kAbort = Symbol('abort');
        const kContentType = Symbol('kContentType');
        const noop = ()=>{};
        module.exports = class extends Readable {
            constructor({ resume, abort, contentType = '', highWaterMark = 65536 }){
                super({
                    autoDestroy: true,
                    read: resume,
                    highWaterMark
                });
                this._readableState.dataEmitted = false;
                this[kAbort] = abort;
                this[kConsume] = null;
                this[kBody] = null;
                this[kContentType] = contentType;
                this[kReading] = false;
            }
            destroy(err) {
                if (this.destroyed) return this;
                if (!err && !this._readableState.endEmitted) err = new RequestAbortedError();
                if (err) this[kAbort]();
                return super.destroy(err);
            }
            emit(ev, ...args) {
                if ('data' === ev) this._readableState.dataEmitted = true;
                else if ('error' === ev) this._readableState.errorEmitted = true;
                return super.emit(ev, ...args);
            }
            on(ev, ...args) {
                if ('data' === ev || 'readable' === ev) this[kReading] = true;
                return super.on(ev, ...args);
            }
            addListener(ev, ...args) {
                return this.on(ev, ...args);
            }
            off(ev, ...args) {
                const ret = super.off(ev, ...args);
                if ('data' === ev || 'readable' === ev) this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;
                return ret;
            }
            removeListener(ev, ...args) {
                return this.off(ev, ...args);
            }
            push(chunk) {
                if (this[kConsume] && null !== chunk && 0 === this.readableLength) {
                    consumePush(this[kConsume], chunk);
                    return this[kReading] ? super.push(chunk) : true;
                }
                return super.push(chunk);
            }
            async text() {
                return consume(this, 'text');
            }
            async json() {
                return consume(this, 'json');
            }
            async blob() {
                return consume(this, 'blob');
            }
            async arrayBuffer() {
                return consume(this, 'arrayBuffer');
            }
            async formData() {
                throw new NotSupportedError();
            }
            get bodyUsed() {
                return util.isDisturbed(this);
            }
            get body() {
                if (!this[kBody]) {
                    this[kBody] = ReadableStreamFrom(this);
                    if (this[kConsume]) {
                        this[kBody].getReader();
                        assert(this[kBody].locked);
                    }
                }
                return this[kBody];
            }
            dump(opts) {
                let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
                const signal = opts && opts.signal;
                if (signal) try {
                    if ('object' != typeof signal || !('aborted' in signal)) throw new InvalidArgumentError('signal must be an AbortSignal');
                    util.throwIfAborted(signal);
                } catch (err) {
                    return Promise.reject(err);
                }
                if (this.closed) return Promise.resolve(null);
                return new Promise((resolve, reject)=>{
                    const signalListenerCleanup = signal ? util.addAbortListener(signal, ()=>{
                        this.destroy();
                    }) : noop;
                    this.on('close', function() {
                        signalListenerCleanup();
                        if (signal && signal.aborted) reject(signal.reason || Object.assign(new Error('The operation was aborted'), {
                            name: 'AbortError'
                        }));
                        else resolve(null);
                    }).on('error', noop).on('data', function(chunk) {
                        limit -= chunk.length;
                        if (limit <= 0) this.destroy();
                    }).resume();
                });
            }
        };
        function isLocked(self1) {
            return self1[kBody] && true === self1[kBody].locked || self1[kConsume];
        }
        function isUnusable(self1) {
            return util.isDisturbed(self1) || isLocked(self1);
        }
        async function consume(stream, type) {
            if (isUnusable(stream)) throw new TypeError('unusable');
            assert(!stream[kConsume]);
            return new Promise((resolve, reject)=>{
                stream[kConsume] = {
                    type,
                    stream,
                    resolve,
                    reject,
                    length: 0,
                    body: []
                };
                stream.on('error', function(err) {
                    consumeFinish(this[kConsume], err);
                }).on('close', function() {
                    if (null !== this[kConsume].body) consumeFinish(this[kConsume], new RequestAbortedError());
                });
                process.nextTick(consumeStart, stream[kConsume]);
            });
        }
        function consumeStart(consume) {
            if (null === consume.body) return;
            const { _readableState: state } = consume.stream;
            for (const chunk of state.buffer)consumePush(consume, chunk);
            if (state.endEmitted) consumeEnd(this[kConsume]);
            else consume.stream.on('end', function() {
                consumeEnd(this[kConsume]);
            });
            consume.stream.resume();
            while(null != consume.stream.read());
        }
        function consumeEnd(consume) {
            const { type, body, resolve, stream, length } = consume;
            try {
                if ('text' === type) resolve(toUSVString(Buffer.concat(body)));
                else if ('json' === type) resolve(JSON.parse(Buffer.concat(body)));
                else if ('arrayBuffer' === type) {
                    const dst = new Uint8Array(length);
                    let pos = 0;
                    for (const buf of body){
                        dst.set(buf, pos);
                        pos += buf.byteLength;
                    }
                    resolve(dst.buffer);
                } else if ('blob' === type) {
                    if (!Blob1) Blob1 = __webpack_require__("buffer").Blob;
                    resolve(new Blob1(body, {
                        type: stream[kContentType]
                    }));
                }
                consumeFinish(consume);
            } catch (err) {
                stream.destroy(err);
            }
        }
        function consumePush(consume, chunk) {
            consume.length += chunk.length;
            consume.body.push(chunk);
        }
        function consumeFinish(consume, err) {
            if (null === consume.body) return;
            if (err) consume.reject(err);
            else consume.resolve();
            consume.type = null;
            consume.stream = null;
            consume.resolve = null;
            consume.reject = null;
            consume.length = 0;
            consume.body = null;
        }
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        const assert = __webpack_require__("assert");
        const { ResponseStatusCodeError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const { toUSVString } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
            assert(body);
            let chunks = [];
            let limit = 0;
            for await (const chunk of body){
                chunks.push(chunk);
                limit += chunk.length;
                if (limit > 131072) {
                    chunks = null;
                    break;
                }
            }
            if (204 === statusCode || !contentType || !chunks) return void process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));
            try {
                if (contentType.startsWith('application/json')) {
                    const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
                    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));
                    return;
                }
                if (contentType.startsWith('text/')) {
                    const payload = toUSVString(Buffer.concat(chunks));
                    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));
                    return;
                }
            } catch (err) {}
            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));
        }
        module.exports = {
            getResolveErrorBodyCallback
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/balanced-pool.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { BalancedPoolMissingUpstreamError, InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-base.js");
        const Pool = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js");
        const { kUrl, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const { parseOrigin } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const kFactory = Symbol('factory');
        const kOptions = Symbol('options');
        const kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');
        const kCurrentWeight = Symbol('kCurrentWeight');
        const kIndex = Symbol('kIndex');
        const kWeight = Symbol('kWeight');
        const kMaxWeightPerServer = Symbol('kMaxWeightPerServer');
        const kErrorPenalty = Symbol('kErrorPenalty');
        function getGreatestCommonDivisor(a, b) {
            if (0 === b) return a;
            return getGreatestCommonDivisor(b, a % b);
        }
        function defaultFactory(origin, opts) {
            return new Pool(origin, opts);
        }
        class BalancedPool extends PoolBase {
            constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}){
                super();
                this[kOptions] = opts;
                this[kIndex] = -1;
                this[kCurrentWeight] = 0;
                this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
                this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
                if (!Array.isArray(upstreams)) upstreams = [
                    upstreams
                ];
                if ('function' != typeof factory) throw new InvalidArgumentError('factory must be a function.');
                this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
                this[kFactory] = factory;
                for (const upstream of upstreams)this.addUpstream(upstream);
                this._updateBalancedPoolStats();
            }
            addUpstream(upstream) {
                const upstreamOrigin = parseOrigin(upstream).origin;
                if (this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && true !== pool.closed && true !== pool.destroyed)) return this;
                const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
                this[kAddClient](pool);
                pool.on('connect', ()=>{
                    pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
                });
                pool.on('connectionError', ()=>{
                    pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
                    this._updateBalancedPoolStats();
                });
                pool.on('disconnect', (...args)=>{
                    const err = args[2];
                    if (err && 'UND_ERR_SOCKET' === err.code) {
                        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
                        this._updateBalancedPoolStats();
                    }
                });
                for (const client of this[kClients])client[kWeight] = this[kMaxWeightPerServer];
                this._updateBalancedPoolStats();
                return this;
            }
            _updateBalancedPoolStats() {
                this[kGreatestCommonDivisor] = this[kClients].map((p)=>p[kWeight]).reduce(getGreatestCommonDivisor, 0);
            }
            removeUpstream(upstream) {
                const upstreamOrigin = parseOrigin(upstream).origin;
                const pool = this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && true !== pool.closed && true !== pool.destroyed);
                if (pool) this[kRemoveClient](pool);
                return this;
            }
            get upstreams() {
                return this[kClients].filter((dispatcher)=>true !== dispatcher.closed && true !== dispatcher.destroyed).map((p)=>p[kUrl].origin);
            }
            [kGetDispatcher]() {
                if (0 === this[kClients].length) throw new BalancedPoolMissingUpstreamError();
                const dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain] && true !== dispatcher.closed && true !== dispatcher.destroyed);
                if (!dispatcher) return;
                const allClientsBusy = this[kClients].map((pool)=>pool[kNeedDrain]).reduce((a, b)=>a && b, true);
                if (allClientsBusy) return;
                let counter = 0;
                let maxWeightIndex = this[kClients].findIndex((pool)=>!pool[kNeedDrain]);
                while(counter++ < this[kClients].length){
                    this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
                    const pool = this[kClients][this[kIndex]];
                    if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) maxWeightIndex = this[kIndex];
                    if (0 === this[kIndex]) {
                        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
                        if (this[kCurrentWeight] <= 0) this[kCurrentWeight] = this[kMaxWeightPerServer];
                    }
                    if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) return pool;
                }
                this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
                this[kIndex] = maxWeightIndex;
                return this[kClients][maxWeightIndex];
            }
        }
        module.exports = BalancedPool;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cache.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/symbols.js");
        const { urlEquals, fieldValues: getFieldValues } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/util.js");
        const { kEnumerableProperty, isDisturbed } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { kHeadersList } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { Response, cloneResponse } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/response.js");
        const { Request } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/request.js");
        const { kState, kHeaders, kGuard, kRealm } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js");
        const { fetching } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/index.js");
        const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const assert = __webpack_require__("assert");
        const { getGlobalDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js");
        class Cache {
            #relevantRequestResponseList;
            constructor(){
                if (arguments[0] !== kConstruct) webidl.illegalConstructor();
                this.#relevantRequestResponseList = arguments[1];
            }
            async match(request, options = {}) {
                webidl.brandCheck(this, Cache);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Cache.match'
                });
                request = webidl.converters.RequestInfo(request);
                options = webidl.converters.CacheQueryOptions(options);
                const p = await this.matchAll(request, options);
                if (0 === p.length) return;
                return p[0];
            }
            async matchAll(request, options = {}) {
                webidl.brandCheck(this, Cache);
                if (void 0 !== request) request = webidl.converters.RequestInfo(request);
                options = webidl.converters.CacheQueryOptions(options);
                let r = null;
                if (void 0 !== request) {
                    if (request instanceof Request) {
                        r = request[kState];
                        if ('GET' !== r.method && !options.ignoreMethod) return [];
                    } else if ('string' == typeof request) r = new Request(request)[kState];
                }
                const responses = [];
                if (void 0 === request) for (const requestResponse of this.#relevantRequestResponseList)responses.push(requestResponse[1]);
                else {
                    const requestResponses = this.#queryCache(r, options);
                    for (const requestResponse of requestResponses)responses.push(requestResponse[1]);
                }
                const responseList = [];
                for (const response of responses){
                    const responseObject = new Response(response.body?.source ?? null);
                    const body = responseObject[kState].body;
                    responseObject[kState] = response;
                    responseObject[kState].body = body;
                    responseObject[kHeaders][kHeadersList] = response.headersList;
                    responseObject[kHeaders][kGuard] = 'immutable';
                    responseList.push(responseObject);
                }
                return Object.freeze(responseList);
            }
            async add(request) {
                webidl.brandCheck(this, Cache);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Cache.add'
                });
                request = webidl.converters.RequestInfo(request);
                const requests = [
                    request
                ];
                const responseArrayPromise = this.addAll(requests);
                return await responseArrayPromise;
            }
            async addAll(requests) {
                webidl.brandCheck(this, Cache);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Cache.addAll'
                });
                requests = webidl.converters['sequence<RequestInfo>'](requests);
                const responsePromises = [];
                const requestList = [];
                for (const request of requests){
                    if ('string' == typeof request) continue;
                    const r = request[kState];
                    if (!urlIsHttpHttpsScheme(r.url) || 'GET' !== r.method) throw webidl.errors.exception({
                        header: 'Cache.addAll',
                        message: 'Expected http/s scheme when method is not GET.'
                    });
                }
                const fetchControllers = [];
                for (const request of requests){
                    const r = new Request(request)[kState];
                    if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
                        header: 'Cache.addAll',
                        message: 'Expected http/s scheme.'
                    });
                    r.initiator = 'fetch';
                    r.destination = 'subresource';
                    requestList.push(r);
                    const responsePromise = createDeferredPromise();
                    fetchControllers.push(fetching({
                        request: r,
                        dispatcher: getGlobalDispatcher(),
                        processResponse (response) {
                            if ('error' === response.type || 206 === response.status || response.status < 200 || response.status > 299) responsePromise.reject(webidl.errors.exception({
                                header: 'Cache.addAll',
                                message: 'Received an invalid status code or the request failed.'
                            }));
                            else if (response.headersList.contains('vary')) {
                                const fieldValues = getFieldValues(response.headersList.get('vary'));
                                for (const fieldValue of fieldValues)if ('*' === fieldValue) {
                                    responsePromise.reject(webidl.errors.exception({
                                        header: 'Cache.addAll',
                                        message: 'invalid vary field value'
                                    }));
                                    for (const controller of fetchControllers)controller.abort();
                                    return;
                                }
                            }
                        },
                        processResponseEndOfBody (response) {
                            if (response.aborted) return void responsePromise.reject(new DOMException('aborted', 'AbortError'));
                            responsePromise.resolve(response);
                        }
                    }));
                    responsePromises.push(responsePromise.promise);
                }
                const p = Promise.all(responsePromises);
                const responses = await p;
                const operations = [];
                let index = 0;
                for (const response of responses){
                    const operation = {
                        type: 'put',
                        request: requestList[index],
                        response
                    };
                    operations.push(operation);
                    index++;
                }
                const cacheJobPromise = createDeferredPromise();
                let errorData = null;
                try {
                    this.#batchCacheOperations(operations);
                } catch (e) {
                    errorData = e;
                }
                queueMicrotask(()=>{
                    if (null === errorData) cacheJobPromise.resolve(void 0);
                    else cacheJobPromise.reject(errorData);
                });
                return cacheJobPromise.promise;
            }
            async put(request, response) {
                webidl.brandCheck(this, Cache);
                webidl.argumentLengthCheck(arguments, 2, {
                    header: 'Cache.put'
                });
                request = webidl.converters.RequestInfo(request);
                response = webidl.converters.Response(response);
                let innerRequest = null;
                innerRequest = request instanceof Request ? request[kState] : new Request(request)[kState];
                if (!urlIsHttpHttpsScheme(innerRequest.url) || 'GET' !== innerRequest.method) throw webidl.errors.exception({
                    header: 'Cache.put',
                    message: 'Expected an http/s scheme when method is not GET'
                });
                const innerResponse = response[kState];
                if (206 === innerResponse.status) throw webidl.errors.exception({
                    header: 'Cache.put',
                    message: 'Got 206 status'
                });
                if (innerResponse.headersList.contains('vary')) {
                    const fieldValues = getFieldValues(innerResponse.headersList.get('vary'));
                    for (const fieldValue of fieldValues)if ('*' === fieldValue) throw webidl.errors.exception({
                        header: 'Cache.put',
                        message: 'Got * vary field value'
                    });
                }
                if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw webidl.errors.exception({
                    header: 'Cache.put',
                    message: 'Response body is locked or disturbed'
                });
                const clonedResponse = cloneResponse(innerResponse);
                const bodyReadPromise = createDeferredPromise();
                if (null != innerResponse.body) {
                    const stream = innerResponse.body.stream;
                    const reader = stream.getReader();
                    readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
                } else bodyReadPromise.resolve(void 0);
                const operations = [];
                const operation = {
                    type: 'put',
                    request: innerRequest,
                    response: clonedResponse
                };
                operations.push(operation);
                const bytes = await bodyReadPromise.promise;
                if (null != clonedResponse.body) clonedResponse.body.source = bytes;
                const cacheJobPromise = createDeferredPromise();
                let errorData = null;
                try {
                    this.#batchCacheOperations(operations);
                } catch (e) {
                    errorData = e;
                }
                queueMicrotask(()=>{
                    if (null === errorData) cacheJobPromise.resolve();
                    else cacheJobPromise.reject(errorData);
                });
                return cacheJobPromise.promise;
            }
            async delete(request, options = {}) {
                webidl.brandCheck(this, Cache);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Cache.delete'
                });
                request = webidl.converters.RequestInfo(request);
                options = webidl.converters.CacheQueryOptions(options);
                let r = null;
                if (request instanceof Request) {
                    r = request[kState];
                    if ('GET' !== r.method && !options.ignoreMethod) return false;
                } else {
                    assert('string' == typeof request);
                    r = new Request(request)[kState];
                }
                const operations = [];
                const operation = {
                    type: 'delete',
                    request: r,
                    options
                };
                operations.push(operation);
                const cacheJobPromise = createDeferredPromise();
                let errorData = null;
                let requestResponses;
                try {
                    requestResponses = this.#batchCacheOperations(operations);
                } catch (e) {
                    errorData = e;
                }
                queueMicrotask(()=>{
                    if (null === errorData) cacheJobPromise.resolve(!!requestResponses?.length);
                    else cacheJobPromise.reject(errorData);
                });
                return cacheJobPromise.promise;
            }
            async keys(request, options = {}) {
                webidl.brandCheck(this, Cache);
                if (void 0 !== request) request = webidl.converters.RequestInfo(request);
                options = webidl.converters.CacheQueryOptions(options);
                let r = null;
                if (void 0 !== request) {
                    if (request instanceof Request) {
                        r = request[kState];
                        if ('GET' !== r.method && !options.ignoreMethod) return [];
                    } else if ('string' == typeof request) r = new Request(request)[kState];
                }
                const promise = createDeferredPromise();
                const requests = [];
                if (void 0 === request) for (const requestResponse of this.#relevantRequestResponseList)requests.push(requestResponse[0]);
                else {
                    const requestResponses = this.#queryCache(r, options);
                    for (const requestResponse of requestResponses)requests.push(requestResponse[0]);
                }
                queueMicrotask(()=>{
                    const requestList = [];
                    for (const request of requests){
                        const requestObject = new Request('https://a');
                        requestObject[kState] = request;
                        requestObject[kHeaders][kHeadersList] = request.headersList;
                        requestObject[kHeaders][kGuard] = 'immutable';
                        requestObject[kRealm] = request.client;
                        requestList.push(requestObject);
                    }
                    promise.resolve(Object.freeze(requestList));
                });
                return promise.promise;
            }
            #batchCacheOperations(operations) {
                const cache = this.#relevantRequestResponseList;
                const backupCache = [
                    ...cache
                ];
                const addedItems = [];
                const resultList = [];
                try {
                    for (const operation of operations){
                        if ('delete' !== operation.type && 'put' !== operation.type) throw webidl.errors.exception({
                            header: 'Cache.#batchCacheOperations',
                            message: 'operation type does not match "delete" or "put"'
                        });
                        if ('delete' === operation.type && null != operation.response) throw webidl.errors.exception({
                            header: 'Cache.#batchCacheOperations',
                            message: 'delete operation should not have an associated response'
                        });
                        if (this.#queryCache(operation.request, operation.options, addedItems).length) throw new DOMException('???', 'InvalidStateError');
                        let requestResponses;
                        if ('delete' === operation.type) {
                            requestResponses = this.#queryCache(operation.request, operation.options);
                            if (0 === requestResponses.length) return [];
                            for (const requestResponse of requestResponses){
                                const idx = cache.indexOf(requestResponse);
                                assert(-1 !== idx);
                                cache.splice(idx, 1);
                            }
                        } else if ('put' === operation.type) {
                            if (null == operation.response) throw webidl.errors.exception({
                                header: 'Cache.#batchCacheOperations',
                                message: 'put operation should have an associated response'
                            });
                            const r = operation.request;
                            if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
                                header: 'Cache.#batchCacheOperations',
                                message: 'expected http or https scheme'
                            });
                            if ('GET' !== r.method) throw webidl.errors.exception({
                                header: 'Cache.#batchCacheOperations',
                                message: 'not get method'
                            });
                            if (null != operation.options) throw webidl.errors.exception({
                                header: 'Cache.#batchCacheOperations',
                                message: 'options must not be defined'
                            });
                            requestResponses = this.#queryCache(operation.request);
                            for (const requestResponse of requestResponses){
                                const idx = cache.indexOf(requestResponse);
                                assert(-1 !== idx);
                                cache.splice(idx, 1);
                            }
                            cache.push([
                                operation.request,
                                operation.response
                            ]);
                            addedItems.push([
                                operation.request,
                                operation.response
                            ]);
                        }
                        resultList.push([
                            operation.request,
                            operation.response
                        ]);
                    }
                    return resultList;
                } catch (e) {
                    this.#relevantRequestResponseList.length = 0;
                    this.#relevantRequestResponseList = backupCache;
                    throw e;
                }
            }
            #queryCache(requestQuery, options, targetStorage) {
                const resultList = [];
                const storage = targetStorage ?? this.#relevantRequestResponseList;
                for (const requestResponse of storage){
                    const [cachedRequest, cachedResponse] = requestResponse;
                    if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) resultList.push(requestResponse);
                }
                return resultList;
            }
            #requestMatchesCachedItem(requestQuery, request, response = null, options) {
                const queryURL = new URL(requestQuery.url);
                const cachedURL = new URL(request.url);
                if (options?.ignoreSearch) {
                    cachedURL.search = '';
                    queryURL.search = '';
                }
                if (!urlEquals(queryURL, cachedURL, true)) return false;
                if (null == response || options?.ignoreVary || !response.headersList.contains('vary')) return true;
                const fieldValues = getFieldValues(response.headersList.get('vary'));
                for (const fieldValue of fieldValues){
                    if ('*' === fieldValue) return false;
                    const requestValue = request.headersList.get(fieldValue);
                    const queryValue = requestQuery.headersList.get(fieldValue);
                    if (requestValue !== queryValue) return false;
                }
                return true;
            }
        }
        Object.defineProperties(Cache.prototype, {
            [Symbol.toStringTag]: {
                value: 'Cache',
                configurable: true
            },
            match: kEnumerableProperty,
            matchAll: kEnumerableProperty,
            add: kEnumerableProperty,
            addAll: kEnumerableProperty,
            put: kEnumerableProperty,
            delete: kEnumerableProperty,
            keys: kEnumerableProperty
        });
        const cacheQueryOptionConverters = [
            {
                key: 'ignoreSearch',
                converter: webidl.converters.boolean,
                defaultValue: false
            },
            {
                key: 'ignoreMethod',
                converter: webidl.converters.boolean,
                defaultValue: false
            },
            {
                key: 'ignoreVary',
                converter: webidl.converters.boolean,
                defaultValue: false
            }
        ];
        webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
        webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
            ...cacheQueryOptionConverters,
            {
                key: 'cacheName',
                converter: webidl.converters.DOMString
            }
        ]);
        webidl.converters.Response = webidl.interfaceConverter(Response);
        webidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(webidl.converters.RequestInfo);
        module.exports = {
            Cache
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cachestorage.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/symbols.js");
        const { Cache } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cache.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        class CacheStorage {
            #caches = new Map();
            constructor(){
                if (arguments[0] !== kConstruct) webidl.illegalConstructor();
            }
            async match(request, options = {}) {
                webidl.brandCheck(this, CacheStorage);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'CacheStorage.match'
                });
                request = webidl.converters.RequestInfo(request);
                options = webidl.converters.MultiCacheQueryOptions(options);
                if (null != options.cacheName) {
                    if (this.#caches.has(options.cacheName)) {
                        const cacheList = this.#caches.get(options.cacheName);
                        const cache = new Cache(kConstruct, cacheList);
                        return await cache.match(request, options);
                    }
                } else for (const cacheList of this.#caches.values()){
                    const cache = new Cache(kConstruct, cacheList);
                    const response = await cache.match(request, options);
                    if (void 0 !== response) return response;
                }
            }
            async has(cacheName) {
                webidl.brandCheck(this, CacheStorage);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'CacheStorage.has'
                });
                cacheName = webidl.converters.DOMString(cacheName);
                return this.#caches.has(cacheName);
            }
            async open(cacheName) {
                webidl.brandCheck(this, CacheStorage);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'CacheStorage.open'
                });
                cacheName = webidl.converters.DOMString(cacheName);
                if (this.#caches.has(cacheName)) {
                    const cache = this.#caches.get(cacheName);
                    return new Cache(kConstruct, cache);
                }
                const cache = [];
                this.#caches.set(cacheName, cache);
                return new Cache(kConstruct, cache);
            }
            async delete(cacheName) {
                webidl.brandCheck(this, CacheStorage);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'CacheStorage.delete'
                });
                cacheName = webidl.converters.DOMString(cacheName);
                return this.#caches.delete(cacheName);
            }
            async keys() {
                webidl.brandCheck(this, CacheStorage);
                const keys = this.#caches.keys();
                return [
                    ...keys
                ];
            }
        }
        Object.defineProperties(CacheStorage.prototype, {
            [Symbol.toStringTag]: {
                value: 'CacheStorage',
                configurable: true
            },
            match: kEnumerableProperty,
            has: kEnumerableProperty,
            open: kEnumerableProperty,
            delete: kEnumerableProperty,
            keys: kEnumerableProperty
        });
        module.exports = {
            CacheStorage
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/symbols.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        module.exports = {
            kConstruct: __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js").kConstruct
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("assert");
        const { URLSerializer } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
        const { isValidHeaderName } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        function urlEquals(A, B, excludeFragment = false) {
            const serializedA = URLSerializer(A, excludeFragment);
            const serializedB = URLSerializer(B, excludeFragment);
            return serializedA === serializedB;
        }
        function fieldValues(header) {
            assert(null !== header);
            const values = [];
            for (let value of header.split(',')){
                value = value.trim();
                if (value.length) {
                    if (isValidHeaderName(value)) values.push(value);
                }
            }
            return values;
        }
        module.exports = {
            urlEquals,
            fieldValues
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("assert");
        const net = __webpack_require__("net");
        const http = __webpack_require__("http");
        const { pipeline } = __webpack_require__("stream");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const timers = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/timers.js");
        const Request = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/request.js");
        const DispatcherBase = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher-base.js");
        const { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, InvalidArgumentError, RequestAbortedError, HeadersTimeoutError, HeadersOverflowError, SocketError, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError, ClientDestroyedError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const buildConnector = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js");
        const { kUrl, kReset, kServerName, kClient, kBusy, kParser, kConnect, kBlocking, kResuming, kRunning, kPending, kSize, kWriting, kQueue, kConnected, kConnecting, kNeedDrain, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections, kMaxRequests, kCounter, kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress, kMaxResponseSize, kHTTPConnVersion, kHost, kHTTP2Session, kHTTP2SessionState, kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        let http2;
        try {
            http2 = __webpack_require__("http2");
        } catch  {
            http2 = {
                constants: {}
            };
        }
        const { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;
        let h2ExperimentalWarned = false;
        const FastBuffer = Buffer[Symbol.species];
        const kClosedResolve = Symbol('kClosedResolve');
        const channels = {};
        try {
            const diagnosticsChannel = __webpack_require__("diagnostics_channel");
            channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');
            channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');
            channels.connectError = diagnosticsChannel.channel('undici:client:connectError');
            channels.connected = diagnosticsChannel.channel('undici:client:connected');
        } catch  {
            channels.sendHeaders = {
                hasSubscribers: false
            };
            channels.beforeConnect = {
                hasSubscribers: false
            };
            channels.connectError = {
                hasSubscribers: false
            };
            channels.connected = {
                hasSubscribers: false
            };
        }
        class Client extends DispatcherBase {
            constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls, strictContentLength, maxCachedSessions, maxRedirections, connect, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, maxConcurrentStreams } = {}){
                super();
                if (void 0 !== keepAlive) throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');
                if (void 0 !== socketTimeout) throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');
                if (void 0 !== requestTimeout) throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');
                if (void 0 !== idleTimeout) throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');
                if (void 0 !== maxKeepAliveTimeout) throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');
                if (null != maxHeaderSize && !Number.isFinite(maxHeaderSize)) throw new InvalidArgumentError('invalid maxHeaderSize');
                if (null != socketPath && 'string' != typeof socketPath) throw new InvalidArgumentError('invalid socketPath');
                if (null != connectTimeout && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new InvalidArgumentError('invalid connectTimeout');
                if (null != keepAliveTimeout && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new InvalidArgumentError('invalid keepAliveTimeout');
                if (null != keepAliveMaxTimeout && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new InvalidArgumentError('invalid keepAliveMaxTimeout');
                if (null != keepAliveTimeoutThreshold && !Number.isFinite(keepAliveTimeoutThreshold)) throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');
                if (null != headersTimeout && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');
                if (null != bodyTimeout && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');
                if (null != connect && 'function' != typeof connect && 'object' != typeof connect) throw new InvalidArgumentError('connect must be a function or an object');
                if (null != maxRedirections && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError('maxRedirections must be a positive number');
                if (null != maxRequestsPerClient && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');
                if (null != localAddress && ('string' != typeof localAddress || 0 === net.isIP(localAddress))) throw new InvalidArgumentError('localAddress must be valid string IP address');
                if (null != maxResponseSize && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new InvalidArgumentError('maxResponseSize must be a positive number');
                if (null != autoSelectFamilyAttemptTimeout && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number');
                if (null != allowH2 && 'boolean' != typeof allowH2) throw new InvalidArgumentError('allowH2 must be a valid boolean value');
                if (null != maxConcurrentStreams && ('number' != typeof maxConcurrentStreams || maxConcurrentStreams < 1)) throw new InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0');
                if ('function' != typeof connect) connect = buildConnector({
                    ...tls,
                    maxCachedSessions,
                    allowH2,
                    socketPath,
                    timeout: connectTimeout,
                    ...util.nodeHasAutoSelectFamily && autoSelectFamily ? {
                        autoSelectFamily,
                        autoSelectFamilyAttemptTimeout
                    } : void 0,
                    ...connect
                });
                this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [
                    createRedirectInterceptor({
                        maxRedirections
                    })
                ];
                this[kUrl] = util.parseOrigin(url);
                this[kConnector] = connect;
                this[kSocket] = null;
                this[kPipelining] = null != pipelining ? pipelining : 1;
                this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
                this[kKeepAliveDefaultTimeout] = null == keepAliveTimeout ? 4e3 : keepAliveTimeout;
                this[kKeepAliveMaxTimeout] = null == keepAliveMaxTimeout ? 600e3 : keepAliveMaxTimeout;
                this[kKeepAliveTimeoutThreshold] = null == keepAliveTimeoutThreshold ? 1e3 : keepAliveTimeoutThreshold;
                this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
                this[kServerName] = null;
                this[kLocalAddress] = null != localAddress ? localAddress : null;
                this[kResuming] = 0;
                this[kNeedDrain] = 0;
                this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\r\n`;
                this[kBodyTimeout] = null != bodyTimeout ? bodyTimeout : 300e3;
                this[kHeadersTimeout] = null != headersTimeout ? headersTimeout : 300e3;
                this[kStrictContentLength] = null == strictContentLength ? true : strictContentLength;
                this[kMaxRedirections] = maxRedirections;
                this[kMaxRequests] = maxRequestsPerClient;
                this[kClosedResolve] = null;
                this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
                this[kHTTPConnVersion] = 'h1';
                this[kHTTP2Session] = null;
                this[kHTTP2SessionState] = allowH2 ? {
                    openStreams: 0,
                    maxConcurrentStreams: null != maxConcurrentStreams ? maxConcurrentStreams : 100
                } : null;
                this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`;
                this[kQueue] = [];
                this[kRunningIdx] = 0;
                this[kPendingIdx] = 0;
            }
            get pipelining() {
                return this[kPipelining];
            }
            set pipelining(value) {
                this[kPipelining] = value;
                resume(this, true);
            }
            get [kPending]() {
                return this[kQueue].length - this[kPendingIdx];
            }
            get [kRunning]() {
                return this[kPendingIdx] - this[kRunningIdx];
            }
            get [kSize]() {
                return this[kQueue].length - this[kRunningIdx];
            }
            get [kConnected]() {
                return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
            }
            get [kBusy]() {
                const socket = this[kSocket];
                return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
            }
            [kConnect](cb) {
                connect(this);
                this.once('connect', cb);
            }
            [kDispatch](opts, handler) {
                const origin = opts.origin || this[kUrl].origin;
                const request = 'h2' === this[kHTTPConnVersion] ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
                this[kQueue].push(request);
                if (this[kResuming]) ;
                else if (null == util.bodyLength(request.body) && util.isIterable(request.body)) {
                    this[kResuming] = 1;
                    process.nextTick(resume, this);
                } else resume(this, true);
                if (this[kResuming] && 2 !== this[kNeedDrain] && this[kBusy]) this[kNeedDrain] = 2;
                return this[kNeedDrain] < 2;
            }
            async [kClose]() {
                return new Promise((resolve)=>{
                    if (this[kSize]) this[kClosedResolve] = resolve;
                    else resolve(null);
                });
            }
            async [kDestroy](err) {
                return new Promise((resolve)=>{
                    const requests = this[kQueue].splice(this[kPendingIdx]);
                    for(let i = 0; i < requests.length; i++){
                        const request = requests[i];
                        errorRequest(this, request, err);
                    }
                    const callback = ()=>{
                        if (this[kClosedResolve]) {
                            this[kClosedResolve]();
                            this[kClosedResolve] = null;
                        }
                        resolve();
                    };
                    if (null != this[kHTTP2Session]) {
                        util.destroy(this[kHTTP2Session], err);
                        this[kHTTP2Session] = null;
                        this[kHTTP2SessionState] = null;
                    }
                    if (this[kSocket]) util.destroy(this[kSocket].on('close', callback), err);
                    else queueMicrotask(callback);
                    resume(this);
                });
            }
        }
        function onHttp2SessionError(err) {
            assert('ERR_TLS_CERT_ALTNAME_INVALID' !== err.code);
            this[kSocket][kError] = err;
            onError(this[kClient], err);
        }
        function onHttp2FrameError(type, code, id) {
            const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
            if (0 === id) {
                this[kSocket][kError] = err;
                onError(this[kClient], err);
            }
        }
        function onHttp2SessionEnd() {
            util.destroy(this, new SocketError('other side closed'));
            util.destroy(this[kSocket], new SocketError('other side closed'));
        }
        function onHTTP2GoAway(code) {
            const client = this[kClient];
            const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
            client[kSocket] = null;
            client[kHTTP2Session] = null;
            if (client.destroyed) {
                assert(0 === this[kPending]);
                const requests = client[kQueue].splice(client[kRunningIdx]);
                for(let i = 0; i < requests.length; i++){
                    const request = requests[i];
                    errorRequest(this, request, err);
                }
            } else if (client[kRunning] > 0) {
                const request = client[kQueue][client[kRunningIdx]];
                client[kQueue][client[kRunningIdx]++] = null;
                errorRequest(client, request, err);
            }
            client[kPendingIdx] = client[kRunningIdx];
            assert(0 === client[kRunning]);
            client.emit('disconnect', client[kUrl], [
                client
            ], err);
            resume(client);
        }
        const constants = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/constants.js");
        const createRedirectInterceptor = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/interceptor/redirectInterceptor.js");
        const EMPTY_BUF = Buffer.alloc(0);
        async function lazyllhttp() {
            const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp-wasm.js") : void 0;
            let mod;
            try {
                mod = await WebAssembly.compile(Buffer.from(__webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"), 'base64'));
            } catch (e) {
                mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp-wasm.js"), 'base64'));
            }
            return await WebAssembly.instantiate(mod, {
                env: {
                    wasm_on_url: (p, at, len)=>0,
                    wasm_on_status: (p, at, len)=>{
                        assert.strictEqual(currentParser.ptr, p);
                        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
                        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
                    },
                    wasm_on_message_begin: (p)=>{
                        assert.strictEqual(currentParser.ptr, p);
                        return currentParser.onMessageBegin() || 0;
                    },
                    wasm_on_header_field: (p, at, len)=>{
                        assert.strictEqual(currentParser.ptr, p);
                        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
                        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
                    },
                    wasm_on_header_value: (p, at, len)=>{
                        assert.strictEqual(currentParser.ptr, p);
                        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
                        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
                    },
                    wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive)=>{
                        assert.strictEqual(currentParser.ptr, p);
                        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
                    },
                    wasm_on_body: (p, at, len)=>{
                        assert.strictEqual(currentParser.ptr, p);
                        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
                        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
                    },
                    wasm_on_message_complete: (p)=>{
                        assert.strictEqual(currentParser.ptr, p);
                        return currentParser.onMessageComplete() || 0;
                    }
                }
            });
        }
        let llhttpInstance = null;
        let llhttpPromise = lazyllhttp();
        llhttpPromise.catch();
        let currentParser = null;
        let currentBufferRef = null;
        let currentBufferSize = 0;
        let currentBufferPtr = null;
        const TIMEOUT_HEADERS = 1;
        const TIMEOUT_BODY = 2;
        const TIMEOUT_IDLE = 3;
        class Parser {
            constructor(client, socket, { exports: exports1 }){
                assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
                this.llhttp = exports1;
                this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
                this.client = client;
                this.socket = socket;
                this.timeout = null;
                this.timeoutValue = null;
                this.timeoutType = null;
                this.statusCode = null;
                this.statusText = '';
                this.upgrade = false;
                this.headers = [];
                this.headersSize = 0;
                this.headersMaxSize = client[kMaxHeadersSize];
                this.shouldKeepAlive = false;
                this.paused = false;
                this.resume = this.resume.bind(this);
                this.bytesRead = 0;
                this.keepAlive = '';
                this.contentLength = '';
                this.connection = '';
                this.maxResponseSize = client[kMaxResponseSize];
            }
            setTimeout(value, type) {
                this.timeoutType = type;
                if (value !== this.timeoutValue) {
                    timers.clearTimeout(this.timeout);
                    if (value) {
                        this.timeout = timers.setTimeout(onParserTimeout, value, this);
                        if (this.timeout.unref) this.timeout.unref();
                    } else this.timeout = null;
                    this.timeoutValue = value;
                } else if (this.timeout) {
                    if (this.timeout.refresh) this.timeout.refresh();
                }
            }
            resume() {
                if (this.socket.destroyed || !this.paused) return;
                assert(null != this.ptr);
                assert(null == currentParser);
                this.llhttp.llhttp_resume(this.ptr);
                assert(this.timeoutType === TIMEOUT_BODY);
                if (this.timeout) {
                    if (this.timeout.refresh) this.timeout.refresh();
                }
                this.paused = false;
                this.execute(this.socket.read() || EMPTY_BUF);
                this.readMore();
            }
            readMore() {
                while(!this.paused && this.ptr){
                    const chunk = this.socket.read();
                    if (null === chunk) break;
                    this.execute(chunk);
                }
            }
            execute(data) {
                assert(null != this.ptr);
                assert(null == currentParser);
                assert(!this.paused);
                const { socket, llhttp } = this;
                if (data.length > currentBufferSize) {
                    if (currentBufferPtr) llhttp.free(currentBufferPtr);
                    currentBufferSize = 4096 * Math.ceil(data.length / 4096);
                    currentBufferPtr = llhttp.malloc(currentBufferSize);
                }
                new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
                try {
                    let ret;
                    try {
                        currentBufferRef = data;
                        currentParser = this;
                        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
                    } catch (err) {
                        throw err;
                    } finally{
                        currentParser = null;
                        currentBufferRef = null;
                    }
                    const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
                    if (ret === constants.ERROR.PAUSED_UPGRADE) this.onUpgrade(data.slice(offset));
                    else if (ret === constants.ERROR.PAUSED) {
                        this.paused = true;
                        socket.unshift(data.slice(offset));
                    } else if (ret !== constants.ERROR.OK) {
                        const ptr = llhttp.llhttp_get_error_reason(this.ptr);
                        let message = '';
                        if (ptr) {
                            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
                            message = 'Response does not match the HTTP/1.1 protocol (' + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ')';
                        }
                        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
                    }
                } catch (err) {
                    util.destroy(socket, err);
                }
            }
            destroy() {
                assert(null != this.ptr);
                assert(null == currentParser);
                this.llhttp.llhttp_free(this.ptr);
                this.ptr = null;
                timers.clearTimeout(this.timeout);
                this.timeout = null;
                this.timeoutValue = null;
                this.timeoutType = null;
                this.paused = false;
            }
            onStatus(buf) {
                this.statusText = buf.toString();
            }
            onMessageBegin() {
                const { socket, client } = this;
                if (socket.destroyed) return -1;
                const request = client[kQueue][client[kRunningIdx]];
                if (!request) return -1;
            }
            onHeaderField(buf) {
                const len = this.headers.length;
                if ((1 & len) === 0) this.headers.push(buf);
                else this.headers[len - 1] = Buffer.concat([
                    this.headers[len - 1],
                    buf
                ]);
                this.trackHeader(buf.length);
            }
            onHeaderValue(buf) {
                let len = this.headers.length;
                if ((1 & len) === 1) {
                    this.headers.push(buf);
                    len += 1;
                } else this.headers[len - 1] = Buffer.concat([
                    this.headers[len - 1],
                    buf
                ]);
                const key = this.headers[len - 2];
                if (10 === key.length && 'keep-alive' === key.toString().toLowerCase()) this.keepAlive += buf.toString();
                else if (10 === key.length && 'connection' === key.toString().toLowerCase()) this.connection += buf.toString();
                else if (14 === key.length && 'content-length' === key.toString().toLowerCase()) this.contentLength += buf.toString();
                this.trackHeader(buf.length);
            }
            trackHeader(len) {
                this.headersSize += len;
                if (this.headersSize >= this.headersMaxSize) util.destroy(this.socket, new HeadersOverflowError());
            }
            onUpgrade(head) {
                const { upgrade, client, socket, headers, statusCode } = this;
                assert(upgrade);
                const request = client[kQueue][client[kRunningIdx]];
                assert(request);
                assert(!socket.destroyed);
                assert(socket === client[kSocket]);
                assert(!this.paused);
                assert(request.upgrade || 'CONNECT' === request.method);
                this.statusCode = null;
                this.statusText = '';
                this.shouldKeepAlive = null;
                assert(this.headers.length % 2 === 0);
                this.headers = [];
                this.headersSize = 0;
                socket.unshift(head);
                socket[kParser].destroy();
                socket[kParser] = null;
                socket[kClient] = null;
                socket[kError] = null;
                socket.removeListener('error', onSocketError).removeListener('readable', onSocketReadable).removeListener('end', onSocketEnd).removeListener('close', onSocketClose);
                client[kSocket] = null;
                client[kQueue][client[kRunningIdx]++] = null;
                client.emit('disconnect', client[kUrl], [
                    client
                ], new InformationalError('upgrade'));
                try {
                    request.onUpgrade(statusCode, headers, socket);
                } catch (err) {
                    util.destroy(socket, err);
                }
                resume(client);
            }
            onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
                const { client, socket, headers, statusText } = this;
                if (socket.destroyed) return -1;
                const request = client[kQueue][client[kRunningIdx]];
                if (!request) return -1;
                assert(!this.upgrade);
                assert(this.statusCode < 200);
                if (100 === statusCode) {
                    util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));
                    return -1;
                }
                if (upgrade && !request.upgrade) {
                    util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));
                    return -1;
                }
                assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
                this.statusCode = statusCode;
                this.shouldKeepAlive = shouldKeepAlive || 'HEAD' === request.method && !socket[kReset] && 'keep-alive' === this.connection.toLowerCase();
                if (this.statusCode >= 200) {
                    const bodyTimeout = null != request.bodyTimeout ? request.bodyTimeout : client[kBodyTimeout];
                    this.setTimeout(bodyTimeout, TIMEOUT_BODY);
                } else if (this.timeout) {
                    if (this.timeout.refresh) this.timeout.refresh();
                }
                if ('CONNECT' === request.method) {
                    assert(1 === client[kRunning]);
                    this.upgrade = true;
                    return 2;
                }
                if (upgrade) {
                    assert(1 === client[kRunning]);
                    this.upgrade = true;
                    return 2;
                }
                assert(this.headers.length % 2 === 0);
                this.headers = [];
                this.headersSize = 0;
                if (this.shouldKeepAlive && client[kPipelining]) {
                    const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
                    if (null != keepAliveTimeout) {
                        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
                        if (timeout <= 0) socket[kReset] = true;
                        else client[kKeepAliveTimeoutValue] = timeout;
                    } else client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
                } else socket[kReset] = true;
                const pause = false === request.onHeaders(statusCode, headers, this.resume, statusText);
                if (request.aborted) return -1;
                if ('HEAD' === request.method) return 1;
                if (statusCode < 200) return 1;
                if (socket[kBlocking]) {
                    socket[kBlocking] = false;
                    resume(client);
                }
                return pause ? constants.ERROR.PAUSED : 0;
            }
            onBody(buf) {
                const { client, socket, statusCode, maxResponseSize } = this;
                if (socket.destroyed) return -1;
                const request = client[kQueue][client[kRunningIdx]];
                assert(request);
                assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
                if (this.timeout) {
                    if (this.timeout.refresh) this.timeout.refresh();
                }
                assert(statusCode >= 200);
                if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
                    util.destroy(socket, new ResponseExceededMaxSizeError());
                    return -1;
                }
                this.bytesRead += buf.length;
                if (false === request.onData(buf)) return constants.ERROR.PAUSED;
            }
            onMessageComplete() {
                const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
                if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;
                if (upgrade) return;
                const request = client[kQueue][client[kRunningIdx]];
                assert(request);
                assert(statusCode >= 100);
                this.statusCode = null;
                this.statusText = '';
                this.bytesRead = 0;
                this.contentLength = '';
                this.keepAlive = '';
                this.connection = '';
                assert(this.headers.length % 2 === 0);
                this.headers = [];
                this.headersSize = 0;
                if (statusCode < 200) return;
                if ('HEAD' !== request.method && contentLength && bytesRead !== parseInt(contentLength, 10)) {
                    util.destroy(socket, new ResponseContentLengthMismatchError());
                    return -1;
                }
                request.onComplete(headers);
                client[kQueue][client[kRunningIdx]++] = null;
                if (socket[kWriting]) {
                    assert.strictEqual(client[kRunning], 0);
                    util.destroy(socket, new InformationalError('reset'));
                    return constants.ERROR.PAUSED;
                }
                if (shouldKeepAlive) if (socket[kReset] && 0 === client[kRunning]) {
                    util.destroy(socket, new InformationalError('reset'));
                    return constants.ERROR.PAUSED;
                } else if (1 === client[kPipelining]) setImmediate(resume, client);
                else resume(client);
                else {
                    util.destroy(socket, new InformationalError('reset'));
                    return constants.ERROR.PAUSED;
                }
            }
        }
        function onParserTimeout(parser) {
            const { socket, timeoutType, client } = parser;
            if (timeoutType === TIMEOUT_HEADERS) {
                if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
                    assert(!parser.paused, 'cannot be paused while waiting for headers');
                    util.destroy(socket, new HeadersTimeoutError());
                }
            } else if (timeoutType === TIMEOUT_BODY) {
                if (!parser.paused) util.destroy(socket, new BodyTimeoutError());
            } else if (timeoutType === TIMEOUT_IDLE) {
                assert(0 === client[kRunning] && client[kKeepAliveTimeoutValue]);
                util.destroy(socket, new InformationalError('socket idle timeout'));
            }
        }
        function onSocketReadable() {
            const { [kParser]: parser } = this;
            if (parser) parser.readMore();
        }
        function onSocketError(err) {
            const { [kClient]: client, [kParser]: parser } = this;
            assert('ERR_TLS_CERT_ALTNAME_INVALID' !== err.code);
            if ('h2' !== client[kHTTPConnVersion]) {
                if ('ECONNRESET' === err.code && parser.statusCode && !parser.shouldKeepAlive) return void parser.onMessageComplete();
            }
            this[kError] = err;
            onError(this[kClient], err);
        }
        function onError(client, err) {
            if (0 === client[kRunning] && 'UND_ERR_INFO' !== err.code && 'UND_ERR_SOCKET' !== err.code) {
                assert(client[kPendingIdx] === client[kRunningIdx]);
                const requests = client[kQueue].splice(client[kRunningIdx]);
                for(let i = 0; i < requests.length; i++){
                    const request = requests[i];
                    errorRequest(client, request, err);
                }
                assert(0 === client[kSize]);
            }
        }
        function onSocketEnd() {
            const { [kParser]: parser, [kClient]: client } = this;
            if ('h2' !== client[kHTTPConnVersion]) {
                if (parser.statusCode && !parser.shouldKeepAlive) return void parser.onMessageComplete();
            }
            util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));
        }
        function onSocketClose() {
            const { [kClient]: client, [kParser]: parser } = this;
            if ('h1' === client[kHTTPConnVersion] && parser) {
                if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) parser.onMessageComplete();
                this[kParser].destroy();
                this[kParser] = null;
            }
            const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));
            client[kSocket] = null;
            if (client.destroyed) {
                assert(0 === client[kPending]);
                const requests = client[kQueue].splice(client[kRunningIdx]);
                for(let i = 0; i < requests.length; i++){
                    const request = requests[i];
                    errorRequest(client, request, err);
                }
            } else if (client[kRunning] > 0 && 'UND_ERR_INFO' !== err.code) {
                const request = client[kQueue][client[kRunningIdx]];
                client[kQueue][client[kRunningIdx]++] = null;
                errorRequest(client, request, err);
            }
            client[kPendingIdx] = client[kRunningIdx];
            assert(0 === client[kRunning]);
            client.emit('disconnect', client[kUrl], [
                client
            ], err);
            resume(client);
        }
        async function connect(client) {
            assert(!client[kConnecting]);
            assert(!client[kSocket]);
            let { host, hostname, protocol, port } = client[kUrl];
            if ('[' === hostname[0]) {
                const idx = hostname.indexOf(']');
                assert(-1 !== idx);
                const ip = hostname.substring(1, idx);
                assert(net.isIP(ip));
                hostname = ip;
            }
            client[kConnecting] = true;
            if (channels.beforeConnect.hasSubscribers) channels.beforeConnect.publish({
                connectParams: {
                    host,
                    hostname,
                    protocol,
                    port,
                    servername: client[kServerName],
                    localAddress: client[kLocalAddress]
                },
                connector: client[kConnector]
            });
            try {
                const socket = await new Promise((resolve, reject)=>{
                    client[kConnector]({
                        host,
                        hostname,
                        protocol,
                        port,
                        servername: client[kServerName],
                        localAddress: client[kLocalAddress]
                    }, (err, socket)=>{
                        if (err) reject(err);
                        else resolve(socket);
                    });
                });
                if (client.destroyed) return void util.destroy(socket.on('error', ()=>{}), new ClientDestroyedError());
                client[kConnecting] = false;
                assert(socket);
                const isH2 = 'h2' === socket.alpnProtocol;
                if (isH2) {
                    if (!h2ExperimentalWarned) {
                        h2ExperimentalWarned = true;
                        process.emitWarning('H2 support is experimental, expect them to change at any time.', {
                            code: 'UNDICI-H2'
                        });
                    }
                    const session = http2.connect(client[kUrl], {
                        createConnection: ()=>socket,
                        peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
                    });
                    client[kHTTPConnVersion] = 'h2';
                    session[kClient] = client;
                    session[kSocket] = socket;
                    session.on('error', onHttp2SessionError);
                    session.on('frameError', onHttp2FrameError);
                    session.on('end', onHttp2SessionEnd);
                    session.on('goaway', onHTTP2GoAway);
                    session.on('close', onSocketClose);
                    session.unref();
                    client[kHTTP2Session] = session;
                    socket[kHTTP2Session] = session;
                } else {
                    if (!llhttpInstance) {
                        llhttpInstance = await llhttpPromise;
                        llhttpPromise = null;
                    }
                    socket[kNoRef] = false;
                    socket[kWriting] = false;
                    socket[kReset] = false;
                    socket[kBlocking] = false;
                    socket[kParser] = new Parser(client, socket, llhttpInstance);
                }
                socket[kCounter] = 0;
                socket[kMaxRequests] = client[kMaxRequests];
                socket[kClient] = client;
                socket[kError] = null;
                socket.on('error', onSocketError).on('readable', onSocketReadable).on('end', onSocketEnd).on('close', onSocketClose);
                client[kSocket] = socket;
                if (channels.connected.hasSubscribers) channels.connected.publish({
                    connectParams: {
                        host,
                        hostname,
                        protocol,
                        port,
                        servername: client[kServerName],
                        localAddress: client[kLocalAddress]
                    },
                    connector: client[kConnector],
                    socket
                });
                client.emit('connect', client[kUrl], [
                    client
                ]);
            } catch (err) {
                if (client.destroyed) return;
                client[kConnecting] = false;
                if (channels.connectError.hasSubscribers) channels.connectError.publish({
                    connectParams: {
                        host,
                        hostname,
                        protocol,
                        port,
                        servername: client[kServerName],
                        localAddress: client[kLocalAddress]
                    },
                    connector: client[kConnector],
                    error: err
                });
                if ('ERR_TLS_CERT_ALTNAME_INVALID' === err.code) {
                    assert(0 === client[kRunning]);
                    while(client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]){
                        const request = client[kQueue][client[kPendingIdx]++];
                        errorRequest(client, request, err);
                    }
                } else onError(client, err);
                client.emit('connectionError', client[kUrl], [
                    client
                ], err);
            }
            resume(client);
        }
        function emitDrain(client) {
            client[kNeedDrain] = 0;
            client.emit('drain', client[kUrl], [
                client
            ]);
        }
        function resume(client, sync) {
            if (2 === client[kResuming]) return;
            client[kResuming] = 2;
            _resume(client, sync);
            client[kResuming] = 0;
            if (client[kRunningIdx] > 256) {
                client[kQueue].splice(0, client[kRunningIdx]);
                client[kPendingIdx] -= client[kRunningIdx];
                client[kRunningIdx] = 0;
            }
        }
        function _resume(client, sync) {
            while(true){
                if (client.destroyed) return void assert(0 === client[kPending]);
                if (client[kClosedResolve] && !client[kSize]) {
                    client[kClosedResolve]();
                    client[kClosedResolve] = null;
                    return;
                }
                const socket = client[kSocket];
                if (socket && !socket.destroyed && 'h2' !== socket.alpnProtocol) {
                    if (0 === client[kSize]) {
                        if (!socket[kNoRef] && socket.unref) {
                            socket.unref();
                            socket[kNoRef] = true;
                        }
                    } else if (socket[kNoRef] && socket.ref) {
                        socket.ref();
                        socket[kNoRef] = false;
                    }
                    if (0 === client[kSize]) {
                        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
                    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
                        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
                            const request = client[kQueue][client[kRunningIdx]];
                            const headersTimeout = null != request.headersTimeout ? request.headersTimeout : client[kHeadersTimeout];
                            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
                        }
                    }
                }
                if (client[kBusy]) client[kNeedDrain] = 2;
                else if (2 === client[kNeedDrain]) {
                    if (sync) {
                        client[kNeedDrain] = 1;
                        process.nextTick(emitDrain, client);
                    } else emitDrain(client);
                    continue;
                }
                if (0 === client[kPending]) return;
                if (client[kRunning] >= (client[kPipelining] || 1)) return;
                const request = client[kQueue][client[kPendingIdx]];
                if ('https:' === client[kUrl].protocol && client[kServerName] !== request.servername) {
                    if (client[kRunning] > 0) return;
                    client[kServerName] = request.servername;
                    if (socket && socket.servername !== request.servername) return void util.destroy(socket, new InformationalError('servername changed'));
                }
                if (client[kConnecting]) return;
                if (!socket && !client[kHTTP2Session]) return void connect(client);
                if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) return;
                if (client[kRunning] > 0 && !request.idempotent) return;
                if (client[kRunning] > 0 && (request.upgrade || 'CONNECT' === request.method)) return;
                if (client[kRunning] > 0 && 0 !== util.bodyLength(request.body) && (util.isStream(request.body) || util.isAsyncIterable(request.body))) return;
                if (!request.aborted && write(client, request)) client[kPendingIdx]++;
                else client[kQueue].splice(client[kPendingIdx], 1);
            }
        }
        function shouldSendContentLength(method) {
            return 'GET' !== method && 'HEAD' !== method && 'OPTIONS' !== method && 'TRACE' !== method && 'CONNECT' !== method;
        }
        function write(client, request) {
            if ('h2' === client[kHTTPConnVersion]) return void writeH2(client, client[kHTTP2Session], request);
            const { body, method, path, host, upgrade, headers, blocking, reset } = request;
            const expectsPayload = 'PUT' === method || 'POST' === method || 'PATCH' === method;
            if (body && 'function' == typeof body.read) body.read(0);
            const bodyLength = util.bodyLength(body);
            let contentLength = bodyLength;
            if (null === contentLength) contentLength = request.contentLength;
            if (0 === contentLength && !expectsPayload) contentLength = null;
            if (shouldSendContentLength(method) && contentLength > 0 && null !== request.contentLength && request.contentLength !== contentLength) {
                if (client[kStrictContentLength]) {
                    errorRequest(client, request, new RequestContentLengthMismatchError());
                    return false;
                }
                process.emitWarning(new RequestContentLengthMismatchError());
            }
            const socket = client[kSocket];
            try {
                request.onConnect((err)=>{
                    if (request.aborted || request.completed) return;
                    errorRequest(client, request, err || new RequestAbortedError());
                    util.destroy(socket, new InformationalError('aborted'));
                });
            } catch (err) {
                errorRequest(client, request, err);
            }
            if (request.aborted) return false;
            if ('HEAD' === method) socket[kReset] = true;
            if (upgrade || 'CONNECT' === method) socket[kReset] = true;
            if (null != reset) socket[kReset] = reset;
            if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) socket[kReset] = true;
            if (blocking) socket[kBlocking] = true;
            let header = `${method} ${path} HTTP/1.1\r\n`;
            if ('string' == typeof host) header += `host: ${host}\r\n`;
            else header += client[kHostHeader];
            if (upgrade) header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
            else if (client[kPipelining] && !socket[kReset]) header += 'connection: keep-alive\r\n';
            else header += 'connection: close\r\n';
            if (headers) header += headers;
            if (channels.sendHeaders.hasSubscribers) channels.sendHeaders.publish({
                request,
                headers: header,
                socket
            });
            if (body && 0 !== bodyLength) if (util.isBuffer(body)) {
                assert(contentLength === body.byteLength, 'buffer body must have content length');
                socket.cork();
                socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
                socket.write(body);
                socket.uncork();
                request.onBodySent(body);
                request.onRequestSent();
                if (!expectsPayload) socket[kReset] = true;
            } else if (util.isBlobLike(body)) if ('function' == typeof body.stream) writeIterable({
                body: body.stream(),
                client,
                request,
                socket,
                contentLength,
                header,
                expectsPayload
            });
            else writeBlob({
                body,
                client,
                request,
                socket,
                contentLength,
                header,
                expectsPayload
            });
            else if (util.isStream(body)) writeStream({
                body,
                client,
                request,
                socket,
                contentLength,
                header,
                expectsPayload
            });
            else if (util.isIterable(body)) writeIterable({
                body,
                client,
                request,
                socket,
                contentLength,
                header,
                expectsPayload
            });
            else assert(false);
            else {
                if (0 === contentLength) socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
                else {
                    assert(null === contentLength, 'no body must not have content length');
                    socket.write(`${header}\r\n`, 'latin1');
                }
                request.onRequestSent();
            }
            return true;
        }
        function writeH2(client, session, request) {
            const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
            let headers;
            headers = 'string' == typeof reqHeaders ? Request[kHTTP2CopyHeaders](reqHeaders.trim()) : reqHeaders;
            if (upgrade) {
                errorRequest(client, request, new Error('Upgrade not supported for H2'));
                return false;
            }
            try {
                request.onConnect((err)=>{
                    if (request.aborted || request.completed) return;
                    errorRequest(client, request, err || new RequestAbortedError());
                });
            } catch (err) {
                errorRequest(client, request, err);
            }
            if (request.aborted) return false;
            let stream;
            const h2State = client[kHTTP2SessionState];
            headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
            headers[HTTP2_HEADER_METHOD] = method;
            if ('CONNECT' === method) {
                session.ref();
                stream = session.request(headers, {
                    endStream: false,
                    signal
                });
                if (stream.id && !stream.pending) {
                    request.onUpgrade(null, null, stream);
                    ++h2State.openStreams;
                } else stream.once('ready', ()=>{
                    request.onUpgrade(null, null, stream);
                    ++h2State.openStreams;
                });
                stream.once('close', ()=>{
                    h2State.openStreams -= 1;
                    if (0 === h2State.openStreams) session.unref();
                });
                return true;
            }
            headers[HTTP2_HEADER_PATH] = path;
            headers[HTTP2_HEADER_SCHEME] = 'https';
            const expectsPayload = 'PUT' === method || 'POST' === method || 'PATCH' === method;
            if (body && 'function' == typeof body.read) body.read(0);
            let contentLength = util.bodyLength(body);
            if (null == contentLength) contentLength = request.contentLength;
            if (0 === contentLength || !expectsPayload) contentLength = null;
            if (shouldSendContentLength(method) && contentLength > 0 && null != request.contentLength && request.contentLength !== contentLength) {
                if (client[kStrictContentLength]) {
                    errorRequest(client, request, new RequestContentLengthMismatchError());
                    return false;
                }
                process.emitWarning(new RequestContentLengthMismatchError());
            }
            if (null != contentLength) {
                assert(body, 'no body must not have content length');
                headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
            }
            session.ref();
            const shouldEndStream = 'GET' === method || 'HEAD' === method;
            if (expectContinue) {
                headers[HTTP2_HEADER_EXPECT] = '100-continue';
                stream = session.request(headers, {
                    endStream: shouldEndStream,
                    signal
                });
                stream.once('continue', writeBodyH2);
            } else {
                stream = session.request(headers, {
                    endStream: shouldEndStream,
                    signal
                });
                writeBodyH2();
            }
            ++h2State.openStreams;
            stream.once('response', (headers)=>{
                const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;
                if (false === request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), '')) stream.pause();
            });
            stream.once('end', ()=>{
                request.onComplete([]);
            });
            stream.on('data', (chunk)=>{
                if (false === request.onData(chunk)) stream.pause();
            });
            stream.once('close', ()=>{
                h2State.openStreams -= 1;
                if (0 === h2State.openStreams) session.unref();
            });
            stream.once('error', function(err) {
                if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
                    h2State.streams -= 1;
                    util.destroy(stream, err);
                }
            });
            stream.once('frameError', (type, code)=>{
                const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
                errorRequest(client, request, err);
                if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
                    h2State.streams -= 1;
                    util.destroy(stream, err);
                }
            });
            return true;
            function writeBodyH2() {
                if (body) if (util.isBuffer(body)) {
                    assert(contentLength === body.byteLength, 'buffer body must have content length');
                    stream.cork();
                    stream.write(body);
                    stream.uncork();
                    stream.end();
                    request.onBodySent(body);
                    request.onRequestSent();
                } else if (util.isBlobLike(body)) if ('function' == typeof body.stream) writeIterable({
                    client,
                    request,
                    contentLength,
                    h2stream: stream,
                    expectsPayload,
                    body: body.stream(),
                    socket: client[kSocket],
                    header: ''
                });
                else writeBlob({
                    body,
                    client,
                    request,
                    contentLength,
                    expectsPayload,
                    h2stream: stream,
                    header: '',
                    socket: client[kSocket]
                });
                else if (util.isStream(body)) writeStream({
                    body,
                    client,
                    request,
                    contentLength,
                    expectsPayload,
                    socket: client[kSocket],
                    h2stream: stream,
                    header: ''
                });
                else if (util.isIterable(body)) writeIterable({
                    body,
                    client,
                    request,
                    contentLength,
                    expectsPayload,
                    header: '',
                    h2stream: stream,
                    socket: client[kSocket]
                });
                else assert(false);
                else request.onRequestSent();
            }
        }
        function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
            assert(0 !== contentLength || 0 === client[kRunning], 'stream body cannot be pipelined');
            if ('h2' === client[kHTTPConnVersion]) {
                const pipe = pipeline(body, h2stream, (err)=>{
                    if (err) {
                        util.destroy(body, err);
                        util.destroy(h2stream, err);
                    } else request.onRequestSent();
                });
                pipe.on('data', onPipeData);
                pipe.once('end', ()=>{
                    pipe.removeListener('data', onPipeData);
                    util.destroy(pipe);
                });
                function onPipeData(chunk) {
                    request.onBodySent(chunk);
                }
                return;
            }
            let finished = false;
            const writer = new AsyncWriter({
                socket,
                request,
                contentLength,
                client,
                expectsPayload,
                header
            });
            const onData = function(chunk) {
                if (finished) return;
                try {
                    if (!writer.write(chunk) && this.pause) this.pause();
                } catch (err) {
                    util.destroy(this, err);
                }
            };
            const onDrain = function() {
                if (finished) return;
                if (body.resume) body.resume();
            };
            const onAbort = function() {
                if (finished) return;
                const err = new RequestAbortedError();
                queueMicrotask(()=>onFinished(err));
            };
            const onFinished = function(err) {
                if (finished) return;
                finished = true;
                assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
                socket.off('drain', onDrain).off('error', onFinished);
                body.removeListener('data', onData).removeListener('end', onFinished).removeListener('error', onFinished).removeListener('close', onAbort);
                if (!err) try {
                    writer.end();
                } catch (er) {
                    err = er;
                }
                writer.destroy(err);
                if (err && ('UND_ERR_INFO' !== err.code || 'reset' !== err.message)) util.destroy(body, err);
                else util.destroy(body);
            };
            body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);
            if (body.resume) body.resume();
            socket.on('drain', onDrain).on('error', onFinished);
        }
        async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
            assert(contentLength === body.size, 'blob body must have content length');
            const isH2 = 'h2' === client[kHTTPConnVersion];
            try {
                if (null != contentLength && contentLength !== body.size) throw new RequestContentLengthMismatchError();
                const buffer = Buffer.from(await body.arrayBuffer());
                if (isH2) {
                    h2stream.cork();
                    h2stream.write(buffer);
                    h2stream.uncork();
                } else {
                    socket.cork();
                    socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
                    socket.write(buffer);
                    socket.uncork();
                }
                request.onBodySent(buffer);
                request.onRequestSent();
                if (!expectsPayload) socket[kReset] = true;
                resume(client);
            } catch (err) {
                util.destroy(isH2 ? h2stream : socket, err);
            }
        }
        async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
            assert(0 !== contentLength || 0 === client[kRunning], 'iterator body cannot be pipelined');
            let callback = null;
            function onDrain() {
                if (callback) {
                    const cb = callback;
                    callback = null;
                    cb();
                }
            }
            const waitForDrain = ()=>new Promise((resolve, reject)=>{
                    assert(null === callback);
                    if (socket[kError]) reject(socket[kError]);
                    else callback = resolve;
                });
            if ('h2' === client[kHTTPConnVersion]) {
                h2stream.on('close', onDrain).on('drain', onDrain);
                try {
                    for await (const chunk of body){
                        if (socket[kError]) throw socket[kError];
                        const res = h2stream.write(chunk);
                        request.onBodySent(chunk);
                        if (!res) await waitForDrain();
                    }
                } catch (err) {
                    h2stream.destroy(err);
                } finally{
                    request.onRequestSent();
                    h2stream.end();
                    h2stream.off('close', onDrain).off('drain', onDrain);
                }
                return;
            }
            socket.on('close', onDrain).on('drain', onDrain);
            const writer = new AsyncWriter({
                socket,
                request,
                contentLength,
                client,
                expectsPayload,
                header
            });
            try {
                for await (const chunk of body){
                    if (socket[kError]) throw socket[kError];
                    if (!writer.write(chunk)) await waitForDrain();
                }
                writer.end();
            } catch (err) {
                writer.destroy(err);
            } finally{
                socket.off('close', onDrain).off('drain', onDrain);
            }
        }
        class AsyncWriter {
            constructor({ socket, request, contentLength, client, expectsPayload, header }){
                this.socket = socket;
                this.request = request;
                this.contentLength = contentLength;
                this.client = client;
                this.bytesWritten = 0;
                this.expectsPayload = expectsPayload;
                this.header = header;
                socket[kWriting] = true;
            }
            write(chunk) {
                const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
                if (socket[kError]) throw socket[kError];
                if (socket.destroyed) return false;
                const len = Buffer.byteLength(chunk);
                if (!len) return true;
                if (null !== contentLength && bytesWritten + len > contentLength) {
                    if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
                    process.emitWarning(new RequestContentLengthMismatchError());
                }
                socket.cork();
                if (0 === bytesWritten) {
                    if (!expectsPayload) socket[kReset] = true;
                    if (null === contentLength) socket.write(`${header}transfer-encoding: chunked\r\n`, 'latin1');
                    else socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
                }
                if (null === contentLength) socket.write(`\r\n${len.toString(16)}\r\n`, 'latin1');
                this.bytesWritten += len;
                const ret = socket.write(chunk);
                socket.uncork();
                request.onBodySent(chunk);
                if (!ret) {
                    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
                        if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
                    }
                }
                return ret;
            }
            end() {
                const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
                request.onRequestSent();
                socket[kWriting] = false;
                if (socket[kError]) throw socket[kError];
                if (socket.destroyed) return;
                if (0 === bytesWritten) if (expectsPayload) socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
                else socket.write(`${header}\r\n`, 'latin1');
                else if (null === contentLength) socket.write('\r\n0\r\n\r\n', 'latin1');
                if (null !== contentLength && bytesWritten !== contentLength) if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
                else process.emitWarning(new RequestContentLengthMismatchError());
                if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
                    if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
                }
                resume(client);
            }
            destroy(err) {
                const { socket, client } = this;
                socket[kWriting] = false;
                if (err) {
                    assert(client[kRunning] <= 1, 'pipeline should only contain this request');
                    util.destroy(socket, err);
                }
            }
        }
        function errorRequest(client, request, err) {
            try {
                request.onError(err);
                assert(request.aborted);
            } catch (err) {
                client.emit('error', err);
            }
        }
        module.exports = Client;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/compat/dispatcher-weakref.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kConnected, kSize } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        class CompatWeakRef {
            constructor(value){
                this.value = value;
            }
            deref() {
                return 0 === this.value[kConnected] && 0 === this.value[kSize] ? void 0 : this.value;
            }
        }
        class CompatFinalizer {
            constructor(finalizer){
                this.finalizer = finalizer;
            }
            register(dispatcher, key) {
                if (dispatcher.on) dispatcher.on('disconnect', ()=>{
                    if (0 === dispatcher[kConnected] && 0 === dispatcher[kSize]) this.finalizer(key);
                });
            }
        }
        module.exports = function() {
            if (process.env.NODE_V8_COVERAGE) return {
                WeakRef: CompatWeakRef,
                FinalizationRegistry: CompatFinalizer
            };
            return {
                WeakRef: global.WeakRef || CompatWeakRef,
                FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
            };
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/constants.js" (module) {
        "use strict";
        const maxAttributeValueSize = 1024;
        const maxNameValuePairSize = 4096;
        module.exports = {
            maxAttributeValueSize,
            maxNameValuePairSize
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { parseSetCookie } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/parse.js");
        const { stringify } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/util.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { Headers } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js");
        function getCookies(headers) {
            webidl.argumentLengthCheck(arguments, 1, {
                header: 'getCookies'
            });
            webidl.brandCheck(headers, Headers, {
                strict: false
            });
            const cookie = headers.get('cookie');
            const out = {};
            if (!cookie) return out;
            for (const piece of cookie.split(';')){
                const [name, ...value] = piece.split('=');
                out[name.trim()] = value.join('=');
            }
            return out;
        }
        function deleteCookie(headers, name, attributes) {
            webidl.argumentLengthCheck(arguments, 2, {
                header: 'deleteCookie'
            });
            webidl.brandCheck(headers, Headers, {
                strict: false
            });
            name = webidl.converters.DOMString(name);
            attributes = webidl.converters.DeleteCookieAttributes(attributes);
            setCookie(headers, {
                name,
                value: '',
                expires: new Date(0),
                ...attributes
            });
        }
        function getSetCookies(headers) {
            webidl.argumentLengthCheck(arguments, 1, {
                header: 'getSetCookies'
            });
            webidl.brandCheck(headers, Headers, {
                strict: false
            });
            const cookies = headers.getSetCookie();
            if (!cookies) return [];
            return cookies.map((pair)=>parseSetCookie(pair));
        }
        function setCookie(headers, cookie) {
            webidl.argumentLengthCheck(arguments, 2, {
                header: 'setCookie'
            });
            webidl.brandCheck(headers, Headers, {
                strict: false
            });
            cookie = webidl.converters.Cookie(cookie);
            const str = stringify(cookie);
            if (str) headers.append('Set-Cookie', stringify(cookie));
        }
        webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
            {
                converter: webidl.nullableConverter(webidl.converters.DOMString),
                key: 'path',
                defaultValue: null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.DOMString),
                key: 'domain',
                defaultValue: null
            }
        ]);
        webidl.converters.Cookie = webidl.dictionaryConverter([
            {
                converter: webidl.converters.DOMString,
                key: 'name'
            },
            {
                converter: webidl.converters.DOMString,
                key: 'value'
            },
            {
                converter: webidl.nullableConverter((value)=>{
                    if ('number' == typeof value) return webidl.converters['unsigned long long'](value);
                    return new Date(value);
                }),
                key: 'expires',
                defaultValue: null
            },
            {
                converter: webidl.nullableConverter(webidl.converters['long long']),
                key: 'maxAge',
                defaultValue: null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.DOMString),
                key: 'domain',
                defaultValue: null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.DOMString),
                key: 'path',
                defaultValue: null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.boolean),
                key: 'secure',
                defaultValue: null
            },
            {
                converter: webidl.nullableConverter(webidl.converters.boolean),
                key: 'httpOnly',
                defaultValue: null
            },
            {
                converter: webidl.converters.USVString,
                key: 'sameSite',
                allowedValues: [
                    'Strict',
                    'Lax',
                    'None'
                ]
            },
            {
                converter: webidl.sequenceConverter(webidl.converters.DOMString),
                key: 'unparsed',
                defaultValue: []
            }
        ]);
        module.exports = {
            getCookies,
            deleteCookie,
            getSetCookies,
            setCookie
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/parse.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/constants.js");
        const { isCTLExcludingHtab } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/util.js");
        const { collectASequenceOfCodePointsFast } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
        const assert = __webpack_require__("assert");
        function parseSetCookie(header) {
            if (isCTLExcludingHtab(header)) return null;
            let nameValuePair = '';
            let unparsedAttributes = '';
            let name = '';
            let value = '';
            if (header.includes(';')) {
                const position = {
                    position: 0
                };
                nameValuePair = collectASequenceOfCodePointsFast(';', header, position);
                unparsedAttributes = header.slice(position.position);
            } else nameValuePair = header;
            if (nameValuePair.includes('=')) {
                const position = {
                    position: 0
                };
                name = collectASequenceOfCodePointsFast('=', nameValuePair, position);
                value = nameValuePair.slice(position.position + 1);
            } else value = nameValuePair;
            name = name.trim();
            value = value.trim();
            if (name.length + value.length > maxNameValuePairSize) return null;
            return {
                name,
                value,
                ...parseUnparsedAttributes(unparsedAttributes)
            };
        }
        function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
            if (0 === unparsedAttributes.length) return cookieAttributeList;
            assert(';' === unparsedAttributes[0]);
            unparsedAttributes = unparsedAttributes.slice(1);
            let cookieAv = '';
            if (unparsedAttributes.includes(';')) {
                cookieAv = collectASequenceOfCodePointsFast(';', unparsedAttributes, {
                    position: 0
                });
                unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
            } else {
                cookieAv = unparsedAttributes;
                unparsedAttributes = '';
            }
            let attributeName = '';
            let attributeValue = '';
            if (cookieAv.includes('=')) {
                const position = {
                    position: 0
                };
                attributeName = collectASequenceOfCodePointsFast('=', cookieAv, position);
                attributeValue = cookieAv.slice(position.position + 1);
            } else attributeName = cookieAv;
            attributeName = attributeName.trim();
            attributeValue = attributeValue.trim();
            if (attributeValue.length > maxAttributeValueSize) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
            const attributeNameLowercase = attributeName.toLowerCase();
            if ('expires' === attributeNameLowercase) {
                const expiryTime = new Date(attributeValue);
                cookieAttributeList.expires = expiryTime;
            } else if ('max-age' === attributeNameLowercase) {
                const charCode = attributeValue.charCodeAt(0);
                if ((charCode < 48 || charCode > 57) && '-' !== attributeValue[0]) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
                if (!/^\d+$/.test(attributeValue)) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
                const deltaSeconds = Number(attributeValue);
                cookieAttributeList.maxAge = deltaSeconds;
            } else if ('domain' === attributeNameLowercase) {
                let cookieDomain = attributeValue;
                if ('.' === cookieDomain[0]) cookieDomain = cookieDomain.slice(1);
                cookieDomain = cookieDomain.toLowerCase();
                cookieAttributeList.domain = cookieDomain;
            } else if ('path' === attributeNameLowercase) {
                let cookiePath = '';
                cookiePath = 0 === attributeValue.length || '/' !== attributeValue[0] ? '/' : attributeValue;
                cookieAttributeList.path = cookiePath;
            } else if ('secure' === attributeNameLowercase) cookieAttributeList.secure = true;
            else if ('httponly' === attributeNameLowercase) cookieAttributeList.httpOnly = true;
            else if ('samesite' === attributeNameLowercase) {
                let enforcement = 'Default';
                const attributeValueLowercase = attributeValue.toLowerCase();
                if (attributeValueLowercase.includes('none')) enforcement = 'None';
                if (attributeValueLowercase.includes('strict')) enforcement = 'Strict';
                if (attributeValueLowercase.includes('lax')) enforcement = 'Lax';
                cookieAttributeList.sameSite = enforcement;
            } else {
                cookieAttributeList.unparsed ??= [];
                cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
            }
            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        module.exports = {
            parseSetCookie,
            parseUnparsedAttributes
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/util.js" (module) {
        "use strict";
        function isCTLExcludingHtab(value) {
            if (0 === value.length) return false;
            for (const char of value){
                const code = char.charCodeAt(0);
                if (code >= 0x00 || code <= 0x08 || code >= 0x0A || code <= 0x1F || 0x7F === code) return false;
            }
        }
        function validateCookieName(name) {
            for (const char of name){
                const code = char.charCodeAt(0);
                if (code <= 0x20 || code > 0x7F || '(' === char || ')' === char || '>' === char || '<' === char || '@' === char || ',' === char || ';' === char || ':' === char || '\\' === char || '"' === char || '/' === char || '[' === char || ']' === char || '?' === char || '=' === char || '{' === char || '}' === char) throw new Error('Invalid cookie name');
            }
        }
        function validateCookieValue(value) {
            for (const char of value){
                const code = char.charCodeAt(0);
                if (code < 0x21 || 0x22 === code || 0x2C === code || 0x3B === code || 0x5C === code || code > 0x7E) throw new Error('Invalid header value');
            }
        }
        function validateCookiePath(path) {
            for (const char of path){
                const code = char.charCodeAt(0);
                if (code < 0x21 || ';' === char) throw new Error('Invalid cookie path');
            }
        }
        function validateCookieDomain(domain) {
            if (domain.startsWith('-') || domain.endsWith('.') || domain.endsWith('-')) throw new Error('Invalid cookie domain');
        }
        function toIMFDate(date) {
            if ('number' == typeof date) date = new Date(date);
            const days = [
                'Sun',
                'Mon',
                'Tue',
                'Wed',
                'Thu',
                'Fri',
                'Sat'
            ];
            const months = [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'
            ];
            const dayName = days[date.getUTCDay()];
            const day = date.getUTCDate().toString().padStart(2, '0');
            const month = months[date.getUTCMonth()];
            const year = date.getUTCFullYear();
            const hour = date.getUTCHours().toString().padStart(2, '0');
            const minute = date.getUTCMinutes().toString().padStart(2, '0');
            const second = date.getUTCSeconds().toString().padStart(2, '0');
            return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
        }
        function validateCookieMaxAge(maxAge) {
            if (maxAge < 0) throw new Error('Invalid cookie max-age');
        }
        function stringify(cookie) {
            if (0 === cookie.name.length) return null;
            validateCookieName(cookie.name);
            validateCookieValue(cookie.value);
            const out = [
                `${cookie.name}=${cookie.value}`
            ];
            if (cookie.name.startsWith('__Secure-')) cookie.secure = true;
            if (cookie.name.startsWith('__Host-')) {
                cookie.secure = true;
                cookie.domain = null;
                cookie.path = '/';
            }
            if (cookie.secure) out.push('Secure');
            if (cookie.httpOnly) out.push('HttpOnly');
            if ('number' == typeof cookie.maxAge) {
                validateCookieMaxAge(cookie.maxAge);
                out.push(`Max-Age=${cookie.maxAge}`);
            }
            if (cookie.domain) {
                validateCookieDomain(cookie.domain);
                out.push(`Domain=${cookie.domain}`);
            }
            if (cookie.path) {
                validateCookiePath(cookie.path);
                out.push(`Path=${cookie.path}`);
            }
            if (cookie.expires && 'Invalid Date' !== cookie.expires.toString()) out.push(`Expires=${toIMFDate(cookie.expires)}`);
            if (cookie.sameSite) out.push(`SameSite=${cookie.sameSite}`);
            for (const part of cookie.unparsed){
                if (!part.includes('=')) throw new Error('Invalid unparsed');
                const [key, ...value] = part.split('=');
                out.push(`${key.trim()}=${value.join('=')}`);
            }
            return out.join('; ');
        }
        module.exports = {
            isCTLExcludingHtab,
            validateCookieName,
            validateCookiePath,
            validateCookieValue,
            toIMFDate,
            stringify
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const net = __webpack_require__("net");
        const assert = __webpack_require__("assert");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        let tls;
        let SessionCache;
        SessionCache = global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE ? class {
            constructor(maxCachedSessions){
                this._maxCachedSessions = maxCachedSessions;
                this._sessionCache = new Map();
                this._sessionRegistry = new global.FinalizationRegistry((key)=>{
                    if (this._sessionCache.size < this._maxCachedSessions) return;
                    const ref = this._sessionCache.get(key);
                    if (void 0 !== ref && void 0 === ref.deref()) this._sessionCache.delete(key);
                });
            }
            get(sessionKey) {
                const ref = this._sessionCache.get(sessionKey);
                return ref ? ref.deref() : null;
            }
            set(sessionKey, session) {
                if (0 === this._maxCachedSessions) return;
                this._sessionCache.set(sessionKey, new WeakRef(session));
                this._sessionRegistry.register(session, sessionKey);
            }
        } : class {
            constructor(maxCachedSessions){
                this._maxCachedSessions = maxCachedSessions;
                this._sessionCache = new Map();
            }
            get(sessionKey) {
                return this._sessionCache.get(sessionKey);
            }
            set(sessionKey, session) {
                if (0 === this._maxCachedSessions) return;
                if (this._sessionCache.size >= this._maxCachedSessions) {
                    const { value: oldestKey } = this._sessionCache.keys().next();
                    this._sessionCache.delete(oldestKey);
                }
                this._sessionCache.set(sessionKey, session);
            }
        };
        function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
            if (null != maxCachedSessions && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');
            const options = {
                path: socketPath,
                ...opts
            };
            const sessionCache = new SessionCache(null == maxCachedSessions ? 100 : maxCachedSessions);
            timeout = null == timeout ? 10e3 : timeout;
            allowH2 = null != allowH2 ? allowH2 : false;
            return function({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
                let socket;
                if ('https:' === protocol) {
                    if (!tls) tls = __webpack_require__("tls");
                    servername = servername || options.servername || util.getServerName(host) || null;
                    const sessionKey = servername || hostname;
                    const session = sessionCache.get(sessionKey) || null;
                    assert(sessionKey);
                    socket = tls.connect({
                        highWaterMark: 16384,
                        ...options,
                        servername,
                        session,
                        localAddress,
                        ALPNProtocols: allowH2 ? [
                            'http/1.1',
                            'h2'
                        ] : [
                            'http/1.1'
                        ],
                        socket: httpSocket,
                        port: port || 443,
                        host: hostname
                    });
                    socket.on('session', function(session) {
                        sessionCache.set(sessionKey, session);
                    });
                } else {
                    assert(!httpSocket, 'httpSocket can only be sent on TLS update');
                    socket = net.connect({
                        highWaterMark: 65536,
                        ...options,
                        localAddress,
                        port: port || 80,
                        host: hostname
                    });
                }
                if (null == options.keepAlive || options.keepAlive) {
                    const keepAliveInitialDelay = void 0 === options.keepAliveInitialDelay ? 60e3 : options.keepAliveInitialDelay;
                    socket.setKeepAlive(true, keepAliveInitialDelay);
                }
                const cancelTimeout = setupTimeout(()=>onConnectTimeout(socket), timeout);
                socket.setNoDelay(true).once('https:' === protocol ? 'secureConnect' : 'connect', function() {
                    cancelTimeout();
                    if (callback) {
                        const cb = callback;
                        callback = null;
                        cb(null, this);
                    }
                }).on('error', function(err) {
                    cancelTimeout();
                    if (callback) {
                        const cb = callback;
                        callback = null;
                        cb(err);
                    }
                });
                return socket;
            };
        }
        function setupTimeout(onConnectTimeout, timeout) {
            if (!timeout) return ()=>{};
            let s1 = null;
            let s2 = null;
            const timeoutId = setTimeout(()=>{
                s1 = setImmediate(()=>{
                    if ('win32' === process.platform) s2 = setImmediate(()=>onConnectTimeout());
                    else onConnectTimeout();
                });
            }, timeout);
            return ()=>{
                clearTimeout(timeoutId);
                clearImmediate(s1);
                clearImmediate(s2);
            };
        }
        function onConnectTimeout(socket) {
            util.destroy(socket, new ConnectTimeoutError());
        }
        module.exports = buildConnector;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/constants.js" (module) {
        "use strict";
        const headerNameLowerCasedRecord = {};
        const wellknownHeaderNames = [
            'Accept',
            'Accept-Encoding',
            'Accept-Language',
            'Accept-Ranges',
            'Access-Control-Allow-Credentials',
            'Access-Control-Allow-Headers',
            'Access-Control-Allow-Methods',
            'Access-Control-Allow-Origin',
            'Access-Control-Expose-Headers',
            'Access-Control-Max-Age',
            'Access-Control-Request-Headers',
            'Access-Control-Request-Method',
            'Age',
            'Allow',
            'Alt-Svc',
            'Alt-Used',
            'Authorization',
            'Cache-Control',
            'Clear-Site-Data',
            'Connection',
            'Content-Disposition',
            'Content-Encoding',
            'Content-Language',
            'Content-Length',
            'Content-Location',
            'Content-Range',
            'Content-Security-Policy',
            'Content-Security-Policy-Report-Only',
            'Content-Type',
            'Cookie',
            'Cross-Origin-Embedder-Policy',
            'Cross-Origin-Opener-Policy',
            'Cross-Origin-Resource-Policy',
            'Date',
            'Device-Memory',
            'Downlink',
            'ECT',
            'ETag',
            'Expect',
            'Expect-CT',
            'Expires',
            'Forwarded',
            'From',
            'Host',
            'If-Match',
            'If-Modified-Since',
            'If-None-Match',
            'If-Range',
            'If-Unmodified-Since',
            'Keep-Alive',
            'Last-Modified',
            'Link',
            'Location',
            'Max-Forwards',
            'Origin',
            'Permissions-Policy',
            'Pragma',
            'Proxy-Authenticate',
            'Proxy-Authorization',
            'RTT',
            'Range',
            'Referer',
            'Referrer-Policy',
            'Refresh',
            'Retry-After',
            'Sec-WebSocket-Accept',
            'Sec-WebSocket-Extensions',
            'Sec-WebSocket-Key',
            'Sec-WebSocket-Protocol',
            'Sec-WebSocket-Version',
            'Server',
            'Server-Timing',
            'Service-Worker-Allowed',
            'Service-Worker-Navigation-Preload',
            'Set-Cookie',
            'SourceMap',
            'Strict-Transport-Security',
            'Supports-Loading-Mode',
            'TE',
            'Timing-Allow-Origin',
            'Trailer',
            'Transfer-Encoding',
            'Upgrade',
            'Upgrade-Insecure-Requests',
            'User-Agent',
            'Vary',
            'Via',
            'WWW-Authenticate',
            'X-Content-Type-Options',
            'X-DNS-Prefetch-Control',
            'X-Frame-Options',
            'X-Permitted-Cross-Domain-Policies',
            'X-Powered-By',
            'X-Requested-With',
            'X-XSS-Protection'
        ];
        for(let i = 0; i < wellknownHeaderNames.length; ++i){
            const key = wellknownHeaderNames[i];
            const lowerCasedKey = key.toLowerCase();
            headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
        }
        Object.setPrototypeOf(headerNameLowerCasedRecord, null);
        module.exports = {
            wellknownHeaderNames,
            headerNameLowerCasedRecord
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js" (module) {
        "use strict";
        class UndiciError extends Error {
            constructor(message){
                super(message);
                this.name = 'UndiciError';
                this.code = 'UND_ERR';
            }
        }
        class ConnectTimeoutError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, ConnectTimeoutError);
                this.name = 'ConnectTimeoutError';
                this.message = message || 'Connect Timeout Error';
                this.code = 'UND_ERR_CONNECT_TIMEOUT';
            }
        }
        class HeadersTimeoutError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, HeadersTimeoutError);
                this.name = 'HeadersTimeoutError';
                this.message = message || 'Headers Timeout Error';
                this.code = 'UND_ERR_HEADERS_TIMEOUT';
            }
        }
        class HeadersOverflowError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, HeadersOverflowError);
                this.name = 'HeadersOverflowError';
                this.message = message || 'Headers Overflow Error';
                this.code = 'UND_ERR_HEADERS_OVERFLOW';
            }
        }
        class BodyTimeoutError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, BodyTimeoutError);
                this.name = 'BodyTimeoutError';
                this.message = message || 'Body Timeout Error';
                this.code = 'UND_ERR_BODY_TIMEOUT';
            }
        }
        class ResponseStatusCodeError extends UndiciError {
            constructor(message, statusCode, headers, body){
                super(message);
                Error.captureStackTrace(this, ResponseStatusCodeError);
                this.name = 'ResponseStatusCodeError';
                this.message = message || 'Response Status Code Error';
                this.code = 'UND_ERR_RESPONSE_STATUS_CODE';
                this.body = body;
                this.status = statusCode;
                this.statusCode = statusCode;
                this.headers = headers;
            }
        }
        class InvalidArgumentError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, InvalidArgumentError);
                this.name = 'InvalidArgumentError';
                this.message = message || 'Invalid Argument Error';
                this.code = 'UND_ERR_INVALID_ARG';
            }
        }
        class InvalidReturnValueError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, InvalidReturnValueError);
                this.name = 'InvalidReturnValueError';
                this.message = message || 'Invalid Return Value Error';
                this.code = 'UND_ERR_INVALID_RETURN_VALUE';
            }
        }
        class RequestAbortedError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, RequestAbortedError);
                this.name = 'AbortError';
                this.message = message || 'Request aborted';
                this.code = 'UND_ERR_ABORTED';
            }
        }
        class InformationalError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, InformationalError);
                this.name = 'InformationalError';
                this.message = message || 'Request information';
                this.code = 'UND_ERR_INFO';
            }
        }
        class RequestContentLengthMismatchError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, RequestContentLengthMismatchError);
                this.name = 'RequestContentLengthMismatchError';
                this.message = message || 'Request body length does not match content-length header';
                this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH';
            }
        }
        class ResponseContentLengthMismatchError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, ResponseContentLengthMismatchError);
                this.name = 'ResponseContentLengthMismatchError';
                this.message = message || 'Response body length does not match content-length header';
                this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH';
            }
        }
        class ClientDestroyedError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, ClientDestroyedError);
                this.name = 'ClientDestroyedError';
                this.message = message || 'The client is destroyed';
                this.code = 'UND_ERR_DESTROYED';
            }
        }
        class ClientClosedError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, ClientClosedError);
                this.name = 'ClientClosedError';
                this.message = message || 'The client is closed';
                this.code = 'UND_ERR_CLOSED';
            }
        }
        class SocketError extends UndiciError {
            constructor(message, socket){
                super(message);
                Error.captureStackTrace(this, SocketError);
                this.name = 'SocketError';
                this.message = message || 'Socket error';
                this.code = 'UND_ERR_SOCKET';
                this.socket = socket;
            }
        }
        class NotSupportedError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, NotSupportedError);
                this.name = 'NotSupportedError';
                this.message = message || 'Not supported error';
                this.code = 'UND_ERR_NOT_SUPPORTED';
            }
        }
        class BalancedPoolMissingUpstreamError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, NotSupportedError);
                this.name = 'MissingUpstreamError';
                this.message = message || 'No upstream has been added to the BalancedPool';
                this.code = 'UND_ERR_BPL_MISSING_UPSTREAM';
            }
        }
        class HTTPParserError extends Error {
            constructor(message, code, data){
                super(message);
                Error.captureStackTrace(this, HTTPParserError);
                this.name = 'HTTPParserError';
                this.code = code ? `HPE_${code}` : void 0;
                this.data = data ? data.toString() : void 0;
            }
        }
        class ResponseExceededMaxSizeError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, ResponseExceededMaxSizeError);
                this.name = 'ResponseExceededMaxSizeError';
                this.message = message || 'Response content exceeded max size';
                this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE';
            }
        }
        class RequestRetryError extends UndiciError {
            constructor(message, code, { headers, data }){
                super(message);
                Error.captureStackTrace(this, RequestRetryError);
                this.name = 'RequestRetryError';
                this.message = message || 'Request retry error';
                this.code = 'UND_ERR_REQ_RETRY';
                this.statusCode = code;
                this.data = data;
                this.headers = headers;
            }
        }
        module.exports = {
            HTTPParserError,
            UndiciError,
            HeadersTimeoutError,
            HeadersOverflowError,
            BodyTimeoutError,
            RequestContentLengthMismatchError,
            ConnectTimeoutError,
            ResponseStatusCodeError,
            InvalidArgumentError,
            InvalidReturnValueError,
            RequestAbortedError,
            ClientDestroyedError,
            ClientClosedError,
            InformationalError,
            SocketError,
            NotSupportedError,
            ResponseContentLengthMismatchError,
            BalancedPoolMissingUpstreamError,
            ResponseExceededMaxSizeError,
            RequestRetryError
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/request.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { InvalidArgumentError, NotSupportedError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const assert = __webpack_require__("assert");
        const { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
        const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
        const invalidPathRegex = /[^\u0021-\u00ff]/;
        const kHandler = Symbol('handler');
        const channels = {};
        let extractBody;
        try {
            const diagnosticsChannel = __webpack_require__("diagnostics_channel");
            channels.create = diagnosticsChannel.channel('undici:request:create');
            channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent');
            channels.headers = diagnosticsChannel.channel('undici:request:headers');
            channels.trailers = diagnosticsChannel.channel('undici:request:trailers');
            channels.error = diagnosticsChannel.channel('undici:request:error');
        } catch  {
            channels.create = {
                hasSubscribers: false
            };
            channels.bodySent = {
                hasSubscribers: false
            };
            channels.headers = {
                hasSubscribers: false
            };
            channels.trailers = {
                hasSubscribers: false
            };
            channels.error = {
                hasSubscribers: false
            };
        }
        class Request {
            constructor(origin, { path, method, body, headers, query, idempotent, blocking, upgrade, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue }, handler){
                if ('string' != typeof path) throw new InvalidArgumentError('path must be a string');
                if ('/' === path[0] || path.startsWith('http://') || path.startsWith('https://') || 'CONNECT' === method) {
                    if (null !== invalidPathRegex.exec(path)) throw new InvalidArgumentError('invalid request path');
                } else throw new InvalidArgumentError('path must be an absolute URL or start with a slash');
                if ('string' != typeof method) throw new InvalidArgumentError('method must be a string');
                if (null === tokenRegExp.exec(method)) throw new InvalidArgumentError('invalid request method');
                if (upgrade && 'string' != typeof upgrade) throw new InvalidArgumentError('upgrade must be a string');
                if (null != headersTimeout && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError('invalid headersTimeout');
                if (null != bodyTimeout && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError('invalid bodyTimeout');
                if (null != reset && 'boolean' != typeof reset) throw new InvalidArgumentError('invalid reset');
                if (null != expectContinue && 'boolean' != typeof expectContinue) throw new InvalidArgumentError('invalid expectContinue');
                this.headersTimeout = headersTimeout;
                this.bodyTimeout = bodyTimeout;
                this.throwOnError = true === throwOnError;
                this.method = method;
                this.abort = null;
                if (null == body) this.body = null;
                else if (util.isStream(body)) {
                    this.body = body;
                    const rState = this.body._readableState;
                    if (!rState || !rState.autoDestroy) {
                        this.endHandler = function() {
                            util.destroy(this);
                        };
                        this.body.on('end', this.endHandler);
                    }
                    this.errorHandler = (err)=>{
                        if (this.abort) this.abort(err);
                        else this.error = err;
                    };
                    this.body.on('error', this.errorHandler);
                } else if (util.isBuffer(body)) this.body = body.byteLength ? body : null;
                else if (ArrayBuffer.isView(body)) this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
                else if (body instanceof ArrayBuffer) this.body = body.byteLength ? Buffer.from(body) : null;
                else if ('string' == typeof body) this.body = body.length ? Buffer.from(body) : null;
                else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) this.body = body;
                else throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable');
                this.completed = false;
                this.aborted = false;
                this.upgrade = upgrade || null;
                this.path = query ? util.buildURL(path, query) : path;
                this.origin = origin;
                this.idempotent = null == idempotent ? 'HEAD' === method || 'GET' === method : idempotent;
                this.blocking = null == blocking ? false : blocking;
                this.reset = null == reset ? null : reset;
                this.host = null;
                this.contentLength = null;
                this.contentType = null;
                this.headers = '';
                this.expectContinue = null != expectContinue ? expectContinue : false;
                if (Array.isArray(headers)) {
                    if (headers.length % 2 !== 0) throw new InvalidArgumentError('headers array must be even');
                    for(let i = 0; i < headers.length; i += 2)processHeader(this, headers[i], headers[i + 1]);
                } else if (headers && 'object' == typeof headers) {
                    const keys = Object.keys(headers);
                    for(let i = 0; i < keys.length; i++){
                        const key = keys[i];
                        processHeader(this, key, headers[key]);
                    }
                } else if (null != headers) throw new InvalidArgumentError('headers must be an object or an array');
                if (util.isFormDataLike(this.body)) {
                    if (util.nodeMajor < 16 || 16 === util.nodeMajor && util.nodeMinor < 8) throw new InvalidArgumentError('Form-Data bodies are only supported in node v16.8 and newer.');
                    if (!extractBody) extractBody = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js").extractBody;
                    const [bodyStream, contentType] = extractBody(body);
                    if (null == this.contentType) {
                        this.contentType = contentType;
                        this.headers += `content-type: ${contentType}\r\n`;
                    }
                    this.body = bodyStream.stream;
                    this.contentLength = bodyStream.length;
                } else if (util.isBlobLike(body) && null == this.contentType && body.type) {
                    this.contentType = body.type;
                    this.headers += `content-type: ${body.type}\r\n`;
                }
                util.validateHandler(handler, method, upgrade);
                this.servername = util.getServerName(this.host);
                this[kHandler] = handler;
                if (channels.create.hasSubscribers) channels.create.publish({
                    request: this
                });
            }
            onBodySent(chunk) {
                if (this[kHandler].onBodySent) try {
                    return this[kHandler].onBodySent(chunk);
                } catch (err) {
                    this.abort(err);
                }
            }
            onRequestSent() {
                if (channels.bodySent.hasSubscribers) channels.bodySent.publish({
                    request: this
                });
                if (this[kHandler].onRequestSent) try {
                    return this[kHandler].onRequestSent();
                } catch (err) {
                    this.abort(err);
                }
            }
            onConnect(abort) {
                assert(!this.aborted);
                assert(!this.completed);
                if (this.error) abort(this.error);
                else {
                    this.abort = abort;
                    return this[kHandler].onConnect(abort);
                }
            }
            onHeaders(statusCode, headers, resume, statusText) {
                assert(!this.aborted);
                assert(!this.completed);
                if (channels.headers.hasSubscribers) channels.headers.publish({
                    request: this,
                    response: {
                        statusCode,
                        headers,
                        statusText
                    }
                });
                try {
                    return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
                } catch (err) {
                    this.abort(err);
                }
            }
            onData(chunk) {
                assert(!this.aborted);
                assert(!this.completed);
                try {
                    return this[kHandler].onData(chunk);
                } catch (err) {
                    this.abort(err);
                    return false;
                }
            }
            onUpgrade(statusCode, headers, socket) {
                assert(!this.aborted);
                assert(!this.completed);
                return this[kHandler].onUpgrade(statusCode, headers, socket);
            }
            onComplete(trailers) {
                this.onFinally();
                assert(!this.aborted);
                this.completed = true;
                if (channels.trailers.hasSubscribers) channels.trailers.publish({
                    request: this,
                    trailers
                });
                try {
                    return this[kHandler].onComplete(trailers);
                } catch (err) {
                    this.onError(err);
                }
            }
            onError(error) {
                this.onFinally();
                if (channels.error.hasSubscribers) channels.error.publish({
                    request: this,
                    error
                });
                if (this.aborted) return;
                this.aborted = true;
                return this[kHandler].onError(error);
            }
            onFinally() {
                if (this.errorHandler) {
                    this.body.off('error', this.errorHandler);
                    this.errorHandler = null;
                }
                if (this.endHandler) {
                    this.body.off('end', this.endHandler);
                    this.endHandler = null;
                }
            }
            addHeader(key, value) {
                processHeader(this, key, value);
                return this;
            }
            static [kHTTP1BuildRequest](origin, opts, handler) {
                return new Request(origin, opts, handler);
            }
            static [kHTTP2BuildRequest](origin, opts, handler) {
                const headers = opts.headers;
                opts = {
                    ...opts,
                    headers: null
                };
                const request = new Request(origin, opts, handler);
                request.headers = {};
                if (Array.isArray(headers)) {
                    if (headers.length % 2 !== 0) throw new InvalidArgumentError('headers array must be even');
                    for(let i = 0; i < headers.length; i += 2)processHeader(request, headers[i], headers[i + 1], true);
                } else if (headers && 'object' == typeof headers) {
                    const keys = Object.keys(headers);
                    for(let i = 0; i < keys.length; i++){
                        const key = keys[i];
                        processHeader(request, key, headers[key], true);
                    }
                } else if (null != headers) throw new InvalidArgumentError('headers must be an object or an array');
                return request;
            }
            static [kHTTP2CopyHeaders](raw) {
                const rawHeaders = raw.split('\r\n');
                const headers = {};
                for (const header of rawHeaders){
                    const [key, value] = header.split(': ');
                    if (null != value && 0 !== value.length) if (headers[key]) headers[key] += `,${value}`;
                    else headers[key] = value;
                }
                return headers;
            }
        }
        function processHeaderValue(key, val, skipAppend) {
            if (val && 'object' == typeof val) throw new InvalidArgumentError(`invalid ${key} header`);
            val = null != val ? `${val}` : '';
            if (null !== headerCharRegex.exec(val)) throw new InvalidArgumentError(`invalid ${key} header`);
            return skipAppend ? val : `${key}: ${val}\r\n`;
        }
        function processHeader(request, key, val, skipAppend = false) {
            if (val && 'object' == typeof val && !Array.isArray(val)) throw new InvalidArgumentError(`invalid ${key} header`);
            if (void 0 === val) return;
            if (null === request.host && 4 === key.length && 'host' === key.toLowerCase()) {
                if (null !== headerCharRegex.exec(val)) throw new InvalidArgumentError(`invalid ${key} header`);
                request.host = val;
            } else if (null === request.contentLength && 14 === key.length && 'content-length' === key.toLowerCase()) {
                request.contentLength = parseInt(val, 10);
                if (!Number.isFinite(request.contentLength)) throw new InvalidArgumentError('invalid content-length header');
            } else if (null === request.contentType && 12 === key.length && 'content-type' === key.toLowerCase()) {
                request.contentType = val;
                if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
                else request.headers += processHeaderValue(key, val);
            } else if (17 === key.length && 'transfer-encoding' === key.toLowerCase()) throw new InvalidArgumentError('invalid transfer-encoding header');
            else if (10 === key.length && 'connection' === key.toLowerCase()) {
                const value = 'string' == typeof val ? val.toLowerCase() : null;
                if ('close' !== value && 'keep-alive' !== value) throw new InvalidArgumentError('invalid connection header');
                if ('close' === value) request.reset = true;
            } else if (10 === key.length && 'keep-alive' === key.toLowerCase()) throw new InvalidArgumentError('invalid keep-alive header');
            else if (7 === key.length && 'upgrade' === key.toLowerCase()) throw new InvalidArgumentError('invalid upgrade header');
            else if (6 === key.length && 'expect' === key.toLowerCase()) throw new NotSupportedError('expect header not supported');
            else if (null === tokenRegExp.exec(key)) throw new InvalidArgumentError('invalid header key');
            else if (Array.isArray(val)) for(let i = 0; i < val.length; i++)if (skipAppend) if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
            else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
            else request.headers += processHeaderValue(key, val[i]);
            else if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
            else request.headers += processHeaderValue(key, val);
        }
        module.exports = Request;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js" (module) {
        module.exports = {
            kClose: Symbol('close'),
            kDestroy: Symbol('destroy'),
            kDispatch: Symbol('dispatch'),
            kUrl: Symbol('url'),
            kWriting: Symbol('writing'),
            kResuming: Symbol('resuming'),
            kQueue: Symbol('queue'),
            kConnect: Symbol('connect'),
            kConnecting: Symbol('connecting'),
            kHeadersList: Symbol('headers list'),
            kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
            kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
            kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
            kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
            kKeepAlive: Symbol('keep alive'),
            kHeadersTimeout: Symbol('headers timeout'),
            kBodyTimeout: Symbol('body timeout'),
            kServerName: Symbol('server name'),
            kLocalAddress: Symbol('local address'),
            kHost: Symbol('host'),
            kNoRef: Symbol('no ref'),
            kBodyUsed: Symbol('used'),
            kRunning: Symbol('running'),
            kBlocking: Symbol('blocking'),
            kPending: Symbol('pending'),
            kSize: Symbol('size'),
            kBusy: Symbol('busy'),
            kQueued: Symbol('queued'),
            kFree: Symbol('free'),
            kConnected: Symbol('connected'),
            kClosed: Symbol('closed'),
            kNeedDrain: Symbol('need drain'),
            kReset: Symbol('reset'),
            kDestroyed: Symbol.for('nodejs.stream.destroyed'),
            kMaxHeadersSize: Symbol('max headers size'),
            kRunningIdx: Symbol('running index'),
            kPendingIdx: Symbol('pending index'),
            kError: Symbol('error'),
            kClients: Symbol('clients'),
            kClient: Symbol('client'),
            kParser: Symbol('parser'),
            kOnDestroyed: Symbol('destroy callbacks'),
            kPipelining: Symbol('pipelining'),
            kSocket: Symbol('socket'),
            kHostHeader: Symbol('host header'),
            kConnector: Symbol('connector'),
            kStrictContentLength: Symbol('strict content length'),
            kMaxRedirections: Symbol('maxRedirections'),
            kMaxRequests: Symbol('maxRequestsPerClient'),
            kProxy: Symbol('proxy agent options'),
            kCounter: Symbol('socket request counter'),
            kInterceptors: Symbol('dispatch interceptors'),
            kMaxResponseSize: Symbol('max response size'),
            kHTTP2Session: Symbol('http2Session'),
            kHTTP2SessionState: Symbol('http2Session state'),
            kHTTP2BuildRequest: Symbol('http2 build request'),
            kHTTP1BuildRequest: Symbol('http1 build request'),
            kHTTP2CopyHeaders: Symbol('http2 copy headers'),
            kHTTPConnVersion: Symbol('http connection version'),
            kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),
            kConstruct: Symbol('constructable')
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const assert = __webpack_require__("assert");
        const { kDestroyed, kBodyUsed } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const { IncomingMessage } = __webpack_require__("http");
        const stream = __webpack_require__("stream");
        const net = __webpack_require__("net");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const { Blob: Blob1 } = __webpack_require__("buffer");
        const nodeUtil = __webpack_require__("util");
        const { stringify } = __webpack_require__("querystring");
        const { headerNameLowerCasedRecord } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/constants.js");
        const [nodeMajor, nodeMinor] = process.versions.node.split('.').map((v)=>Number(v));
        function nop() {}
        function isStream(obj) {
            return obj && 'object' == typeof obj && 'function' == typeof obj.pipe && 'function' == typeof obj.on;
        }
        function isBlobLike(object) {
            return Blob1 && object instanceof Blob1 || object && 'object' == typeof object && ('function' == typeof object.stream || 'function' == typeof object.arrayBuffer) && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
        }
        function buildURL(url, queryParams) {
            if (url.includes('?') || url.includes('#')) throw new Error('Query params cannot be passed when url already contains "?" or "#".');
            const stringified = stringify(queryParams);
            if (stringified) url += '?' + stringified;
            return url;
        }
        function parseURL(url) {
            if ('string' == typeof url) {
                url = new URL(url);
                if (!/^https?:/.test(url.origin || url.protocol)) throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');
                return url;
            }
            if (!url || 'object' != typeof url) throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.');
            if (!/^https?:/.test(url.origin || url.protocol)) throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.');
            if (!(url instanceof URL)) {
                if (null != url.port && '' !== url.port && !Number.isFinite(parseInt(url.port))) throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.');
                if (null != url.path && 'string' != typeof url.path) throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.');
                if (null != url.pathname && 'string' != typeof url.pathname) throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.');
                if (null != url.hostname && 'string' != typeof url.hostname) throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.');
                if (null != url.origin && 'string' != typeof url.origin) throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.');
                const port = null != url.port ? url.port : 'https:' === url.protocol ? 443 : 80;
                let origin = null != url.origin ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
                let path = null != url.path ? url.path : `${url.pathname || ''}${url.search || ''}`;
                if (origin.endsWith('/')) origin = origin.substring(0, origin.length - 1);
                if (path && !path.startsWith('/')) path = `/${path}`;
                url = new URL(origin + path);
            }
            return url;
        }
        function parseOrigin(url) {
            url = parseURL(url);
            if ('/' !== url.pathname || url.search || url.hash) throw new InvalidArgumentError('invalid url');
            return url;
        }
        function getHostname(host) {
            if ('[' === host[0]) {
                const idx = host.indexOf(']');
                assert(-1 !== idx);
                return host.substring(1, idx);
            }
            const idx = host.indexOf(':');
            if (-1 === idx) return host;
            return host.substring(0, idx);
        }
        function getServerName(host) {
            if (!host) return null;
            assert.strictEqual(typeof host, 'string');
            const servername = getHostname(host);
            if (net.isIP(servername)) return '';
            return servername;
        }
        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }
        function isAsyncIterable(obj) {
            return !!(null != obj && 'function' == typeof obj[Symbol.asyncIterator]);
        }
        function isIterable(obj) {
            return !!(null != obj && ('function' == typeof obj[Symbol.iterator] || 'function' == typeof obj[Symbol.asyncIterator]));
        }
        function bodyLength(body) {
            if (null == body) return 0;
            if (isStream(body)) {
                const state = body._readableState;
                return state && false === state.objectMode && true === state.ended && Number.isFinite(state.length) ? state.length : null;
            }
            if (isBlobLike(body)) return null != body.size ? body.size : null;
            if (isBuffer(body)) return body.byteLength;
            return null;
        }
        function isDestroyed(stream) {
            return !stream || !!(stream.destroyed || stream[kDestroyed]);
        }
        function isReadableAborted(stream) {
            const state = stream && stream._readableState;
            return isDestroyed(stream) && state && !state.endEmitted;
        }
        function destroy(stream, err) {
            if (null == stream || !isStream(stream) || isDestroyed(stream)) return;
            if ('function' == typeof stream.destroy) {
                if (Object.getPrototypeOf(stream).constructor === IncomingMessage) stream.socket = null;
                stream.destroy(err);
            } else if (err) process.nextTick((stream, err)=>{
                stream.emit('error', err);
            }, stream, err);
            if (true !== stream.destroyed) stream[kDestroyed] = true;
        }
        const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
        function parseKeepAliveTimeout(val) {
            const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
            return m ? 1000 * parseInt(m[1], 10) : null;
        }
        function headerNameToString(value) {
            return headerNameLowerCasedRecord[value] || value.toLowerCase();
        }
        function parseHeaders(headers, obj = {}) {
            if (!Array.isArray(headers)) return headers;
            for(let i = 0; i < headers.length; i += 2){
                const key = headers[i].toString().toLowerCase();
                let val = obj[key];
                if (val) {
                    if (!Array.isArray(val)) {
                        val = [
                            val
                        ];
                        obj[key] = val;
                    }
                    val.push(headers[i + 1].toString('utf8'));
                } else if (Array.isArray(headers[i + 1])) obj[key] = headers[i + 1].map((x)=>x.toString('utf8'));
                else obj[key] = headers[i + 1].toString('utf8');
            }
            if ('content-length' in obj && 'content-disposition' in obj) obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1');
            return obj;
        }
        function parseRawHeaders(headers) {
            const ret = [];
            let hasContentLength = false;
            let contentDispositionIdx = -1;
            for(let n = 0; n < headers.length; n += 2){
                const key = headers[n + 0].toString();
                const val = headers[n + 1].toString('utf8');
                if (14 === key.length && ('content-length' === key || 'content-length' === key.toLowerCase())) {
                    ret.push(key, val);
                    hasContentLength = true;
                } else if (19 === key.length && ('content-disposition' === key || 'content-disposition' === key.toLowerCase())) contentDispositionIdx = ret.push(key, val) - 1;
                else ret.push(key, val);
            }
            if (hasContentLength && -1 !== contentDispositionIdx) ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1');
            return ret;
        }
        function isBuffer(buffer) {
            return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
        }
        function validateHandler(handler, method, upgrade) {
            if (!handler || 'object' != typeof handler) throw new InvalidArgumentError('handler must be an object');
            if ('function' != typeof handler.onConnect) throw new InvalidArgumentError('invalid onConnect method');
            if ('function' != typeof handler.onError) throw new InvalidArgumentError('invalid onError method');
            if ('function' != typeof handler.onBodySent && void 0 !== handler.onBodySent) throw new InvalidArgumentError('invalid onBodySent method');
            if (upgrade || 'CONNECT' === method) {
                if ('function' != typeof handler.onUpgrade) throw new InvalidArgumentError('invalid onUpgrade method');
            } else {
                if ('function' != typeof handler.onHeaders) throw new InvalidArgumentError('invalid onHeaders method');
                if ('function' != typeof handler.onData) throw new InvalidArgumentError('invalid onData method');
                if ('function' != typeof handler.onComplete) throw new InvalidArgumentError('invalid onComplete method');
            }
        }
        function isDisturbed(body) {
            return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
        }
        function isErrored(body) {
            return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
        }
        function isReadable(body) {
            return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
        }
        function getSocketInfo(socket) {
            return {
                localAddress: socket.localAddress,
                localPort: socket.localPort,
                remoteAddress: socket.remoteAddress,
                remotePort: socket.remotePort,
                remoteFamily: socket.remoteFamily,
                timeout: socket.timeout,
                bytesWritten: socket.bytesWritten,
                bytesRead: socket.bytesRead
            };
        }
        async function* convertIterableToBuffer(iterable) {
            for await (const chunk of iterable)yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }
        let ReadableStream;
        function ReadableStreamFrom(iterable) {
            if (!ReadableStream) ReadableStream = __webpack_require__("stream/web").ReadableStream;
            if (ReadableStream.from) return ReadableStream.from(convertIterableToBuffer(iterable));
            let iterator;
            return new ReadableStream({
                async start () {
                    iterator = iterable[Symbol.asyncIterator]();
                },
                async pull (controller) {
                    const { done, value } = await iterator.next();
                    if (done) queueMicrotask(()=>{
                        controller.close();
                    });
                    else {
                        const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
                        controller.enqueue(new Uint8Array(buf));
                    }
                    return controller.desiredSize > 0;
                },
                async cancel (reason) {
                    await iterator.return();
                }
            }, 0);
        }
        function isFormDataLike(object) {
            return object && 'object' == typeof object && 'function' == typeof object.append && 'function' == typeof object.delete && 'function' == typeof object.get && 'function' == typeof object.getAll && 'function' == typeof object.has && 'function' == typeof object.set && 'FormData' === object[Symbol.toStringTag];
        }
        function throwIfAborted(signal) {
            if (!signal) return;
            if ('function' == typeof signal.throwIfAborted) signal.throwIfAborted();
            else if (signal.aborted) {
                const err = new Error('The operation was aborted');
                err.name = 'AbortError';
                throw err;
            }
        }
        function addAbortListener(signal, listener) {
            if ('addEventListener' in signal) {
                signal.addEventListener('abort', listener, {
                    once: true
                });
                return ()=>signal.removeEventListener('abort', listener);
            }
            signal.addListener('abort', listener);
            return ()=>signal.removeListener('abort', listener);
        }
        const hasToWellFormed = !!String.prototype.toWellFormed;
        function toUSVString(val) {
            if (hasToWellFormed) return `${val}`.toWellFormed();
            if (nodeUtil.toUSVString) return nodeUtil.toUSVString(val);
            return `${val}`;
        }
        function parseRangeHeader(range) {
            if (null == range || '' === range) return {
                start: 0,
                end: null,
                size: null
            };
            const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
            return m ? {
                start: parseInt(m[1]),
                end: m[2] ? parseInt(m[2]) : null,
                size: m[3] ? parseInt(m[3]) : null
            } : null;
        }
        const kEnumerableProperty = Object.create(null);
        kEnumerableProperty.enumerable = true;
        module.exports = {
            kEnumerableProperty,
            nop,
            isDisturbed,
            isErrored,
            isReadable,
            toUSVString,
            isReadableAborted,
            isBlobLike,
            parseOrigin,
            parseURL,
            getServerName,
            isStream,
            isIterable,
            isAsyncIterable,
            isDestroyed,
            headerNameToString,
            parseRawHeaders,
            parseHeaders,
            parseKeepAliveTimeout,
            destroy,
            bodyLength,
            deepClone,
            ReadableStreamFrom,
            isBuffer,
            validateHandler,
            getSocketInfo,
            isFormDataLike,
            buildURL,
            throwIfAborted,
            addAbortListener,
            parseRangeHeader,
            nodeMajor,
            nodeMinor,
            nodeHasAutoSelectFamily: nodeMajor > 18 || 18 === nodeMajor && nodeMinor >= 13,
            safeHTTPMethods: [
                'GET',
                'HEAD',
                'OPTIONS',
                'TRACE'
            ]
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher-base.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const Dispatcher = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher.js");
        const { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const { kDestroy, kClose, kDispatch, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const kDestroyed = Symbol('destroyed');
        const kClosed = Symbol('closed');
        const kOnDestroyed = Symbol('onDestroyed');
        const kOnClosed = Symbol('onClosed');
        const kInterceptedDispatch = Symbol('Intercepted Dispatch');
        class DispatcherBase extends Dispatcher {
            constructor(){
                super();
                this[kDestroyed] = false;
                this[kOnDestroyed] = null;
                this[kClosed] = false;
                this[kOnClosed] = [];
            }
            get destroyed() {
                return this[kDestroyed];
            }
            get closed() {
                return this[kClosed];
            }
            get interceptors() {
                return this[kInterceptors];
            }
            set interceptors(newInterceptors) {
                if (newInterceptors) for(let i = newInterceptors.length - 1; i >= 0; i--){
                    const interceptor = this[kInterceptors][i];
                    if ('function' != typeof interceptor) throw new InvalidArgumentError('interceptor must be an function');
                }
                this[kInterceptors] = newInterceptors;
            }
            close(callback) {
                if (void 0 === callback) return new Promise((resolve, reject)=>{
                    this.close((err, data)=>err ? reject(err) : resolve(data));
                });
                if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                if (this[kDestroyed]) return void queueMicrotask(()=>callback(new ClientDestroyedError(), null));
                if (this[kClosed]) {
                    if (this[kOnClosed]) this[kOnClosed].push(callback);
                    else queueMicrotask(()=>callback(null, null));
                    return;
                }
                this[kClosed] = true;
                this[kOnClosed].push(callback);
                const onClosed = ()=>{
                    const callbacks = this[kOnClosed];
                    this[kOnClosed] = null;
                    for(let i = 0; i < callbacks.length; i++)callbacks[i](null, null);
                };
                this[kClose]().then(()=>this.destroy()).then(()=>{
                    queueMicrotask(onClosed);
                });
            }
            destroy(err, callback) {
                if ('function' == typeof err) {
                    callback = err;
                    err = null;
                }
                if (void 0 === callback) return new Promise((resolve, reject)=>{
                    this.destroy(err, (err, data)=>err ? reject(err) : resolve(data));
                });
                if ('function' != typeof callback) throw new InvalidArgumentError('invalid callback');
                if (this[kDestroyed]) {
                    if (this[kOnDestroyed]) this[kOnDestroyed].push(callback);
                    else queueMicrotask(()=>callback(null, null));
                    return;
                }
                if (!err) err = new ClientDestroyedError();
                this[kDestroyed] = true;
                this[kOnDestroyed] = this[kOnDestroyed] || [];
                this[kOnDestroyed].push(callback);
                const onDestroyed = ()=>{
                    const callbacks = this[kOnDestroyed];
                    this[kOnDestroyed] = null;
                    for(let i = 0; i < callbacks.length; i++)callbacks[i](null, null);
                };
                this[kDestroy](err).then(()=>{
                    queueMicrotask(onDestroyed);
                });
            }
            [kInterceptedDispatch](opts, handler) {
                if (!this[kInterceptors] || 0 === this[kInterceptors].length) {
                    this[kInterceptedDispatch] = this[kDispatch];
                    return this[kDispatch](opts, handler);
                }
                let dispatch = this[kDispatch].bind(this);
                for(let i = this[kInterceptors].length - 1; i >= 0; i--)dispatch = this[kInterceptors][i](dispatch);
                this[kInterceptedDispatch] = dispatch;
                return dispatch(opts, handler);
            }
            dispatch(opts, handler) {
                if (!handler || 'object' != typeof handler) throw new InvalidArgumentError('handler must be an object');
                try {
                    if (!opts || 'object' != typeof opts) throw new InvalidArgumentError('opts must be an object.');
                    if (this[kDestroyed] || this[kOnDestroyed]) throw new ClientDestroyedError();
                    if (this[kClosed]) throw new ClientClosedError();
                    return this[kInterceptedDispatch](opts, handler);
                } catch (err) {
                    if ('function' != typeof handler.onError) throw new InvalidArgumentError('invalid onError method');
                    handler.onError(err);
                    return false;
                }
            }
        }
        module.exports = DispatcherBase;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const EventEmitter = __webpack_require__("events");
        class Dispatcher extends EventEmitter {
            dispatch() {
                throw new Error('not implemented');
            }
            close() {
                throw new Error('not implemented');
            }
            destroy() {
                throw new Error('not implemented');
            }
        }
        module.exports = Dispatcher;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const Busboy = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { ReadableStreamFrom, isBlobLike, isReadableStreamLike, readableStreamClose, createDeferredPromise, fullyReadBody } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const { FormData } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/formdata.js");
        const { kState } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { DOMException: DOMException1, structuredClone } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js");
        const { Blob: Blob1, File: NativeFile } = __webpack_require__("buffer");
        const { kBodyUsed } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const assert = __webpack_require__("assert");
        const { isErrored } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { isUint8Array, isArrayBuffer } = __webpack_require__("util/types");
        const { File: UndiciFile } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/file.js");
        const { parseMIMEType, serializeAMimeType } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
        let random;
        try {
            const crypto = __webpack_require__("node:crypto");
            random = (max)=>crypto.randomInt(0, max);
        } catch  {
            random = (max)=>Math.floor(Math.random(max));
        }
        let ReadableStream = globalThis.ReadableStream;
        const File = NativeFile ?? UndiciFile;
        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder();
        function extractBody(object, keepalive = false) {
            if (!ReadableStream) ReadableStream = __webpack_require__("stream/web").ReadableStream;
            let stream = null;
            stream = object instanceof ReadableStream ? object : isBlobLike(object) ? object.stream() : new ReadableStream({
                async pull (controller) {
                    controller.enqueue('string' == typeof source ? textEncoder.encode(source) : source);
                    queueMicrotask(()=>readableStreamClose(controller));
                },
                start () {},
                type: void 0
            });
            assert(isReadableStreamLike(stream));
            let action = null;
            let source = null;
            let length = null;
            let type = null;
            if ('string' == typeof object) {
                source = object;
                type = 'text/plain;charset=UTF-8';
            } else if (object instanceof URLSearchParams) {
                source = object.toString();
                type = 'application/x-www-form-urlencoded;charset=UTF-8';
            } else if (isArrayBuffer(object)) source = new Uint8Array(object.slice());
            else if (ArrayBuffer.isView(object)) source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
            else if (util.isFormDataLike(object)) {
                const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`;
                const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
                /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ const escape1 = (str)=>str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22');
                const normalizeLinefeeds = (value)=>value.replace(/\r?\n|\r/g, '\r\n');
                const blobParts = [];
                const rn = new Uint8Array([
                    13,
                    10
                ]);
                length = 0;
                let hasUnknownSizeValue = false;
                for (const [name, value] of object)if ('string' == typeof value) {
                    const chunk = textEncoder.encode(prefix + `; name="${escape1(normalizeLinefeeds(name))}"` + `\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
                    blobParts.push(chunk);
                    length += chunk.byteLength;
                } else {
                    const chunk = textEncoder.encode(`${prefix}; name="${escape1(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape1(value.name)}"` : '') + '\r\n' + `Content-Type: ${value.type || 'application/octet-stream'}\r\n\r\n`);
                    blobParts.push(chunk, value, rn);
                    if ('number' == typeof value.size) length += chunk.byteLength + value.size + rn.byteLength;
                    else hasUnknownSizeValue = true;
                }
                const chunk = textEncoder.encode(`--${boundary}--`);
                blobParts.push(chunk);
                length += chunk.byteLength;
                if (hasUnknownSizeValue) length = null;
                source = object;
                action = async function*() {
                    for (const part of blobParts)if (part.stream) yield* part.stream();
                    else yield part;
                };
                type = 'multipart/form-data; boundary=' + boundary;
            } else if (isBlobLike(object)) {
                source = object;
                length = object.size;
                if (object.type) type = object.type;
            } else if ('function' == typeof object[Symbol.asyncIterator]) {
                if (keepalive) throw new TypeError('keepalive');
                if (util.isDisturbed(object) || object.locked) throw new TypeError('Response body object should not be disturbed or locked');
                stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
            }
            if ('string' == typeof source || util.isBuffer(source)) length = Buffer.byteLength(source);
            if (null != action) {
                let iterator;
                stream = new ReadableStream({
                    async start () {
                        iterator = action(object)[Symbol.asyncIterator]();
                    },
                    async pull (controller) {
                        const { value, done } = await iterator.next();
                        if (done) queueMicrotask(()=>{
                            controller.close();
                        });
                        else if (!isErrored(stream)) controller.enqueue(new Uint8Array(value));
                        return controller.desiredSize > 0;
                    },
                    async cancel (reason) {
                        await iterator.return();
                    },
                    type: void 0
                });
            }
            const body = {
                stream,
                source,
                length
            };
            return [
                body,
                type
            ];
        }
        function safelyExtractBody(object, keepalive = false) {
            if (!ReadableStream) ReadableStream = __webpack_require__("stream/web").ReadableStream;
            if (object instanceof ReadableStream) {
                assert(!util.isDisturbed(object), 'The body has already been consumed.');
                assert(!object.locked, 'The stream is locked.');
            }
            return extractBody(object, keepalive);
        }
        function cloneBody(body) {
            const [out1, out2] = body.stream.tee();
            const out2Clone = structuredClone(out2, {
                transfer: [
                    out2
                ]
            });
            const [, finalClone] = out2Clone.tee();
            body.stream = out1;
            return {
                stream: finalClone,
                length: body.length,
                source: body.source
            };
        }
        async function* consumeBody(body) {
            if (body) if (isUint8Array(body)) yield body;
            else {
                const stream = body.stream;
                if (util.isDisturbed(stream)) throw new TypeError('The body has already been consumed.');
                if (stream.locked) throw new TypeError('The stream is locked.');
                stream[kBodyUsed] = true;
                yield* stream;
            }
        }
        function throwIfAborted(state) {
            if (state.aborted) throw new DOMException1('The operation was aborted.', 'AbortError');
        }
        function bodyMixinMethods(instance) {
            const methods = {
                blob () {
                    return specConsumeBody(this, (bytes)=>{
                        let mimeType = bodyMimeType(this);
                        if ('failure' === mimeType) mimeType = '';
                        else if (mimeType) mimeType = serializeAMimeType(mimeType);
                        return new Blob1([
                            bytes
                        ], {
                            type: mimeType
                        });
                    }, instance);
                },
                arrayBuffer () {
                    return specConsumeBody(this, (bytes)=>new Uint8Array(bytes).buffer, instance);
                },
                text () {
                    return specConsumeBody(this, utf8DecodeBytes, instance);
                },
                json () {
                    return specConsumeBody(this, parseJSONFromBytes, instance);
                },
                async formData () {
                    webidl.brandCheck(this, instance);
                    throwIfAborted(this[kState]);
                    const contentType = this.headers.get('Content-Type');
                    if (/multipart\/form-data/.test(contentType)) {
                        const headers = {};
                        for (const [key, value] of this.headers)headers[key.toLowerCase()] = value;
                        const responseFormData = new FormData();
                        let busboy;
                        try {
                            busboy = new Busboy({
                                headers,
                                preservePath: true
                            });
                        } catch (err) {
                            throw new DOMException1(`${err}`, 'AbortError');
                        }
                        busboy.on('field', (name, value)=>{
                            responseFormData.append(name, value);
                        });
                        busboy.on('file', (name, value, filename, encoding, mimeType)=>{
                            const chunks = [];
                            if ('base64' === encoding || 'base64' === encoding.toLowerCase()) {
                                let base64chunk = '';
                                value.on('data', (chunk)=>{
                                    base64chunk += chunk.toString().replace(/[\r\n]/gm, '');
                                    const end = base64chunk.length - base64chunk.length % 4;
                                    chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));
                                    base64chunk = base64chunk.slice(end);
                                });
                                value.on('end', ()=>{
                                    chunks.push(Buffer.from(base64chunk, 'base64'));
                                    responseFormData.append(name, new File(chunks, filename, {
                                        type: mimeType
                                    }));
                                });
                            } else {
                                value.on('data', (chunk)=>{
                                    chunks.push(chunk);
                                });
                                value.on('end', ()=>{
                                    responseFormData.append(name, new File(chunks, filename, {
                                        type: mimeType
                                    }));
                                });
                            }
                        });
                        const busboyResolve = new Promise((resolve, reject)=>{
                            busboy.on('finish', resolve);
                            busboy.on('error', (err)=>reject(new TypeError(err)));
                        });
                        if (null !== this.body) for await (const chunk of consumeBody(this[kState].body))busboy.write(chunk);
                        busboy.end();
                        await busboyResolve;
                        return responseFormData;
                    }
                    if (/application\/x-www-form-urlencoded/.test(contentType)) {
                        let entries;
                        try {
                            let text = '';
                            const streamingDecoder = new TextDecoder('utf-8', {
                                ignoreBOM: true
                            });
                            for await (const chunk of consumeBody(this[kState].body)){
                                if (!isUint8Array(chunk)) throw new TypeError('Expected Uint8Array chunk');
                                text += streamingDecoder.decode(chunk, {
                                    stream: true
                                });
                            }
                            text += streamingDecoder.decode();
                            entries = new URLSearchParams(text);
                        } catch (err) {
                            throw Object.assign(new TypeError(), {
                                cause: err
                            });
                        }
                        const formData = new FormData();
                        for (const [name, value] of entries)formData.append(name, value);
                        return formData;
                    }
                    await Promise.resolve();
                    throwIfAborted(this[kState]);
                    throw webidl.errors.exception({
                        header: `${instance.name}.formData`,
                        message: 'Could not parse content as FormData.'
                    });
                }
            };
            return methods;
        }
        function mixinBody(prototype) {
            Object.assign(prototype.prototype, bodyMixinMethods(prototype));
        }
        async function specConsumeBody(object, convertBytesToJSValue, instance) {
            webidl.brandCheck(object, instance);
            throwIfAborted(object[kState]);
            if (bodyUnusable(object[kState].body)) throw new TypeError('Body is unusable');
            const promise = createDeferredPromise();
            const errorSteps = (error)=>promise.reject(error);
            const successSteps = (data)=>{
                try {
                    promise.resolve(convertBytesToJSValue(data));
                } catch (e) {
                    errorSteps(e);
                }
            };
            if (null == object[kState].body) {
                successSteps(new Uint8Array());
                return promise.promise;
            }
            await fullyReadBody(object[kState].body, successSteps, errorSteps);
            return promise.promise;
        }
        function bodyUnusable(body) {
            return null != body && (body.stream.locked || util.isDisturbed(body.stream));
        }
        function utf8DecodeBytes(buffer) {
            if (0 === buffer.length) return '';
            if (0xEF === buffer[0] && 0xBB === buffer[1] && 0xBF === buffer[2]) buffer = buffer.subarray(3);
            const output = textDecoder.decode(buffer);
            return output;
        }
        function parseJSONFromBytes(bytes) {
            return JSON.parse(utf8DecodeBytes(bytes));
        }
        function bodyMimeType(object) {
            const { headersList } = object[kState];
            const contentType = headersList.get('content-type');
            if (null === contentType) return 'failure';
            return parseMIMEType(contentType);
        }
        module.exports = {
            extractBody,
            safelyExtractBody,
            cloneBody,
            mixinBody
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { MessageChannel, receiveMessageOnPort } = __webpack_require__("worker_threads");
        const corsSafeListedMethods = [
            'GET',
            'HEAD',
            'POST'
        ];
        const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
        const nullBodyStatus = [
            101,
            204,
            205,
            304
        ];
        const redirectStatus = [
            301,
            302,
            303,
            307,
            308
        ];
        const redirectStatusSet = new Set(redirectStatus);
        const badPorts = [
            '1',
            '7',
            '9',
            '11',
            '13',
            '15',
            '17',
            '19',
            '20',
            '21',
            '22',
            '23',
            '25',
            '37',
            '42',
            '43',
            '53',
            '69',
            '77',
            '79',
            '87',
            '95',
            '101',
            '102',
            '103',
            '104',
            '109',
            '110',
            '111',
            '113',
            '115',
            '117',
            '119',
            '123',
            '135',
            '137',
            '139',
            '143',
            '161',
            '179',
            '389',
            '427',
            '465',
            '512',
            '513',
            '514',
            '515',
            '526',
            '530',
            '531',
            '532',
            '540',
            '548',
            '554',
            '556',
            '563',
            '587',
            '601',
            '636',
            '989',
            '990',
            '993',
            '995',
            '1719',
            '1720',
            '1723',
            '2049',
            '3659',
            '4045',
            '5060',
            '5061',
            '6000',
            '6566',
            '6665',
            '6666',
            '6667',
            '6668',
            '6669',
            '6697',
            '10080'
        ];
        const badPortsSet = new Set(badPorts);
        const referrerPolicy = [
            '',
            'no-referrer',
            'no-referrer-when-downgrade',
            'same-origin',
            'origin',
            'strict-origin',
            'origin-when-cross-origin',
            'strict-origin-when-cross-origin',
            'unsafe-url'
        ];
        const referrerPolicySet = new Set(referrerPolicy);
        const requestRedirect = [
            'follow',
            'manual',
            'error'
        ];
        const safeMethods = [
            'GET',
            'HEAD',
            'OPTIONS',
            'TRACE'
        ];
        const safeMethodsSet = new Set(safeMethods);
        const requestMode = [
            'navigate',
            'same-origin',
            'no-cors',
            'cors'
        ];
        const requestCredentials = [
            'omit',
            'same-origin',
            'include'
        ];
        const requestCache = [
            'default',
            'no-store',
            'reload',
            'no-cache',
            'force-cache',
            'only-if-cached'
        ];
        const requestBodyHeader = [
            'content-encoding',
            'content-language',
            'content-location',
            'content-type',
            'content-length'
        ];
        const requestDuplex = [
            'half'
        ];
        const forbiddenMethods = [
            'CONNECT',
            'TRACE',
            'TRACK'
        ];
        const forbiddenMethodsSet = new Set(forbiddenMethods);
        const subresource = [
            'audio',
            'audioworklet',
            'font',
            'image',
            'manifest',
            'paintworklet',
            "script",
            'style',
            'track',
            'video',
            'xslt',
            ''
        ];
        const subresourceSet = new Set(subresource);
        const DOMException1 = globalThis.DOMException ?? (()=>{
            try {
                atob('~');
            } catch (err) {
                return Object.getPrototypeOf(err).constructor;
            }
        })();
        let channel;
        const structuredClone = globalThis.structuredClone ?? function(value, options) {
            if (0 === arguments.length) throw new TypeError('missing argument');
            if (!channel) channel = new MessageChannel();
            channel.port1.unref();
            channel.port2.unref();
            channel.port1.postMessage(value, options?.transfer);
            return receiveMessageOnPort(channel.port2).message;
        };
        module.exports = {
            DOMException: DOMException1,
            structuredClone,
            subresource,
            forbiddenMethods,
            requestBodyHeader,
            referrerPolicy,
            requestRedirect,
            requestMode,
            requestCredentials,
            requestCache,
            redirectStatus,
            corsSafeListedMethods,
            nullBodyStatus,
            safeMethods,
            badPorts,
            requestDuplex,
            subresourceSet,
            badPortsSet,
            redirectStatusSet,
            corsSafeListedMethodsSet,
            safeMethodsSet,
            forbiddenMethodsSet,
            referrerPolicySet
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js" (module, __unused_rspack_exports, __webpack_require__) {
        const assert = __webpack_require__("assert");
        const { atob: atob1 } = __webpack_require__("buffer");
        const { isomorphicDecode } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const encoder = new TextEncoder();
        const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
        const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
        const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
        function dataURLProcessor(dataURL) {
            assert('data:' === dataURL.protocol);
            let input = URLSerializer(dataURL, true);
            input = input.slice(5);
            const position = {
                position: 0
            };
            let mimeType = collectASequenceOfCodePointsFast(',', input, position);
            const mimeTypeLength = mimeType.length;
            mimeType = removeASCIIWhitespace(mimeType, true, true);
            if (position.position >= input.length) return 'failure';
            position.position++;
            const encodedBody = input.slice(mimeTypeLength + 1);
            let body = stringPercentDecode(encodedBody);
            if (/;(\u0020){0,}base64$/i.test(mimeType)) {
                const stringBody = isomorphicDecode(body);
                body = forgivingBase64(stringBody);
                if ('failure' === body) return 'failure';
                mimeType = mimeType.slice(0, -6);
                mimeType = mimeType.replace(/(\u0020)+$/, '');
                mimeType = mimeType.slice(0, -1);
            }
            if (mimeType.startsWith(';')) mimeType = 'text/plain' + mimeType;
            let mimeTypeRecord = parseMIMEType(mimeType);
            if ('failure' === mimeTypeRecord) mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');
            return {
                mimeType: mimeTypeRecord,
                body
            };
        }
        function URLSerializer(url, excludeFragment = false) {
            if (!excludeFragment) return url.href;
            const href = url.href;
            const hashLength = url.hash.length;
            return 0 === hashLength ? href : href.substring(0, href.length - hashLength);
        }
        function collectASequenceOfCodePoints(condition, input, position) {
            let result = '';
            while(position.position < input.length && condition(input[position.position])){
                result += input[position.position];
                position.position++;
            }
            return result;
        }
        function collectASequenceOfCodePointsFast(char, input, position) {
            const idx = input.indexOf(char, position.position);
            const start = position.position;
            if (-1 === idx) {
                position.position = input.length;
                return input.slice(start);
            }
            position.position = idx;
            return input.slice(start, position.position);
        }
        function stringPercentDecode(input) {
            const bytes = encoder.encode(input);
            return percentDecode(bytes);
        }
        function percentDecode(input) {
            const output = [];
            for(let i = 0; i < input.length; i++){
                const byte = input[i];
                if (0x25 !== byte) output.push(byte);
                else if (0x25 !== byte || /^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
                    const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
                    const bytePoint = Number.parseInt(nextTwoBytes, 16);
                    output.push(bytePoint);
                    i += 2;
                } else output.push(0x25);
            }
            return Uint8Array.from(output);
        }
        function parseMIMEType(input) {
            input = removeHTTPWhitespace(input, true, true);
            const position = {
                position: 0
            };
            const type = collectASequenceOfCodePointsFast('/', input, position);
            if (0 === type.length || !HTTP_TOKEN_CODEPOINTS.test(type)) return 'failure';
            if (position.position > input.length) return 'failure';
            position.position++;
            let subtype = collectASequenceOfCodePointsFast(';', input, position);
            subtype = removeHTTPWhitespace(subtype, false, true);
            if (0 === subtype.length || !HTTP_TOKEN_CODEPOINTS.test(subtype)) return 'failure';
            const typeLowercase = type.toLowerCase();
            const subtypeLowercase = subtype.toLowerCase();
            const mimeType = {
                type: typeLowercase,
                subtype: subtypeLowercase,
                parameters: new Map(),
                essence: `${typeLowercase}/${subtypeLowercase}`
            };
            while(position.position < input.length){
                position.position++;
                collectASequenceOfCodePoints((char)=>HTTP_WHITESPACE_REGEX.test(char), input, position);
                let parameterName = collectASequenceOfCodePoints((char)=>';' !== char && '=' !== char, input, position);
                parameterName = parameterName.toLowerCase();
                if (position.position < input.length) {
                    if (';' === input[position.position]) continue;
                    position.position++;
                }
                if (position.position > input.length) break;
                let parameterValue = null;
                if ('"' === input[position.position]) {
                    parameterValue = collectAnHTTPQuotedString(input, position, true);
                    collectASequenceOfCodePointsFast(';', input, position);
                } else {
                    parameterValue = collectASequenceOfCodePointsFast(';', input, position);
                    parameterValue = removeHTTPWhitespace(parameterValue, false, true);
                    if (0 === parameterValue.length) continue;
                }
                if (0 !== parameterName.length && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (0 === parameterValue.length || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) mimeType.parameters.set(parameterName, parameterValue);
            }
            return mimeType;
        }
        function forgivingBase64(data) {
            data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, '');
            if (data.length % 4 === 0) data = data.replace(/=?=$/, '');
            if (data.length % 4 === 1) return 'failure';
            if (/[^+/0-9A-Za-z]/.test(data)) return 'failure';
            const binary = atob1(data);
            const bytes = new Uint8Array(binary.length);
            for(let byte = 0; byte < binary.length; byte++)bytes[byte] = binary.charCodeAt(byte);
            return bytes;
        }
        function collectAnHTTPQuotedString(input, position, extractValue) {
            const positionStart = position.position;
            let value = '';
            assert('"' === input[position.position]);
            position.position++;
            while(true){
                value += collectASequenceOfCodePoints((char)=>'"' !== char && '\\' !== char, input, position);
                if (position.position >= input.length) break;
                const quoteOrBackslash = input[position.position];
                position.position++;
                if ('\\' === quoteOrBackslash) {
                    if (position.position >= input.length) {
                        value += '\\';
                        break;
                    }
                    value += input[position.position];
                    position.position++;
                } else {
                    assert('"' === quoteOrBackslash);
                    break;
                }
            }
            if (extractValue) return value;
            return input.slice(positionStart, position.position);
        }
        function serializeAMimeType(mimeType) {
            assert('failure' !== mimeType);
            const { parameters, essence } = mimeType;
            let serialization = essence;
            for (let [name, value] of parameters.entries()){
                serialization += ';';
                serialization += name;
                serialization += '=';
                if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
                    value = value.replace(/(\\|")/g, '\\$1');
                    value = '"' + value;
                    value += '"';
                }
                serialization += value;
            }
            return serialization;
        }
        function isHTTPWhiteSpace(char) {
            return '\r' === char || '\n' === char || '\t' === char || ' ' === char;
        }
        function removeHTTPWhitespace(str, leading = true, trailing = true) {
            let lead = 0;
            let trail = str.length - 1;
            if (leading) for(; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
            if (trailing) for(; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
            return str.slice(lead, trail + 1);
        }
        function isASCIIWhitespace(char) {
            return '\r' === char || '\n' === char || '\t' === char || '\f' === char || ' ' === char;
        }
        function removeASCIIWhitespace(str, leading = true, trailing = true) {
            let lead = 0;
            let trail = str.length - 1;
            if (leading) for(; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
            if (trailing) for(; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
            return str.slice(lead, trail + 1);
        }
        module.exports = {
            dataURLProcessor,
            URLSerializer,
            collectASequenceOfCodePoints,
            collectASequenceOfCodePointsFast,
            stringPercentDecode,
            parseMIMEType,
            collectAnHTTPQuotedString,
            serializeAMimeType
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/file.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Blob: Blob1, File: NativeFile } = __webpack_require__("buffer");
        const { types } = __webpack_require__("util");
        const { kState } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js");
        const { isBlobLike } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { parseMIMEType, serializeAMimeType } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const encoder = new TextEncoder();
        class File extends Blob1 {
            constructor(fileBits, fileName, options = {}){
                webidl.argumentLengthCheck(arguments, 2, {
                    header: 'File constructor'
                });
                fileBits = webidl.converters['sequence<BlobPart>'](fileBits);
                fileName = webidl.converters.USVString(fileName);
                options = webidl.converters.FilePropertyBag(options);
                const n = fileName;
                let t = options.type;
                let d;
                substep: {
                    if (t) {
                        t = parseMIMEType(t);
                        if ('failure' === t) {
                            t = '';
                            break substep;
                        }
                        t = serializeAMimeType(t).toLowerCase();
                    }
                    d = options.lastModified;
                }
                super(processBlobParts(fileBits, options), {
                    type: t
                });
                this[kState] = {
                    name: n,
                    lastModified: d,
                    type: t
                };
            }
            get name() {
                webidl.brandCheck(this, File);
                return this[kState].name;
            }
            get lastModified() {
                webidl.brandCheck(this, File);
                return this[kState].lastModified;
            }
            get type() {
                webidl.brandCheck(this, File);
                return this[kState].type;
            }
        }
        class FileLike {
            constructor(blobLike, fileName, options = {}){
                const n = fileName;
                const t = options.type;
                const d = options.lastModified ?? Date.now();
                this[kState] = {
                    blobLike,
                    name: n,
                    type: t,
                    lastModified: d
                };
            }
            stream(...args) {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.stream(...args);
            }
            arrayBuffer(...args) {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.arrayBuffer(...args);
            }
            slice(...args) {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.slice(...args);
            }
            text(...args) {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.text(...args);
            }
            get size() {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.size;
            }
            get type() {
                webidl.brandCheck(this, FileLike);
                return this[kState].blobLike.type;
            }
            get name() {
                webidl.brandCheck(this, FileLike);
                return this[kState].name;
            }
            get lastModified() {
                webidl.brandCheck(this, FileLike);
                return this[kState].lastModified;
            }
            get [Symbol.toStringTag]() {
                return 'File';
            }
        }
        Object.defineProperties(File.prototype, {
            [Symbol.toStringTag]: {
                value: 'File',
                configurable: true
            },
            name: kEnumerableProperty,
            lastModified: kEnumerableProperty
        });
        webidl.converters.Blob = webidl.interfaceConverter(Blob1);
        webidl.converters.BlobPart = function(V, opts) {
            if ('Object' === webidl.util.Type(V)) {
                if (isBlobLike(V)) return webidl.converters.Blob(V, {
                    strict: false
                });
                if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) return webidl.converters.BufferSource(V, opts);
            }
            return webidl.converters.USVString(V, opts);
        };
        webidl.converters['sequence<BlobPart>'] = webidl.sequenceConverter(webidl.converters.BlobPart);
        webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
            {
                key: 'lastModified',
                converter: webidl.converters['long long'],
                get defaultValue () {
                    return Date.now();
                }
            },
            {
                key: 'type',
                converter: webidl.converters.DOMString,
                defaultValue: ''
            },
            {
                key: 'endings',
                converter: (value)=>{
                    value = webidl.converters.DOMString(value);
                    value = value.toLowerCase();
                    if ('native' !== value) value = 'transparent';
                    return value;
                },
                defaultValue: 'transparent'
            }
        ]);
        function processBlobParts(parts, options) {
            const bytes = [];
            for (const element of parts)if ('string' == typeof element) {
                let s = element;
                if ('native' === options.endings) s = convertLineEndingsNative(s);
                bytes.push(encoder.encode(s));
            } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) if (element.buffer) bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
            else bytes.push(new Uint8Array(element));
            else if (isBlobLike(element)) bytes.push(element);
            return bytes;
        }
        function convertLineEndingsNative(s) {
            let nativeLineEnding = '\n';
            if ('win32' === process.platform) nativeLineEnding = '\r\n';
            return s.replace(/\r?\n/g, nativeLineEnding);
        }
        function isFileLike(object) {
            return NativeFile && object instanceof NativeFile || object instanceof File || object && ('function' == typeof object.stream || 'function' == typeof object.arrayBuffer) && 'File' === object[Symbol.toStringTag];
        }
        module.exports = {
            File,
            FileLike,
            isFileLike
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/formdata.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { isBlobLike, toUSVString, makeIterator } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const { kState } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js");
        const { File: UndiciFile, FileLike, isFileLike } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/file.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { Blob: Blob1, File: NativeFile } = __webpack_require__("buffer");
        const File = NativeFile ?? UndiciFile;
        class FormData {
            constructor(form){
                if (void 0 !== form) throw webidl.errors.conversionFailed({
                    prefix: 'FormData constructor',
                    argument: 'Argument 1',
                    types: [
                        'undefined'
                    ]
                });
                this[kState] = [];
            }
            append(name, value, filename) {
                webidl.brandCheck(this, FormData);
                webidl.argumentLengthCheck(arguments, 2, {
                    header: 'FormData.append'
                });
                if (3 === arguments.length && !isBlobLike(value)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
                name = webidl.converters.USVString(name);
                value = isBlobLike(value) ? webidl.converters.Blob(value, {
                    strict: false
                }) : webidl.converters.USVString(value);
                filename = 3 === arguments.length ? webidl.converters.USVString(filename) : void 0;
                const entry = makeEntry(name, value, filename);
                this[kState].push(entry);
            }
            delete(name) {
                webidl.brandCheck(this, FormData);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'FormData.delete'
                });
                name = webidl.converters.USVString(name);
                this[kState] = this[kState].filter((entry)=>entry.name !== name);
            }
            get(name) {
                webidl.brandCheck(this, FormData);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'FormData.get'
                });
                name = webidl.converters.USVString(name);
                const idx = this[kState].findIndex((entry)=>entry.name === name);
                if (-1 === idx) return null;
                return this[kState][idx].value;
            }
            getAll(name) {
                webidl.brandCheck(this, FormData);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'FormData.getAll'
                });
                name = webidl.converters.USVString(name);
                return this[kState].filter((entry)=>entry.name === name).map((entry)=>entry.value);
            }
            has(name) {
                webidl.brandCheck(this, FormData);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'FormData.has'
                });
                name = webidl.converters.USVString(name);
                return -1 !== this[kState].findIndex((entry)=>entry.name === name);
            }
            set(name, value, filename) {
                webidl.brandCheck(this, FormData);
                webidl.argumentLengthCheck(arguments, 2, {
                    header: 'FormData.set'
                });
                if (3 === arguments.length && !isBlobLike(value)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
                name = webidl.converters.USVString(name);
                value = isBlobLike(value) ? webidl.converters.Blob(value, {
                    strict: false
                }) : webidl.converters.USVString(value);
                filename = 3 === arguments.length ? toUSVString(filename) : void 0;
                const entry = makeEntry(name, value, filename);
                const idx = this[kState].findIndex((entry)=>entry.name === name);
                if (-1 !== idx) this[kState] = [
                    ...this[kState].slice(0, idx),
                    entry,
                    ...this[kState].slice(idx + 1).filter((entry)=>entry.name !== name)
                ];
                else this[kState].push(entry);
            }
            entries() {
                webidl.brandCheck(this, FormData);
                return makeIterator(()=>this[kState].map((pair)=>[
                            pair.name,
                            pair.value
                        ]), 'FormData', 'key+value');
            }
            keys() {
                webidl.brandCheck(this, FormData);
                return makeIterator(()=>this[kState].map((pair)=>[
                            pair.name,
                            pair.value
                        ]), 'FormData', 'key');
            }
            values() {
                webidl.brandCheck(this, FormData);
                return makeIterator(()=>this[kState].map((pair)=>[
                            pair.name,
                            pair.value
                        ]), 'FormData', 'value');
            }
            forEach(callbackFn, thisArg = globalThis) {
                webidl.brandCheck(this, FormData);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'FormData.forEach'
                });
                if ('function' != typeof callbackFn) throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
                for (const [key, value] of this)callbackFn.apply(thisArg, [
                    value,
                    key,
                    this
                ]);
            }
        }
        FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
        Object.defineProperties(FormData.prototype, {
            [Symbol.toStringTag]: {
                value: 'FormData',
                configurable: true
            }
        });
        function makeEntry(name, value, filename) {
            name = Buffer.from(name).toString('utf8');
            if ('string' == typeof value) value = Buffer.from(value).toString('utf8');
            else {
                if (!isFileLike(value)) value = value instanceof Blob1 ? new File([
                    value
                ], 'blob', {
                    type: value.type
                }) : new FileLike(value, 'blob', {
                    type: value.type
                });
                if (void 0 !== filename) {
                    const options = {
                        type: value.type,
                        lastModified: value.lastModified
                    };
                    value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([
                        value
                    ], filename, options) : new FileLike(value, filename, options);
                }
            }
            return {
                name,
                value
            };
        }
        module.exports = {
            FormData
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js" (module) {
        "use strict";
        const globalOrigin = Symbol.for('undici.globalOrigin.1');
        function getGlobalOrigin() {
            return globalThis[globalOrigin];
        }
        function setGlobalOrigin(newOrigin) {
            if (void 0 === newOrigin) return void Object.defineProperty(globalThis, globalOrigin, {
                value: void 0,
                writable: true,
                enumerable: false,
                configurable: false
            });
            const parsedURL = new URL(newOrigin);
            if ('http:' !== parsedURL.protocol && 'https:' !== parsedURL.protocol) throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
            Object.defineProperty(globalThis, globalOrigin, {
                value: parsedURL,
                writable: true,
                enumerable: false,
                configurable: false
            });
        }
        module.exports = {
            getGlobalOrigin,
            setGlobalOrigin
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kHeadersList, kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const { kGuard } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { makeIterator, isValidHeaderName, isValidHeaderValue } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const util = __webpack_require__("util");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const assert = __webpack_require__("assert");
        const kHeadersMap = Symbol('headers map');
        const kHeadersSortedMap = Symbol('headers map sorted');
        function isHTTPWhiteSpaceCharCode(code) {
            return 0x00a === code || 0x00d === code || 0x009 === code || 0x020 === code;
        }
        function headerValueNormalize(potentialValue) {
            let i = 0;
            let j = potentialValue.length;
            while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))--j;
            while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))++i;
            return 0 === i && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
        }
        function fill(headers, object) {
            if (Array.isArray(object)) for(let i = 0; i < object.length; ++i){
                const header = object[i];
                if (2 !== header.length) throw webidl.errors.exception({
                    header: 'Headers constructor',
                    message: `expected name/value pair to be length 2, found ${header.length}.`
                });
                appendHeader(headers, header[0], header[1]);
            }
            else if ('object' == typeof object && null !== object) {
                const keys = Object.keys(object);
                for(let i = 0; i < keys.length; ++i)appendHeader(headers, keys[i], object[keys[i]]);
            } else throw webidl.errors.conversionFailed({
                prefix: 'Headers constructor',
                argument: 'Argument 1',
                types: [
                    'sequence<sequence<ByteString>>',
                    'record<ByteString, ByteString>'
                ]
            });
        }
        function appendHeader(headers, name, value) {
            value = headerValueNormalize(value);
            if (isValidHeaderName(name)) {
                if (!isValidHeaderValue(value)) throw webidl.errors.invalidArgument({
                    prefix: 'Headers.append',
                    value,
                    type: 'header value'
                });
            } else throw webidl.errors.invalidArgument({
                prefix: 'Headers.append',
                value: name,
                type: 'header name'
            });
            if ('immutable' === headers[kGuard]) throw new TypeError('immutable');
            headers[kGuard];
            return headers[kHeadersList].append(name, value);
        }
        class HeadersList {
            cookies = null;
            constructor(init){
                if (init instanceof HeadersList) {
                    this[kHeadersMap] = new Map(init[kHeadersMap]);
                    this[kHeadersSortedMap] = init[kHeadersSortedMap];
                    this.cookies = null === init.cookies ? null : [
                        ...init.cookies
                    ];
                } else {
                    this[kHeadersMap] = new Map(init);
                    this[kHeadersSortedMap] = null;
                }
            }
            contains(name) {
                name = name.toLowerCase();
                return this[kHeadersMap].has(name);
            }
            clear() {
                this[kHeadersMap].clear();
                this[kHeadersSortedMap] = null;
                this.cookies = null;
            }
            append(name, value) {
                this[kHeadersSortedMap] = null;
                const lowercaseName = name.toLowerCase();
                const exists = this[kHeadersMap].get(lowercaseName);
                if (exists) {
                    const delimiter = 'cookie' === lowercaseName ? '; ' : ', ';
                    this[kHeadersMap].set(lowercaseName, {
                        name: exists.name,
                        value: `${exists.value}${delimiter}${value}`
                    });
                } else this[kHeadersMap].set(lowercaseName, {
                    name,
                    value
                });
                if ('set-cookie' === lowercaseName) {
                    this.cookies ??= [];
                    this.cookies.push(value);
                }
            }
            set(name, value) {
                this[kHeadersSortedMap] = null;
                const lowercaseName = name.toLowerCase();
                if ('set-cookie' === lowercaseName) this.cookies = [
                    value
                ];
                this[kHeadersMap].set(lowercaseName, {
                    name,
                    value
                });
            }
            delete(name) {
                this[kHeadersSortedMap] = null;
                name = name.toLowerCase();
                if ('set-cookie' === name) this.cookies = null;
                this[kHeadersMap].delete(name);
            }
            get(name) {
                const value = this[kHeadersMap].get(name.toLowerCase());
                return void 0 === value ? null : value.value;
            }
            *[Symbol.iterator]() {
                for (const [name, { value }] of this[kHeadersMap])yield [
                    name,
                    value
                ];
            }
            get entries() {
                const headers = {};
                if (this[kHeadersMap].size) for (const { name, value } of this[kHeadersMap].values())headers[name] = value;
                return headers;
            }
        }
        class Headers {
            constructor(init){
                if (init === kConstruct) return;
                this[kHeadersList] = new HeadersList();
                this[kGuard] = 'none';
                if (void 0 !== init) {
                    init = webidl.converters.HeadersInit(init);
                    fill(this, init);
                }
            }
            append(name, value) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 2, {
                    header: 'Headers.append'
                });
                name = webidl.converters.ByteString(name);
                value = webidl.converters.ByteString(value);
                return appendHeader(this, name, value);
            }
            delete(name) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Headers.delete'
                });
                name = webidl.converters.ByteString(name);
                if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
                    prefix: 'Headers.delete',
                    value: name,
                    type: 'header name'
                });
                if ('immutable' === this[kGuard]) throw new TypeError('immutable');
                this[kGuard];
                if (!this[kHeadersList].contains(name)) return;
                this[kHeadersList].delete(name);
            }
            get(name) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Headers.get'
                });
                name = webidl.converters.ByteString(name);
                if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
                    prefix: 'Headers.get',
                    value: name,
                    type: 'header name'
                });
                return this[kHeadersList].get(name);
            }
            has(name) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Headers.has'
                });
                name = webidl.converters.ByteString(name);
                if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
                    prefix: 'Headers.has',
                    value: name,
                    type: 'header name'
                });
                return this[kHeadersList].contains(name);
            }
            set(name, value) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 2, {
                    header: 'Headers.set'
                });
                name = webidl.converters.ByteString(name);
                value = webidl.converters.ByteString(value);
                value = headerValueNormalize(value);
                if (isValidHeaderName(name)) {
                    if (!isValidHeaderValue(value)) throw webidl.errors.invalidArgument({
                        prefix: 'Headers.set',
                        value,
                        type: 'header value'
                    });
                } else throw webidl.errors.invalidArgument({
                    prefix: 'Headers.set',
                    value: name,
                    type: 'header name'
                });
                if ('immutable' === this[kGuard]) throw new TypeError('immutable');
                this[kGuard];
                this[kHeadersList].set(name, value);
            }
            getSetCookie() {
                webidl.brandCheck(this, Headers);
                const list = this[kHeadersList].cookies;
                if (list) return [
                    ...list
                ];
                return [];
            }
            get [kHeadersSortedMap]() {
                if (this[kHeadersList][kHeadersSortedMap]) return this[kHeadersList][kHeadersSortedMap];
                const headers = [];
                const names = [
                    ...this[kHeadersList]
                ].sort((a, b)=>a[0] < b[0] ? -1 : 1);
                const cookies = this[kHeadersList].cookies;
                for(let i = 0; i < names.length; ++i){
                    const [name, value] = names[i];
                    if ('set-cookie' === name) for(let j = 0; j < cookies.length; ++j)headers.push([
                        name,
                        cookies[j]
                    ]);
                    else {
                        assert(null !== value);
                        headers.push([
                            name,
                            value
                        ]);
                    }
                }
                this[kHeadersList][kHeadersSortedMap] = headers;
                return headers;
            }
            keys() {
                webidl.brandCheck(this, Headers);
                if ('immutable' === this[kGuard]) {
                    const value = this[kHeadersSortedMap];
                    return makeIterator(()=>value, 'Headers', 'key');
                }
                return makeIterator(()=>[
                        ...this[kHeadersSortedMap].values()
                    ], 'Headers', 'key');
            }
            values() {
                webidl.brandCheck(this, Headers);
                if ('immutable' === this[kGuard]) {
                    const value = this[kHeadersSortedMap];
                    return makeIterator(()=>value, 'Headers', 'value');
                }
                return makeIterator(()=>[
                        ...this[kHeadersSortedMap].values()
                    ], 'Headers', 'value');
            }
            entries() {
                webidl.brandCheck(this, Headers);
                if ('immutable' === this[kGuard]) {
                    const value = this[kHeadersSortedMap];
                    return makeIterator(()=>value, 'Headers', 'key+value');
                }
                return makeIterator(()=>[
                        ...this[kHeadersSortedMap].values()
                    ], 'Headers', 'key+value');
            }
            forEach(callbackFn, thisArg = globalThis) {
                webidl.brandCheck(this, Headers);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Headers.forEach'
                });
                if ('function' != typeof callbackFn) throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
                for (const [key, value] of this)callbackFn.apply(thisArg, [
                    value,
                    key,
                    this
                ]);
            }
            [Symbol.for('nodejs.util.inspect.custom')]() {
                webidl.brandCheck(this, Headers);
                return this[kHeadersList];
            }
        }
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        Object.defineProperties(Headers.prototype, {
            append: kEnumerableProperty,
            delete: kEnumerableProperty,
            get: kEnumerableProperty,
            has: kEnumerableProperty,
            set: kEnumerableProperty,
            getSetCookie: kEnumerableProperty,
            keys: kEnumerableProperty,
            values: kEnumerableProperty,
            entries: kEnumerableProperty,
            forEach: kEnumerableProperty,
            [Symbol.iterator]: {
                enumerable: false
            },
            [Symbol.toStringTag]: {
                value: 'Headers',
                configurable: true
            },
            [util.inspect.custom]: {
                enumerable: false
            }
        });
        webidl.converters.HeadersInit = function(V) {
            if ('Object' === webidl.util.Type(V)) {
                if (V[Symbol.iterator]) return webidl.converters['sequence<sequence<ByteString>>'](V);
                return webidl.converters['record<ByteString, ByteString>'](V);
            }
            throw webidl.errors.conversionFailed({
                prefix: 'Headers constructor',
                argument: 'Argument 1',
                types: [
                    'sequence<sequence<ByteString>>',
                    'record<ByteString, ByteString>'
                ]
            });
        };
        module.exports = {
            fill,
            Headers,
            HeadersList
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Response, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/response.js");
        const { Headers } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js");
        const { Request, makeRequest } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/request.js");
        const zlib = __webpack_require__("zlib");
        const { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise, isBlobLike, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme, urlHasHttpsScheme } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const { kState, kHeaders, kGuard, kRealm } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js");
        const assert = __webpack_require__("assert");
        const { safelyExtractBody } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js");
        const { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet, DOMException: DOMException1 } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js");
        const { kHeadersList } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const EE = __webpack_require__("events");
        const { Readable, pipeline } = __webpack_require__("stream");
        const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { dataURLProcessor, serializeAMimeType } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
        const { TransformStream } = __webpack_require__("stream/web");
        const { getGlobalDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { STATUS_CODES } = __webpack_require__("http");
        const GET_OR_HEAD = [
            'GET',
            'HEAD'
        ];
        let resolveObjectURL;
        let ReadableStream = globalThis.ReadableStream;
        class Fetch extends EE {
            constructor(dispatcher){
                super();
                this.dispatcher = dispatcher;
                this.connection = null;
                this.dump = false;
                this.state = 'ongoing';
                this.setMaxListeners(21);
            }
            terminate(reason) {
                if ('ongoing' !== this.state) return;
                this.state = 'terminated';
                this.connection?.destroy(reason);
                this.emit('terminated', reason);
            }
            abort(error) {
                if ('ongoing' !== this.state) return;
                this.state = 'aborted';
                if (!error) error = new DOMException1('The operation was aborted.', 'AbortError');
                this.serializedAbortReason = error;
                this.connection?.destroy(error);
                this.emit('terminated', error);
            }
        }
        function fetch(input, init = {}) {
            webidl.argumentLengthCheck(arguments, 1, {
                header: 'globalThis.fetch'
            });
            const p = createDeferredPromise();
            let requestObject;
            try {
                requestObject = new Request(input, init);
            } catch (e) {
                p.reject(e);
                return p.promise;
            }
            const request = requestObject[kState];
            if (requestObject.signal.aborted) {
                abortFetch(p, request, null, requestObject.signal.reason);
                return p.promise;
            }
            const globalObject = request.client.globalObject;
            if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') request.serviceWorkers = 'none';
            let responseObject = null;
            const relevantRealm = null;
            let locallyAborted = false;
            let controller = null;
            addAbortListener(requestObject.signal, ()=>{
                locallyAborted = true;
                assert(null != controller);
                controller.abort(requestObject.signal.reason);
                abortFetch(p, request, responseObject, requestObject.signal.reason);
            });
            const handleFetchDone = (response)=>finalizeAndReportTiming(response, 'fetch');
            const processResponse = (response)=>{
                if (locallyAborted) return Promise.resolve();
                if (response.aborted) {
                    abortFetch(p, request, responseObject, controller.serializedAbortReason);
                    return Promise.resolve();
                }
                if ('error' === response.type) {
                    p.reject(Object.assign(new TypeError('fetch failed'), {
                        cause: response.error
                    }));
                    return Promise.resolve();
                }
                responseObject = new Response();
                responseObject[kState] = response;
                responseObject[kRealm] = relevantRealm;
                responseObject[kHeaders][kHeadersList] = response.headersList;
                responseObject[kHeaders][kGuard] = 'immutable';
                responseObject[kHeaders][kRealm] = relevantRealm;
                p.resolve(responseObject);
            };
            controller = fetching({
                request,
                processResponseEndOfBody: handleFetchDone,
                processResponse,
                dispatcher: init.dispatcher ?? getGlobalDispatcher()
            });
            return p.promise;
        }
        function finalizeAndReportTiming(response, initiatorType = 'other') {
            if ('error' === response.type && response.aborted) return;
            if (!response.urlList?.length) return;
            const originalURL = response.urlList[0];
            let timingInfo = response.timingInfo;
            let cacheState = response.cacheState;
            if (!urlIsHttpHttpsScheme(originalURL)) return;
            if (null === timingInfo) return;
            if (!response.timingAllowPassed) {
                timingInfo = createOpaqueTimingInfo({
                    startTime: timingInfo.startTime
                });
                cacheState = '';
            }
            timingInfo.endTime = coarsenedSharedCurrentTime();
            response.timingInfo = timingInfo;
            markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
        }
        function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis1, cacheState) {
            if (nodeMajor > 18 || 18 === nodeMajor && nodeMinor >= 2) performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis1, cacheState);
        }
        function abortFetch(p, request, responseObject, error) {
            if (!error) error = new DOMException1('The operation was aborted.', 'AbortError');
            p.reject(error);
            if (null != request.body && isReadable(request.body?.stream)) request.body.stream.cancel(error).catch((err)=>{
                if ('ERR_INVALID_STATE' === err.code) return;
                throw err;
            });
            if (null == responseObject) return;
            const response = responseObject[kState];
            if (null != response.body && isReadable(response.body?.stream)) response.body.stream.cancel(error).catch((err)=>{
                if ('ERR_INVALID_STATE' === err.code) return;
                throw err;
            });
        }
        function fetching({ request, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher }) {
            let taskDestination = null;
            let crossOriginIsolatedCapability = false;
            if (null != request.client) {
                taskDestination = request.client.globalObject;
                crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
            }
            const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
            const timingInfo = createOpaqueTimingInfo({
                startTime: currenTime
            });
            const fetchParams = {
                controller: new Fetch(dispatcher),
                request,
                timingInfo,
                processRequestBodyChunkLength,
                processRequestEndOfBody,
                processResponse,
                processResponseConsumeBody,
                processResponseEndOfBody,
                taskDestination,
                crossOriginIsolatedCapability
            };
            assert(!request.body || request.body.stream);
            if ('client' === request.window) request.window = request.client?.globalObject?.constructor?.name === 'Window' ? request.client : 'no-window';
            if ('client' === request.origin) request.origin = request.client?.origin;
            if ('client' === request.policyContainer) if (null != request.client) request.policyContainer = clonePolicyContainer(request.client.policyContainer);
            else request.policyContainer = makePolicyContainer();
            if (!request.headersList.contains('accept')) {
                const value = '*/*';
                request.headersList.append('accept', value);
            }
            if (!request.headersList.contains('accept-language')) request.headersList.append('accept-language', '*');
            request.priority;
            subresourceSet.has(request.destination);
            mainFetch(fetchParams).catch((err)=>{
                fetchParams.controller.terminate(err);
            });
            return fetchParams.controller;
        }
        async function mainFetch(fetchParams, recursive = false) {
            const request = fetchParams.request;
            let response = null;
            if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) response = makeNetworkError('local URLs only');
            tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
            if ('blocked' === requestBadPort(request)) response = makeNetworkError('bad port');
            if ('' === request.referrerPolicy) request.referrerPolicy = request.policyContainer.referrerPolicy;
            if ('no-referrer' !== request.referrer) request.referrer = determineRequestsReferrer(request);
            if (null === response) response = await (async ()=>{
                const currentURL = requestCurrentURL(request);
                if (sameOrigin(currentURL, request.url) && 'basic' === request.responseTainting || 'data:' === currentURL.protocol || 'navigate' === request.mode || 'websocket' === request.mode) {
                    request.responseTainting = 'basic';
                    return await schemeFetch(fetchParams);
                }
                if ('same-origin' === request.mode) return makeNetworkError('request mode cannot be "same-origin"');
                if ('no-cors' === request.mode) {
                    if ('follow' !== request.redirect) return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
                    request.responseTainting = 'opaque';
                    return await schemeFetch(fetchParams);
                }
                if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) return makeNetworkError('URL scheme must be a HTTP(S) scheme');
                request.responseTainting = 'cors';
                return await httpFetch(fetchParams);
            })();
            if (recursive) return response;
            if (0 !== response.status && !response.internalResponse) {
                request.responseTainting;
                if ('basic' === request.responseTainting) response = filterResponse(response, 'basic');
                else if ('cors' === request.responseTainting) response = filterResponse(response, 'cors');
                else if ('opaque' === request.responseTainting) response = filterResponse(response, 'opaque');
                else assert(false);
            }
            let internalResponse = 0 === response.status ? response : response.internalResponse;
            if (0 === internalResponse.urlList.length) internalResponse.urlList.push(...request.urlList);
            if (!request.timingAllowFailed) response.timingAllowPassed = true;
            if ('opaque' === response.type && 206 === internalResponse.status && internalResponse.rangeRequested && !request.headers.contains('range')) response = internalResponse = makeNetworkError();
            if (0 !== response.status && ('HEAD' === request.method || 'CONNECT' === request.method || nullBodyStatus.includes(internalResponse.status))) {
                internalResponse.body = null;
                fetchParams.controller.dump = true;
            }
            if (request.integrity) {
                const processBodyError = (reason)=>fetchFinale(fetchParams, makeNetworkError(reason));
                if ('opaque' === request.responseTainting || null == response.body) return void processBodyError(response.error);
                const processBody = (bytes)=>{
                    if (!bytesMatch(bytes, request.integrity)) return void processBodyError('integrity mismatch');
                    response.body = safelyExtractBody(bytes)[0];
                    fetchFinale(fetchParams, response);
                };
                await fullyReadBody(response.body, processBody, processBodyError);
            } else fetchFinale(fetchParams, response);
        }
        function schemeFetch(fetchParams) {
            if (isCancelled(fetchParams) && 0 === fetchParams.request.redirectCount) return Promise.resolve(makeAppropriateNetworkError(fetchParams));
            const { request } = fetchParams;
            const { protocol: scheme } = requestCurrentURL(request);
            switch(scheme){
                case 'about:':
                    return Promise.resolve(makeNetworkError('about scheme is not supported'));
                case 'blob:':
                    {
                        if (!resolveObjectURL) resolveObjectURL = __webpack_require__("buffer").resolveObjectURL;
                        const blobURLEntry = requestCurrentURL(request);
                        if (0 !== blobURLEntry.search.length) return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'));
                        const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
                        if ('GET' !== request.method || !isBlobLike(blobURLEntryObject)) return Promise.resolve(makeNetworkError('invalid method'));
                        const bodyWithType = safelyExtractBody(blobURLEntryObject);
                        const body = bodyWithType[0];
                        const length = isomorphicEncode(`${body.length}`);
                        const type = bodyWithType[1] ?? '';
                        const response = makeResponse({
                            statusText: 'OK',
                            headersList: [
                                [
                                    'content-length',
                                    {
                                        name: 'Content-Length',
                                        value: length
                                    }
                                ],
                                [
                                    'content-type',
                                    {
                                        name: 'Content-Type',
                                        value: type
                                    }
                                ]
                            ]
                        });
                        response.body = body;
                        return Promise.resolve(response);
                    }
                case 'data:':
                    {
                        const currentURL = requestCurrentURL(request);
                        const dataURLStruct = dataURLProcessor(currentURL);
                        if ('failure' === dataURLStruct) return Promise.resolve(makeNetworkError('failed to fetch the data URL'));
                        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
                        return Promise.resolve(makeResponse({
                            statusText: 'OK',
                            headersList: [
                                [
                                    'content-type',
                                    {
                                        name: 'Content-Type',
                                        value: mimeType
                                    }
                                ]
                            ],
                            body: safelyExtractBody(dataURLStruct.body)[0]
                        }));
                    }
                case 'file:':
                    return Promise.resolve(makeNetworkError('not implemented... yet...'));
                case 'http:':
                case 'https:':
                    return httpFetch(fetchParams).catch((err)=>makeNetworkError(err));
                default:
                    return Promise.resolve(makeNetworkError('unknown scheme'));
            }
        }
        function finalizeResponse(fetchParams, response) {
            fetchParams.request.done = true;
            if (null != fetchParams.processResponseDone) queueMicrotask(()=>fetchParams.processResponseDone(response));
        }
        function fetchFinale(fetchParams, response) {
            if ('error' === response.type) {
                response.urlList = [
                    fetchParams.request.urlList[0]
                ];
                response.timingInfo = createOpaqueTimingInfo({
                    startTime: fetchParams.timingInfo.startTime
                });
            }
            const processResponseEndOfBody = ()=>{
                fetchParams.request.done = true;
                if (null != fetchParams.processResponseEndOfBody) queueMicrotask(()=>fetchParams.processResponseEndOfBody(response));
            };
            if (null != fetchParams.processResponse) queueMicrotask(()=>fetchParams.processResponse(response));
            if (null == response.body) processResponseEndOfBody();
            else {
                const identityTransformAlgorithm = (chunk, controller)=>{
                    controller.enqueue(chunk);
                };
                const transformStream = new TransformStream({
                    start () {},
                    transform: identityTransformAlgorithm,
                    flush: processResponseEndOfBody
                }, {
                    size () {
                        return 1;
                    }
                }, {
                    size () {
                        return 1;
                    }
                });
                response.body = {
                    stream: response.body.stream.pipeThrough(transformStream)
                };
            }
            if (null != fetchParams.processResponseConsumeBody) {
                const processBody = (nullOrBytes)=>fetchParams.processResponseConsumeBody(response, nullOrBytes);
                const processBodyError = (failure)=>fetchParams.processResponseConsumeBody(response, failure);
                if (null != response.body) return fullyReadBody(response.body, processBody, processBodyError);
                queueMicrotask(()=>processBody(null));
                return Promise.resolve();
            }
        }
        async function httpFetch(fetchParams) {
            const request = fetchParams.request;
            let response = null;
            let actualResponse = null;
            const timingInfo = fetchParams.timingInfo;
            request.serviceWorkers;
            if (null === response) {
                if ('follow' === request.redirect) request.serviceWorkers = 'none';
                actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
                if ('cors' === request.responseTainting && 'failure' === corsCheck(request, response)) return makeNetworkError('cors failure');
                if ('failure' === TAOCheck(request, response)) request.timingAllowFailed = true;
            }
            if (('opaque' === request.responseTainting || 'opaque' === response.type) && 'blocked' === crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse)) return makeNetworkError('blocked');
            if (redirectStatusSet.has(actualResponse.status)) {
                if ('manual' !== request.redirect) fetchParams.controller.connection.destroy();
                if ('error' === request.redirect) response = makeNetworkError('unexpected redirect');
                else if ('manual' === request.redirect) response = actualResponse;
                else if ('follow' === request.redirect) response = await httpRedirectFetch(fetchParams, response);
                else assert(false);
            }
            response.timingInfo = timingInfo;
            return response;
        }
        function httpRedirectFetch(fetchParams, response) {
            const request = fetchParams.request;
            const actualResponse = response.internalResponse ? response.internalResponse : response;
            let locationURL;
            try {
                locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
                if (null == locationURL) return response;
            } catch (err) {
                return Promise.resolve(makeNetworkError(err));
            }
            if (!urlIsHttpHttpsScheme(locationURL)) return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'));
            if (20 === request.redirectCount) return Promise.resolve(makeNetworkError('redirect count exceeded'));
            request.redirectCount += 1;
            if ('cors' === request.mode && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
            if ('cors' === request.responseTainting && (locationURL.username || locationURL.password)) return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
            if (303 !== actualResponse.status && null != request.body && null == request.body.source) return Promise.resolve(makeNetworkError());
            if ([
                301,
                302
            ].includes(actualResponse.status) && 'POST' === request.method || 303 === actualResponse.status && !GET_OR_HEAD.includes(request.method)) {
                request.method = 'GET';
                request.body = null;
                for (const headerName of requestBodyHeader)request.headersList.delete(headerName);
            }
            if (!sameOrigin(requestCurrentURL(request), locationURL)) {
                request.headersList.delete('authorization');
                request.headersList.delete('proxy-authorization', true);
                request.headersList.delete('cookie');
                request.headersList.delete('host');
            }
            if (null != request.body) {
                assert(null != request.body.source);
                request.body = safelyExtractBody(request.body.source)[0];
            }
            const timingInfo = fetchParams.timingInfo;
            timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            if (0 === timingInfo.redirectStartTime) timingInfo.redirectStartTime = timingInfo.startTime;
            request.urlList.push(locationURL);
            setRequestReferrerPolicyOnRedirect(request, actualResponse);
            return mainFetch(fetchParams, true);
        }
        async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
            const request = fetchParams.request;
            let httpFetchParams = null;
            let httpRequest = null;
            let response = null;
            const httpCache = null;
            const revalidatingFlag = false;
            if ('no-window' === request.window && 'error' === request.redirect) {
                httpFetchParams = fetchParams;
                httpRequest = request;
            } else {
                httpRequest = makeRequest(request);
                httpFetchParams = {
                    ...fetchParams
                };
                httpFetchParams.request = httpRequest;
            }
            const includeCredentials = 'include' === request.credentials || 'same-origin' === request.credentials && 'basic' === request.responseTainting;
            const contentLength = httpRequest.body ? httpRequest.body.length : null;
            let contentLengthHeaderValue = null;
            if (null == httpRequest.body && [
                'POST',
                'PUT'
            ].includes(httpRequest.method)) contentLengthHeaderValue = '0';
            if (null != contentLength) contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
            if (null != contentLengthHeaderValue) httpRequest.headersList.append('content-length', contentLengthHeaderValue);
            null != contentLength && httpRequest.keepalive;
            if (httpRequest.referrer instanceof URL) httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href));
            appendRequestOriginHeader(httpRequest);
            appendFetchMetadata(httpRequest);
            if (!httpRequest.headersList.contains('user-agent')) httpRequest.headersList.append('user-agent', "u" < typeof esbuildDetection ? 'undici' : 'node');
            if ('default' === httpRequest.cache && (httpRequest.headersList.contains('if-modified-since') || httpRequest.headersList.contains('if-none-match') || httpRequest.headersList.contains('if-unmodified-since') || httpRequest.headersList.contains('if-match') || httpRequest.headersList.contains('if-range'))) httpRequest.cache = 'no-store';
            if ('no-cache' === httpRequest.cache && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains('cache-control')) httpRequest.headersList.append('cache-control', 'max-age=0');
            if ('no-store' === httpRequest.cache || 'reload' === httpRequest.cache) {
                if (!httpRequest.headersList.contains('pragma')) httpRequest.headersList.append('pragma', 'no-cache');
                if (!httpRequest.headersList.contains('cache-control')) httpRequest.headersList.append('cache-control', 'no-cache');
            }
            if (httpRequest.headersList.contains('range')) httpRequest.headersList.append('accept-encoding', 'identity');
            if (!httpRequest.headersList.contains('accept-encoding')) if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate');
            else httpRequest.headersList.append('accept-encoding', 'gzip, deflate');
            httpRequest.headersList.delete('host');
            if (null == httpCache) httpRequest.cache = 'no-store';
            'no-store' !== httpRequest.mode && httpRequest.mode;
            if (null == response) {
                if ('only-if-cached' === httpRequest.mode) return makeNetworkError('only if cached');
                const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
                !safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status;
                revalidatingFlag && forwardResponse.status;
                if (null == response) response = forwardResponse;
            }
            response.urlList = [
                ...httpRequest.urlList
            ];
            if (httpRequest.headersList.contains('range')) response.rangeRequested = true;
            response.requestIncludesCredentials = includeCredentials;
            if (407 === response.status) {
                if ('no-window' === request.window) return makeNetworkError();
                if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
                return makeNetworkError('proxy authentication required');
            }
            if (421 === response.status && !isNewConnectionFetch && (null == request.body || null != request.body.source)) {
                if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
                fetchParams.controller.connection.destroy();
                response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
            }
            return response;
        }
        async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
            assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
            fetchParams.controller.connection = {
                abort: null,
                destroyed: false,
                destroy (err) {
                    if (!this.destroyed) {
                        this.destroyed = true;
                        this.abort?.(err ?? new DOMException1('The operation was aborted.', 'AbortError'));
                    }
                }
            };
            const request = fetchParams.request;
            let response = null;
            const timingInfo = fetchParams.timingInfo;
            const httpCache = null;
            if (null == httpCache) request.cache = 'no-store';
            request.mode;
            let requestBody = null;
            if (null == request.body && fetchParams.processRequestEndOfBody) queueMicrotask(()=>fetchParams.processRequestEndOfBody());
            else if (null != request.body) {
                const processBodyChunk = async function*(bytes) {
                    if (isCancelled(fetchParams)) return;
                    yield bytes;
                    fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
                };
                const processEndOfBody = ()=>{
                    if (isCancelled(fetchParams)) return;
                    if (fetchParams.processRequestEndOfBody) fetchParams.processRequestEndOfBody();
                };
                const processBodyError = (e)=>{
                    if (isCancelled(fetchParams)) return;
                    if ('AbortError' === e.name) fetchParams.controller.abort();
                    else fetchParams.controller.terminate(e);
                };
                requestBody = async function*() {
                    try {
                        for await (const bytes of request.body.stream)yield* processBodyChunk(bytes);
                        processEndOfBody();
                    } catch (err) {
                        processBodyError(err);
                    }
                }();
            }
            try {
                const { body, status, statusText, headersList, socket } = await dispatch({
                    body: requestBody
                });
                if (socket) response = makeResponse({
                    status,
                    statusText,
                    headersList,
                    socket
                });
                else {
                    const iterator = body[Symbol.asyncIterator]();
                    fetchParams.controller.next = ()=>iterator.next();
                    response = makeResponse({
                        status,
                        statusText,
                        headersList
                    });
                }
            } catch (err) {
                if ('AbortError' === err.name) {
                    fetchParams.controller.connection.destroy();
                    return makeAppropriateNetworkError(fetchParams, err);
                }
                return makeNetworkError(err);
            }
            const pullAlgorithm = ()=>{
                fetchParams.controller.resume();
            };
            const cancelAlgorithm = (reason)=>{
                fetchParams.controller.abort(reason);
            };
            if (!ReadableStream) ReadableStream = __webpack_require__("stream/web").ReadableStream;
            const stream = new ReadableStream({
                async start (controller) {
                    fetchParams.controller.controller = controller;
                },
                async pull (controller) {
                    await pullAlgorithm(controller);
                },
                async cancel (reason) {
                    await cancelAlgorithm(reason);
                }
            }, {
                highWaterMark: 0,
                size () {
                    return 1;
                }
            });
            response.body = {
                stream
            };
            fetchParams.controller.on('terminated', onAborted);
            fetchParams.controller.resume = async ()=>{
                while(true){
                    let bytes;
                    let isFailure;
                    try {
                        const { done, value } = await fetchParams.controller.next();
                        if (isAborted(fetchParams)) break;
                        bytes = done ? void 0 : value;
                    } catch (err) {
                        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) bytes = void 0;
                        else {
                            bytes = err;
                            isFailure = true;
                        }
                    }
                    if (void 0 === bytes) {
                        readableStreamClose(fetchParams.controller.controller);
                        finalizeResponse(fetchParams, response);
                        return;
                    }
                    timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
                    if (isFailure) return void fetchParams.controller.terminate(bytes);
                    fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
                    if (isErrored(stream)) return void fetchParams.controller.terminate();
                    if (!fetchParams.controller.controller.desiredSize) return;
                }
            };
            function onAborted(reason) {
                if (isAborted(fetchParams)) {
                    response.aborted = true;
                    if (isReadable(stream)) fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
                } else if (isReadable(stream)) fetchParams.controller.controller.error(new TypeError('terminated', {
                    cause: isErrorLike(reason) ? reason : void 0
                }));
                fetchParams.controller.connection.destroy();
            }
            return response;
            async function dispatch({ body }) {
                const url = requestCurrentURL(request);
                const agent = fetchParams.controller.dispatcher;
                return new Promise((resolve, reject)=>agent.dispatch({
                        path: url.pathname + url.search,
                        origin: url.origin,
                        method: request.method,
                        body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
                        headers: request.headersList.entries,
                        maxRedirections: 0,
                        upgrade: 'websocket' === request.mode ? 'websocket' : void 0
                    }, {
                        body: null,
                        abort: null,
                        onConnect (abort) {
                            const { connection } = fetchParams.controller;
                            if (connection.destroyed) abort(new DOMException1('The operation was aborted.', 'AbortError'));
                            else {
                                fetchParams.controller.on('terminated', abort);
                                this.abort = connection.abort = abort;
                            }
                        },
                        onHeaders (status, headersList, resume, statusText) {
                            if (status < 200) return;
                            let codings = [];
                            let location = '';
                            const headers = new Headers();
                            if (Array.isArray(headersList)) for(let n = 0; n < headersList.length; n += 2){
                                const key = headersList[n + 0].toString('latin1');
                                const val = headersList[n + 1].toString('latin1');
                                if ('content-encoding' === key.toLowerCase()) codings = val.toLowerCase().split(',').map((x)=>x.trim());
                                else if ('location' === key.toLowerCase()) location = val;
                                headers[kHeadersList].append(key, val);
                            }
                            else {
                                const keys = Object.keys(headersList);
                                for (const key of keys){
                                    const val = headersList[key];
                                    if ('content-encoding' === key.toLowerCase()) codings = val.toLowerCase().split(',').map((x)=>x.trim()).reverse();
                                    else if ('location' === key.toLowerCase()) location = val;
                                    headers[kHeadersList].append(key, val);
                                }
                            }
                            this.body = new Readable({
                                read: resume
                            });
                            const decoders = [];
                            const willFollow = 'follow' === request.redirect && location && redirectStatusSet.has(status);
                            if ('HEAD' !== request.method && 'CONNECT' !== request.method && !nullBodyStatus.includes(status) && !willFollow) for (const coding of codings)if ('x-gzip' === coding || 'gzip' === coding) decoders.push(zlib.createGunzip({
                                flush: zlib.constants.Z_SYNC_FLUSH,
                                finishFlush: zlib.constants.Z_SYNC_FLUSH
                            }));
                            else if ('deflate' === coding) decoders.push(zlib.createInflate());
                            else if ('br' === coding) decoders.push(zlib.createBrotliDecompress());
                            else {
                                decoders.length = 0;
                                break;
                            }
                            resolve({
                                status,
                                statusText,
                                headersList: headers[kHeadersList],
                                body: decoders.length ? pipeline(this.body, ...decoders, ()=>{}) : this.body.on('error', ()=>{})
                            });
                            return true;
                        },
                        onData (chunk) {
                            if (fetchParams.controller.dump) return;
                            const bytes = chunk;
                            timingInfo.encodedBodySize += bytes.byteLength;
                            return this.body.push(bytes);
                        },
                        onComplete () {
                            if (this.abort) fetchParams.controller.off('terminated', this.abort);
                            fetchParams.controller.ended = true;
                            this.body.push(null);
                        },
                        onError (error) {
                            if (this.abort) fetchParams.controller.off('terminated', this.abort);
                            this.body?.destroy(error);
                            fetchParams.controller.terminate(error);
                            reject(error);
                        },
                        onUpgrade (status, headersList, socket) {
                            if (101 !== status) return;
                            const headers = new Headers();
                            for(let n = 0; n < headersList.length; n += 2){
                                const key = headersList[n + 0].toString('latin1');
                                const val = headersList[n + 1].toString('latin1');
                                headers[kHeadersList].append(key, val);
                            }
                            resolve({
                                status,
                                statusText: STATUS_CODES[status],
                                headersList: headers[kHeadersList],
                                socket
                            });
                            return true;
                        }
                    }));
            }
        }
        module.exports = {
            fetch,
            Fetch,
            fetching,
            finalizeAndReportTiming
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/request.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { extractBody, mixinBody, cloneBody } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js");
        const { Headers, fill: fillHeaders, HeadersList } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js");
        const { FinalizationRegistry: FinalizationRegistry1 } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/compat/dispatcher-weakref.js")();
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { isValidHTTPToken, sameOrigin, normalizeMethod, makePolicyContainer, normalizeMethodRecord } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js");
        const { kEnumerableProperty } = util;
        const { kHeaders, kSignal, kState, kGuard, kRealm } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { getGlobalOrigin } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js");
        const { URLSerializer } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
        const { kHeadersList, kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const assert = __webpack_require__("assert");
        const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__("events");
        let TransformStream = globalThis.TransformStream;
        const kAbortController = Symbol('abortController');
        const requestFinalizer = new FinalizationRegistry1(({ signal, abort })=>{
            signal.removeEventListener('abort', abort);
        });
        class Request {
            constructor(input, init = {}){
                if (input === kConstruct) return;
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Request constructor'
                });
                input = webidl.converters.RequestInfo(input);
                init = webidl.converters.RequestInit(init);
                this[kRealm] = {
                    settingsObject: {
                        baseUrl: getGlobalOrigin(),
                        get origin () {
                            return this.baseUrl?.origin;
                        },
                        policyContainer: makePolicyContainer()
                    }
                };
                let request = null;
                let fallbackMode = null;
                const baseUrl = this[kRealm].settingsObject.baseUrl;
                let signal = null;
                if ('string' == typeof input) {
                    let parsedURL;
                    try {
                        parsedURL = new URL(input, baseUrl);
                    } catch (err) {
                        throw new TypeError('Failed to parse URL from ' + input, {
                            cause: err
                        });
                    }
                    if (parsedURL.username || parsedURL.password) throw new TypeError('Request cannot be constructed from a URL that includes credentials: ' + input);
                    request = makeRequest({
                        urlList: [
                            parsedURL
                        ]
                    });
                    fallbackMode = 'cors';
                } else {
                    assert(input instanceof Request);
                    request = input[kState];
                    signal = input[kSignal];
                }
                const origin = this[kRealm].settingsObject.origin;
                let window1 = 'client';
                if (request.window?.constructor?.name === 'EnvironmentSettingsObject' && sameOrigin(request.window, origin)) window1 = request.window;
                if (null != init.window) throw new TypeError(`'window' option '${window1}' must be null`);
                if ('window' in init) window1 = 'no-window';
                request = makeRequest({
                    method: request.method,
                    headersList: request.headersList,
                    unsafeRequest: request.unsafeRequest,
                    client: this[kRealm].settingsObject,
                    window: window1,
                    priority: request.priority,
                    origin: request.origin,
                    referrer: request.referrer,
                    referrerPolicy: request.referrerPolicy,
                    mode: request.mode,
                    credentials: request.credentials,
                    cache: request.cache,
                    redirect: request.redirect,
                    integrity: request.integrity,
                    keepalive: request.keepalive,
                    reloadNavigation: request.reloadNavigation,
                    historyNavigation: request.historyNavigation,
                    urlList: [
                        ...request.urlList
                    ]
                });
                const initHasKey = 0 !== Object.keys(init).length;
                if (initHasKey) {
                    if ('navigate' === request.mode) request.mode = 'same-origin';
                    request.reloadNavigation = false;
                    request.historyNavigation = false;
                    request.origin = 'client';
                    request.referrer = 'client';
                    request.referrerPolicy = '';
                    request.url = request.urlList[request.urlList.length - 1];
                    request.urlList = [
                        request.url
                    ];
                }
                if (void 0 !== init.referrer) {
                    const referrer = init.referrer;
                    if ('' === referrer) request.referrer = 'no-referrer';
                    else {
                        let parsedReferrer;
                        try {
                            parsedReferrer = new URL(referrer, baseUrl);
                        } catch (err) {
                            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, {
                                cause: err
                            });
                        }
                        if ('about:' === parsedReferrer.protocol && 'client' === parsedReferrer.hostname || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) request.referrer = 'client';
                        else request.referrer = parsedReferrer;
                    }
                }
                if (void 0 !== init.referrerPolicy) request.referrerPolicy = init.referrerPolicy;
                let mode;
                mode = void 0 !== init.mode ? init.mode : fallbackMode;
                if ('navigate' === mode) throw webidl.errors.exception({
                    header: 'Request constructor',
                    message: 'invalid request mode navigate.'
                });
                if (null != mode) request.mode = mode;
                if (void 0 !== init.credentials) request.credentials = init.credentials;
                if (void 0 !== init.cache) request.cache = init.cache;
                if ('only-if-cached' === request.cache && 'same-origin' !== request.mode) throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
                if (void 0 !== init.redirect) request.redirect = init.redirect;
                if (null != init.integrity) request.integrity = String(init.integrity);
                if (void 0 !== init.keepalive) request.keepalive = Boolean(init.keepalive);
                if (void 0 !== init.method) {
                    let method = init.method;
                    if (!isValidHTTPToken(method)) throw new TypeError(`'${method}' is not a valid HTTP method.`);
                    if (forbiddenMethodsSet.has(method.toUpperCase())) throw new TypeError(`'${method}' HTTP method is unsupported.`);
                    method = normalizeMethodRecord[method] ?? normalizeMethod(method);
                    request.method = method;
                }
                if (void 0 !== init.signal) signal = init.signal;
                this[kState] = request;
                const ac = new AbortController();
                this[kSignal] = ac.signal;
                this[kSignal][kRealm] = this[kRealm];
                if (null != signal) {
                    if (!signal || 'boolean' != typeof signal.aborted || 'function' != typeof signal.addEventListener) throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
                    if (signal.aborted) ac.abort(signal.reason);
                    else {
                        this[kAbortController] = ac;
                        const acRef = new WeakRef(ac);
                        const abort = function() {
                            const ac = acRef.deref();
                            if (void 0 !== ac) ac.abort(this.reason);
                        };
                        try {
                            if ('function' == typeof getMaxListeners && getMaxListeners(signal) === defaultMaxListeners) setMaxListeners(100, signal);
                            else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) setMaxListeners(100, signal);
                        } catch  {}
                        util.addAbortListener(signal, abort);
                        requestFinalizer.register(ac, {
                            signal,
                            abort
                        });
                    }
                }
                this[kHeaders] = new Headers(kConstruct);
                this[kHeaders][kHeadersList] = request.headersList;
                this[kHeaders][kGuard] = 'request';
                this[kHeaders][kRealm] = this[kRealm];
                if ('no-cors' === mode) {
                    if (!corsSafeListedMethodsSet.has(request.method)) throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
                    this[kHeaders][kGuard] = 'request-no-cors';
                }
                if (initHasKey) {
                    const headersList = this[kHeaders][kHeadersList];
                    const headers = void 0 !== init.headers ? init.headers : new HeadersList(headersList);
                    headersList.clear();
                    if (headers instanceof HeadersList) {
                        for (const [key, val] of headers)headersList.append(key, val);
                        headersList.cookies = headers.cookies;
                    } else fillHeaders(this[kHeaders], headers);
                }
                const inputBody = input instanceof Request ? input[kState].body : null;
                if ((null != init.body || null != inputBody) && ('GET' === request.method || 'HEAD' === request.method)) throw new TypeError('Request with GET/HEAD method cannot have body.');
                let initBody = null;
                if (null != init.body) {
                    const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
                    initBody = extractedBody;
                    if (contentType && !this[kHeaders][kHeadersList].contains('content-type')) this[kHeaders].append('content-type', contentType);
                }
                const inputOrInitBody = initBody ?? inputBody;
                if (null != inputOrInitBody && null == inputOrInitBody.source) {
                    if (null != initBody && null == init.duplex) throw new TypeError('RequestInit: duplex option is required when sending a body.');
                    if ('same-origin' !== request.mode && 'cors' !== request.mode) throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
                    request.useCORSPreflightFlag = true;
                }
                let finalBody = inputOrInitBody;
                if (null == initBody && null != inputBody) {
                    if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) throw new TypeError('Cannot construct a Request with a Request object that has already been used.');
                    if (!TransformStream) TransformStream = __webpack_require__("stream/web").TransformStream;
                    const identityTransform = new TransformStream();
                    inputBody.stream.pipeThrough(identityTransform);
                    finalBody = {
                        source: inputBody.source,
                        length: inputBody.length,
                        stream: identityTransform.readable
                    };
                }
                this[kState].body = finalBody;
            }
            get method() {
                webidl.brandCheck(this, Request);
                return this[kState].method;
            }
            get url() {
                webidl.brandCheck(this, Request);
                return URLSerializer(this[kState].url);
            }
            get headers() {
                webidl.brandCheck(this, Request);
                return this[kHeaders];
            }
            get destination() {
                webidl.brandCheck(this, Request);
                return this[kState].destination;
            }
            get referrer() {
                webidl.brandCheck(this, Request);
                if ('no-referrer' === this[kState].referrer) return '';
                if ('client' === this[kState].referrer) return 'about:client';
                return this[kState].referrer.toString();
            }
            get referrerPolicy() {
                webidl.brandCheck(this, Request);
                return this[kState].referrerPolicy;
            }
            get mode() {
                webidl.brandCheck(this, Request);
                return this[kState].mode;
            }
            get credentials() {
                return this[kState].credentials;
            }
            get cache() {
                webidl.brandCheck(this, Request);
                return this[kState].cache;
            }
            get redirect() {
                webidl.brandCheck(this, Request);
                return this[kState].redirect;
            }
            get integrity() {
                webidl.brandCheck(this, Request);
                return this[kState].integrity;
            }
            get keepalive() {
                webidl.brandCheck(this, Request);
                return this[kState].keepalive;
            }
            get isReloadNavigation() {
                webidl.brandCheck(this, Request);
                return this[kState].reloadNavigation;
            }
            get isHistoryNavigation() {
                webidl.brandCheck(this, Request);
                return this[kState].historyNavigation;
            }
            get signal() {
                webidl.brandCheck(this, Request);
                return this[kSignal];
            }
            get body() {
                webidl.brandCheck(this, Request);
                return this[kState].body ? this[kState].body.stream : null;
            }
            get bodyUsed() {
                webidl.brandCheck(this, Request);
                return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
            }
            get duplex() {
                webidl.brandCheck(this, Request);
                return 'half';
            }
            clone() {
                webidl.brandCheck(this, Request);
                if (this.bodyUsed || this.body?.locked) throw new TypeError('unusable');
                const clonedRequest = cloneRequest(this[kState]);
                const clonedRequestObject = new Request(kConstruct);
                clonedRequestObject[kState] = clonedRequest;
                clonedRequestObject[kRealm] = this[kRealm];
                clonedRequestObject[kHeaders] = new Headers(kConstruct);
                clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
                clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
                clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
                const ac = new AbortController();
                if (this.signal.aborted) ac.abort(this.signal.reason);
                else util.addAbortListener(this.signal, ()=>{
                    ac.abort(this.signal.reason);
                });
                clonedRequestObject[kSignal] = ac.signal;
                return clonedRequestObject;
            }
        }
        mixinBody(Request);
        function makeRequest(init) {
            const request = {
                method: 'GET',
                localURLsOnly: false,
                unsafeRequest: false,
                body: null,
                client: null,
                reservedClient: null,
                replacesClientId: '',
                window: 'client',
                keepalive: false,
                serviceWorkers: 'all',
                initiator: '',
                destination: '',
                priority: null,
                origin: 'client',
                policyContainer: 'client',
                referrer: 'client',
                referrerPolicy: '',
                mode: 'no-cors',
                useCORSPreflightFlag: false,
                credentials: 'same-origin',
                useCredentials: false,
                cache: 'default',
                redirect: 'follow',
                integrity: '',
                cryptoGraphicsNonceMetadata: '',
                parserMetadata: '',
                reloadNavigation: false,
                historyNavigation: false,
                userActivation: false,
                taintedOrigin: false,
                redirectCount: 0,
                responseTainting: 'basic',
                preventNoCacheCacheControlHeaderModification: false,
                done: false,
                timingAllowFailed: false,
                ...init,
                headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
            };
            request.url = request.urlList[0];
            return request;
        }
        function cloneRequest(request) {
            const newRequest = makeRequest({
                ...request,
                body: null
            });
            if (null != request.body) newRequest.body = cloneBody(request.body);
            return newRequest;
        }
        Object.defineProperties(Request.prototype, {
            method: kEnumerableProperty,
            url: kEnumerableProperty,
            headers: kEnumerableProperty,
            redirect: kEnumerableProperty,
            clone: kEnumerableProperty,
            signal: kEnumerableProperty,
            duplex: kEnumerableProperty,
            destination: kEnumerableProperty,
            body: kEnumerableProperty,
            bodyUsed: kEnumerableProperty,
            isHistoryNavigation: kEnumerableProperty,
            isReloadNavigation: kEnumerableProperty,
            keepalive: kEnumerableProperty,
            integrity: kEnumerableProperty,
            cache: kEnumerableProperty,
            credentials: kEnumerableProperty,
            attribute: kEnumerableProperty,
            referrerPolicy: kEnumerableProperty,
            referrer: kEnumerableProperty,
            mode: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'Request',
                configurable: true
            }
        });
        webidl.converters.Request = webidl.interfaceConverter(Request);
        webidl.converters.RequestInfo = function(V) {
            if ('string' == typeof V) return webidl.converters.USVString(V);
            if (V instanceof Request) return webidl.converters.Request(V);
            return webidl.converters.USVString(V);
        };
        webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
        webidl.converters.RequestInit = webidl.dictionaryConverter([
            {
                key: 'method',
                converter: webidl.converters.ByteString
            },
            {
                key: 'headers',
                converter: webidl.converters.HeadersInit
            },
            {
                key: 'body',
                converter: webidl.nullableConverter(webidl.converters.BodyInit)
            },
            {
                key: 'referrer',
                converter: webidl.converters.USVString
            },
            {
                key: 'referrerPolicy',
                converter: webidl.converters.DOMString,
                allowedValues: referrerPolicy
            },
            {
                key: 'mode',
                converter: webidl.converters.DOMString,
                allowedValues: requestMode
            },
            {
                key: 'credentials',
                converter: webidl.converters.DOMString,
                allowedValues: requestCredentials
            },
            {
                key: 'cache',
                converter: webidl.converters.DOMString,
                allowedValues: requestCache
            },
            {
                key: 'redirect',
                converter: webidl.converters.DOMString,
                allowedValues: requestRedirect
            },
            {
                key: 'integrity',
                converter: webidl.converters.DOMString
            },
            {
                key: 'keepalive',
                converter: webidl.converters.boolean
            },
            {
                key: 'signal',
                converter: webidl.nullableConverter((signal)=>webidl.converters.AbortSignal(signal, {
                        strict: false
                    }))
            },
            {
                key: 'window',
                converter: webidl.converters.any
            },
            {
                key: 'duplex',
                converter: webidl.converters.DOMString,
                allowedValues: requestDuplex
            }
        ]);
        module.exports = {
            Request,
            makeRequest
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/response.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Headers, HeadersList, fill } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js");
        const { extractBody, cloneBody, mixinBody } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { kEnumerableProperty } = util;
        const { isValidReasonPhrase, isCancelled, isAborted, isBlobLike, serializeJavascriptValueToJSONString, isErrorLike, isomorphicEncode } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const { redirectStatusSet, nullBodyStatus, DOMException: DOMException1 } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js");
        const { kState, kHeaders, kGuard, kRealm } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { FormData } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/formdata.js");
        const { getGlobalOrigin } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js");
        const { URLSerializer } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
        const { kHeadersList, kConstruct } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const assert = __webpack_require__("assert");
        const { types } = __webpack_require__("util");
        const ReadableStream = globalThis.ReadableStream || __webpack_require__("stream/web").ReadableStream;
        const textEncoder = new TextEncoder('utf-8');
        class Response {
            static error() {
                const relevantRealm = {
                    settingsObject: {}
                };
                const responseObject = new Response();
                responseObject[kState] = makeNetworkError();
                responseObject[kRealm] = relevantRealm;
                responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
                responseObject[kHeaders][kGuard] = 'immutable';
                responseObject[kHeaders][kRealm] = relevantRealm;
                return responseObject;
            }
            static json(data, init = {}) {
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Response.json'
                });
                if (null !== init) init = webidl.converters.ResponseInit(init);
                const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
                const body = extractBody(bytes);
                const relevantRealm = {
                    settingsObject: {}
                };
                const responseObject = new Response();
                responseObject[kRealm] = relevantRealm;
                responseObject[kHeaders][kGuard] = 'response';
                responseObject[kHeaders][kRealm] = relevantRealm;
                initializeResponse(responseObject, init, {
                    body: body[0],
                    type: 'application/json'
                });
                return responseObject;
            }
            static redirect(url, status = 302) {
                const relevantRealm = {
                    settingsObject: {}
                };
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'Response.redirect'
                });
                url = webidl.converters.USVString(url);
                status = webidl.converters['unsigned short'](status);
                let parsedURL;
                try {
                    parsedURL = new URL(url, getGlobalOrigin());
                } catch (err) {
                    throw Object.assign(new TypeError('Failed to parse URL from ' + url), {
                        cause: err
                    });
                }
                if (!redirectStatusSet.has(status)) throw new RangeError('Invalid status code ' + status);
                const responseObject = new Response();
                responseObject[kRealm] = relevantRealm;
                responseObject[kHeaders][kGuard] = 'immutable';
                responseObject[kHeaders][kRealm] = relevantRealm;
                responseObject[kState].status = status;
                const value = isomorphicEncode(URLSerializer(parsedURL));
                responseObject[kState].headersList.append('location', value);
                return responseObject;
            }
            constructor(body = null, init = {}){
                if (null !== body) body = webidl.converters.BodyInit(body);
                init = webidl.converters.ResponseInit(init);
                this[kRealm] = {
                    settingsObject: {}
                };
                this[kState] = makeResponse({});
                this[kHeaders] = new Headers(kConstruct);
                this[kHeaders][kGuard] = 'response';
                this[kHeaders][kHeadersList] = this[kState].headersList;
                this[kHeaders][kRealm] = this[kRealm];
                let bodyWithType = null;
                if (null != body) {
                    const [extractedBody, type] = extractBody(body);
                    bodyWithType = {
                        body: extractedBody,
                        type
                    };
                }
                initializeResponse(this, init, bodyWithType);
            }
            get type() {
                webidl.brandCheck(this, Response);
                return this[kState].type;
            }
            get url() {
                webidl.brandCheck(this, Response);
                const urlList = this[kState].urlList;
                const url = urlList[urlList.length - 1] ?? null;
                if (null === url) return '';
                return URLSerializer(url, true);
            }
            get redirected() {
                webidl.brandCheck(this, Response);
                return this[kState].urlList.length > 1;
            }
            get status() {
                webidl.brandCheck(this, Response);
                return this[kState].status;
            }
            get ok() {
                webidl.brandCheck(this, Response);
                return this[kState].status >= 200 && this[kState].status <= 299;
            }
            get statusText() {
                webidl.brandCheck(this, Response);
                return this[kState].statusText;
            }
            get headers() {
                webidl.brandCheck(this, Response);
                return this[kHeaders];
            }
            get body() {
                webidl.brandCheck(this, Response);
                return this[kState].body ? this[kState].body.stream : null;
            }
            get bodyUsed() {
                webidl.brandCheck(this, Response);
                return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
            }
            clone() {
                webidl.brandCheck(this, Response);
                if (this.bodyUsed || this.body && this.body.locked) throw webidl.errors.exception({
                    header: 'Response.clone',
                    message: 'Body has already been consumed.'
                });
                const clonedResponse = cloneResponse(this[kState]);
                const clonedResponseObject = new Response();
                clonedResponseObject[kState] = clonedResponse;
                clonedResponseObject[kRealm] = this[kRealm];
                clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
                clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
                clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
                return clonedResponseObject;
            }
        }
        mixinBody(Response);
        Object.defineProperties(Response.prototype, {
            type: kEnumerableProperty,
            url: kEnumerableProperty,
            status: kEnumerableProperty,
            ok: kEnumerableProperty,
            redirected: kEnumerableProperty,
            statusText: kEnumerableProperty,
            headers: kEnumerableProperty,
            clone: kEnumerableProperty,
            body: kEnumerableProperty,
            bodyUsed: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'Response',
                configurable: true
            }
        });
        Object.defineProperties(Response, {
            json: kEnumerableProperty,
            redirect: kEnumerableProperty,
            error: kEnumerableProperty
        });
        function cloneResponse(response) {
            if (response.internalResponse) return filterResponse(cloneResponse(response.internalResponse), response.type);
            const newResponse = makeResponse({
                ...response,
                body: null
            });
            if (null != response.body) newResponse.body = cloneBody(response.body);
            return newResponse;
        }
        function makeResponse(init) {
            return {
                aborted: false,
                rangeRequested: false,
                timingAllowPassed: false,
                requestIncludesCredentials: false,
                type: 'default',
                status: 200,
                timingInfo: null,
                cacheState: '',
                statusText: '',
                ...init,
                headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
                urlList: init.urlList ? [
                    ...init.urlList
                ] : []
            };
        }
        function makeNetworkError(reason) {
            const isError = isErrorLike(reason);
            return makeResponse({
                type: 'error',
                status: 0,
                error: isError ? reason : new Error(reason ? String(reason) : reason),
                aborted: reason && 'AbortError' === reason.name
            });
        }
        function makeFilteredResponse(response, state) {
            state = {
                internalResponse: response,
                ...state
            };
            return new Proxy(response, {
                get (target, p) {
                    return p in state ? state[p] : target[p];
                },
                set (target, p, value) {
                    assert(!(p in state));
                    target[p] = value;
                    return true;
                }
            });
        }
        function filterResponse(response, type) {
            if ('basic' === type) return makeFilteredResponse(response, {
                type: 'basic',
                headersList: response.headersList
            });
            if ('cors' === type) return makeFilteredResponse(response, {
                type: 'cors',
                headersList: response.headersList
            });
            if ('opaque' === type) return makeFilteredResponse(response, {
                type: 'opaque',
                urlList: Object.freeze([]),
                status: 0,
                statusText: '',
                body: null
            });
            if ('opaqueredirect' === type) return makeFilteredResponse(response, {
                type: 'opaqueredirect',
                status: 0,
                statusText: '',
                headersList: [],
                body: null
            });
            assert(false);
        }
        function makeAppropriateNetworkError(fetchParams, err = null) {
            assert(isCancelled(fetchParams));
            return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException1('The operation was aborted.', 'AbortError'), {
                cause: err
            })) : makeNetworkError(Object.assign(new DOMException1('Request was cancelled.'), {
                cause: err
            }));
        }
        function initializeResponse(response, init, body) {
            if (null !== init.status && (init.status < 200 || init.status > 599)) throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
            if ('statusText' in init && null != init.statusText) {
                if (!isValidReasonPhrase(String(init.statusText))) throw new TypeError('Invalid statusText');
            }
            if ('status' in init && null != init.status) response[kState].status = init.status;
            if ('statusText' in init && null != init.statusText) response[kState].statusText = init.statusText;
            if ('headers' in init && null != init.headers) fill(response[kHeaders], init.headers);
            if (body) {
                if (nullBodyStatus.includes(response.status)) throw webidl.errors.exception({
                    header: 'Response constructor',
                    message: 'Invalid response status code ' + response.status
                });
                response[kState].body = body.body;
                if (null != body.type && !response[kState].headersList.contains('Content-Type')) response[kState].headersList.append('content-type', body.type);
            }
        }
        webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
        webidl.converters.FormData = webidl.interfaceConverter(FormData);
        webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
        webidl.converters.XMLHttpRequestBodyInit = function(V) {
            if ('string' == typeof V) return webidl.converters.USVString(V);
            if (isBlobLike(V)) return webidl.converters.Blob(V, {
                strict: false
            });
            if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) return webidl.converters.BufferSource(V);
            if (util.isFormDataLike(V)) return webidl.converters.FormData(V, {
                strict: false
            });
            if (V instanceof URLSearchParams) return webidl.converters.URLSearchParams(V);
            return webidl.converters.DOMString(V);
        };
        webidl.converters.BodyInit = function(V) {
            if (V instanceof ReadableStream) return webidl.converters.ReadableStream(V);
            if (V?.[Symbol.asyncIterator]) return V;
            return webidl.converters.XMLHttpRequestBodyInit(V);
        };
        webidl.converters.ResponseInit = webidl.dictionaryConverter([
            {
                key: 'status',
                converter: webidl.converters['unsigned short'],
                defaultValue: 200
            },
            {
                key: 'statusText',
                converter: webidl.converters.ByteString,
                defaultValue: ''
            },
            {
                key: 'headers',
                converter: webidl.converters.HeadersInit
            }
        ]);
        module.exports = {
            makeNetworkError,
            makeResponse,
            makeAppropriateNetworkError,
            filterResponse,
            Response,
            cloneResponse
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js" (module) {
        "use strict";
        module.exports = {
            kUrl: Symbol('url'),
            kHeaders: Symbol('headers'),
            kSignal: Symbol('signal'),
            kState: Symbol('state'),
            kGuard: Symbol('guard'),
            kRealm: Symbol('realm')
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js");
        const { getGlobalOrigin } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js");
        const { performance: performance1 } = __webpack_require__("perf_hooks");
        const { isBlobLike, toUSVString, ReadableStreamFrom } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const assert = __webpack_require__("assert");
        const { isUint8Array } = __webpack_require__("util/types");
        let supportedHashes = [];
        let crypto;
        try {
            crypto = __webpack_require__("crypto");
            const possibleRelevantHashes = [
                'sha256',
                'sha384',
                'sha512'
            ];
            supportedHashes = crypto.getHashes().filter((hash)=>possibleRelevantHashes.includes(hash));
        } catch  {}
        function responseURL(response) {
            const urlList = response.urlList;
            const length = urlList.length;
            return 0 === length ? null : urlList[length - 1].toString();
        }
        function responseLocationURL(response, requestFragment) {
            if (!redirectStatusSet.has(response.status)) return null;
            let location = response.headersList.get('location');
            if (null !== location && isValidHeaderValue(location)) location = new URL(location, responseURL(response));
            if (location && !location.hash) location.hash = requestFragment;
            return location;
        }
        function requestCurrentURL(request) {
            return request.urlList[request.urlList.length - 1];
        }
        function requestBadPort(request) {
            const url = requestCurrentURL(request);
            if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) return 'blocked';
            return 'allowed';
        }
        function isErrorLike(object) {
            return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';
        }
        function isValidReasonPhrase(statusText) {
            for(let i = 0; i < statusText.length; ++i){
                const c = statusText.charCodeAt(i);
                if (!(0x09 === c || c >= 0x20 && c <= 0x7e || c >= 0x80 && c <= 0xff)) return false;
            }
            return true;
        }
        function isTokenCharCode(c) {
            switch(c){
                case 0x22:
                case 0x28:
                case 0x29:
                case 0x2c:
                case 0x2f:
                case 0x3a:
                case 0x3b:
                case 0x3c:
                case 0x3d:
                case 0x3e:
                case 0x3f:
                case 0x40:
                case 0x5b:
                case 0x5c:
                case 0x5d:
                case 0x7b:
                case 0x7d:
                    return false;
                default:
                    return c >= 0x21 && c <= 0x7e;
            }
        }
        function isValidHTTPToken(characters) {
            if (0 === characters.length) return false;
            for(let i = 0; i < characters.length; ++i)if (!isTokenCharCode(characters.charCodeAt(i))) return false;
            return true;
        }
        function isValidHeaderName(potentialValue) {
            return isValidHTTPToken(potentialValue);
        }
        function isValidHeaderValue(potentialValue) {
            if (potentialValue.startsWith('\t') || potentialValue.startsWith(' ') || potentialValue.endsWith('\t') || potentialValue.endsWith(' ')) return false;
            if (potentialValue.includes('\0') || potentialValue.includes('\r') || potentialValue.includes('\n')) return false;
            return true;
        }
        function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
            const { headersList } = actualResponse;
            const policyHeader = (headersList.get('referrer-policy') ?? '').split(',');
            let policy = '';
            if (policyHeader.length > 0) for(let i = policyHeader.length; 0 !== i; i--){
                const token = policyHeader[i - 1].trim();
                if (referrerPolicyTokens.has(token)) {
                    policy = token;
                    break;
                }
            }
            if ('' !== policy) request.referrerPolicy = policy;
        }
        function crossOriginResourcePolicyCheck() {
            return 'allowed';
        }
        function corsCheck() {
            return 'success';
        }
        function TAOCheck() {
            return 'success';
        }
        function appendFetchMetadata(httpRequest) {
            let header = null;
            header = httpRequest.mode;
            httpRequest.headersList.set('sec-fetch-mode', header);
        }
        function appendRequestOriginHeader(request) {
            let serializedOrigin = request.origin;
            if ('cors' === request.responseTainting || 'websocket' === request.mode) {
                if (serializedOrigin) request.headersList.append('origin', serializedOrigin);
            } else if ('GET' !== request.method && 'HEAD' !== request.method) {
                switch(request.referrerPolicy){
                    case 'no-referrer':
                        serializedOrigin = null;
                        break;
                    case 'no-referrer-when-downgrade':
                    case 'strict-origin':
                    case 'strict-origin-when-cross-origin':
                        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) serializedOrigin = null;
                        break;
                    case 'same-origin':
                        if (!sameOrigin(request, requestCurrentURL(request))) serializedOrigin = null;
                        break;
                    default:
                }
                if (serializedOrigin) request.headersList.append('origin', serializedOrigin);
            }
        }
        function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
            return performance1.now();
        }
        function createOpaqueTimingInfo(timingInfo) {
            return {
                startTime: timingInfo.startTime ?? 0,
                redirectStartTime: 0,
                redirectEndTime: 0,
                postRedirectStartTime: timingInfo.startTime ?? 0,
                finalServiceWorkerStartTime: 0,
                finalNetworkResponseStartTime: 0,
                finalNetworkRequestStartTime: 0,
                endTime: 0,
                encodedBodySize: 0,
                decodedBodySize: 0,
                finalConnectionTimingInfo: null
            };
        }
        function makePolicyContainer() {
            return {
                referrerPolicy: 'strict-origin-when-cross-origin'
            };
        }
        function clonePolicyContainer(policyContainer) {
            return {
                referrerPolicy: policyContainer.referrerPolicy
            };
        }
        function determineRequestsReferrer(request) {
            const policy = request.referrerPolicy;
            assert(policy);
            let referrerSource = null;
            if ('client' === request.referrer) {
                const globalOrigin = getGlobalOrigin();
                if (!globalOrigin || 'null' === globalOrigin.origin) return 'no-referrer';
                referrerSource = new URL(globalOrigin);
            } else if (request.referrer instanceof URL) referrerSource = request.referrer;
            let referrerURL = stripURLForReferrer(referrerSource);
            const referrerOrigin = stripURLForReferrer(referrerSource, true);
            if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
            const areSameOrigin = sameOrigin(request, referrerURL);
            const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
            switch(policy){
                case 'origin':
                    return null != referrerOrigin ? referrerOrigin : stripURLForReferrer(referrerSource, true);
                case 'unsafe-url':
                    return referrerURL;
                case 'same-origin':
                    return areSameOrigin ? referrerOrigin : 'no-referrer';
                case 'origin-when-cross-origin':
                    return areSameOrigin ? referrerURL : referrerOrigin;
                case 'strict-origin-when-cross-origin':
                    {
                        const currentURL = requestCurrentURL(request);
                        if (sameOrigin(referrerURL, currentURL)) return referrerURL;
                        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) return 'no-referrer';
                        return referrerOrigin;
                    }
                case 'strict-origin':
                case 'no-referrer-when-downgrade':
                default:
                    return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;
            }
        }
        function stripURLForReferrer(url, originOnly) {
            assert(url instanceof URL);
            if ('file:' === url.protocol || 'about:' === url.protocol || 'blank:' === url.protocol) return 'no-referrer';
            url.username = '';
            url.password = '';
            url.hash = '';
            if (originOnly) {
                url.pathname = '';
                url.search = '';
            }
            return url;
        }
        function isURLPotentiallyTrustworthy(url) {
            if (!(url instanceof URL)) return false;
            if ('about:blank' === url.href || 'about:srcdoc' === url.href) return true;
            if ('data:' === url.protocol) return true;
            if ('file:' === url.protocol) return true;
            return isOriginPotentiallyTrustworthy(url.origin);
            function isOriginPotentiallyTrustworthy(origin) {
                if (null == origin || 'null' === origin) return false;
                const originAsURL = new URL(origin);
                if ('https:' === originAsURL.protocol || 'wss:' === originAsURL.protocol) return true;
                if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || 'localhost' === originAsURL.hostname || originAsURL.hostname.includes('localhost.') || originAsURL.hostname.endsWith('.localhost')) return true;
                return false;
            }
        }
        function bytesMatch(bytes, metadataList) {
            if (void 0 === crypto) return true;
            const parsedMetadata = parseMetadata(metadataList);
            if ('no metadata' === parsedMetadata) return true;
            if (0 === parsedMetadata.length) return true;
            const strongest = getStrongestMetadata(parsedMetadata);
            const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
            for (const item of metadata){
                const algorithm = item.algo;
                const expectedValue = item.hash;
                let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');
                if ('=' === actualValue[actualValue.length - 1]) actualValue = '=' === actualValue[actualValue.length - 2] ? actualValue.slice(0, -2) : actualValue.slice(0, -1);
                if (compareBase64Mixed(actualValue, expectedValue)) return true;
            }
            return false;
        }
        const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
        function parseMetadata(metadata) {
            const result = [];
            let empty = true;
            for (const token of metadata.split(' ')){
                empty = false;
                const parsedToken = parseHashWithOptions.exec(token);
                if (null === parsedToken || void 0 === parsedToken.groups || void 0 === parsedToken.groups.algo) continue;
                const algorithm = parsedToken.groups.algo.toLowerCase();
                if (supportedHashes.includes(algorithm)) result.push(parsedToken.groups);
            }
            if (true === empty) return 'no metadata';
            return result;
        }
        function getStrongestMetadata(metadataList) {
            let algorithm = metadataList[0].algo;
            if ('5' === algorithm[3]) return algorithm;
            for(let i = 1; i < metadataList.length; ++i){
                const metadata = metadataList[i];
                if ('5' === metadata.algo[3]) {
                    algorithm = 'sha512';
                    break;
                }
                if ('3' !== algorithm[3]) {
                    if ('3' === metadata.algo[3]) algorithm = 'sha384';
                }
            }
            return algorithm;
        }
        function filterMetadataListByAlgorithm(metadataList, algorithm) {
            if (1 === metadataList.length) return metadataList;
            let pos = 0;
            for(let i = 0; i < metadataList.length; ++i)if (metadataList[i].algo === algorithm) metadataList[pos++] = metadataList[i];
            metadataList.length = pos;
            return metadataList;
        }
        function compareBase64Mixed(actualValue, expectedValue) {
            if (actualValue.length !== expectedValue.length) return false;
            for(let i = 0; i < actualValue.length; ++i)if (actualValue[i] !== expectedValue[i]) {
                if ('+' === actualValue[i] && '-' === expectedValue[i] || '/' === actualValue[i] && '_' === expectedValue[i]) continue;
                return false;
            }
            return true;
        }
        function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
        function sameOrigin(A, B) {
            if (A.origin === B.origin && 'null' === A.origin) return true;
            if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) return true;
            return false;
        }
        function createDeferredPromise() {
            let res;
            let rej;
            const promise = new Promise((resolve, reject)=>{
                res = resolve;
                rej = reject;
            });
            return {
                promise,
                resolve: res,
                reject: rej
            };
        }
        function isAborted(fetchParams) {
            return 'aborted' === fetchParams.controller.state;
        }
        function isCancelled(fetchParams) {
            return 'aborted' === fetchParams.controller.state || 'terminated' === fetchParams.controller.state;
        }
        const normalizeMethodRecord = {
            delete: 'DELETE',
            DELETE: 'DELETE',
            get: 'GET',
            GET: 'GET',
            head: 'HEAD',
            HEAD: 'HEAD',
            options: 'OPTIONS',
            OPTIONS: 'OPTIONS',
            post: 'POST',
            POST: 'POST',
            put: 'PUT',
            PUT: 'PUT'
        };
        Object.setPrototypeOf(normalizeMethodRecord, null);
        function normalizeMethod(method) {
            return normalizeMethodRecord[method.toLowerCase()] ?? method;
        }
        function serializeJavascriptValueToJSONString(value) {
            const result = JSON.stringify(value);
            if (void 0 === result) throw new TypeError('Value is not JSON serializable');
            assert('string' == typeof result);
            return result;
        }
        const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
        function makeIterator(iterator, name, kind) {
            const object = {
                index: 0,
                kind,
                target: iterator
            };
            const i = {
                next () {
                    if (Object.getPrototypeOf(this) !== i) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
                    const { index, kind, target } = object;
                    const values = target();
                    const len = values.length;
                    if (index >= len) return {
                        value: void 0,
                        done: true
                    };
                    const pair = values[index];
                    object.index = index + 1;
                    return iteratorResult(pair, kind);
                },
                [Symbol.toStringTag]: `${name} Iterator`
            };
            Object.setPrototypeOf(i, esIteratorPrototype);
            return Object.setPrototypeOf({}, i);
        }
        function iteratorResult(pair, kind) {
            let result;
            switch(kind){
                case 'key':
                    result = pair[0];
                    break;
                case 'value':
                    result = pair[1];
                    break;
                case 'key+value':
                    result = pair;
                    break;
            }
            return {
                value: result,
                done: false
            };
        }
        async function fullyReadBody(body, processBody, processBodyError) {
            const successSteps = processBody;
            const errorSteps = processBodyError;
            let reader;
            try {
                reader = body.stream.getReader();
            } catch (e) {
                errorSteps(e);
                return;
            }
            try {
                const result = await readAllBytes(reader);
                successSteps(result);
            } catch (e) {
                errorSteps(e);
            }
        }
        let ReadableStream = globalThis.ReadableStream;
        function isReadableStreamLike(stream) {
            if (!ReadableStream) ReadableStream = __webpack_require__("stream/web").ReadableStream;
            return stream instanceof ReadableStream || 'ReadableStream' === stream[Symbol.toStringTag] && 'function' == typeof stream.tee;
        }
        const MAXIMUM_ARGUMENT_LENGTH = 65535;
        function isomorphicDecode(input) {
            if (input.length < MAXIMUM_ARGUMENT_LENGTH) return String.fromCharCode(...input);
            return input.reduce((previous, current)=>previous + String.fromCharCode(current), '');
        }
        function readableStreamClose(controller) {
            try {
                controller.close();
            } catch (err) {
                if (!err.message.includes('Controller is already closed')) throw err;
            }
        }
        function isomorphicEncode(input) {
            for(let i = 0; i < input.length; i++)assert(input.charCodeAt(i) <= 0xFF);
            return input;
        }
        async function readAllBytes(reader) {
            const bytes = [];
            let byteLength = 0;
            while(true){
                const { done, value: chunk } = await reader.read();
                if (done) return Buffer.concat(bytes, byteLength);
                if (!isUint8Array(chunk)) throw new TypeError('Received non-Uint8Array chunk');
                bytes.push(chunk);
                byteLength += chunk.length;
            }
        }
        function urlIsLocal(url) {
            assert('protocol' in url);
            const protocol = url.protocol;
            return 'about:' === protocol || 'blob:' === protocol || 'data:' === protocol;
        }
        function urlHasHttpsScheme(url) {
            if ('string' == typeof url) return url.startsWith('https:');
            return 'https:' === url.protocol;
        }
        function urlIsHttpHttpsScheme(url) {
            assert('protocol' in url);
            const protocol = url.protocol;
            return 'http:' === protocol || 'https:' === protocol;
        }
        const hasOwn = Object.hasOwn || ((dict, key)=>Object.prototype.hasOwnProperty.call(dict, key));
        module.exports = {
            isAborted,
            isCancelled,
            createDeferredPromise,
            ReadableStreamFrom,
            toUSVString,
            tryUpgradeRequestToAPotentiallyTrustworthyURL,
            coarsenedSharedCurrentTime,
            determineRequestsReferrer,
            makePolicyContainer,
            clonePolicyContainer,
            appendFetchMetadata,
            appendRequestOriginHeader,
            TAOCheck,
            corsCheck,
            crossOriginResourcePolicyCheck,
            createOpaqueTimingInfo,
            setRequestReferrerPolicyOnRedirect,
            isValidHTTPToken,
            requestBadPort,
            requestCurrentURL,
            responseURL,
            responseLocationURL,
            isBlobLike,
            isURLPotentiallyTrustworthy,
            isValidReasonPhrase,
            sameOrigin,
            normalizeMethod,
            serializeJavascriptValueToJSONString,
            makeIterator,
            isValidHeaderName,
            isValidHeaderValue,
            hasOwn,
            isErrorLike,
            fullyReadBody,
            bytesMatch,
            isReadableStreamLike,
            readableStreamClose,
            isomorphicEncode,
            isomorphicDecode,
            urlIsLocal,
            urlHasHttpsScheme,
            urlIsHttpHttpsScheme,
            readAllBytes,
            normalizeMethodRecord,
            parseMetadata
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { types } = __webpack_require__("util");
        const { hasOwn, toUSVString } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js");
        const webidl = {};
        webidl.converters = {};
        webidl.util = {};
        webidl.errors = {};
        webidl.errors.exception = function(message) {
            return new TypeError(`${message.header}: ${message.message}`);
        };
        webidl.errors.conversionFailed = function(context) {
            const plural = 1 === context.types.length ? '' : ' one of';
            const message = `${context.argument} could not be converted to${plural}: ${context.types.join(', ')}.`;
            return webidl.errors.exception({
                header: context.prefix,
                message
            });
        };
        webidl.errors.invalidArgument = function(context) {
            return webidl.errors.exception({
                header: context.prefix,
                message: `"${context.value}" is an invalid ${context.type}.`
            });
        };
        webidl.brandCheck = function(V, I, opts) {
            if (opts?.strict === false || V instanceof I) return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
            throw new TypeError('Illegal invocation');
        };
        webidl.argumentLengthCheck = function({ length }, min, ctx) {
            if (length < min) throw webidl.errors.exception({
                message: `${min} argument${1 !== min ? 's' : ''} required, but${length ? ' only' : ''} ${length} found.`,
                ...ctx
            });
        };
        webidl.illegalConstructor = function() {
            throw webidl.errors.exception({
                header: 'TypeError',
                message: 'Illegal constructor'
            });
        };
        webidl.util.Type = function(V) {
            switch(typeof V){
                case 'undefined':
                    return 'Undefined';
                case 'boolean':
                    return 'Boolean';
                case 'string':
                    return 'String';
                case 'symbol':
                    return 'Symbol';
                case 'number':
                    return 'Number';
                case 'bigint':
                    return 'BigInt';
                case 'function':
                case 'object':
                    if (null === V) return 'Null';
                    return 'Object';
            }
        };
        webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
            let upperBound;
            let lowerBound;
            if (64 === bitLength) {
                upperBound = Math.pow(2, 53) - 1;
                lowerBound = 'unsigned' === signedness ? 0 : Math.pow(-2, 53) + 1;
            } else if ('unsigned' === signedness) {
                lowerBound = 0;
                upperBound = Math.pow(2, bitLength) - 1;
            } else {
                lowerBound = Math.pow(-2, bitLength) - 1;
                upperBound = Math.pow(2, bitLength - 1) - 1;
            }
            let x = Number(V);
            if (0 === x) x = 0;
            if (true === opts.enforceRange) {
                if (Number.isNaN(x) || x === 1 / 0 || x === -1 / 0) throw webidl.errors.exception({
                    header: 'Integer conversion',
                    message: `Could not convert ${V} to an integer.`
                });
                x = webidl.util.IntegerPart(x);
                if (x < lowerBound || x > upperBound) throw webidl.errors.exception({
                    header: 'Integer conversion',
                    message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
                });
                return x;
            }
            if (!Number.isNaN(x) && true === opts.clamp) {
                x = Math.min(Math.max(x, lowerBound), upperBound);
                x = Math.floor(x) % 2 === 0 ? Math.floor(x) : Math.ceil(x);
                return x;
            }
            if (Number.isNaN(x) || 0 === x && Object.is(0, x) || x === 1 / 0 || x === -1 / 0) return 0;
            x = webidl.util.IntegerPart(x);
            x %= Math.pow(2, bitLength);
            if ('signed' === signedness && x >= Math.pow(2, bitLength) - 1) return x - Math.pow(2, bitLength);
            return x;
        };
        webidl.util.IntegerPart = function(n) {
            const r = Math.floor(Math.abs(n));
            if (n < 0) return -1 * r;
            return r;
        };
        webidl.sequenceConverter = function(converter) {
            return (V)=>{
                if ('Object' !== webidl.util.Type(V)) throw webidl.errors.exception({
                    header: 'Sequence',
                    message: `Value of type ${webidl.util.Type(V)} is not an Object.`
                });
                const method = V?.[Symbol.iterator]?.();
                const seq = [];
                if (void 0 === method || 'function' != typeof method.next) throw webidl.errors.exception({
                    header: 'Sequence',
                    message: 'Object is not an iterator.'
                });
                while(true){
                    const { done, value } = method.next();
                    if (done) break;
                    seq.push(converter(value));
                }
                return seq;
            };
        };
        webidl.recordConverter = function(keyConverter, valueConverter) {
            return (O)=>{
                if ('Object' !== webidl.util.Type(O)) throw webidl.errors.exception({
                    header: 'Record',
                    message: `Value of type ${webidl.util.Type(O)} is not an Object.`
                });
                const result = {};
                if (!types.isProxy(O)) {
                    const keys = Object.keys(O);
                    for (const key of keys){
                        const typedKey = keyConverter(key);
                        const typedValue = valueConverter(O[key]);
                        result[typedKey] = typedValue;
                    }
                    return result;
                }
                const keys = Reflect.ownKeys(O);
                for (const key of keys){
                    const desc = Reflect.getOwnPropertyDescriptor(O, key);
                    if (desc?.enumerable) {
                        const typedKey = keyConverter(key);
                        const typedValue = valueConverter(O[key]);
                        result[typedKey] = typedValue;
                    }
                }
                return result;
            };
        };
        webidl.interfaceConverter = function(i) {
            return (V, opts = {})=>{
                if (false !== opts.strict && !(V instanceof i)) throw webidl.errors.exception({
                    header: i.name,
                    message: `Expected ${V} to be an instance of ${i.name}.`
                });
                return V;
            };
        };
        webidl.dictionaryConverter = function(converters) {
            return (dictionary)=>{
                const type = webidl.util.Type(dictionary);
                const dict = {};
                if ('Null' === type || 'Undefined' === type) return dict;
                if ('Object' !== type) throw webidl.errors.exception({
                    header: 'Dictionary',
                    message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
                });
                for (const options of converters){
                    const { key, defaultValue, required, converter } = options;
                    if (true === required) {
                        if (!hasOwn(dictionary, key)) throw webidl.errors.exception({
                            header: 'Dictionary',
                            message: `Missing required key "${key}".`
                        });
                    }
                    let value = dictionary[key];
                    const hasDefault = hasOwn(options, 'defaultValue');
                    if (hasDefault && null !== value) value = value ?? defaultValue;
                    if (required || hasDefault || void 0 !== value) {
                        value = converter(value);
                        if (options.allowedValues && !options.allowedValues.includes(value)) throw webidl.errors.exception({
                            header: 'Dictionary',
                            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`
                        });
                        dict[key] = value;
                    }
                }
                return dict;
            };
        };
        webidl.nullableConverter = function(converter) {
            return (V)=>{
                if (null === V) return V;
                return converter(V);
            };
        };
        webidl.converters.DOMString = function(V, opts = {}) {
            if (null === V && opts.legacyNullToEmptyString) return '';
            if ('symbol' == typeof V) throw new TypeError('Could not convert argument of type symbol to string.');
            return String(V);
        };
        webidl.converters.ByteString = function(V) {
            const x = webidl.converters.DOMString(V);
            for(let index = 0; index < x.length; index++)if (x.charCodeAt(index) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
            return x;
        };
        webidl.converters.USVString = toUSVString;
        webidl.converters.boolean = function(V) {
            const x = Boolean(V);
            return x;
        };
        webidl.converters.any = function(V) {
            return V;
        };
        webidl.converters['long long'] = function(V) {
            const x = webidl.util.ConvertToInt(V, 64, 'signed');
            return x;
        };
        webidl.converters['unsigned long long'] = function(V) {
            const x = webidl.util.ConvertToInt(V, 64, 'unsigned');
            return x;
        };
        webidl.converters['unsigned long'] = function(V) {
            const x = webidl.util.ConvertToInt(V, 32, 'unsigned');
            return x;
        };
        webidl.converters['unsigned short'] = function(V, opts) {
            const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts);
            return x;
        };
        webidl.converters.ArrayBuffer = function(V, opts = {}) {
            if ('Object' !== webidl.util.Type(V) || !types.isAnyArrayBuffer(V)) throw webidl.errors.conversionFailed({
                prefix: `${V}`,
                argument: `${V}`,
                types: [
                    'ArrayBuffer'
                ]
            });
            if (false === opts.allowShared && types.isSharedArrayBuffer(V)) throw webidl.errors.exception({
                header: 'ArrayBuffer',
                message: 'SharedArrayBuffer is not allowed.'
            });
            return V;
        };
        webidl.converters.TypedArray = function(V, T, opts = {}) {
            if ('Object' !== webidl.util.Type(V) || !types.isTypedArray(V) || V.constructor.name !== T.name) throw webidl.errors.conversionFailed({
                prefix: `${T.name}`,
                argument: `${V}`,
                types: [
                    T.name
                ]
            });
            if (false === opts.allowShared && types.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
                header: 'ArrayBuffer',
                message: 'SharedArrayBuffer is not allowed.'
            });
            return V;
        };
        webidl.converters.DataView = function(V, opts = {}) {
            if ('Object' !== webidl.util.Type(V) || !types.isDataView(V)) throw webidl.errors.exception({
                header: 'DataView',
                message: 'Object is not a DataView.'
            });
            if (false === opts.allowShared && types.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
                header: 'ArrayBuffer',
                message: 'SharedArrayBuffer is not allowed.'
            });
            return V;
        };
        webidl.converters.BufferSource = function(V, opts = {}) {
            if (types.isAnyArrayBuffer(V)) return webidl.converters.ArrayBuffer(V, opts);
            if (types.isTypedArray(V)) return webidl.converters.TypedArray(V, V.constructor);
            if (types.isDataView(V)) return webidl.converters.DataView(V, opts);
            throw new TypeError(`Could not convert ${V} to a BufferSource.`);
        };
        webidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(webidl.converters.ByteString);
        webidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(webidl.converters['sequence<ByteString>']);
        webidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
        module.exports = {
            webidl
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/encoding.js" (module) {
        "use strict";
        function getEncoding(label) {
            if (!label) return 'failure';
            switch(label.trim().toLowerCase()){
                case 'unicode-1-1-utf-8':
                case 'unicode11utf8':
                case 'unicode20utf8':
                case 'utf-8':
                case 'utf8':
                case 'x-unicode20utf8':
                    return 'UTF-8';
                case '866':
                case 'cp866':
                case 'csibm866':
                case 'ibm866':
                    return 'IBM866';
                case 'csisolatin2':
                case 'iso-8859-2':
                case 'iso-ir-101':
                case 'iso8859-2':
                case 'iso88592':
                case 'iso_8859-2':
                case 'iso_8859-2:1987':
                case 'l2':
                case 'latin2':
                    return 'ISO-8859-2';
                case 'csisolatin3':
                case 'iso-8859-3':
                case 'iso-ir-109':
                case 'iso8859-3':
                case 'iso88593':
                case 'iso_8859-3':
                case 'iso_8859-3:1988':
                case 'l3':
                case 'latin3':
                    return 'ISO-8859-3';
                case 'csisolatin4':
                case 'iso-8859-4':
                case 'iso-ir-110':
                case 'iso8859-4':
                case 'iso88594':
                case 'iso_8859-4':
                case 'iso_8859-4:1988':
                case 'l4':
                case 'latin4':
                    return 'ISO-8859-4';
                case 'csisolatincyrillic':
                case 'cyrillic':
                case 'iso-8859-5':
                case 'iso-ir-144':
                case 'iso8859-5':
                case 'iso88595':
                case 'iso_8859-5':
                case 'iso_8859-5:1988':
                    return 'ISO-8859-5';
                case 'arabic':
                case 'asmo-708':
                case 'csiso88596e':
                case 'csiso88596i':
                case 'csisolatinarabic':
                case 'ecma-114':
                case 'iso-8859-6':
                case 'iso-8859-6-e':
                case 'iso-8859-6-i':
                case 'iso-ir-127':
                case 'iso8859-6':
                case 'iso88596':
                case 'iso_8859-6':
                case 'iso_8859-6:1987':
                    return 'ISO-8859-6';
                case 'csisolatingreek':
                case 'ecma-118':
                case 'elot_928':
                case 'greek':
                case 'greek8':
                case 'iso-8859-7':
                case 'iso-ir-126':
                case 'iso8859-7':
                case 'iso88597':
                case 'iso_8859-7':
                case 'iso_8859-7:1987':
                case 'sun_eu_greek':
                    return 'ISO-8859-7';
                case 'csiso88598e':
                case 'csisolatinhebrew':
                case 'hebrew':
                case 'iso-8859-8':
                case 'iso-8859-8-e':
                case 'iso-ir-138':
                case 'iso8859-8':
                case 'iso88598':
                case 'iso_8859-8':
                case 'iso_8859-8:1988':
                case 'visual':
                    return 'ISO-8859-8';
                case 'csiso88598i':
                case 'iso-8859-8-i':
                case 'logical':
                    return 'ISO-8859-8-I';
                case 'csisolatin6':
                case 'iso-8859-10':
                case 'iso-ir-157':
                case 'iso8859-10':
                case 'iso885910':
                case 'l6':
                case 'latin6':
                    return 'ISO-8859-10';
                case 'iso-8859-13':
                case 'iso8859-13':
                case 'iso885913':
                    return 'ISO-8859-13';
                case 'iso-8859-14':
                case 'iso8859-14':
                case 'iso885914':
                    return 'ISO-8859-14';
                case 'csisolatin9':
                case 'iso-8859-15':
                case 'iso8859-15':
                case 'iso885915':
                case 'iso_8859-15':
                case 'l9':
                    return 'ISO-8859-15';
                case 'iso-8859-16':
                    return 'ISO-8859-16';
                case 'cskoi8r':
                case 'koi':
                case 'koi8':
                case 'koi8-r':
                case 'koi8_r':
                    return 'KOI8-R';
                case 'koi8-ru':
                case 'koi8-u':
                    return 'KOI8-U';
                case 'csmacintosh':
                case 'mac':
                case 'macintosh':
                case 'x-mac-roman':
                    return 'macintosh';
                case 'iso-8859-11':
                case 'iso8859-11':
                case 'iso885911':
                case 'tis-620':
                case 'windows-874':
                    return 'windows-874';
                case 'cp1250':
                case 'windows-1250':
                case 'x-cp1250':
                    return 'windows-1250';
                case 'cp1251':
                case 'windows-1251':
                case 'x-cp1251':
                    return 'windows-1251';
                case 'ansi_x3.4-1968':
                case 'ascii':
                case 'cp1252':
                case 'cp819':
                case 'csisolatin1':
                case 'ibm819':
                case 'iso-8859-1':
                case 'iso-ir-100':
                case 'iso8859-1':
                case 'iso88591':
                case 'iso_8859-1':
                case 'iso_8859-1:1987':
                case 'l1':
                case 'latin1':
                case 'us-ascii':
                case 'windows-1252':
                case 'x-cp1252':
                    return 'windows-1252';
                case 'cp1253':
                case 'windows-1253':
                case 'x-cp1253':
                    return 'windows-1253';
                case 'cp1254':
                case 'csisolatin5':
                case 'iso-8859-9':
                case 'iso-ir-148':
                case 'iso8859-9':
                case 'iso88599':
                case 'iso_8859-9':
                case 'iso_8859-9:1989':
                case 'l5':
                case 'latin5':
                case 'windows-1254':
                case 'x-cp1254':
                    return 'windows-1254';
                case 'cp1255':
                case 'windows-1255':
                case 'x-cp1255':
                    return 'windows-1255';
                case 'cp1256':
                case 'windows-1256':
                case 'x-cp1256':
                    return 'windows-1256';
                case 'cp1257':
                case 'windows-1257':
                case 'x-cp1257':
                    return 'windows-1257';
                case 'cp1258':
                case 'windows-1258':
                case 'x-cp1258':
                    return 'windows-1258';
                case 'x-mac-cyrillic':
                case 'x-mac-ukrainian':
                    return 'x-mac-cyrillic';
                case 'chinese':
                case 'csgb2312':
                case 'csiso58gb231280':
                case 'gb2312':
                case 'gb_2312':
                case 'gb_2312-80':
                case 'gbk':
                case 'iso-ir-58':
                case 'x-gbk':
                    return 'GBK';
                case 'gb18030':
                    return 'gb18030';
                case 'big5':
                case 'big5-hkscs':
                case 'cn-big5':
                case 'csbig5':
                case 'x-x-big5':
                    return 'Big5';
                case 'cseucpkdfmtjapanese':
                case 'euc-jp':
                case 'x-euc-jp':
                    return 'EUC-JP';
                case 'csiso2022jp':
                case 'iso-2022-jp':
                    return 'ISO-2022-JP';
                case 'csshiftjis':
                case 'ms932':
                case 'ms_kanji':
                case 'shift-jis':
                case 'shift_jis':
                case 'sjis':
                case 'windows-31j':
                case 'x-sjis':
                    return 'Shift_JIS';
                case 'cseuckr':
                case 'csksc56011987':
                case 'euc-kr':
                case 'iso-ir-149':
                case 'korean':
                case 'ks_c_5601-1987':
                case 'ks_c_5601-1989':
                case 'ksc5601':
                case 'ksc_5601':
                case 'windows-949':
                    return 'EUC-KR';
                case 'csiso2022kr':
                case 'hz-gb-2312':
                case 'iso-2022-cn':
                case 'iso-2022-cn-ext':
                case 'iso-2022-kr':
                case 'replacement':
                    return 'replacement';
                case 'unicodefffe':
                case 'utf-16be':
                    return 'UTF-16BE';
                case 'csunicode':
                case 'iso-10646-ucs-2':
                case 'ucs-2':
                case 'unicode':
                case 'unicodefeff':
                case 'utf-16':
                case 'utf-16le':
                    return 'UTF-16LE';
                case 'x-user-defined':
                    return 'x-user-defined';
                default:
                    return 'failure';
            }
        }
        module.exports = {
            getEncoding
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/filereader.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { staticPropertyDescriptors, readOperation, fireAProgressEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/util.js");
        const { kState, kError, kResult, kEvents, kAborted } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/symbols.js");
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        class FileReader extends EventTarget {
            constructor(){
                super();
                this[kState] = 'empty';
                this[kResult] = null;
                this[kError] = null;
                this[kEvents] = {
                    loadend: null,
                    error: null,
                    abort: null,
                    load: null,
                    progress: null,
                    loadstart: null
                };
            }
            readAsArrayBuffer(blob) {
                webidl.brandCheck(this, FileReader);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'FileReader.readAsArrayBuffer'
                });
                blob = webidl.converters.Blob(blob, {
                    strict: false
                });
                readOperation(this, blob, 'ArrayBuffer');
            }
            readAsBinaryString(blob) {
                webidl.brandCheck(this, FileReader);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'FileReader.readAsBinaryString'
                });
                blob = webidl.converters.Blob(blob, {
                    strict: false
                });
                readOperation(this, blob, 'BinaryString');
            }
            readAsText(blob, encoding) {
                webidl.brandCheck(this, FileReader);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'FileReader.readAsText'
                });
                blob = webidl.converters.Blob(blob, {
                    strict: false
                });
                if (void 0 !== encoding) encoding = webidl.converters.DOMString(encoding);
                readOperation(this, blob, 'Text', encoding);
            }
            readAsDataURL(blob) {
                webidl.brandCheck(this, FileReader);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'FileReader.readAsDataURL'
                });
                blob = webidl.converters.Blob(blob, {
                    strict: false
                });
                readOperation(this, blob, 'DataURL');
            }
            abort() {
                if ('empty' === this[kState] || 'done' === this[kState]) {
                    this[kResult] = null;
                    return;
                }
                if ('loading' === this[kState]) {
                    this[kState] = 'done';
                    this[kResult] = null;
                }
                this[kAborted] = true;
                fireAProgressEvent('abort', this);
                if ('loading' !== this[kState]) fireAProgressEvent('loadend', this);
            }
            get readyState() {
                webidl.brandCheck(this, FileReader);
                switch(this[kState]){
                    case 'empty':
                        return this.EMPTY;
                    case 'loading':
                        return this.LOADING;
                    case 'done':
                        return this.DONE;
                }
            }
            get result() {
                webidl.brandCheck(this, FileReader);
                return this[kResult];
            }
            get error() {
                webidl.brandCheck(this, FileReader);
                return this[kError];
            }
            get onloadend() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].loadend;
            }
            set onloadend(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].loadend) this.removeEventListener('loadend', this[kEvents].loadend);
                if ('function' == typeof fn) {
                    this[kEvents].loadend = fn;
                    this.addEventListener('loadend', fn);
                } else this[kEvents].loadend = null;
            }
            get onerror() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].error;
            }
            set onerror(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].error) this.removeEventListener('error', this[kEvents].error);
                if ('function' == typeof fn) {
                    this[kEvents].error = fn;
                    this.addEventListener('error', fn);
                } else this[kEvents].error = null;
            }
            get onloadstart() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].loadstart;
            }
            set onloadstart(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].loadstart) this.removeEventListener('loadstart', this[kEvents].loadstart);
                if ('function' == typeof fn) {
                    this[kEvents].loadstart = fn;
                    this.addEventListener('loadstart', fn);
                } else this[kEvents].loadstart = null;
            }
            get onprogress() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].progress;
            }
            set onprogress(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].progress) this.removeEventListener('progress', this[kEvents].progress);
                if ('function' == typeof fn) {
                    this[kEvents].progress = fn;
                    this.addEventListener('progress', fn);
                } else this[kEvents].progress = null;
            }
            get onload() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].load;
            }
            set onload(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].load) this.removeEventListener('load', this[kEvents].load);
                if ('function' == typeof fn) {
                    this[kEvents].load = fn;
                    this.addEventListener('load', fn);
                } else this[kEvents].load = null;
            }
            get onabort() {
                webidl.brandCheck(this, FileReader);
                return this[kEvents].abort;
            }
            set onabort(fn) {
                webidl.brandCheck(this, FileReader);
                if (this[kEvents].abort) this.removeEventListener('abort', this[kEvents].abort);
                if ('function' == typeof fn) {
                    this[kEvents].abort = fn;
                    this.addEventListener('abort', fn);
                } else this[kEvents].abort = null;
            }
        }
        FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
        FileReader.LOADING = FileReader.prototype.LOADING = 1;
        FileReader.DONE = FileReader.prototype.DONE = 2;
        Object.defineProperties(FileReader.prototype, {
            EMPTY: staticPropertyDescriptors,
            LOADING: staticPropertyDescriptors,
            DONE: staticPropertyDescriptors,
            readAsArrayBuffer: kEnumerableProperty,
            readAsBinaryString: kEnumerableProperty,
            readAsText: kEnumerableProperty,
            readAsDataURL: kEnumerableProperty,
            abort: kEnumerableProperty,
            readyState: kEnumerableProperty,
            result: kEnumerableProperty,
            error: kEnumerableProperty,
            onloadstart: kEnumerableProperty,
            onprogress: kEnumerableProperty,
            onload: kEnumerableProperty,
            onabort: kEnumerableProperty,
            onerror: kEnumerableProperty,
            onloadend: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'FileReader',
                writable: false,
                enumerable: false,
                configurable: true
            }
        });
        Object.defineProperties(FileReader, {
            EMPTY: staticPropertyDescriptors,
            LOADING: staticPropertyDescriptors,
            DONE: staticPropertyDescriptors
        });
        module.exports = {
            FileReader
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/progressevent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const kState = Symbol('ProgressEvent state');
        class ProgressEvent extends Event {
            constructor(type, eventInitDict = {}){
                type = webidl.converters.DOMString(type);
                eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
                super(type, eventInitDict);
                this[kState] = {
                    lengthComputable: eventInitDict.lengthComputable,
                    loaded: eventInitDict.loaded,
                    total: eventInitDict.total
                };
            }
            get lengthComputable() {
                webidl.brandCheck(this, ProgressEvent);
                return this[kState].lengthComputable;
            }
            get loaded() {
                webidl.brandCheck(this, ProgressEvent);
                return this[kState].loaded;
            }
            get total() {
                webidl.brandCheck(this, ProgressEvent);
                return this[kState].total;
            }
        }
        webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
            {
                key: 'lengthComputable',
                converter: webidl.converters.boolean,
                defaultValue: false
            },
            {
                key: 'loaded',
                converter: webidl.converters['unsigned long long'],
                defaultValue: 0
            },
            {
                key: 'total',
                converter: webidl.converters['unsigned long long'],
                defaultValue: 0
            },
            {
                key: 'bubbles',
                converter: webidl.converters.boolean,
                defaultValue: false
            },
            {
                key: 'cancelable',
                converter: webidl.converters.boolean,
                defaultValue: false
            },
            {
                key: 'composed',
                converter: webidl.converters.boolean,
                defaultValue: false
            }
        ]);
        module.exports = {
            ProgressEvent
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/symbols.js" (module) {
        "use strict";
        module.exports = {
            kState: Symbol('FileReader state'),
            kResult: Symbol('FileReader result'),
            kError: Symbol('FileReader error'),
            kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),
            kEvents: Symbol('FileReader events'),
            kAborted: Symbol('FileReader aborted')
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kState, kError, kResult, kAborted, kLastProgressEventFired } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/symbols.js");
        const { ProgressEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/progressevent.js");
        const { getEncoding } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/encoding.js");
        const { DOMException: DOMException1 } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js");
        const { serializeAMimeType, parseMIMEType } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
        const { types } = __webpack_require__("util");
        const { StringDecoder } = __webpack_require__("string_decoder");
        const { btoa: btoa1 } = __webpack_require__("buffer");
        const staticPropertyDescriptors = {
            enumerable: true,
            writable: false,
            configurable: false
        };
        function readOperation(fr, blob, type, encodingName) {
            if ('loading' === fr[kState]) throw new DOMException1('Invalid state', 'InvalidStateError');
            fr[kState] = 'loading';
            fr[kResult] = null;
            fr[kError] = null;
            const stream = blob.stream();
            const reader = stream.getReader();
            const bytes = [];
            let chunkPromise = reader.read();
            let isFirstChunk = true;
            (async ()=>{
                while(!fr[kAborted])try {
                    const { done, value } = await chunkPromise;
                    if (isFirstChunk && !fr[kAborted]) queueMicrotask(()=>{
                        fireAProgressEvent('loadstart', fr);
                    });
                    isFirstChunk = false;
                    if (!done && types.isUint8Array(value)) {
                        bytes.push(value);
                        if ((void 0 === fr[kLastProgressEventFired] || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                            fr[kLastProgressEventFired] = Date.now();
                            queueMicrotask(()=>{
                                fireAProgressEvent('progress', fr);
                            });
                        }
                        chunkPromise = reader.read();
                    } else if (done) {
                        queueMicrotask(()=>{
                            fr[kState] = 'done';
                            try {
                                const result = packageData(bytes, type, blob.type, encodingName);
                                if (fr[kAborted]) return;
                                fr[kResult] = result;
                                fireAProgressEvent('load', fr);
                            } catch (error) {
                                fr[kError] = error;
                                fireAProgressEvent('error', fr);
                            }
                            if ('loading' !== fr[kState]) fireAProgressEvent('loadend', fr);
                        });
                        break;
                    }
                } catch (error) {
                    if (fr[kAborted]) return;
                    queueMicrotask(()=>{
                        fr[kState] = 'done';
                        fr[kError] = error;
                        fireAProgressEvent('error', fr);
                        if ('loading' !== fr[kState]) fireAProgressEvent('loadend', fr);
                    });
                    break;
                }
            })();
        }
        function fireAProgressEvent(e, reader) {
            const event = new ProgressEvent(e, {
                bubbles: false,
                cancelable: false
            });
            reader.dispatchEvent(event);
        }
        function packageData(bytes, type, mimeType, encodingName) {
            switch(type){
                case 'DataURL':
                    {
                        let dataURL = 'data:';
                        const parsed = parseMIMEType(mimeType || 'application/octet-stream');
                        if ('failure' !== parsed) dataURL += serializeAMimeType(parsed);
                        dataURL += ';base64,';
                        const decoder = new StringDecoder('latin1');
                        for (const chunk of bytes)dataURL += btoa1(decoder.write(chunk));
                        dataURL += btoa1(decoder.end());
                        return dataURL;
                    }
                case 'Text':
                    {
                        let encoding = 'failure';
                        if (encodingName) encoding = getEncoding(encodingName);
                        if ('failure' === encoding && mimeType) {
                            const type = parseMIMEType(mimeType);
                            if ('failure' !== type) encoding = getEncoding(type.parameters.get('charset'));
                        }
                        if ('failure' === encoding) encoding = 'UTF-8';
                        return decode(bytes, encoding);
                    }
                case 'ArrayBuffer':
                    {
                        const sequence = combineByteSequences(bytes);
                        return sequence.buffer;
                    }
                case 'BinaryString':
                    {
                        let binaryString = '';
                        const decoder = new StringDecoder('latin1');
                        for (const chunk of bytes)binaryString += decoder.write(chunk);
                        binaryString += decoder.end();
                        return binaryString;
                    }
            }
        }
        function decode(ioQueue, encoding) {
            const bytes = combineByteSequences(ioQueue);
            const BOMEncoding = BOMSniffing(bytes);
            let slice = 0;
            if (null !== BOMEncoding) {
                encoding = BOMEncoding;
                slice = 'UTF-8' === BOMEncoding ? 3 : 2;
            }
            const sliced = bytes.slice(slice);
            return new TextDecoder(encoding).decode(sliced);
        }
        function BOMSniffing(ioQueue) {
            const [a, b, c] = ioQueue;
            if (0xEF === a && 0xBB === b && 0xBF === c) return 'UTF-8';
            if (0xFE === a && 0xFF === b) return 'UTF-16BE';
            if (0xFF === a && 0xFE === b) return 'UTF-16LE';
            return null;
        }
        function combineByteSequences(sequences) {
            const size = sequences.reduce((a, b)=>a + b.byteLength, 0);
            let offset = 0;
            return sequences.reduce((a, b)=>{
                a.set(b, offset);
                offset += b.byteLength;
                return a;
            }, new Uint8Array(size));
        }
        module.exports = {
            staticPropertyDescriptors,
            readOperation,
            fireAProgressEvent
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const globalDispatcher = Symbol.for('undici.globalDispatcher.1');
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const Agent = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/agent.js");
        if (void 0 === getGlobalDispatcher()) setGlobalDispatcher(new Agent());
        function setGlobalDispatcher(agent) {
            if (!agent || 'function' != typeof agent.dispatch) throw new InvalidArgumentError('Argument agent must implement Agent');
            Object.defineProperty(globalThis, globalDispatcher, {
                value: agent,
                writable: true,
                enumerable: false,
                configurable: false
            });
        }
        function getGlobalDispatcher() {
            return globalThis[globalDispatcher];
        }
        module.exports = {
            setGlobalDispatcher,
            getGlobalDispatcher
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/DecoratorHandler.js" (module) {
        "use strict";
        module.exports = class {
            constructor(handler){
                this.handler = handler;
            }
            onConnect(...args) {
                return this.handler.onConnect(...args);
            }
            onError(...args) {
                return this.handler.onError(...args);
            }
            onUpgrade(...args) {
                return this.handler.onUpgrade(...args);
            }
            onHeaders(...args) {
                return this.handler.onHeaders(...args);
            }
            onData(...args) {
                return this.handler.onData(...args);
            }
            onComplete(...args) {
                return this.handler.onComplete(...args);
            }
            onBodySent(...args) {
                return this.handler.onBodySent(...args);
            }
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RedirectHandler.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { kBodyUsed } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const assert = __webpack_require__("assert");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const EE = __webpack_require__("events");
        const redirectableStatusCodes = [
            300,
            301,
            302,
            303,
            307,
            308
        ];
        const kBody = Symbol('body');
        class BodyAsyncIterable {
            constructor(body){
                this[kBody] = body;
                this[kBodyUsed] = false;
            }
            async *[Symbol.asyncIterator]() {
                assert(!this[kBodyUsed], 'disturbed');
                this[kBodyUsed] = true;
                yield* this[kBody];
            }
        }
        class RedirectHandler {
            constructor(dispatch, maxRedirections, opts, handler){
                if (null != maxRedirections && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError('maxRedirections must be a positive number');
                util.validateHandler(handler, opts.method, opts.upgrade);
                this.dispatch = dispatch;
                this.location = null;
                this.abort = null;
                this.opts = {
                    ...opts,
                    maxRedirections: 0
                };
                this.maxRedirections = maxRedirections;
                this.handler = handler;
                this.history = [];
                if (util.isStream(this.opts.body)) {
                    if (0 === util.bodyLength(this.opts.body)) this.opts.body.on('data', function() {
                        assert(false);
                    });
                    if ('boolean' != typeof this.opts.body.readableDidRead) {
                        this.opts.body[kBodyUsed] = false;
                        EE.prototype.on.call(this.opts.body, 'data', function() {
                            this[kBodyUsed] = true;
                        });
                    }
                } else if (this.opts.body && 'function' == typeof this.opts.body.pipeTo) this.opts.body = new BodyAsyncIterable(this.opts.body);
                else if (this.opts.body && 'string' != typeof this.opts.body && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) this.opts.body = new BodyAsyncIterable(this.opts.body);
            }
            onConnect(abort) {
                this.abort = abort;
                this.handler.onConnect(abort, {
                    history: this.history
                });
            }
            onUpgrade(statusCode, headers, socket) {
                this.handler.onUpgrade(statusCode, headers, socket);
            }
            onError(error) {
                this.handler.onError(error);
            }
            onHeaders(statusCode, headers, resume, statusText) {
                this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
                if (this.opts.origin) this.history.push(new URL(this.opts.path, this.opts.origin));
                if (!this.location) return this.handler.onHeaders(statusCode, headers, resume, statusText);
                const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
                const path = search ? `${pathname}${search}` : pathname;
                this.opts.headers = cleanRequestHeaders(this.opts.headers, 303 === statusCode, this.opts.origin !== origin);
                this.opts.path = path;
                this.opts.origin = origin;
                this.opts.maxRedirections = 0;
                this.opts.query = null;
                if (303 === statusCode && 'HEAD' !== this.opts.method) {
                    this.opts.method = 'GET';
                    this.opts.body = null;
                }
            }
            onData(chunk) {
                if (!this.location) return this.handler.onData(chunk);
            }
            onComplete(trailers) {
                if (this.location) {
                    this.location = null;
                    this.abort = null;
                    this.dispatch(this.opts, this);
                } else this.handler.onComplete(trailers);
            }
            onBodySent(chunk) {
                if (this.handler.onBodySent) this.handler.onBodySent(chunk);
            }
        }
        function parseLocation(statusCode, headers) {
            if (-1 === redirectableStatusCodes.indexOf(statusCode)) return null;
            for(let i = 0; i < headers.length; i += 2)if ('location' === headers[i].toString().toLowerCase()) return headers[i + 1];
        }
        function shouldRemoveHeader(header, removeContent, unknownOrigin) {
            if (4 === header.length) return 'host' === util.headerNameToString(header);
            if (removeContent && util.headerNameToString(header).startsWith('content-')) return true;
            if (unknownOrigin && (13 === header.length || 6 === header.length || 19 === header.length)) {
                const name = util.headerNameToString(header);
                return 'authorization' === name || 'cookie' === name || 'proxy-authorization' === name;
            }
            return false;
        }
        function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
            const ret = [];
            if (Array.isArray(headers)) {
                for(let i = 0; i < headers.length; i += 2)if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) ret.push(headers[i], headers[i + 1]);
            } else if (headers && 'object' == typeof headers) {
                for (const key of Object.keys(headers))if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) ret.push(key, headers[key]);
            } else assert(null == headers, 'headers must be an object or an array');
            return ret;
        }
        module.exports = RedirectHandler;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RetryHandler.js" (module, __unused_rspack_exports, __webpack_require__) {
        const assert = __webpack_require__("assert");
        const { kRetryHandlerDefaultRetry } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const { RequestRetryError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const { isDisturbed, parseHeaders, parseRangeHeader } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        function calculateRetryAfterHeader(retryAfter) {
            const current = Date.now();
            const diff = new Date(retryAfter).getTime() - current;
            return diff;
        }
        class RetryHandler {
            constructor(opts, handlers){
                const { retryOptions, ...dispatchOpts } = opts;
                const { retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};
                this.dispatch = handlers.dispatch;
                this.handler = handlers.handler;
                this.opts = dispatchOpts;
                this.abort = null;
                this.aborted = false;
                this.retryOpts = {
                    retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
                    retryAfter: retryAfter ?? true,
                    maxTimeout: maxTimeout ?? 30000,
                    timeout: minTimeout ?? 500,
                    timeoutFactor: timeoutFactor ?? 2,
                    maxRetries: maxRetries ?? 5,
                    methods: methods ?? [
                        'GET',
                        'HEAD',
                        'OPTIONS',
                        'PUT',
                        'DELETE',
                        'TRACE'
                    ],
                    statusCodes: statusCodes ?? [
                        500,
                        502,
                        503,
                        504,
                        429
                    ],
                    errorCodes: errorCodes ?? [
                        'ECONNRESET',
                        'ECONNREFUSED',
                        'ENOTFOUND',
                        'ENETDOWN',
                        'ENETUNREACH',
                        'EHOSTDOWN',
                        'EHOSTUNREACH',
                        'EPIPE'
                    ]
                };
                this.retryCount = 0;
                this.start = 0;
                this.end = null;
                this.etag = null;
                this.resume = null;
                this.handler.onConnect((reason)=>{
                    this.aborted = true;
                    if (this.abort) this.abort(reason);
                    else this.reason = reason;
                });
            }
            onRequestSent() {
                if (this.handler.onRequestSent) this.handler.onRequestSent();
            }
            onUpgrade(statusCode, headers, socket) {
                if (this.handler.onUpgrade) this.handler.onUpgrade(statusCode, headers, socket);
            }
            onConnect(abort) {
                if (this.aborted) abort(this.reason);
                else this.abort = abort;
            }
            onBodySent(chunk) {
                if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
            }
            static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
                const { statusCode, code, headers } = err;
                const { method, retryOptions } = opts;
                const { maxRetries, timeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;
                let { counter, currentTimeout } = state;
                currentTimeout = null != currentTimeout && currentTimeout > 0 ? currentTimeout : timeout;
                if (code && 'UND_ERR_REQ_RETRY' !== code && 'UND_ERR_SOCKET' !== code && !errorCodes.includes(code)) return void cb(err);
                if (Array.isArray(methods) && !methods.includes(method)) return void cb(err);
                if (null != statusCode && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) return void cb(err);
                if (counter > maxRetries) return void cb(err);
                let retryAfterHeader = null != headers && headers['retry-after'];
                if (retryAfterHeader) {
                    retryAfterHeader = Number(retryAfterHeader);
                    retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : 1e3 * retryAfterHeader;
                }
                const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
                state.currentTimeout = retryTimeout;
                setTimeout(()=>cb(null), retryTimeout);
            }
            onHeaders(statusCode, rawHeaders, resume, statusMessage) {
                const headers = parseHeaders(rawHeaders);
                this.retryCount += 1;
                if (statusCode >= 300) {
                    this.abort(new RequestRetryError('Request failed', statusCode, {
                        headers,
                        count: this.retryCount
                    }));
                    return false;
                }
                if (null != this.resume) {
                    this.resume = null;
                    if (206 !== statusCode) return true;
                    const contentRange = parseRangeHeader(headers['content-range']);
                    if (!contentRange) {
                        this.abort(new RequestRetryError('Content-Range mismatch', statusCode, {
                            headers,
                            count: this.retryCount
                        }));
                        return false;
                    }
                    if (null != this.etag && this.etag !== headers.etag) {
                        this.abort(new RequestRetryError('ETag mismatch', statusCode, {
                            headers,
                            count: this.retryCount
                        }));
                        return false;
                    }
                    const { start, size, end = size } = contentRange;
                    assert(this.start === start, 'content-range mismatch');
                    assert(null == this.end || this.end === end, 'content-range mismatch');
                    this.resume = resume;
                    return true;
                }
                if (null == this.end) {
                    if (206 === statusCode) {
                        const range = parseRangeHeader(headers['content-range']);
                        if (null == range) return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
                        const { start, size, end = size } = range;
                        assert(null != start && Number.isFinite(start) && this.start !== start, 'content-range mismatch');
                        assert(Number.isFinite(start));
                        assert(null != end && Number.isFinite(end) && this.end !== end, 'invalid content-length');
                        this.start = start;
                        this.end = end;
                    }
                    if (null == this.end) {
                        const contentLength = headers['content-length'];
                        this.end = null != contentLength ? Number(contentLength) : null;
                    }
                    assert(Number.isFinite(this.start));
                    assert(null == this.end || Number.isFinite(this.end), 'invalid content-length');
                    this.resume = resume;
                    this.etag = null != headers.etag ? headers.etag : null;
                    return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
                }
                const err = new RequestRetryError('Request failed', statusCode, {
                    headers,
                    count: this.retryCount
                });
                this.abort(err);
                return false;
            }
            onData(chunk) {
                this.start += chunk.length;
                return this.handler.onData(chunk);
            }
            onComplete(rawTrailers) {
                this.retryCount = 0;
                return this.handler.onComplete(rawTrailers);
            }
            onError(err) {
                if (this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err);
                this.retryOpts.retry(err, {
                    state: {
                        counter: this.retryCount++,
                        currentTimeout: this.retryAfter
                    },
                    opts: {
                        retryOptions: this.retryOpts,
                        ...this.opts
                    }
                }, onRetry.bind(this));
                function onRetry(err) {
                    if (null != err || this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err);
                    if (0 !== this.start) this.opts = {
                        ...this.opts,
                        headers: {
                            ...this.opts.headers,
                            range: `bytes=${this.start}-${this.end ?? ''}`
                        }
                    };
                    try {
                        this.dispatch(this.opts, this);
                    } catch (err) {
                        this.handler.onError(err);
                    }
                }
            }
        }
        module.exports = RetryHandler;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/interceptor/redirectInterceptor.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const RedirectHandler = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RedirectHandler.js");
        function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
            return (dispatch)=>function(opts, handler) {
                    const { maxRedirections = defaultMaxRedirections } = opts;
                    if (!maxRedirections) return dispatch(opts, handler);
                    const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
                    opts = {
                        ...opts,
                        maxRedirections: 0
                    };
                    return dispatch(opts, redirectHandler);
                };
        }
        module.exports = createRedirectInterceptor;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/constants.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.SPECIAL_HEADERS = exports1.HEADER_STATE = exports1.MINOR = exports1.MAJOR = exports1.CONNECTION_TOKEN_CHARS = exports1.HEADER_CHARS = exports1.TOKEN = exports1.STRICT_TOKEN = exports1.HEX = exports1.URL_CHAR = exports1.STRICT_URL_CHAR = exports1.USERINFO_CHARS = exports1.MARK = exports1.ALPHANUM = exports1.NUM = exports1.HEX_MAP = exports1.NUM_MAP = exports1.ALPHA = exports1.FINISH = exports1.H_METHOD_MAP = exports1.METHOD_MAP = exports1.METHODS_RTSP = exports1.METHODS_ICE = exports1.METHODS_HTTP = exports1.METHODS = exports1.LENIENT_FLAGS = exports1.FLAGS = exports1.TYPE = exports1.ERROR = void 0;
        const utils_1 = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/utils.js");
        (function(ERROR) {
            ERROR[ERROR["OK"] = 0] = "OK";
            ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
            ERROR[ERROR["STRICT"] = 2] = "STRICT";
            ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
            ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
            ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
            ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
            ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
            ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
            ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
            ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
            ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
            ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
            ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
            ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
            ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
            ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
            ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
            ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
            ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
            ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
            ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
            ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
            ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
            ERROR[ERROR["USER"] = 24] = "USER";
        })(exports1.ERROR || (exports1.ERROR = {}));
        (function(TYPE) {
            TYPE[TYPE["BOTH"] = 0] = "BOTH";
            TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
            TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
        })(exports1.TYPE || (exports1.TYPE = {}));
        (function(FLAGS) {
            FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
            FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
            FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
            FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
            FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
            FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
            FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
            FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
            FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
        })(exports1.FLAGS || (exports1.FLAGS = {}));
        (function(LENIENT_FLAGS) {
            LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
            LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
            LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
        })(exports1.LENIENT_FLAGS || (exports1.LENIENT_FLAGS = {}));
        var METHODS;
        (function(METHODS) {
            METHODS[METHODS["DELETE"] = 0] = "DELETE";
            METHODS[METHODS["GET"] = 1] = "GET";
            METHODS[METHODS["HEAD"] = 2] = "HEAD";
            METHODS[METHODS["POST"] = 3] = "POST";
            METHODS[METHODS["PUT"] = 4] = "PUT";
            METHODS[METHODS["CONNECT"] = 5] = "CONNECT";
            METHODS[METHODS["OPTIONS"] = 6] = "OPTIONS";
            METHODS[METHODS["TRACE"] = 7] = "TRACE";
            METHODS[METHODS["COPY"] = 8] = "COPY";
            METHODS[METHODS["LOCK"] = 9] = "LOCK";
            METHODS[METHODS["MKCOL"] = 10] = "MKCOL";
            METHODS[METHODS["MOVE"] = 11] = "MOVE";
            METHODS[METHODS["PROPFIND"] = 12] = "PROPFIND";
            METHODS[METHODS["PROPPATCH"] = 13] = "PROPPATCH";
            METHODS[METHODS["SEARCH"] = 14] = "SEARCH";
            METHODS[METHODS["UNLOCK"] = 15] = "UNLOCK";
            METHODS[METHODS["BIND"] = 16] = "BIND";
            METHODS[METHODS["REBIND"] = 17] = "REBIND";
            METHODS[METHODS["UNBIND"] = 18] = "UNBIND";
            METHODS[METHODS["ACL"] = 19] = "ACL";
            METHODS[METHODS["REPORT"] = 20] = "REPORT";
            METHODS[METHODS["MKACTIVITY"] = 21] = "MKACTIVITY";
            METHODS[METHODS["CHECKOUT"] = 22] = "CHECKOUT";
            METHODS[METHODS["MERGE"] = 23] = "MERGE";
            METHODS[METHODS["M-SEARCH"] = 24] = "M-SEARCH";
            METHODS[METHODS["NOTIFY"] = 25] = "NOTIFY";
            METHODS[METHODS["SUBSCRIBE"] = 26] = "SUBSCRIBE";
            METHODS[METHODS["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
            METHODS[METHODS["PATCH"] = 28] = "PATCH";
            METHODS[METHODS["PURGE"] = 29] = "PURGE";
            METHODS[METHODS["MKCALENDAR"] = 30] = "MKCALENDAR";
            METHODS[METHODS["LINK"] = 31] = "LINK";
            METHODS[METHODS["UNLINK"] = 32] = "UNLINK";
            METHODS[METHODS["SOURCE"] = 33] = "SOURCE";
            METHODS[METHODS["PRI"] = 34] = "PRI";
            METHODS[METHODS["DESCRIBE"] = 35] = "DESCRIBE";
            METHODS[METHODS["ANNOUNCE"] = 36] = "ANNOUNCE";
            METHODS[METHODS["SETUP"] = 37] = "SETUP";
            METHODS[METHODS["PLAY"] = 38] = "PLAY";
            METHODS[METHODS["PAUSE"] = 39] = "PAUSE";
            METHODS[METHODS["TEARDOWN"] = 40] = "TEARDOWN";
            METHODS[METHODS["GET_PARAMETER"] = 41] = "GET_PARAMETER";
            METHODS[METHODS["SET_PARAMETER"] = 42] = "SET_PARAMETER";
            METHODS[METHODS["REDIRECT"] = 43] = "REDIRECT";
            METHODS[METHODS["RECORD"] = 44] = "RECORD";
            METHODS[METHODS["FLUSH"] = 45] = "FLUSH";
        })(METHODS = exports1.METHODS || (exports1.METHODS = {}));
        exports1.METHODS_HTTP = [
            METHODS.DELETE,
            METHODS.GET,
            METHODS.HEAD,
            METHODS.POST,
            METHODS.PUT,
            METHODS.CONNECT,
            METHODS.OPTIONS,
            METHODS.TRACE,
            METHODS.COPY,
            METHODS.LOCK,
            METHODS.MKCOL,
            METHODS.MOVE,
            METHODS.PROPFIND,
            METHODS.PROPPATCH,
            METHODS.SEARCH,
            METHODS.UNLOCK,
            METHODS.BIND,
            METHODS.REBIND,
            METHODS.UNBIND,
            METHODS.ACL,
            METHODS.REPORT,
            METHODS.MKACTIVITY,
            METHODS.CHECKOUT,
            METHODS.MERGE,
            METHODS['M-SEARCH'],
            METHODS.NOTIFY,
            METHODS.SUBSCRIBE,
            METHODS.UNSUBSCRIBE,
            METHODS.PATCH,
            METHODS.PURGE,
            METHODS.MKCALENDAR,
            METHODS.LINK,
            METHODS.UNLINK,
            METHODS.PRI,
            METHODS.SOURCE
        ];
        exports1.METHODS_ICE = [
            METHODS.SOURCE
        ];
        exports1.METHODS_RTSP = [
            METHODS.OPTIONS,
            METHODS.DESCRIBE,
            METHODS.ANNOUNCE,
            METHODS.SETUP,
            METHODS.PLAY,
            METHODS.PAUSE,
            METHODS.TEARDOWN,
            METHODS.GET_PARAMETER,
            METHODS.SET_PARAMETER,
            METHODS.REDIRECT,
            METHODS.RECORD,
            METHODS.FLUSH,
            METHODS.GET,
            METHODS.POST
        ];
        exports1.METHOD_MAP = utils_1.enumToMap(METHODS);
        exports1.H_METHOD_MAP = {};
        Object.keys(exports1.METHOD_MAP).forEach((key)=>{
            if (/^H/.test(key)) exports1.H_METHOD_MAP[key] = exports1.METHOD_MAP[key];
        });
        (function(FINISH) {
            FINISH[FINISH["SAFE"] = 0] = "SAFE";
            FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
            FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
        })(exports1.FINISH || (exports1.FINISH = {}));
        exports1.ALPHA = [];
        for(let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++){
            exports1.ALPHA.push(String.fromCharCode(i));
            exports1.ALPHA.push(String.fromCharCode(i + 0x20));
        }
        exports1.NUM_MAP = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9
        };
        exports1.HEX_MAP = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            A: 0XA,
            B: 0XB,
            C: 0XC,
            D: 0XD,
            E: 0XE,
            F: 0XF,
            a: 0xa,
            b: 0xb,
            c: 0xc,
            d: 0xd,
            e: 0xe,
            f: 0xf
        };
        exports1.NUM = [
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9'
        ];
        exports1.ALPHANUM = exports1.ALPHA.concat(exports1.NUM);
        exports1.MARK = [
            '-',
            '_',
            '.',
            '!',
            '~',
            '*',
            '\'',
            '(',
            ')'
        ];
        exports1.USERINFO_CHARS = exports1.ALPHANUM.concat(exports1.MARK).concat([
            '%',
            ';',
            ':',
            '&',
            '=',
            '+',
            '$',
            ','
        ]);
        exports1.STRICT_URL_CHAR = [
            '!',
            '"',
            '$',
            '%',
            '&',
            '\'',
            '(',
            ')',
            '*',
            '+',
            ',',
            '-',
            '.',
            '/',
            ':',
            ';',
            '<',
            '=',
            '>',
            '@',
            '[',
            '\\',
            ']',
            '^',
            '_',
            '`',
            '{',
            '|',
            '}',
            '~'
        ].concat(exports1.ALPHANUM);
        exports1.URL_CHAR = exports1.STRICT_URL_CHAR.concat([
            '\t',
            '\f'
        ]);
        for(let i = 0x80; i <= 0xff; i++)exports1.URL_CHAR.push(i);
        exports1.HEX = exports1.NUM.concat([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'A',
            'B',
            'C',
            'D',
            'E',
            'F'
        ]);
        exports1.STRICT_TOKEN = [
            '!',
            '#',
            '$',
            '%',
            '&',
            '\'',
            '*',
            '+',
            '-',
            '.',
            '^',
            '_',
            '`',
            '|',
            '~'
        ].concat(exports1.ALPHANUM);
        exports1.TOKEN = exports1.STRICT_TOKEN.concat([
            ' '
        ]);
        exports1.HEADER_CHARS = [
            '\t'
        ];
        for(let i = 32; i <= 255; i++)if (127 !== i) exports1.HEADER_CHARS.push(i);
        exports1.CONNECTION_TOKEN_CHARS = exports1.HEADER_CHARS.filter((c)=>44 !== c);
        exports1.MAJOR = exports1.NUM_MAP;
        exports1.MINOR = exports1.MAJOR;
        var HEADER_STATE;
        (function(HEADER_STATE) {
            HEADER_STATE[HEADER_STATE["GENERAL"] = 0] = "GENERAL";
            HEADER_STATE[HEADER_STATE["CONNECTION"] = 1] = "CONNECTION";
            HEADER_STATE[HEADER_STATE["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
            HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
            HEADER_STATE[HEADER_STATE["UPGRADE"] = 4] = "UPGRADE";
            HEADER_STATE[HEADER_STATE["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
            HEADER_STATE[HEADER_STATE["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
            HEADER_STATE[HEADER_STATE["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
            HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
        })(HEADER_STATE = exports1.HEADER_STATE || (exports1.HEADER_STATE = {}));
        exports1.SPECIAL_HEADERS = {
            connection: HEADER_STATE.CONNECTION,
            'content-length': HEADER_STATE.CONTENT_LENGTH,
            'proxy-connection': HEADER_STATE.CONNECTION,
            'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
            upgrade: HEADER_STATE.UPGRADE
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp-wasm.js" (module) {
        module.exports = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAUNgIUIAAgATYCDEEAIRAMogELIABBADYCHCAAIBQ2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKEBCyAAQQA2AhwgACABNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhEAygAQtBACEQIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgwMnwELIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgxBACEQDJ4BCyAAQQA2AhwgACAUNgIUIABB/pGAgAA2AhAgAEEHNgIMQQAhEAydAQsgAEEANgIcIAAgATYCFCAAQY6bgIAANgIQIABBBjYCDEEAIRAMnAELIBBBFUYNVyAAQQA2AhwgACABNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhEAybAQsgAEEANgIAIBBBAWohAUEkIRALIAAgEDoAKSAAKAIEIRAgAEEANgIEIAAgECABEKuAgIAAIhANVCABIQEMPgsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQfGbgIAANgIQIABBBjYCDAyXAQsgAUEVRg1QIABBADYCHCAAIAU2AhQgAEHwjICAADYCECAAQRs2AgxBACEQDJYBCyAAKAIEIQUgAEEANgIEIAAgBSAQEKmAgIAAIgUNASAQQQFqIQULQa0BIRAMewsgAEHBATYCHCAAIAU2AgwgACAQQQFqNgIUQQAhEAyTAQsgACgCBCEGIABBADYCBCAAIAYgEBCpgICAACIGDQEgEEEBaiEGC0GuASEQDHgLIABBwgE2AhwgACAGNgIMIAAgEEEBajYCFEEAIRAMkAELIABBADYCHCAAIAc2AhQgAEGXi4CAADYCECAAQQ02AgxBACEQDI8BCyAAQQA2AhwgACAINgIUIABB45CAgAA2AhAgAEEJNgIMQQAhEAyOAQsgAEEANgIcIAAgCDYCFCAAQZSNgIAANgIQIABBITYCDEEAIRAMjQELQQEhFkEAIRdBACEUQQEhEAsgACAQOgArIAlBAWohCAJAAkAgAC0ALUEQcQ0AAkACQAJAIAAtACoOAwEAAgQLIBZFDQMMAgsgFA0BDAILIBdFDQELIAAoAgQhECAAQQA2AgQgACAQIAgQrYCAgAAiEEUNPSAAQckBNgIcIAAgCDYCFCAAIBA2AgxBACEQDIwBCyAAKAIEIQQgAEEANgIEIAAgBCAIEK2AgIAAIgRFDXYgAEHKATYCHCAAIAg2AhQgACAENgIMQQAhEAyLAQsgACgCBCEEIABBADYCBCAAIAQgCRCtgICAACIERQ10IABBywE2AhwgACAJNgIUIAAgBDYCDEEAIRAMigELIAAoAgQhBCAAQQA2AgQgACAEIAoQrYCAgAAiBEUNciAAQc0BNgIcIAAgCjYCFCAAIAQ2AgxBACEQDIkBCwJAIAstAABBUGoiEEH/AXFBCk8NACAAIBA6ACogC0EBaiEKQbYBIRAMcAsgACgCBCEEIABBADYCBCAAIAQgCxCtgICAACIERQ1wIABBzwE2AhwgACALNgIUIAAgBDYCDEEAIRAMiAELIABBADYCHCAAIAQ2AhQgAEGQs4CAADYCECAAQQg2AgwgAEEANgIAQQAhEAyHAQsgAUEVRg0/IABBADYCHCAAIAw2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDIYBCyAAQYEEOwEoIAAoAgQhECAAQgA3AwAgACAQIAxBAWoiDBCrgICAACIQRQ04IABB0wE2AhwgACAMNgIUIAAgEDYCDEEAIRAMhQELIABBADYCAAtBACEQIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMgwELIAAoAgQhECAAQgA3AwAgACAQIAtBAWoiCxCrgICAACIQDQFBxgEhEAxpCyAAQQI6ACgMVQsgAEHVATYCHCAAIAs2AhQgACAQNgIMQQAhEAyAAQsgEEEVRg03IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEQDH8LIAAtADRBAUcNNCAAIAQgAhC8gICAACIQRQ00IBBBFUcNNSAAQdwBNgIcIAAgBDYCFCAAQdWWgIAANgIQIABBFTYCDEEAIRAMfgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQMfQtBACEQDGMLQQIhEAxiC0ENIRAMYQtBDyEQDGALQSUhEAxfC0ETIRAMXgtBFSEQDF0LQRYhEAxcC0EXIRAMWwtBGCEQDFoLQRkhEAxZC0EaIRAMWAtBGyEQDFcLQRwhEAxWC0EdIRAMVQtBHyEQDFQLQSEhEAxTC0EjIRAMUgtBxgAhEAxRC0EuIRAMUAtBLyEQDE8LQTshEAxOC0E9IRAMTQtByAAhEAxMC0HJACEQDEsLQcsAIRAMSgtBzAAhEAxJC0HOACEQDEgLQdEAIRAMRwtB1QAhEAxGC0HYACEQDEULQdkAIRAMRAtB2wAhEAxDC0HkACEQDEILQeUAIRAMQQtB8QAhEAxAC0H0ACEQDD8LQY0BIRAMPgtBlwEhEAw9C0GpASEQDDwLQawBIRAMOwtBwAEhEAw6C0G5ASEQDDkLQa8BIRAMOAtBsQEhEAw3C0GyASEQDDYLQbQBIRAMNQtBtQEhEAw0C0G6ASEQDDMLQb0BIRAMMgtBvwEhEAwxC0HBASEQDDALIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEQDEgLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhEAxHCyAAQfgANgIcIAAgDDYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMRgsgAEHRADYCHCAAIAU2AhQgAEGwl4CAADYCECAAQRU2AgxBACEQDEULIABB+QA2AhwgACABNgIUIAAgEDYCDEEAIRAMRAsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEQDEMLIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAxCCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAIRAMQQsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMQAsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEQDD8LIABBADYCBCAAIA8gDxCxgICAACIERQ0BIABBOjYCHCAAIAQ2AgwgACAPQQFqNgIUQQAhEAw+CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAIRAMPgsgAUEBaiEBDC0LIA9BAWohAQwtCyAAQQA2AhwgACAPNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhEAw7CyAAQTY2AhwgACAENgIUIAAgAjYCDEEAIRAMOgsgAEEuNgIcIAAgDjYCFCAAIAQ2AgxBACEQDDkLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhEAw4CyANQQFqIQEMLAsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMNgsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNQsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNAsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMMwsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMgsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMQsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAIRAMMAsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAMLwsgAEEANgIcIAAgEDYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMLgsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMLQsgAEEANgIAIAtBAWohCwtBuAEhEAwSCyAAQQA2AgAgEEEBaiEBQfUAIRAMEQsgASEBAkAgAC0AKUEFRw0AQeMAIRAMEQtB4gAhEAwQC0EAIRAgAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAwoCyAAQQA2AgAgF0EBaiEBQcAAIRAMDgtBASEBCyAAIAE6ACwgAEEANgIAIBdBAWohAQtBKCEQDAsLIAEhAQtBOCEQDAkLAkAgASIPIAJGDQADQAJAIA8tAABBgL6AgABqLQAAIgFBAUYNACABQQJHDQMgD0EBaiEBDAQLIA9BAWoiDyACRw0AC0E+IRAMIgtBPiEQDCELIABBADoALCAPIQEMAQtBCyEQDAYLQTohEAwFCyABQQFqIQFBLSEQDAQLIAAgAToALCAAQQA2AgAgFkEBaiEBQQwhEAwDCyAAQQA2AgAgF0EBaiEBQQohEAwCCyAAQQA2AgALIABBADoALCANIQFBCSEQDAALC0EAIRAgAEEANgIcIAAgCzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAIRAgAEEANgIcIAAgCjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAIRAgAEEANgIcIAAgCTYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAIRAgAEEANgIcIAAgCDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAIRAgAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAIRAgAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAIRAgAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAIRAgAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAIRAgAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAIRAgAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAIRAgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAIRAgAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAIRAgAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAIRAgAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAIRAgAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhEAwGC0EBIRAMBQtB1AAhECABIgQgAkYNBCADQQhqIAAgBCACQdjCgIAAQQoQxYCAgAAgAygCDCEEIAMoAggOAwEEAgALEMqAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgBEEBajYCFEEAIRAMAgsgAEEANgIcIAAgBDYCFCAAQcqagIAANgIQIABBCTYCDEEAIRAMAQsCQCABIgQgAkcNAEEiIRAMAQsgAEGJgICAADYCCCAAIAQ2AgRBISEQCyADQRBqJICAgIAAIBALrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAvyNgELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMuAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAkFIaiIFIANrIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAQYDUhIAAIAVqQTg2AgQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQACQAJAIANBAXEgBHJBAXMiBUEDdCIEQbDQgIAAaiIDIARBuNCAgABqKAIAIgQoAggiAkcNAEEAIAZBfiAFd3E2AojQgIAADAELIAMgAjYCCCACIAM2AgwLIARBCGohAyAEIAVBA3QiBUEDcjYCBCAEIAVqIgQgBCgCBEEBcjYCBAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgRBA3QiA0Gw0ICAAGoiBSADQbjQgIAAaigCACIDKAIIIgBHDQBBACAGQX4gBHdxIgY2AojQgIAADAELIAUgADYCCCAAIAU2AgwLIAMgAkEDcjYCBCADIARBA3QiBGogBCACayIFNgIAIAMgAmoiACAFQQFyNgIEAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAHQQN2dCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIICyADQQhqIQNBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQAgACgCCCIDQQAoApjQgIAASRogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNACAIKAIIIgNBACgCmNCAgABJGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAQgA2oiAyADKAIEQQFyNgIEQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMuAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMuAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDLgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQy4CAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQy4CAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQy4CAgAAhAEEAEMuAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBkFIaiIFIANrIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAIAAgBWpBODYCBAwCCyADLQAMQQhxDQAgBCAFSQ0AIAQgAE8NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAQgC2pBODYCBAwBCwJAIABBACgCmNCAgAAiCE8NAEEAIAA2ApjQgIAAIAAhCAsgACAGaiEFQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgBUYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiCyACQQNyNgIEIAVBeCAFa0EPcUEAIAVBCGpBD3EbaiIGIAsgAmoiAmshAwJAIAYgBEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgA2oiAzYClNCAgAAgAiADQQFyNgIEDAMLAkAgBkEAKAKc0ICAAEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgA2oiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAYoAgQiBEEDcUEBRw0AIARBeHEhBwJAAkAgBEH/AUsNACAGKAIIIgUgBEEDdiIIQQN0QbDQgIAAaiIARhoCQCAGKAIMIgQgBUcNAEEAQQAoAojQgIAAQX4gCHdxNgKI0ICAAAwCCyAEIABGGiAEIAU2AgggBSAENgIMDAELIAYoAhghCQJAAkAgBigCDCIAIAZGDQAgBigCCCIEIAhJGiAAIAQ2AgggBCAANgIMDAELAkAgBkEUaiIEKAIAIgUNACAGQRBqIgQoAgAiBQ0AQQAhAAwBCwNAIAQhCCAFIgBBFGoiBCgCACIFDQAgAEEQaiEEIAAoAhAiBQ0ACyAIQQA2AgALIAlFDQACQAJAIAYgBigCHCIFQQJ0QbjSgIAAaiIEKAIARw0AIAQgADYCACAADQFBAEEAKAKM0ICAAEF+IAV3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAGRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgBigCECIERQ0AIAAgBDYCECAEIAA2AhgLIAYoAhQiBEUNACAAQRRqIAQ2AgAgBCAANgIYCyAHIANqIQMgBiAHaiIGKAIEIQQLIAYgBEF+cTYCBCACIANqIAM2AgAgAiADQQFyNgIEAkAgA0H/AUsNACADQXhxQbDQgIAAaiEEAkACQEEAKAKI0ICAACIFQQEgA0EDdnQiA3ENAEEAIAUgA3I2AojQgIAAIAQhAwwBCyAEKAIIIQMLIAMgAjYCDCAEIAI2AgggAiAENgIMIAIgAzYCCAwDC0EfIQQCQCADQf///wdLDQAgA0EIdiIEIARBgP4/akEQdkEIcSIEdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiAEIAVyIAByayIEQQF0IAMgBEEVanZBAXFyQRxqIQQLIAIgBDYCHCACQgA3AhAgBEECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASAEdCIIcQ0AIAUgAjYCAEEAIAAgCHI2AozQgIAAIAIgBTYCGCACIAI2AgggAiACNgIMDAMLIANBAEEZIARBAXZrIARBH0YbdCEEIAUoAgAhAANAIAAiBSgCBEF4cSADRg0CIARBHXYhACAEQQF0IQQgBSAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBTYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBkFIaiIIIANrIgNBAXI2AgQgACAIakE4NgIEIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgAzYClNCAgABBACALNgKg0ICAACAIQRBqQQApAtDTgIAANwIAIAhBACkCyNOAgAA3AghBACAIQQhqNgLQ04CAAEEAIAY2AszTgIAAQQAgADYCyNOAgABBAEEANgLU04CAACAIQSRqIQMDQCADQQc2AgAgA0EEaiIDIAVJDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgA2AgAgBCAAQQFyNgIEAkAgAEH/AUsNACAAQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAAQf///wdLDQAgAEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIIIAhBgIAPakEQdkECcSIIdEEPdiADIAVyIAhyayIDQQF0IAAgA0EVanZBAXFyQRxqIQMLIAQgAzYCHCAEQgA3AhAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIghBASADdCIGcQ0AIAUgBDYCAEEAIAggBnI2AozQgIAAIAQgBTYCGCAEIAQ2AgggBCAENgIMDAQLIABBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhCANAIAgiBSgCBEF4cSAARg0DIANBHXYhCCADQQF0IQMgBSAIQQRxakEQaiIGKAIAIggNAAsgBiAENgIAIAQgBTYCGCAEIAQ2AgwgBCAENgIIDAMLIAUoAggiAyACNgIMIAUgAjYCCCACQQA2AhggAiAFNgIMIAIgAzYCCAsgC0EIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQQA2AhggBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgCCADaiIDIAMoAgRBAXI2AgQMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEF4cUGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIARBA3Z0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCAAIANqIgMgAygCBEEBcjYCBAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQMCQAJAQQEgB0EDdnQiCCAGcQ0AQQAgCCAGcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2ApzQgIAAQQAgBDYCkNCAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQyYCAgAAL4g0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApjQgIAAIgRJDQEgAiAAaiEAAkAgAUEAKAKc0ICAAEYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAEoAggiAiAESRogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABIAEoAhwiBEECdEG40oCAAGoiAigCAEcNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQ0ICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgASADTw0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkAgA0EAKAKg0ICAAEcNAEEAIAE2AqDQgIAAQQBBACgClNCAgAAgAGoiADYClNCAgAAgASAAQQFyNgIEIAFBACgCnNCAgABHDQNBAEEANgKQ0ICAAEEAQQA2ApzQgIAADwsCQCADQQAoApzQgIAARw0AQQAgATYCnNCAgABBAEEAKAKQ0ICAACAAaiIANgKQ0ICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNACADKAIIIgJBACgCmNCAgABJGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMgAygCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnNCAgABHDQFBACAANgKQ0ICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEF4cUGw0ICAAGohAgJAAkBBACgCiNCAgAAiBEEBIABBA3Z0IgBxDQBBACAEIAByNgKI0ICAACACIQAMAQsgAigCCCEACyAAIAE2AgwgAiABNgIIIAEgAjYCDCABIAA2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAEgAjYCHCABQgA3AhAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgASAENgIYIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABIAQ2AhggASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEANgIYIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLBAAAAAtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+NOAgABBfw8LIABBEHQPCxDKgICAAAAL8gICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=';
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js" (module) {
        module.exports = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==';
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/utils.js" (__unused_rspack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.enumToMap = void 0;
        function enumToMap(obj) {
            const res = {};
            Object.keys(obj).forEach((key)=>{
                const value = obj[key];
                if ('number' == typeof value) res[key] = value;
            });
            return res;
        }
        exports1.enumToMap = enumToMap;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-agent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kClients } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const Agent = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/agent.js");
        const { kAgent, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js");
        const MockClient = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-client.js");
        const MockPool = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-pool.js");
        const { matchValue, buildMockOptions } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js");
        const { InvalidArgumentError, UndiciError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const Dispatcher = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher.js");
        const Pluralizer = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pluralizer.js");
        const PendingInterceptorsFormatter = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js");
        class FakeWeakRef {
            constructor(value){
                this.value = value;
            }
            deref() {
                return this.value;
            }
        }
        class MockAgent extends Dispatcher {
            constructor(opts){
                super(opts);
                this[kNetConnect] = true;
                this[kIsMockActive] = true;
                if (opts && opts.agent && 'function' != typeof opts.agent.dispatch) throw new InvalidArgumentError('Argument opts.agent must implement Agent');
                const agent = opts && opts.agent ? opts.agent : new Agent(opts);
                this[kAgent] = agent;
                this[kClients] = agent[kClients];
                this[kOptions] = buildMockOptions(opts);
            }
            get(origin) {
                let dispatcher = this[kMockAgentGet](origin);
                if (!dispatcher) {
                    dispatcher = this[kFactory](origin);
                    this[kMockAgentSet](origin, dispatcher);
                }
                return dispatcher;
            }
            dispatch(opts, handler) {
                this.get(opts.origin);
                return this[kAgent].dispatch(opts, handler);
            }
            async close() {
                await this[kAgent].close();
                this[kClients].clear();
            }
            deactivate() {
                this[kIsMockActive] = false;
            }
            activate() {
                this[kIsMockActive] = true;
            }
            enableNetConnect(matcher) {
                if ('string' == typeof matcher || 'function' == typeof matcher || matcher instanceof RegExp) if (Array.isArray(this[kNetConnect])) this[kNetConnect].push(matcher);
                else this[kNetConnect] = [
                    matcher
                ];
                else if (void 0 === matcher) this[kNetConnect] = true;
                else throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.');
            }
            disableNetConnect() {
                this[kNetConnect] = false;
            }
            get isMockActive() {
                return this[kIsMockActive];
            }
            [kMockAgentSet](origin, dispatcher) {
                this[kClients].set(origin, new FakeWeakRef(dispatcher));
            }
            [kFactory](origin) {
                const mockOptions = Object.assign({
                    agent: this
                }, this[kOptions]);
                return this[kOptions] && 1 === this[kOptions].connections ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
            }
            [kMockAgentGet](origin) {
                const ref = this[kClients].get(origin);
                if (ref) return ref.deref();
                if ('string' != typeof origin) {
                    const dispatcher = this[kFactory]('http://localhost:9999');
                    this[kMockAgentSet](origin, dispatcher);
                    return dispatcher;
                }
                for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])){
                    const nonExplicitDispatcher = nonExplicitRef.deref();
                    if (nonExplicitDispatcher && 'string' != typeof keyMatcher && matchValue(keyMatcher, origin)) {
                        const dispatcher = this[kFactory](origin);
                        this[kMockAgentSet](origin, dispatcher);
                        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
                        return dispatcher;
                    }
                }
            }
            [kGetNetConnect]() {
                return this[kNetConnect];
            }
            pendingInterceptors() {
                const mockAgentClients = this[kClients];
                return Array.from(mockAgentClients.entries()).flatMap(([origin, scope])=>scope.deref()[kDispatches].map((dispatch)=>({
                            ...dispatch,
                            origin
                        }))).filter(({ pending })=>pending);
            }
            assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
                const pending = this.pendingInterceptors();
                if (0 === pending.length) return;
                const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length);
                throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
            }
        }
        module.exports = MockAgent;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-client.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { promisify } = __webpack_require__("util");
        const Client = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js");
        const { buildMockDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js");
        const { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js");
        const { MockInterceptor } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-interceptor.js");
        const Symbols = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        class MockClient extends Client {
            constructor(origin, opts){
                super(origin, opts);
                if (!opts || !opts.agent || 'function' != typeof opts.agent.dispatch) throw new InvalidArgumentError('Argument opts.agent must implement Agent');
                this[kMockAgent] = opts.agent;
                this[kOrigin] = origin;
                this[kDispatches] = [];
                this[kConnected] = 1;
                this[kOriginalDispatch] = this.dispatch;
                this[kOriginalClose] = this.close.bind(this);
                this.dispatch = buildMockDispatch.call(this);
                this.close = this[kClose];
            }
            get [Symbols.kConnected]() {
                return this[kConnected];
            }
            intercept(opts) {
                return new MockInterceptor(opts, this[kDispatches]);
            }
            async [kClose]() {
                await promisify(this[kOriginalClose])();
                this[kConnected] = 0;
                this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
            }
        }
        module.exports = MockClient;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-errors.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { UndiciError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        class MockNotMatchedError extends UndiciError {
            constructor(message){
                super(message);
                Error.captureStackTrace(this, MockNotMatchedError);
                this.name = 'MockNotMatchedError';
                this.message = message || 'The request does not match any registered mock dispatches';
                this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED';
            }
        }
        module.exports = {
            MockNotMatchedError
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-interceptor.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { getResponseData, buildKey, addMockDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js");
        const { kDispatches, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const { buildURL } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        class MockScope {
            constructor(mockDispatch){
                this[kMockDispatch] = mockDispatch;
            }
            delay(waitInMs) {
                if ('number' != typeof waitInMs || !Number.isInteger(waitInMs) || waitInMs <= 0) throw new InvalidArgumentError('waitInMs must be a valid integer > 0');
                this[kMockDispatch].delay = waitInMs;
                return this;
            }
            persist() {
                this[kMockDispatch].persist = true;
                return this;
            }
            times(repeatTimes) {
                if ('number' != typeof repeatTimes || !Number.isInteger(repeatTimes) || repeatTimes <= 0) throw new InvalidArgumentError('repeatTimes must be a valid integer > 0');
                this[kMockDispatch].times = repeatTimes;
                return this;
            }
        }
        class MockInterceptor {
            constructor(opts, mockDispatches){
                if ('object' != typeof opts) throw new InvalidArgumentError('opts must be an object');
                if (void 0 === opts.path) throw new InvalidArgumentError('opts.path must be defined');
                if (void 0 === opts.method) opts.method = 'GET';
                if ('string' == typeof opts.path) if (opts.query) opts.path = buildURL(opts.path, opts.query);
                else {
                    const parsedURL = new URL(opts.path, 'data://');
                    opts.path = parsedURL.pathname + parsedURL.search;
                }
                if ('string' == typeof opts.method) opts.method = opts.method.toUpperCase();
                this[kDispatchKey] = buildKey(opts);
                this[kDispatches] = mockDispatches;
                this[kDefaultHeaders] = {};
                this[kDefaultTrailers] = {};
                this[kContentLength] = false;
            }
            createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
                const responseData = getResponseData(data);
                const contentLength = this[kContentLength] ? {
                    'content-length': responseData.length
                } : {};
                const headers = {
                    ...this[kDefaultHeaders],
                    ...contentLength,
                    ...responseOptions.headers
                };
                const trailers = {
                    ...this[kDefaultTrailers],
                    ...responseOptions.trailers
                };
                return {
                    statusCode,
                    data,
                    headers,
                    trailers
                };
            }
            validateReplyParameters(statusCode, data, responseOptions) {
                if (void 0 === statusCode) throw new InvalidArgumentError('statusCode must be defined');
                if (void 0 === data) throw new InvalidArgumentError('data must be defined');
                if ('object' != typeof responseOptions) throw new InvalidArgumentError('responseOptions must be an object');
            }
            reply(replyData) {
                if ('function' == typeof replyData) {
                    const wrappedDefaultsCallback = (opts)=>{
                        const resolvedData = replyData(opts);
                        if ('object' != typeof resolvedData) throw new InvalidArgumentError('reply options callback must return an object');
                        const { statusCode, data = '', responseOptions = {} } = resolvedData;
                        this.validateReplyParameters(statusCode, data, responseOptions);
                        return {
                            ...this.createMockScopeDispatchData(statusCode, data, responseOptions)
                        };
                    };
                    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
                    return new MockScope(newMockDispatch);
                }
                const [statusCode, data = '', responseOptions = {}] = [
                    ...arguments
                ];
                this.validateReplyParameters(statusCode, data, responseOptions);
                const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
                const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
                return new MockScope(newMockDispatch);
            }
            replyWithError(error) {
                if (void 0 === error) throw new InvalidArgumentError('error must be defined');
                const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {
                    error
                });
                return new MockScope(newMockDispatch);
            }
            defaultReplyHeaders(headers) {
                if (void 0 === headers) throw new InvalidArgumentError('headers must be defined');
                this[kDefaultHeaders] = headers;
                return this;
            }
            defaultReplyTrailers(trailers) {
                if (void 0 === trailers) throw new InvalidArgumentError('trailers must be defined');
                this[kDefaultTrailers] = trailers;
                return this;
            }
            replyContentLength() {
                this[kContentLength] = true;
                return this;
            }
        }
        module.exports.MockInterceptor = MockInterceptor;
        module.exports.MockScope = MockScope;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-pool.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { promisify } = __webpack_require__("util");
        const Pool = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js");
        const { buildMockDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js");
        const { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js");
        const { MockInterceptor } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-interceptor.js");
        const Symbols = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        class MockPool extends Pool {
            constructor(origin, opts){
                super(origin, opts);
                if (!opts || !opts.agent || 'function' != typeof opts.agent.dispatch) throw new InvalidArgumentError('Argument opts.agent must implement Agent');
                this[kMockAgent] = opts.agent;
                this[kOrigin] = origin;
                this[kDispatches] = [];
                this[kConnected] = 1;
                this[kOriginalDispatch] = this.dispatch;
                this[kOriginalClose] = this.close.bind(this);
                this.dispatch = buildMockDispatch.call(this);
                this.close = this[kClose];
            }
            get [Symbols.kConnected]() {
                return this[kConnected];
            }
            intercept(opts) {
                return new MockInterceptor(opts, this[kDispatches]);
            }
            async [kClose]() {
                await promisify(this[kOriginalClose])();
                this[kConnected] = 0;
                this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
            }
        }
        module.exports = MockPool;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js" (module) {
        "use strict";
        module.exports = {
            kAgent: Symbol('agent'),
            kOptions: Symbol('options'),
            kFactory: Symbol('factory'),
            kDispatches: Symbol('dispatches'),
            kDispatchKey: Symbol('dispatch key'),
            kDefaultHeaders: Symbol('default headers'),
            kDefaultTrailers: Symbol('default trailers'),
            kContentLength: Symbol('content length'),
            kMockAgent: Symbol('mock agent'),
            kMockAgentSet: Symbol('mock agent set'),
            kMockAgentGet: Symbol('mock agent get'),
            kMockDispatch: Symbol('mock dispatch'),
            kClose: Symbol('close'),
            kOriginalClose: Symbol('original agent close'),
            kOrigin: Symbol('origin'),
            kIsMockActive: Symbol('is mock active'),
            kNetConnect: Symbol('net connect'),
            kGetNetConnect: Symbol('get net connect'),
            kConnected: Symbol('connected')
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { MockNotMatchedError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-errors.js");
        const { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js");
        const { buildURL, nop } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { STATUS_CODES } = __webpack_require__("http");
        const { types: { isPromise } } = __webpack_require__("util");
        function matchValue(match, value) {
            if ('string' == typeof match) return match === value;
            if (match instanceof RegExp) return match.test(value);
            if ('function' == typeof match) return true === match(value);
            return false;
        }
        function lowerCaseEntries(headers) {
            return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue])=>[
                    headerName.toLocaleLowerCase(),
                    headerValue
                ]));
        }
        function getHeaderByName(headers, key) {
            if (Array.isArray(headers)) {
                for(let i = 0; i < headers.length; i += 2)if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers[i + 1];
                return;
            }
            if ('function' == typeof headers.get) return headers.get(key);
            return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
        }
        function buildHeadersFromArray(headers) {
            const clone = headers.slice();
            const entries = [];
            for(let index = 0; index < clone.length; index += 2)entries.push([
                clone[index],
                clone[index + 1]
            ]);
            return Object.fromEntries(entries);
        }
        function matchHeaders(mockDispatch, headers) {
            if ('function' == typeof mockDispatch.headers) {
                if (Array.isArray(headers)) headers = buildHeadersFromArray(headers);
                return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});
            }
            if (void 0 === mockDispatch.headers) return true;
            if ('object' != typeof headers || 'object' != typeof mockDispatch.headers) return false;
            for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)){
                const headerValue = getHeaderByName(headers, matchHeaderName);
                if (!matchValue(matchHeaderValue, headerValue)) return false;
            }
            return true;
        }
        function safeUrl(path) {
            if ('string' != typeof path) return path;
            const pathSegments = path.split('?');
            if (2 !== pathSegments.length) return path;
            const qp = new URLSearchParams(pathSegments.pop());
            qp.sort();
            return [
                ...pathSegments,
                qp.toString()
            ].join('?');
        }
        function matchKey(mockDispatch, { path, method, body, headers }) {
            const pathMatch = matchValue(mockDispatch.path, path);
            const methodMatch = matchValue(mockDispatch.method, method);
            const bodyMatch = void 0 !== mockDispatch.body ? matchValue(mockDispatch.body, body) : true;
            const headersMatch = matchHeaders(mockDispatch, headers);
            return pathMatch && methodMatch && bodyMatch && headersMatch;
        }
        function getResponseData(data) {
            if (Buffer.isBuffer(data)) return data;
            if ('object' == typeof data) return JSON.stringify(data);
            return data.toString();
        }
        function getMockDispatch(mockDispatches, key) {
            const basePath = key.query ? buildURL(key.path, key.query) : key.path;
            const resolvedPath = 'string' == typeof basePath ? safeUrl(basePath) : basePath;
            let matchedMockDispatches = mockDispatches.filter(({ consumed })=>!consumed).filter(({ path })=>matchValue(safeUrl(path), resolvedPath));
            if (0 === matchedMockDispatches.length) throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
            matchedMockDispatches = matchedMockDispatches.filter(({ method })=>matchValue(method, key.method));
            if (0 === matchedMockDispatches.length) throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
            matchedMockDispatches = matchedMockDispatches.filter(({ body })=>void 0 !== body ? matchValue(body, key.body) : true);
            if (0 === matchedMockDispatches.length) throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
            matchedMockDispatches = matchedMockDispatches.filter((mockDispatch)=>matchHeaders(mockDispatch, key.headers));
            if (0 === matchedMockDispatches.length) throw new MockNotMatchedError(`Mock dispatch not matched for headers '${'object' == typeof key.headers ? JSON.stringify(key.headers) : key.headers}'`);
            return matchedMockDispatches[0];
        }
        function addMockDispatch(mockDispatches, key, data) {
            const baseData = {
                timesInvoked: 0,
                times: 1,
                persist: false,
                consumed: false
            };
            const replyData = 'function' == typeof data ? {
                callback: data
            } : {
                ...data
            };
            const newMockDispatch = {
                ...baseData,
                ...key,
                pending: true,
                data: {
                    error: null,
                    ...replyData
                }
            };
            mockDispatches.push(newMockDispatch);
            return newMockDispatch;
        }
        function deleteMockDispatch(mockDispatches, key) {
            const index = mockDispatches.findIndex((dispatch)=>{
                if (!dispatch.consumed) return false;
                return matchKey(dispatch, key);
            });
            if (-1 !== index) mockDispatches.splice(index, 1);
        }
        function buildKey(opts) {
            const { path, method, body, headers, query } = opts;
            return {
                path,
                method,
                body,
                headers,
                query
            };
        }
        function generateKeyValues(data) {
            return Object.entries(data).reduce((keyValuePairs, [key, value])=>[
                    ...keyValuePairs,
                    Buffer.from(`${key}`),
                    Array.isArray(value) ? value.map((x)=>Buffer.from(`${x}`)) : Buffer.from(`${value}`)
                ], []);
        }
        function getStatusText(statusCode) {
            return STATUS_CODES[statusCode] || 'unknown';
        }
        async function getResponse(body) {
            const buffers = [];
            for await (const data of body)buffers.push(data);
            return Buffer.concat(buffers).toString('utf8');
        }
        function mockDispatch(opts, handler) {
            const key = buildKey(opts);
            const mockDispatch = getMockDispatch(this[kDispatches], key);
            mockDispatch.timesInvoked++;
            if (mockDispatch.data.callback) mockDispatch.data = {
                ...mockDispatch.data,
                ...mockDispatch.data.callback(opts)
            };
            const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;
            const { timesInvoked, times } = mockDispatch;
            mockDispatch.consumed = !persist && timesInvoked >= times;
            mockDispatch.pending = timesInvoked < times;
            if (null !== error) {
                deleteMockDispatch(this[kDispatches], key);
                handler.onError(error);
                return true;
            }
            if ('number' == typeof delay && delay > 0) setTimeout(()=>{
                handleReply(this[kDispatches]);
            }, delay);
            else handleReply(this[kDispatches]);
            function handleReply(mockDispatches, _data = data) {
                const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
                const body = 'function' == typeof _data ? _data({
                    ...opts,
                    headers: optsHeaders
                }) : _data;
                if (isPromise(body)) return void body.then((newData)=>handleReply(mockDispatches, newData));
                const responseData = getResponseData(body);
                const responseHeaders = generateKeyValues(headers);
                const responseTrailers = generateKeyValues(trailers);
                handler.abort = nop;
                handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
                handler.onData(Buffer.from(responseData));
                handler.onComplete(responseTrailers);
                deleteMockDispatch(mockDispatches, key);
            }
            function resume() {}
            return true;
        }
        function buildMockDispatch() {
            const agent = this[kMockAgent];
            const origin = this[kOrigin];
            const originalDispatch = this[kOriginalDispatch];
            return function(opts, handler) {
                if (agent.isMockActive) try {
                    mockDispatch.call(this, opts, handler);
                } catch (error) {
                    if (error instanceof MockNotMatchedError) {
                        const netConnect = agent[kGetNetConnect]();
                        if (false === netConnect) throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
                        if (checkNetConnect(netConnect, origin)) originalDispatch.call(this, opts, handler);
                        else throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
                    } else throw error;
                }
                else originalDispatch.call(this, opts, handler);
            };
        }
        function checkNetConnect(netConnect, origin) {
            const url = new URL(origin);
            if (true === netConnect) return true;
            if (Array.isArray(netConnect) && netConnect.some((matcher)=>matchValue(matcher, url.host))) return true;
            return false;
        }
        function buildMockOptions(opts) {
            if (opts) {
                const { agent, ...mockOptions } = opts;
                return mockOptions;
            }
        }
        module.exports = {
            getResponseData,
            getMockDispatch,
            addMockDispatch,
            deleteMockDispatch,
            buildKey,
            generateKeyValues,
            matchValue,
            getResponse,
            getStatusText,
            mockDispatch,
            buildMockDispatch,
            checkNetConnect,
            buildMockOptions,
            getHeaderByName
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Transform } = __webpack_require__("stream");
        const { Console } = __webpack_require__("console");
        module.exports = class {
            constructor({ disableColors } = {}){
                this.transform = new Transform({
                    transform (chunk, _enc, cb) {
                        cb(null, chunk);
                    }
                });
                this.logger = new Console({
                    stdout: this.transform,
                    inspectOptions: {
                        colors: !disableColors && !process.env.CI
                    }
                });
            }
            format(pendingInterceptors) {
                const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin })=>({
                        Method: method,
                        Origin: origin,
                        Path: path,
                        'Status code': statusCode,
                        Persistent: persist ? '' : '',
                        Invocations: timesInvoked,
                        Remaining: persist ? 1 / 0 : times - timesInvoked
                    }));
                this.logger.table(withPrettyHeaders);
                return this.transform.read().toString();
            }
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pluralizer.js" (module) {
        "use strict";
        const singulars = {
            pronoun: 'it',
            is: 'is',
            was: 'was',
            this: 'this'
        };
        const plurals = {
            pronoun: 'they',
            is: 'are',
            was: 'were',
            this: 'these'
        };
        module.exports = class {
            constructor(singular, plural){
                this.singular = singular;
                this.plural = plural;
            }
            pluralize(count) {
                const one = 1 === count;
                const keys = one ? singulars : plurals;
                const noun = one ? this.singular : this.plural;
                return {
                    ...keys,
                    count,
                    noun
                };
            }
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/node/fixed-queue.js" (module) {
        "use strict";
        const kSize = 2048;
        const kMask = kSize - 1;
        class FixedCircularBuffer {
            constructor(){
                this.bottom = 0;
                this.top = 0;
                this.list = new Array(kSize);
                this.next = null;
            }
            isEmpty() {
                return this.top === this.bottom;
            }
            isFull() {
                return (this.top + 1 & kMask) === this.bottom;
            }
            push(data) {
                this.list[this.top] = data;
                this.top = this.top + 1 & kMask;
            }
            shift() {
                const nextItem = this.list[this.bottom];
                if (void 0 === nextItem) return null;
                this.list[this.bottom] = void 0;
                this.bottom = this.bottom + 1 & kMask;
                return nextItem;
            }
        }
        module.exports = class {
            constructor(){
                this.head = this.tail = new FixedCircularBuffer();
            }
            isEmpty() {
                return this.head.isEmpty();
            }
            push(data) {
                if (this.head.isFull()) this.head = this.head.next = new FixedCircularBuffer();
                this.head.push(data);
            }
            shift() {
                const tail = this.tail;
                const next = tail.shift();
                if (tail.isEmpty() && null !== tail.next) this.tail = tail.next;
                return next;
            }
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-base.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const DispatcherBase = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher-base.js");
        const FixedQueue = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/node/fixed-queue.js");
        const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const PoolStats = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-stats.js");
        const kClients = Symbol('clients');
        const kNeedDrain = Symbol('needDrain');
        const kQueue = Symbol('queue');
        const kClosedResolve = Symbol('closed resolve');
        const kOnDrain = Symbol('onDrain');
        const kOnConnect = Symbol('onConnect');
        const kOnDisconnect = Symbol('onDisconnect');
        const kOnConnectionError = Symbol('onConnectionError');
        const kGetDispatcher = Symbol('get dispatcher');
        const kAddClient = Symbol('add client');
        const kRemoveClient = Symbol('remove client');
        const kStats = Symbol('stats');
        class PoolBase extends DispatcherBase {
            constructor(){
                super();
                this[kQueue] = new FixedQueue();
                this[kClients] = [];
                this[kQueued] = 0;
                const pool = this;
                this[kOnDrain] = function(origin, targets) {
                    const queue = pool[kQueue];
                    let needDrain = false;
                    while(!needDrain){
                        const item = queue.shift();
                        if (!item) break;
                        pool[kQueued]--;
                        needDrain = !this.dispatch(item.opts, item.handler);
                    }
                    this[kNeedDrain] = needDrain;
                    if (!this[kNeedDrain] && pool[kNeedDrain]) {
                        pool[kNeedDrain] = false;
                        pool.emit('drain', origin, [
                            pool,
                            ...targets
                        ]);
                    }
                    if (pool[kClosedResolve] && queue.isEmpty()) Promise.all(pool[kClients].map((c)=>c.close())).then(pool[kClosedResolve]);
                };
                this[kOnConnect] = (origin, targets)=>{
                    pool.emit('connect', origin, [
                        pool,
                        ...targets
                    ]);
                };
                this[kOnDisconnect] = (origin, targets, err)=>{
                    pool.emit('disconnect', origin, [
                        pool,
                        ...targets
                    ], err);
                };
                this[kOnConnectionError] = (origin, targets, err)=>{
                    pool.emit('connectionError', origin, [
                        pool,
                        ...targets
                    ], err);
                };
                this[kStats] = new PoolStats(this);
            }
            get [kBusy]() {
                return this[kNeedDrain];
            }
            get [kConnected]() {
                return this[kClients].filter((client)=>client[kConnected]).length;
            }
            get [kFree]() {
                return this[kClients].filter((client)=>client[kConnected] && !client[kNeedDrain]).length;
            }
            get [kPending]() {
                let ret = this[kQueued];
                for (const { [kPending]: pending } of this[kClients])ret += pending;
                return ret;
            }
            get [kRunning]() {
                let ret = 0;
                for (const { [kRunning]: running } of this[kClients])ret += running;
                return ret;
            }
            get [kSize]() {
                let ret = this[kQueued];
                for (const { [kSize]: size } of this[kClients])ret += size;
                return ret;
            }
            get stats() {
                return this[kStats];
            }
            async [kClose]() {
                if (this[kQueue].isEmpty()) return Promise.all(this[kClients].map((c)=>c.close()));
                return new Promise((resolve)=>{
                    this[kClosedResolve] = resolve;
                });
            }
            async [kDestroy](err) {
                while(true){
                    const item = this[kQueue].shift();
                    if (!item) break;
                    item.handler.onError(err);
                }
                return Promise.all(this[kClients].map((c)=>c.destroy(err)));
            }
            [kDispatch](opts, handler) {
                const dispatcher = this[kGetDispatcher]();
                if (dispatcher) {
                    if (!dispatcher.dispatch(opts, handler)) {
                        dispatcher[kNeedDrain] = true;
                        this[kNeedDrain] = !this[kGetDispatcher]();
                    }
                } else {
                    this[kNeedDrain] = true;
                    this[kQueue].push({
                        opts,
                        handler
                    });
                    this[kQueued]++;
                }
                return !this[kNeedDrain];
            }
            [kAddClient](client) {
                client.on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);
                this[kClients].push(client);
                if (this[kNeedDrain]) process.nextTick(()=>{
                    if (this[kNeedDrain]) this[kOnDrain](client[kUrl], [
                        this,
                        client
                    ]);
                });
                return this;
            }
            [kRemoveClient](client) {
                client.close(()=>{
                    const idx = this[kClients].indexOf(client);
                    if (-1 !== idx) this[kClients].splice(idx, 1);
                });
                this[kNeedDrain] = this[kClients].some((dispatcher)=>!dispatcher[kNeedDrain] && true !== dispatcher.closed && true !== dispatcher.destroyed);
            }
        }
        module.exports = {
            PoolBase,
            kClients,
            kNeedDrain,
            kAddClient,
            kRemoveClient,
            kGetDispatcher
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-stats.js" (module, __unused_rspack_exports, __webpack_require__) {
        const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const kPool = Symbol('pool');
        class PoolStats {
            constructor(pool){
                this[kPool] = pool;
            }
            get connected() {
                return this[kPool][kConnected];
            }
            get free() {
                return this[kPool][kFree];
            }
            get pending() {
                return this[kPool][kPending];
            }
            get queued() {
                return this[kPool][kQueued];
            }
            get running() {
                return this[kPool][kRunning];
            }
            get size() {
                return this[kPool][kSize];
            }
        }
        module.exports = PoolStats;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-base.js");
        const Client = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js");
        const { InvalidArgumentError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const util = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { kUrl, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const buildConnector = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js");
        const kOptions = Symbol('options');
        const kConnections = Symbol('connections');
        const kFactory = Symbol('factory');
        function defaultFactory(origin, opts) {
            return new Client(origin, opts);
        }
        class Pool extends PoolBase {
            constructor(origin, { connections, factory = defaultFactory, connect, connectTimeout, tls, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}){
                super();
                if (null != connections && (!Number.isFinite(connections) || connections < 0)) throw new InvalidArgumentError('invalid connections');
                if ('function' != typeof factory) throw new InvalidArgumentError('factory must be a function.');
                if (null != connect && 'function' != typeof connect && 'object' != typeof connect) throw new InvalidArgumentError('connect must be a function or an object');
                if ('function' != typeof connect) connect = buildConnector({
                    ...tls,
                    maxCachedSessions,
                    allowH2,
                    socketPath,
                    timeout: connectTimeout,
                    ...util.nodeHasAutoSelectFamily && autoSelectFamily ? {
                        autoSelectFamily,
                        autoSelectFamilyAttemptTimeout
                    } : void 0,
                    ...connect
                });
                this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
                this[kConnections] = connections || null;
                this[kUrl] = util.parseOrigin(origin);
                this[kOptions] = {
                    ...util.deepClone(options),
                    connect,
                    allowH2
                };
                this[kOptions].interceptors = options.interceptors ? {
                    ...options.interceptors
                } : void 0;
                this[kFactory] = factory;
                this.on('connectionError', (origin, targets, error)=>{
                    for (const target of targets){
                        const idx = this[kClients].indexOf(target);
                        if (-1 !== idx) this[kClients].splice(idx, 1);
                    }
                });
            }
            [kGetDispatcher]() {
                let dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain]);
                if (dispatcher) return dispatcher;
                if (!this[kConnections] || this[kClients].length < this[kConnections]) {
                    dispatcher = this[kFactory](this[kUrl], this[kOptions]);
                    this[kAddClient](dispatcher);
                }
                return dispatcher;
            }
        }
        module.exports = Pool;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/proxy-agent.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const { URL: URL1 } = __webpack_require__("url");
        const Agent = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/agent.js");
        const Pool = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js");
        const DispatcherBase = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher-base.js");
        const { InvalidArgumentError, RequestAbortedError } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js");
        const buildConnector = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js");
        const kAgent = Symbol('proxy agent');
        const kClient = Symbol('proxy client');
        const kProxyHeaders = Symbol('proxy headers');
        const kRequestTls = Symbol('request tls settings');
        const kProxyTls = Symbol('proxy tls settings');
        const kConnectEndpoint = Symbol('connect endpoint function');
        function defaultProtocolPort(protocol) {
            return 'https:' === protocol ? 443 : 80;
        }
        function buildProxyOptions(opts) {
            if ('string' == typeof opts) opts = {
                uri: opts
            };
            if (!opts || !opts.uri) throw new InvalidArgumentError('Proxy opts.uri is mandatory');
            return {
                uri: opts.uri,
                protocol: opts.protocol || 'https'
            };
        }
        function defaultFactory(origin, opts) {
            return new Pool(origin, opts);
        }
        class ProxyAgent extends DispatcherBase {
            constructor(opts){
                super(opts);
                this[kProxy] = buildProxyOptions(opts);
                this[kAgent] = new Agent(opts);
                this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
                if ('string' == typeof opts) opts = {
                    uri: opts
                };
                if (!opts || !opts.uri) throw new InvalidArgumentError('Proxy opts.uri is mandatory');
                const { clientFactory = defaultFactory } = opts;
                if ('function' != typeof clientFactory) throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.');
                this[kRequestTls] = opts.requestTls;
                this[kProxyTls] = opts.proxyTls;
                this[kProxyHeaders] = opts.headers || {};
                const resolvedUrl = new URL1(opts.uri);
                const { origin, port, host, username, password } = resolvedUrl;
                if (opts.auth && opts.token) throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token');
                if (opts.auth) this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;
                else if (opts.token) this[kProxyHeaders]['proxy-authorization'] = opts.token;
                else if (username && password) this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`;
                const connect = buildConnector({
                    ...opts.proxyTls
                });
                this[kConnectEndpoint] = buildConnector({
                    ...opts.requestTls
                });
                this[kClient] = clientFactory(resolvedUrl, {
                    connect
                });
                this[kAgent] = new Agent({
                    ...opts,
                    connect: async (opts, callback)=>{
                        let requestedHost = opts.host;
                        if (!opts.port) requestedHost += `:${defaultProtocolPort(opts.protocol)}`;
                        try {
                            const { socket, statusCode } = await this[kClient].connect({
                                origin,
                                port,
                                path: requestedHost,
                                signal: opts.signal,
                                headers: {
                                    ...this[kProxyHeaders],
                                    host
                                }
                            });
                            if (200 !== statusCode) {
                                socket.on('error', ()=>{}).destroy();
                                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
                            }
                            if ('https:' !== opts.protocol) return void callback(null, socket);
                            let servername;
                            servername = this[kRequestTls] ? this[kRequestTls].servername : opts.servername;
                            this[kConnectEndpoint]({
                                ...opts,
                                servername,
                                httpSocket: socket
                            }, callback);
                        } catch (err) {
                            callback(err);
                        }
                    }
                });
            }
            dispatch(opts, handler) {
                const { host } = new URL1(opts.origin);
                const headers = buildHeaders(opts.headers);
                throwIfProxyAuthIsSent(headers);
                return this[kAgent].dispatch({
                    ...opts,
                    headers: {
                        ...headers,
                        host
                    }
                }, handler);
            }
            async [kClose]() {
                await this[kAgent].close();
                await this[kClient].close();
            }
            async [kDestroy]() {
                await this[kAgent].destroy();
                await this[kClient].destroy();
            }
        }
        function buildHeaders(headers) {
            if (Array.isArray(headers)) {
                const headersPair = {};
                for(let i = 0; i < headers.length; i += 2)headersPair[headers[i]] = headers[i + 1];
                return headersPair;
            }
            return headers;
        }
        function throwIfProxyAuthIsSent(headers) {
            const existProxyAuth = headers && Object.keys(headers).find((key)=>'proxy-authorization' === key.toLowerCase());
            if (existProxyAuth) throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor');
        }
        module.exports = ProxyAgent;
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/timers.js" (module) {
        "use strict";
        let fastNow = Date.now();
        let fastNowTimeout;
        const fastTimers = [];
        function onTimeout() {
            fastNow = Date.now();
            let len = fastTimers.length;
            let idx = 0;
            while(idx < len){
                const timer = fastTimers[idx];
                if (0 === timer.state) timer.state = fastNow + timer.delay;
                else if (timer.state > 0 && fastNow >= timer.state) {
                    timer.state = -1;
                    timer.callback(timer.opaque);
                }
                if (-1 === timer.state) {
                    timer.state = -2;
                    if (idx !== len - 1) fastTimers[idx] = fastTimers.pop();
                    else fastTimers.pop();
                    len -= 1;
                } else idx += 1;
            }
            if (fastTimers.length > 0) refreshTimeout();
        }
        function refreshTimeout() {
            if (fastNowTimeout && fastNowTimeout.refresh) fastNowTimeout.refresh();
            else {
                clearTimeout(fastNowTimeout);
                fastNowTimeout = setTimeout(onTimeout, 1e3);
                if (fastNowTimeout.unref) fastNowTimeout.unref();
            }
        }
        class Timeout {
            constructor(callback, delay, opaque){
                this.callback = callback;
                this.delay = delay;
                this.opaque = opaque;
                this.state = -2;
                this.refresh();
            }
            refresh() {
                if (-2 === this.state) {
                    fastTimers.push(this);
                    if (!fastNowTimeout || 1 === fastTimers.length) refreshTimeout();
                }
                this.state = 0;
            }
            clear() {
                this.state = -1;
            }
        }
        module.exports = {
            setTimeout (callback, delay, opaque) {
                return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
            },
            clearTimeout (timeout) {
                if (timeout instanceof Timeout) timeout.clear();
                else clearTimeout(timeout);
            }
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/connection.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const diagnosticsChannel = __webpack_require__("diagnostics_channel");
        const { uid, states } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js");
        const { kReadyState, kSentClose, kByteParser, kReceivedClose } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/symbols.js");
        const { fireEvent, failWebsocketConnection } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/util.js");
        const { CloseEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/events.js");
        const { makeRequest } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/request.js");
        const { fetching } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/index.js");
        const { Headers } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js");
        const { getGlobalDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js");
        const { kHeadersList } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js");
        const channels = {};
        channels.open = diagnosticsChannel.channel('undici:websocket:open');
        channels.close = diagnosticsChannel.channel('undici:websocket:close');
        channels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error');
        let crypto;
        try {
            crypto = __webpack_require__("crypto");
        } catch  {}
        function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
            const requestURL = url;
            requestURL.protocol = 'ws:' === url.protocol ? 'http:' : 'https:';
            const request = makeRequest({
                urlList: [
                    requestURL
                ],
                serviceWorkers: 'none',
                referrer: 'no-referrer',
                mode: 'websocket',
                credentials: 'include',
                cache: 'no-store',
                redirect: 'error'
            });
            if (options.headers) {
                const headersList = new Headers(options.headers)[kHeadersList];
                request.headersList = headersList;
            }
            const keyValue = crypto.randomBytes(16).toString('base64');
            request.headersList.append('sec-websocket-key', keyValue);
            request.headersList.append('sec-websocket-version', '13');
            for (const protocol of protocols)request.headersList.append('sec-websocket-protocol', protocol);
            const permessageDeflate = '';
            const controller = fetching({
                request,
                useParallelQueue: true,
                dispatcher: options.dispatcher ?? getGlobalDispatcher(),
                processResponse (response) {
                    if ('error' === response.type || 101 !== response.status) return void failWebsocketConnection(ws, 'Received network error or non-101 status code.');
                    if (0 !== protocols.length && !response.headersList.get('Sec-WebSocket-Protocol')) return void failWebsocketConnection(ws, 'Server did not respond with sent protocols.');
                    if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') return void failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
                    if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') return void failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
                    const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');
                    const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64');
                    if (secWSAccept !== digest) return void failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');
                    const secExtension = response.headersList.get('Sec-WebSocket-Extensions');
                    if (null !== secExtension && secExtension !== permessageDeflate) return void failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.');
                    const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');
                    if (null !== secProtocol && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) return void failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');
                    response.socket.on('data', onSocketData);
                    response.socket.on('close', onSocketClose);
                    response.socket.on('error', onSocketError);
                    if (channels.open.hasSubscribers) channels.open.publish({
                        address: response.socket.address(),
                        protocol: secProtocol,
                        extensions: secExtension
                    });
                    onEstablish(response);
                }
            });
            return controller;
        }
        function onSocketData(chunk) {
            if (!this.ws[kByteParser].write(chunk)) this.pause();
        }
        function onSocketClose() {
            const { ws } = this;
            const wasClean = ws[kSentClose] && ws[kReceivedClose];
            let code = 1005;
            let reason = '';
            const result = ws[kByteParser].closingInfo;
            if (result) {
                code = result.code ?? 1005;
                reason = result.reason;
            } else if (!ws[kSentClose]) code = 1006;
            ws[kReadyState] = states.CLOSED;
            fireEvent('close', ws, CloseEvent, {
                wasClean,
                code,
                reason
            });
            if (channels.close.hasSubscribers) channels.close.publish({
                websocket: ws,
                code,
                reason
            });
        }
        function onSocketError(error) {
            const { ws } = this;
            ws[kReadyState] = states.CLOSING;
            if (channels.socketError.hasSubscribers) channels.socketError.publish(error);
            this.destroy();
        }
        module.exports = {
            establishWebSocketConnection
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js" (module) {
        "use strict";
        const uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
        const staticPropertyDescriptors = {
            enumerable: true,
            writable: false,
            configurable: false
        };
        const states = {
            CONNECTING: 0,
            OPEN: 1,
            CLOSING: 2,
            CLOSED: 3
        };
        const opcodes = {
            CONTINUATION: 0x0,
            TEXT: 0x1,
            BINARY: 0x2,
            CLOSE: 0x8,
            PING: 0x9,
            PONG: 0xA
        };
        const maxUnsigned16Bit = 2 ** 16 - 1;
        const parserStates = {
            INFO: 0,
            PAYLOADLENGTH_16: 2,
            PAYLOADLENGTH_64: 3,
            READ_DATA: 4
        };
        const emptyBuffer = Buffer.allocUnsafe(0);
        module.exports = {
            uid,
            staticPropertyDescriptors,
            states,
            opcodes,
            maxUnsigned16Bit,
            parserStates,
            emptyBuffer
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/events.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { kEnumerableProperty } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { MessagePort } = __webpack_require__("worker_threads");
        class MessageEvent extends Event {
            #eventInit;
            constructor(type, eventInitDict = {}){
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'MessageEvent constructor'
                });
                type = webidl.converters.DOMString(type);
                eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
                super(type, eventInitDict);
                this.#eventInit = eventInitDict;
            }
            get data() {
                webidl.brandCheck(this, MessageEvent);
                return this.#eventInit.data;
            }
            get origin() {
                webidl.brandCheck(this, MessageEvent);
                return this.#eventInit.origin;
            }
            get lastEventId() {
                webidl.brandCheck(this, MessageEvent);
                return this.#eventInit.lastEventId;
            }
            get source() {
                webidl.brandCheck(this, MessageEvent);
                return this.#eventInit.source;
            }
            get ports() {
                webidl.brandCheck(this, MessageEvent);
                if (!Object.isFrozen(this.#eventInit.ports)) Object.freeze(this.#eventInit.ports);
                return this.#eventInit.ports;
            }
            initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = '', lastEventId = '', source = null, ports = []) {
                webidl.brandCheck(this, MessageEvent);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'MessageEvent.initMessageEvent'
                });
                return new MessageEvent(type, {
                    bubbles,
                    cancelable,
                    data,
                    origin,
                    lastEventId,
                    source,
                    ports
                });
            }
        }
        class CloseEvent extends Event {
            #eventInit;
            constructor(type, eventInitDict = {}){
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'CloseEvent constructor'
                });
                type = webidl.converters.DOMString(type);
                eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
                super(type, eventInitDict);
                this.#eventInit = eventInitDict;
            }
            get wasClean() {
                webidl.brandCheck(this, CloseEvent);
                return this.#eventInit.wasClean;
            }
            get code() {
                webidl.brandCheck(this, CloseEvent);
                return this.#eventInit.code;
            }
            get reason() {
                webidl.brandCheck(this, CloseEvent);
                return this.#eventInit.reason;
            }
        }
        class ErrorEvent extends Event {
            #eventInit;
            constructor(type, eventInitDict){
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'ErrorEvent constructor'
                });
                super(type, eventInitDict);
                type = webidl.converters.DOMString(type);
                eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
                this.#eventInit = eventInitDict;
            }
            get message() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.message;
            }
            get filename() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.filename;
            }
            get lineno() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.lineno;
            }
            get colno() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.colno;
            }
            get error() {
                webidl.brandCheck(this, ErrorEvent);
                return this.#eventInit.error;
            }
        }
        Object.defineProperties(MessageEvent.prototype, {
            [Symbol.toStringTag]: {
                value: 'MessageEvent',
                configurable: true
            },
            data: kEnumerableProperty,
            origin: kEnumerableProperty,
            lastEventId: kEnumerableProperty,
            source: kEnumerableProperty,
            ports: kEnumerableProperty,
            initMessageEvent: kEnumerableProperty
        });
        Object.defineProperties(CloseEvent.prototype, {
            [Symbol.toStringTag]: {
                value: 'CloseEvent',
                configurable: true
            },
            reason: kEnumerableProperty,
            code: kEnumerableProperty,
            wasClean: kEnumerableProperty
        });
        Object.defineProperties(ErrorEvent.prototype, {
            [Symbol.toStringTag]: {
                value: 'ErrorEvent',
                configurable: true
            },
            message: kEnumerableProperty,
            filename: kEnumerableProperty,
            lineno: kEnumerableProperty,
            colno: kEnumerableProperty,
            error: kEnumerableProperty
        });
        webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
        webidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(webidl.converters.MessagePort);
        const eventInit = [
            {
                key: 'bubbles',
                converter: webidl.converters.boolean,
                defaultValue: false
            },
            {
                key: 'cancelable',
                converter: webidl.converters.boolean,
                defaultValue: false
            },
            {
                key: 'composed',
                converter: webidl.converters.boolean,
                defaultValue: false
            }
        ];
        webidl.converters.MessageEventInit = webidl.dictionaryConverter([
            ...eventInit,
            {
                key: 'data',
                converter: webidl.converters.any,
                defaultValue: null
            },
            {
                key: 'origin',
                converter: webidl.converters.USVString,
                defaultValue: ''
            },
            {
                key: 'lastEventId',
                converter: webidl.converters.DOMString,
                defaultValue: ''
            },
            {
                key: 'source',
                converter: webidl.nullableConverter(webidl.converters.MessagePort),
                defaultValue: null
            },
            {
                key: 'ports',
                converter: webidl.converters['sequence<MessagePort>'],
                get defaultValue () {
                    return [];
                }
            }
        ]);
        webidl.converters.CloseEventInit = webidl.dictionaryConverter([
            ...eventInit,
            {
                key: 'wasClean',
                converter: webidl.converters.boolean,
                defaultValue: false
            },
            {
                key: 'code',
                converter: webidl.converters['unsigned short'],
                defaultValue: 0
            },
            {
                key: 'reason',
                converter: webidl.converters.USVString,
                defaultValue: ''
            }
        ]);
        webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
            ...eventInit,
            {
                key: 'message',
                converter: webidl.converters.DOMString,
                defaultValue: ''
            },
            {
                key: 'filename',
                converter: webidl.converters.USVString,
                defaultValue: ''
            },
            {
                key: 'lineno',
                converter: webidl.converters['unsigned long'],
                defaultValue: 0
            },
            {
                key: 'colno',
                converter: webidl.converters['unsigned long'],
                defaultValue: 0
            },
            {
                key: 'error',
                converter: webidl.converters.any
            }
        ]);
        module.exports = {
            MessageEvent,
            CloseEvent,
            ErrorEvent
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/frame.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { maxUnsigned16Bit } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js");
        let crypto;
        try {
            crypto = __webpack_require__("crypto");
        } catch  {}
        class WebsocketFrameSend {
            constructor(data){
                this.frameData = data;
                this.maskKey = crypto.randomBytes(4);
            }
            createFrame(opcode) {
                const bodyLength = this.frameData?.byteLength ?? 0;
                let payloadLength = bodyLength;
                let offset = 6;
                if (bodyLength > maxUnsigned16Bit) {
                    offset += 8;
                    payloadLength = 127;
                } else if (bodyLength > 125) {
                    offset += 2;
                    payloadLength = 126;
                }
                const buffer = Buffer.allocUnsafe(bodyLength + offset);
                buffer[0] = buffer[1] = 0;
                buffer[0] |= 0x80;
                buffer[0] = (0xF0 & buffer[0]) + opcode;
                /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ buffer[offset - 4] = this.maskKey[0];
                buffer[offset - 3] = this.maskKey[1];
                buffer[offset - 2] = this.maskKey[2];
                buffer[offset - 1] = this.maskKey[3];
                buffer[1] = payloadLength;
                if (126 === payloadLength) buffer.writeUInt16BE(bodyLength, 2);
                else if (127 === payloadLength) {
                    buffer[2] = buffer[3] = 0;
                    buffer.writeUIntBE(bodyLength, 4, 6);
                }
                buffer[1] |= 0x80;
                for(let i = 0; i < bodyLength; i++)buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
                return buffer;
            }
        }
        module.exports = {
            WebsocketFrameSend
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/receiver.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Writable } = __webpack_require__("stream");
        const diagnosticsChannel = __webpack_require__("diagnostics_channel");
        const { parserStates, opcodes, states, emptyBuffer } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js");
        const { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/symbols.js");
        const { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/util.js");
        const { WebsocketFrameSend } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/frame.js");
        const channels = {};
        channels.ping = diagnosticsChannel.channel('undici:websocket:ping');
        channels.pong = diagnosticsChannel.channel('undici:websocket:pong');
        class ByteParser extends Writable {
            #buffers = [];
            #byteOffset = 0;
            #state = parserStates.INFO;
            #info = {};
            #fragments = [];
            constructor(ws){
                super();
                this.ws = ws;
            }
            _write(chunk, _, callback) {
                this.#buffers.push(chunk);
                this.#byteOffset += chunk.length;
                this.run(callback);
            }
            run(callback) {
                while(true){
                    if (this.#state === parserStates.INFO) {
                        if (this.#byteOffset < 2) return callback();
                        const buffer = this.consume(2);
                        this.#info.fin = (0x80 & buffer[0]) !== 0;
                        this.#info.opcode = 0x0F & buffer[0];
                        this.#info.originalOpcode ??= this.#info.opcode;
                        this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
                        if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) return void failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');
                        const payloadLength = 0x7F & buffer[1];
                        if (payloadLength <= 125) {
                            this.#info.payloadLength = payloadLength;
                            this.#state = parserStates.READ_DATA;
                        } else if (126 === payloadLength) this.#state = parserStates.PAYLOADLENGTH_16;
                        else if (127 === payloadLength) this.#state = parserStates.PAYLOADLENGTH_64;
                        if (this.#info.fragmented && payloadLength > 125) return void failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');
                        if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) return void failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.');
                        if (this.#info.opcode === opcodes.CLOSE) {
                            if (1 === payloadLength) return void failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');
                            const body = this.consume(payloadLength);
                            this.#info.closeInfo = this.parseCloseBody(false, body);
                            if (!this.ws[kSentClose]) {
                                const body = Buffer.allocUnsafe(2);
                                body.writeUInt16BE(this.#info.closeInfo.code, 0);
                                const closeFrame = new WebsocketFrameSend(body);
                                this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err)=>{
                                    if (!err) this.ws[kSentClose] = true;
                                });
                            }
                            this.ws[kReadyState] = states.CLOSING;
                            this.ws[kReceivedClose] = true;
                            this.end();
                            return;
                        } else if (this.#info.opcode === opcodes.PING) {
                            const body = this.consume(payloadLength);
                            if (!this.ws[kReceivedClose]) {
                                const frame = new WebsocketFrameSend(body);
                                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                                if (channels.ping.hasSubscribers) channels.ping.publish({
                                    payload: body
                                });
                            }
                            this.#state = parserStates.INFO;
                            if (this.#byteOffset > 0) continue;
                            return void callback();
                        } else if (this.#info.opcode === opcodes.PONG) {
                            const body = this.consume(payloadLength);
                            if (channels.pong.hasSubscribers) channels.pong.publish({
                                payload: body
                            });
                            if (this.#byteOffset > 0) continue;
                            return void callback();
                        }
                    } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
                        if (this.#byteOffset < 2) return callback();
                        const buffer = this.consume(2);
                        this.#info.payloadLength = buffer.readUInt16BE(0);
                        this.#state = parserStates.READ_DATA;
                    } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
                        if (this.#byteOffset < 8) return callback();
                        const buffer = this.consume(8);
                        const upper = buffer.readUInt32BE(0);
                        if (upper > 2 ** 31 - 1) return void failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');
                        const lower = buffer.readUInt32BE(4);
                        this.#info.payloadLength = (upper << 8) + lower;
                        this.#state = parserStates.READ_DATA;
                    } else if (this.#state === parserStates.READ_DATA) {
                        if (this.#byteOffset < this.#info.payloadLength) return callback();
                        else if (this.#byteOffset >= this.#info.payloadLength) {
                            const body = this.consume(this.#info.payloadLength);
                            this.#fragments.push(body);
                            if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
                                const fullMessage = Buffer.concat(this.#fragments);
                                websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
                                this.#info = {};
                                this.#fragments.length = 0;
                            }
                            this.#state = parserStates.INFO;
                        }
                    }
                    if (this.#byteOffset > 0) continue;
                    callback();
                    break;
                }
            }
            consume(n) {
                if (n > this.#byteOffset) return null;
                if (0 === n) return emptyBuffer;
                if (this.#buffers[0].length === n) {
                    this.#byteOffset -= this.#buffers[0].length;
                    return this.#buffers.shift();
                }
                const buffer = Buffer.allocUnsafe(n);
                let offset = 0;
                while(offset !== n){
                    const next = this.#buffers[0];
                    const { length } = next;
                    if (length + offset === n) {
                        buffer.set(this.#buffers.shift(), offset);
                        break;
                    }
                    if (length + offset > n) {
                        buffer.set(next.subarray(0, n - offset), offset);
                        this.#buffers[0] = next.subarray(n - offset);
                        break;
                    }
                    buffer.set(this.#buffers.shift(), offset);
                    offset += next.length;
                }
                this.#byteOffset -= n;
                return buffer;
            }
            parseCloseBody(onlyCode, data) {
                let code;
                if (data.length >= 2) code = data.readUInt16BE(0);
                if (onlyCode) {
                    if (!isValidStatusCode(code)) return null;
                    return {
                        code
                    };
                }
                let reason = data.subarray(2);
                if (0xEF === reason[0] && 0xBB === reason[1] && 0xBF === reason[2]) reason = reason.subarray(3);
                if (void 0 !== code && !isValidStatusCode(code)) return null;
                try {
                    reason = new TextDecoder('utf-8', {
                        fatal: true
                    }).decode(reason);
                } catch  {
                    return null;
                }
                return {
                    code,
                    reason
                };
            }
            get closingInfo() {
                return this.#info.closeInfo;
            }
        }
        module.exports = {
            ByteParser
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/symbols.js" (module) {
        "use strict";
        module.exports = {
            kWebSocketURL: Symbol('url'),
            kReadyState: Symbol('ready state'),
            kController: Symbol('controller'),
            kResponse: Symbol('response'),
            kBinaryType: Symbol('binary type'),
            kSentClose: Symbol('sent close'),
            kReceivedClose: Symbol('received close'),
            kByteParser: Symbol('byte parser')
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/util.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/symbols.js");
        const { states, opcodes } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js");
        const { MessageEvent, ErrorEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/events.js");
        function isEstablished(ws) {
            return ws[kReadyState] === states.OPEN;
        }
        function isClosing(ws) {
            return ws[kReadyState] === states.CLOSING;
        }
        function isClosed(ws) {
            return ws[kReadyState] === states.CLOSED;
        }
        function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
            const event = new eventConstructor(e, eventInitDict);
            target.dispatchEvent(event);
        }
        function websocketMessageReceived(ws, type, data) {
            if (ws[kReadyState] !== states.OPEN) return;
            let dataForEvent;
            if (type === opcodes.TEXT) try {
                dataForEvent = new TextDecoder('utf-8', {
                    fatal: true
                }).decode(data);
            } catch  {
                failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');
                return;
            }
            else if (type === opcodes.BINARY) dataForEvent = 'blob' === ws[kBinaryType] ? new Blob([
                data
            ]) : new Uint8Array(data).buffer;
            fireEvent('message', ws, MessageEvent, {
                origin: ws[kWebSocketURL].origin,
                data: dataForEvent
            });
        }
        function isValidSubprotocol(protocol) {
            if (0 === protocol.length) return false;
            for (const char of protocol){
                const code = char.charCodeAt(0);
                if (code < 0x21 || code > 0x7E || '(' === char || ')' === char || '<' === char || '>' === char || '@' === char || ',' === char || ';' === char || ':' === char || '\\' === char || '"' === char || '/' === char || '[' === char || ']' === char || '?' === char || '=' === char || '{' === char || '}' === char || 32 === code || 9 === code) return false;
            }
            return true;
        }
        function isValidStatusCode(code) {
            if (code >= 1000 && code < 1015) return 1004 !== code && 1005 !== code && 1006 !== code;
            return code >= 3000 && code <= 4999;
        }
        function failWebsocketConnection(ws, reason) {
            const { [kController]: controller, [kResponse]: response } = ws;
            controller.abort();
            if (response?.socket && !response.socket.destroyed) response.socket.destroy();
            if (reason) fireEvent('error', ws, ErrorEvent, {
                error: new Error(reason)
            });
        }
        module.exports = {
            isEstablished,
            isClosing,
            isClosed,
            fireEvent,
            isValidSubprotocol,
            isValidStatusCode,
            failWebsocketConnection,
            websocketMessageReceived
        };
    },
    "../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/websocket.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { webidl } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js");
        const { DOMException: DOMException1 } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js");
        const { URLSerializer } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js");
        const { getGlobalOrigin } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js");
        const { staticPropertyDescriptors, states, opcodes, emptyBuffer } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js");
        const { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/symbols.js");
        const { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/util.js");
        const { establishWebSocketConnection } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/connection.js");
        const { WebsocketFrameSend } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/frame.js");
        const { ByteParser } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/receiver.js");
        const { kEnumerableProperty, isBlobLike } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js");
        const { getGlobalDispatcher } = __webpack_require__("../../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js");
        const { types } = __webpack_require__("util");
        let experimentalWarned = false;
        class WebSocket extends EventTarget {
            #events = {
                open: null,
                error: null,
                close: null,
                message: null
            };
            #bufferedAmount = 0;
            #protocol = '';
            #extensions = '';
            constructor(url, protocols = []){
                super();
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'WebSocket constructor'
                });
                if (!experimentalWarned) {
                    experimentalWarned = true;
                    process.emitWarning('WebSockets are experimental, expect them to change at any time.', {
                        code: 'UNDICI-WS'
                    });
                }
                const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols);
                url = webidl.converters.USVString(url);
                protocols = options.protocols;
                const baseURL = getGlobalOrigin();
                let urlRecord;
                try {
                    urlRecord = new URL(url, baseURL);
                } catch (e) {
                    throw new DOMException1(e, 'SyntaxError');
                }
                if ('http:' === urlRecord.protocol) urlRecord.protocol = 'ws:';
                else if ('https:' === urlRecord.protocol) urlRecord.protocol = 'wss:';
                if ('ws:' !== urlRecord.protocol && 'wss:' !== urlRecord.protocol) throw new DOMException1(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, 'SyntaxError');
                if (urlRecord.hash || urlRecord.href.endsWith('#')) throw new DOMException1('Got fragment', 'SyntaxError');
                if ('string' == typeof protocols) protocols = [
                    protocols
                ];
                if (protocols.length !== new Set(protocols.map((p)=>p.toLowerCase())).size) throw new DOMException1('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');
                if (protocols.length > 0 && !protocols.every((p)=>isValidSubprotocol(p))) throw new DOMException1('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');
                this[kWebSocketURL] = new URL(urlRecord.href);
                this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response)=>this.#onConnectionEstablished(response), options);
                this[kReadyState] = WebSocket.CONNECTING;
                this[kBinaryType] = 'blob';
            }
            close(code, reason) {
                webidl.brandCheck(this, WebSocket);
                if (void 0 !== code) code = webidl.converters['unsigned short'](code, {
                    clamp: true
                });
                if (void 0 !== reason) reason = webidl.converters.USVString(reason);
                if (void 0 !== code) {
                    if (1000 !== code && (code < 3000 || code > 4999)) throw new DOMException1('invalid code', 'InvalidAccessError');
                }
                let reasonByteLength = 0;
                if (void 0 !== reason) {
                    reasonByteLength = Buffer.byteLength(reason);
                    if (reasonByteLength > 123) throw new DOMException1(`Reason must be less than 123 bytes; received ${reasonByteLength}`, 'SyntaxError');
                }
                if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) ;
                else if (isEstablished(this)) if (isClosing(this)) this[kReadyState] = WebSocket.CLOSING;
                else {
                    const frame = new WebsocketFrameSend();
                    if (void 0 !== code && void 0 === reason) {
                        frame.frameData = Buffer.allocUnsafe(2);
                        frame.frameData.writeUInt16BE(code, 0);
                    } else if (void 0 !== code && void 0 !== reason) {
                        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
                        frame.frameData.writeUInt16BE(code, 0);
                        frame.frameData.write(reason, 2, 'utf-8');
                    } else frame.frameData = emptyBuffer;
                    const socket = this[kResponse].socket;
                    socket.write(frame.createFrame(opcodes.CLOSE), (err)=>{
                        if (!err) this[kSentClose] = true;
                    });
                    this[kReadyState] = states.CLOSING;
                }
                else {
                    failWebsocketConnection(this, 'Connection was closed before it was established.');
                    this[kReadyState] = WebSocket.CLOSING;
                }
            }
            send(data) {
                webidl.brandCheck(this, WebSocket);
                webidl.argumentLengthCheck(arguments, 1, {
                    header: 'WebSocket.send'
                });
                data = webidl.converters.WebSocketSendData(data);
                if (this[kReadyState] === WebSocket.CONNECTING) throw new DOMException1('Sent before connected.', 'InvalidStateError');
                if (!isEstablished(this) || isClosing(this)) return;
                const socket = this[kResponse].socket;
                if ('string' == typeof data) {
                    const value = Buffer.from(data);
                    const frame = new WebsocketFrameSend(value);
                    const buffer = frame.createFrame(opcodes.TEXT);
                    this.#bufferedAmount += value.byteLength;
                    socket.write(buffer, ()=>{
                        this.#bufferedAmount -= value.byteLength;
                    });
                } else if (types.isArrayBuffer(data)) {
                    const value = Buffer.from(data);
                    const frame = new WebsocketFrameSend(value);
                    const buffer = frame.createFrame(opcodes.BINARY);
                    this.#bufferedAmount += value.byteLength;
                    socket.write(buffer, ()=>{
                        this.#bufferedAmount -= value.byteLength;
                    });
                } else if (ArrayBuffer.isView(data)) {
                    const ab = Buffer.from(data, data.byteOffset, data.byteLength);
                    const frame = new WebsocketFrameSend(ab);
                    const buffer = frame.createFrame(opcodes.BINARY);
                    this.#bufferedAmount += ab.byteLength;
                    socket.write(buffer, ()=>{
                        this.#bufferedAmount -= ab.byteLength;
                    });
                } else if (isBlobLike(data)) {
                    const frame = new WebsocketFrameSend();
                    data.arrayBuffer().then((ab)=>{
                        const value = Buffer.from(ab);
                        frame.frameData = value;
                        const buffer = frame.createFrame(opcodes.BINARY);
                        this.#bufferedAmount += value.byteLength;
                        socket.write(buffer, ()=>{
                            this.#bufferedAmount -= value.byteLength;
                        });
                    });
                }
            }
            get readyState() {
                webidl.brandCheck(this, WebSocket);
                return this[kReadyState];
            }
            get bufferedAmount() {
                webidl.brandCheck(this, WebSocket);
                return this.#bufferedAmount;
            }
            get url() {
                webidl.brandCheck(this, WebSocket);
                return URLSerializer(this[kWebSocketURL]);
            }
            get extensions() {
                webidl.brandCheck(this, WebSocket);
                return this.#extensions;
            }
            get protocol() {
                webidl.brandCheck(this, WebSocket);
                return this.#protocol;
            }
            get onopen() {
                webidl.brandCheck(this, WebSocket);
                return this.#events.open;
            }
            set onopen(fn) {
                webidl.brandCheck(this, WebSocket);
                if (this.#events.open) this.removeEventListener('open', this.#events.open);
                if ('function' == typeof fn) {
                    this.#events.open = fn;
                    this.addEventListener('open', fn);
                } else this.#events.open = null;
            }
            get onerror() {
                webidl.brandCheck(this, WebSocket);
                return this.#events.error;
            }
            set onerror(fn) {
                webidl.brandCheck(this, WebSocket);
                if (this.#events.error) this.removeEventListener('error', this.#events.error);
                if ('function' == typeof fn) {
                    this.#events.error = fn;
                    this.addEventListener('error', fn);
                } else this.#events.error = null;
            }
            get onclose() {
                webidl.brandCheck(this, WebSocket);
                return this.#events.close;
            }
            set onclose(fn) {
                webidl.brandCheck(this, WebSocket);
                if (this.#events.close) this.removeEventListener('close', this.#events.close);
                if ('function' == typeof fn) {
                    this.#events.close = fn;
                    this.addEventListener('close', fn);
                } else this.#events.close = null;
            }
            get onmessage() {
                webidl.brandCheck(this, WebSocket);
                return this.#events.message;
            }
            set onmessage(fn) {
                webidl.brandCheck(this, WebSocket);
                if (this.#events.message) this.removeEventListener('message', this.#events.message);
                if ('function' == typeof fn) {
                    this.#events.message = fn;
                    this.addEventListener('message', fn);
                } else this.#events.message = null;
            }
            get binaryType() {
                webidl.brandCheck(this, WebSocket);
                return this[kBinaryType];
            }
            set binaryType(type) {
                webidl.brandCheck(this, WebSocket);
                if ('blob' !== type && 'arraybuffer' !== type) this[kBinaryType] = 'blob';
                else this[kBinaryType] = type;
            }
            #onConnectionEstablished(response) {
                this[kResponse] = response;
                const parser = new ByteParser(this);
                parser.on('drain', function() {
                    this.ws[kResponse].socket.resume();
                });
                response.socket.ws = this;
                this[kByteParser] = parser;
                this[kReadyState] = states.OPEN;
                const extensions = response.headersList.get('sec-websocket-extensions');
                if (null !== extensions) this.#extensions = extensions;
                const protocol = response.headersList.get('sec-websocket-protocol');
                if (null !== protocol) this.#protocol = protocol;
                fireEvent('open', this);
            }
        }
        WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
        WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
        WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
        WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
        Object.defineProperties(WebSocket.prototype, {
            CONNECTING: staticPropertyDescriptors,
            OPEN: staticPropertyDescriptors,
            CLOSING: staticPropertyDescriptors,
            CLOSED: staticPropertyDescriptors,
            url: kEnumerableProperty,
            readyState: kEnumerableProperty,
            bufferedAmount: kEnumerableProperty,
            onopen: kEnumerableProperty,
            onerror: kEnumerableProperty,
            onclose: kEnumerableProperty,
            close: kEnumerableProperty,
            onmessage: kEnumerableProperty,
            binaryType: kEnumerableProperty,
            send: kEnumerableProperty,
            extensions: kEnumerableProperty,
            protocol: kEnumerableProperty,
            [Symbol.toStringTag]: {
                value: 'WebSocket',
                writable: false,
                enumerable: false,
                configurable: true
            }
        });
        Object.defineProperties(WebSocket, {
            CONNECTING: staticPropertyDescriptors,
            OPEN: staticPropertyDescriptors,
            CLOSING: staticPropertyDescriptors,
            CLOSED: staticPropertyDescriptors
        });
        webidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(webidl.converters.DOMString);
        webidl.converters['DOMString or sequence<DOMString>'] = function(V) {
            if ('Object' === webidl.util.Type(V) && Symbol.iterator in V) return webidl.converters['sequence<DOMString>'](V);
            return webidl.converters.DOMString(V);
        };
        webidl.converters.WebSocketInit = webidl.dictionaryConverter([
            {
                key: 'protocols',
                converter: webidl.converters['DOMString or sequence<DOMString>'],
                get defaultValue () {
                    return [];
                }
            },
            {
                key: 'dispatcher',
                converter: (V)=>V,
                get defaultValue () {
                    return getGlobalDispatcher();
                }
            },
            {
                key: 'headers',
                converter: webidl.nullableConverter(webidl.converters.HeadersInit)
            }
        ]);
        webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function(V) {
            if ('Object' === webidl.util.Type(V) && !(Symbol.iterator in V)) return webidl.converters.WebSocketInit(V);
            return {
                protocols: webidl.converters['DOMString or sequence<DOMString>'](V)
            };
        };
        webidl.converters.WebSocketSendData = function(V) {
            if ('Object' === webidl.util.Type(V)) {
                if (isBlobLike(V)) return webidl.converters.Blob(V, {
                    strict: false
                });
                if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) return webidl.converters.BufferSource(V);
            }
            return webidl.converters.USVString(V);
        };
        module.exports = {
            WebSocket
        };
    },
    "../../../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js" (module) {
        "use strict";
        /*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = unpipe;
        function hasPipeDataListeners(stream) {
            var listeners = stream.listeners('data');
            for(var i = 0; i < listeners.length; i++)if ('ondata' === listeners[i].name) return true;
            return false;
        }
        function unpipe(stream) {
            if (!stream) throw new TypeError('argument stream is required');
            if ('function' == typeof stream.unpipe) return void stream.unpipe();
            if (!hasPipeDataListeners(stream)) return;
            var listener;
            var listeners = stream.listeners('close');
            for(var i = 0; i < listeners.length; i++){
                listener = listeners[i];
                if ('cleanup' === listener.name || 'onclose' === listener.name) listener.call(stream);
            }
        }
    },
    "../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        var v1 = __webpack_require__("../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v1.js");
        var v4 = __webpack_require__("../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v4.js");
        var uuid = v4;
        uuid.v1 = v1;
        uuid.v4 = v4;
        module.exports = uuid;
    },
    "../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js" (module) {
        var byteToHex = [];
        for(var i = 0; i < 256; ++i)byteToHex[i] = (i + 0x100).toString(16).substr(1);
        function bytesToUuid(buf, offset) {
            var i = offset || 0;
            var bth = byteToHex;
            return [
                bth[buf[i++]],
                bth[buf[i++]],
                bth[buf[i++]],
                bth[buf[i++]],
                '-',
                bth[buf[i++]],
                bth[buf[i++]],
                '-',
                bth[buf[i++]],
                bth[buf[i++]],
                '-',
                bth[buf[i++]],
                bth[buf[i++]],
                '-',
                bth[buf[i++]],
                bth[buf[i++]],
                bth[buf[i++]],
                bth[buf[i++]],
                bth[buf[i++]],
                bth[buf[i++]]
            ].join('');
        }
        module.exports = bytesToUuid;
    },
    "../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js" (module, __unused_rspack_exports, __webpack_require__) {
        var crypto = __webpack_require__("crypto");
        module.exports = function() {
            return crypto.randomBytes(16);
        };
    },
    "../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v1.js" (module, __unused_rspack_exports, __webpack_require__) {
        var rng = __webpack_require__("../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js");
        var bytesToUuid = __webpack_require__("../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js");
        var _nodeId;
        var _clockseq;
        var _lastMSecs = 0;
        var _lastNSecs = 0;
        function v1(options, buf, offset) {
            var i = buf && offset || 0;
            var b = buf || [];
            options = options || {};
            var node = options.node || _nodeId;
            var clockseq = void 0 !== options.clockseq ? options.clockseq : _clockseq;
            if (null == node || null == clockseq) {
                var seedBytes = rng();
                if (null == node) node = _nodeId = [
                    0x01 | seedBytes[0],
                    seedBytes[1],
                    seedBytes[2],
                    seedBytes[3],
                    seedBytes[4],
                    seedBytes[5]
                ];
                if (null == clockseq) clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
            }
            var msecs = void 0 !== options.msecs ? options.msecs : new Date().getTime();
            var nsecs = void 0 !== options.nsecs ? options.nsecs : _lastNSecs + 1;
            var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;
            if (dt < 0 && void 0 === options.clockseq) clockseq = clockseq + 1 & 0x3fff;
            if ((dt < 0 || msecs > _lastMSecs) && void 0 === options.nsecs) nsecs = 0;
            if (nsecs >= 10000) throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
            _lastMSecs = msecs;
            _lastNSecs = nsecs;
            _clockseq = clockseq;
            msecs += 12219292800000;
            var tl = ((0xfffffff & msecs) * 10000 + nsecs) % 0x100000000;
            b[i++] = tl >>> 24 & 0xff;
            b[i++] = tl >>> 16 & 0xff;
            b[i++] = tl >>> 8 & 0xff;
            b[i++] = 0xff & tl;
            var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
            b[i++] = tmh >>> 8 & 0xff;
            b[i++] = 0xff & tmh;
            b[i++] = tmh >>> 24 & 0xf | 0x10;
            b[i++] = tmh >>> 16 & 0xff;
            b[i++] = clockseq >>> 8 | 0x80;
            b[i++] = 0xff & clockseq;
            for(var n = 0; n < 6; ++n)b[i + n] = node[n];
            return buf ? buf : bytesToUuid(b);
        }
        module.exports = v1;
    },
    "../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v4.js" (module, __unused_rspack_exports, __webpack_require__) {
        var rng = __webpack_require__("../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js");
        var bytesToUuid = __webpack_require__("../../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js");
        function v4(options, buf, offset) {
            var i = buf && offset || 0;
            if ('string' == typeof options) {
                buf = 'binary' === options ? new Array(16) : null;
                options = null;
            }
            options = options || {};
            var rnds = options.random || (options.rng || rng)();
            rnds[6] = 0x0f & rnds[6] | 0x40;
            rnds[8] = 0x3f & rnds[8] | 0x80;
            if (buf) for(var ii = 0; ii < 16; ++ii)buf[i + ii] = rnds[ii];
            return buf || bytesToUuid(rnds);
        }
        module.exports = v4;
    },
    "../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js" (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            parse: ()=>esm_node_parse,
            version: ()=>esm_node_version,
            NIL: ()=>nil,
            v4: ()=>v4.A,
            stringify: ()=>stringify.A,
            v1: ()=>esm_node_v1,
            v3: ()=>esm_node_v3,
            validate: ()=>validate.A,
            v5: ()=>esm_node_v5
        });
        var rng = __webpack_require__("../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/rng.js");
        var stringify = __webpack_require__("../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/stringify.js");
        let _nodeId;
        let _clockseq;
        let _lastMSecs = 0;
        let _lastNSecs = 0;
        function v1(options, buf, offset) {
            let i = buf && offset || 0;
            const b = buf || new Array(16);
            options = options || {};
            let node = options.node || _nodeId;
            let clockseq = void 0 !== options.clockseq ? options.clockseq : _clockseq;
            if (null == node || null == clockseq) {
                const seedBytes = options.random || (options.rng || rng.A)();
                if (null == node) node = _nodeId = [
                    0x01 | seedBytes[0],
                    seedBytes[1],
                    seedBytes[2],
                    seedBytes[3],
                    seedBytes[4],
                    seedBytes[5]
                ];
                if (null == clockseq) clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
            }
            let msecs = void 0 !== options.msecs ? options.msecs : Date.now();
            let nsecs = void 0 !== options.nsecs ? options.nsecs : _lastNSecs + 1;
            const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;
            if (dt < 0 && void 0 === options.clockseq) clockseq = clockseq + 1 & 0x3fff;
            if ((dt < 0 || msecs > _lastMSecs) && void 0 === options.nsecs) nsecs = 0;
            if (nsecs >= 10000) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
            _lastMSecs = msecs;
            _lastNSecs = nsecs;
            _clockseq = clockseq;
            msecs += 12219292800000;
            const tl = ((0xfffffff & msecs) * 10000 + nsecs) % 0x100000000;
            b[i++] = tl >>> 24 & 0xff;
            b[i++] = tl >>> 16 & 0xff;
            b[i++] = tl >>> 8 & 0xff;
            b[i++] = 0xff & tl;
            const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
            b[i++] = tmh >>> 8 & 0xff;
            b[i++] = 0xff & tmh;
            b[i++] = tmh >>> 24 & 0xf | 0x10;
            b[i++] = tmh >>> 16 & 0xff;
            b[i++] = clockseq >>> 8 | 0x80;
            b[i++] = 0xff & clockseq;
            for(let n = 0; n < 6; ++n)b[i + n] = node[n];
            return buf || (0, stringify.A)(b);
        }
        const esm_node_v1 = v1;
        var validate = __webpack_require__("../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/validate.js");
        function parse(uuid) {
            if (!(0, validate.A)(uuid)) throw TypeError('Invalid UUID');
            let v;
            const arr = new Uint8Array(16);
            arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
            arr[1] = v >>> 16 & 0xff;
            arr[2] = v >>> 8 & 0xff;
            arr[3] = 0xff & v;
            arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
            arr[5] = 0xff & v;
            arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
            arr[7] = 0xff & v;
            arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
            arr[9] = 0xff & v;
            arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
            arr[11] = v / 0x100000000 & 0xff;
            arr[12] = v >>> 24 & 0xff;
            arr[13] = v >>> 16 & 0xff;
            arr[14] = v >>> 8 & 0xff;
            arr[15] = 0xff & v;
            return arr;
        }
        const esm_node_parse = parse;
        function stringToBytes(str) {
            str = unescape(encodeURIComponent(str));
            const bytes = [];
            for(let i = 0; i < str.length; ++i)bytes.push(str.charCodeAt(i));
            return bytes;
        }
        const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
        const URL1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
        function v35(name, version, hashfunc) {
            function generateUUID(value, namespace, buf, offset) {
                if ('string' == typeof value) value = stringToBytes(value);
                if ('string' == typeof namespace) namespace = esm_node_parse(namespace);
                if (16 !== namespace.length) throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
                let bytes = new Uint8Array(16 + value.length);
                bytes.set(namespace);
                bytes.set(value, namespace.length);
                bytes = hashfunc(bytes);
                bytes[6] = 0x0f & bytes[6] | version;
                bytes[8] = 0x3f & bytes[8] | 0x80;
                if (buf) {
                    offset = offset || 0;
                    for(let i = 0; i < 16; ++i)buf[offset + i] = bytes[i];
                    return buf;
                }
                return (0, stringify.A)(bytes);
            }
            try {
                generateUUID.name = name;
            } catch (err) {}
            generateUUID.DNS = DNS;
            generateUUID.URL = URL1;
            return generateUUID;
        }
        var external_crypto_ = __webpack_require__("crypto");
        var external_crypto_default = /*#__PURE__*/ __webpack_require__.n(external_crypto_);
        function md5(bytes) {
            if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
            else if ('string' == typeof bytes) bytes = Buffer.from(bytes, 'utf8');
            return external_crypto_default().createHash('md5').update(bytes).digest();
        }
        const esm_node_md5 = md5;
        const v3 = v35('v3', 0x30, esm_node_md5);
        const esm_node_v3 = v3;
        var v4 = __webpack_require__("../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v4.js");
        function sha1(bytes) {
            if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
            else if ('string' == typeof bytes) bytes = Buffer.from(bytes, 'utf8');
            return external_crypto_default().createHash('sha1').update(bytes).digest();
        }
        const esm_node_sha1 = sha1;
        const v5 = v35('v5', 0x50, esm_node_sha1);
        const esm_node_v5 = v5;
        const nil = '00000000-0000-0000-0000-000000000000';
        function version_version(uuid) {
            if (!(0, validate.A)(uuid)) throw TypeError('Invalid UUID');
            return parseInt(uuid.substr(14, 1), 16);
        }
        const esm_node_version = version_version;
    },
    "../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/rng.js" (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            A: ()=>rng
        });
        var crypto__rspack_import_0 = __webpack_require__("crypto");
        var crypto__rspack_import_0_default = /*#__PURE__*/ __webpack_require__.n(crypto__rspack_import_0);
        const rnds8Pool = new Uint8Array(256);
        let poolPtr = rnds8Pool.length;
        function rng() {
            if (poolPtr > rnds8Pool.length - 16) {
                crypto__rspack_import_0_default().randomFillSync(rnds8Pool);
                poolPtr = 0;
            }
            return rnds8Pool.slice(poolPtr, poolPtr += 16);
        }
    },
    "../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/stringify.js" (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            A: ()=>__rspack_default_export
        });
        var _validate_js__rspack_import_0 = __webpack_require__("../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/validate.js");
        const byteToHex = [];
        for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).substr(1));
        function stringify(arr, offset = 0) {
            const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
            if (!(0, _validate_js__rspack_import_0.A)(uuid)) throw TypeError('Stringified UUID is invalid');
            return uuid;
        }
        const __rspack_default_export = stringify;
    },
    "../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v4.js" (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            A: ()=>__rspack_default_export
        });
        var _rng_js__rspack_import_0 = __webpack_require__("../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/rng.js");
        var _stringify_js__rspack_import_1 = __webpack_require__("../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/stringify.js");
        function v4(options, buf, offset) {
            options = options || {};
            const rnds = options.random || (options.rng || _rng_js__rspack_import_0.A)();
            rnds[6] = 0x0f & rnds[6] | 0x40;
            rnds[8] = 0x3f & rnds[8] | 0x80;
            if (buf) {
                offset = offset || 0;
                for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
                return buf;
            }
            return (0, _stringify_js__rspack_import_1.A)(rnds);
        }
        const __rspack_default_export = v4;
    },
    "../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/validate.js" (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            A: ()=>esm_node_validate
        });
        const regex = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
        function validate(uuid) {
            return 'string' == typeof uuid && regex.test(uuid);
        }
        const esm_node_validate = validate;
    },
    "../../../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js" (module) {
        "use strict";
        /*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = vary;
        module.exports.append = append;
        var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
        function append(header, field) {
            if ('string' != typeof header) throw new TypeError('header argument is required');
            if (!field) throw new TypeError('field argument is required');
            var fields = Array.isArray(field) ? field : parse(String(field));
            for(var j = 0; j < fields.length; j++)if (!FIELD_NAME_REGEXP.test(fields[j])) throw new TypeError('field argument contains an invalid header name');
            if ('*' === header) return header;
            var val = header;
            var vals = parse(header.toLowerCase());
            if (-1 !== fields.indexOf('*') || -1 !== vals.indexOf('*')) return '*';
            for(var i = 0; i < fields.length; i++){
                var fld = fields[i].toLowerCase();
                if (-1 === vals.indexOf(fld)) {
                    vals.push(fld);
                    val = val ? val + ', ' + fields[i] : fields[i];
                }
            }
            return val;
        }
        function parse(header) {
            var end = 0;
            var list = [];
            var start = 0;
            for(var i = 0, len = header.length; i < len; i++)switch(header.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i + 1;
                    break;
                case 0x2c:
                    list.push(header.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
            list.push(header.substring(start, end));
            return list;
        }
        function vary(res, field) {
            if (!res || !res.getHeader || !res.setHeader) throw new TypeError('res argument is required');
            var val = res.getHeader('Vary') || '';
            var header = Array.isArray(val) ? val.join(', ') : String(val);
            if (val = append(header, field)) res.setHeader('Vary', val);
        }
    },
    "../../../node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js" (module) {
        "use strict";
        var conversions = {};
        module.exports = conversions;
        function sign(x) {
            return x < 0 ? -1 : 1;
        }
        function evenRound(x) {
            if (x % 1 === 0.5 && (1 & x) === 0) return Math.floor(x);
            return Math.round(x);
        }
        function createNumberConversion(bitLength, typeOpts) {
            if (!typeOpts.unsigned) --bitLength;
            const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
            const upperBound = Math.pow(2, bitLength) - 1;
            const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
            const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
            return function(V, opts) {
                if (!opts) opts = {};
                let x = +V;
                if (opts.enforceRange) {
                    if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite number");
                    x = sign(x) * Math.floor(Math.abs(x));
                    if (x < lowerBound || x > upperBound) throw new TypeError("Argument is not in byte range");
                    return x;
                }
                if (!isNaN(x) && opts.clamp) {
                    x = evenRound(x);
                    if (x < lowerBound) x = lowerBound;
                    if (x > upperBound) x = upperBound;
                    return x;
                }
                if (!Number.isFinite(x) || 0 === x) return 0;
                x = sign(x) * Math.floor(Math.abs(x));
                x %= moduloVal;
                if (!typeOpts.unsigned && x >= moduloBound) return x - moduloVal;
                if (typeOpts.unsigned) {
                    if (x < 0) x += moduloVal;
                    else if (-0 === x) return 0;
                }
                return x;
            };
        }
        conversions["void"] = function() {};
        conversions["boolean"] = function(val) {
            return !!val;
        };
        conversions["byte"] = createNumberConversion(8, {
            unsigned: false
        });
        conversions["octet"] = createNumberConversion(8, {
            unsigned: true
        });
        conversions["short"] = createNumberConversion(16, {
            unsigned: false
        });
        conversions["unsigned short"] = createNumberConversion(16, {
            unsigned: true
        });
        conversions["long"] = createNumberConversion(32, {
            unsigned: false
        });
        conversions["unsigned long"] = createNumberConversion(32, {
            unsigned: true
        });
        conversions["long long"] = createNumberConversion(32, {
            unsigned: false,
            moduloBitLength: 64
        });
        conversions["unsigned long long"] = createNumberConversion(32, {
            unsigned: true,
            moduloBitLength: 64
        });
        conversions["double"] = function(V) {
            const x = +V;
            if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite floating-point value");
            return x;
        };
        conversions["unrestricted double"] = function(V) {
            const x = +V;
            if (isNaN(x)) throw new TypeError("Argument is NaN");
            return x;
        };
        conversions["float"] = conversions["double"];
        conversions["unrestricted float"] = conversions["unrestricted double"];
        conversions["DOMString"] = function(V, opts) {
            if (!opts) opts = {};
            if (opts.treatNullAsEmptyString && null === V) return "";
            return String(V);
        };
        conversions["ByteString"] = function(V, opts) {
            const x = String(V);
            let c;
            for(let i = 0; void 0 !== (c = x.codePointAt(i)); ++i)if (c > 255) throw new TypeError("Argument is not a valid bytestring");
            return x;
        };
        conversions["USVString"] = function(V) {
            const S = String(V);
            const n = S.length;
            const U = [];
            for(let i = 0; i < n; ++i){
                const c = S.charCodeAt(i);
                if (c < 0xD800 || c > 0xDFFF) U.push(String.fromCodePoint(c));
                else if (0xDC00 <= c && c <= 0xDFFF) U.push(String.fromCodePoint(0xFFFD));
                else if (i === n - 1) U.push(String.fromCodePoint(0xFFFD));
                else {
                    const d = S.charCodeAt(i + 1);
                    if (0xDC00 <= d && d <= 0xDFFF) {
                        const a = 0x3FF & c;
                        const b = 0x3FF & d;
                        U.push(String.fromCodePoint(65536 + 1024 * a + b));
                        ++i;
                    } else U.push(String.fromCodePoint(0xFFFD));
                }
            }
            return U.join('');
        };
        conversions["Date"] = function(V, opts) {
            if (!(V instanceof Date)) throw new TypeError("Argument is not a Date object");
            if (isNaN(V)) return;
            return V;
        };
        conversions["RegExp"] = function(V, opts) {
            if (!(V instanceof RegExp)) V = new RegExp(V);
            return V;
        };
    },
    "../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        const usm = __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js");
        exports1.implementation = class {
            constructor(constructorArgs){
                const url = constructorArgs[0];
                const base = constructorArgs[1];
                let parsedBase = null;
                if (void 0 !== base) {
                    parsedBase = usm.basicURLParse(base);
                    if ("failure" === parsedBase) throw new TypeError("Invalid base URL");
                }
                const parsedURL = usm.basicURLParse(url, {
                    baseURL: parsedBase
                });
                if ("failure" === parsedURL) throw new TypeError("Invalid URL");
                this._url = parsedURL;
            }
            get href() {
                return usm.serializeURL(this._url);
            }
            set href(v) {
                const parsedURL = usm.basicURLParse(v);
                if ("failure" === parsedURL) throw new TypeError("Invalid URL");
                this._url = parsedURL;
            }
            get origin() {
                return usm.serializeURLOrigin(this._url);
            }
            get protocol() {
                return this._url.scheme + ":";
            }
            set protocol(v) {
                usm.basicURLParse(v + ":", {
                    url: this._url,
                    stateOverride: "scheme start"
                });
            }
            get username() {
                return this._url.username;
            }
            set username(v) {
                if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
                usm.setTheUsername(this._url, v);
            }
            get password() {
                return this._url.password;
            }
            set password(v) {
                if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
                usm.setThePassword(this._url, v);
            }
            get host() {
                const url = this._url;
                if (null === url.host) return "";
                if (null === url.port) return usm.serializeHost(url.host);
                return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
            }
            set host(v) {
                if (this._url.cannotBeABaseURL) return;
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "host"
                });
            }
            get hostname() {
                if (null === this._url.host) return "";
                return usm.serializeHost(this._url.host);
            }
            set hostname(v) {
                if (this._url.cannotBeABaseURL) return;
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "hostname"
                });
            }
            get port() {
                if (null === this._url.port) return "";
                return usm.serializeInteger(this._url.port);
            }
            set port(v) {
                if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
                if ("" === v) this._url.port = null;
                else usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "port"
                });
            }
            get pathname() {
                if (this._url.cannotBeABaseURL) return this._url.path[0];
                if (0 === this._url.path.length) return "";
                return "/" + this._url.path.join("/");
            }
            set pathname(v) {
                if (this._url.cannotBeABaseURL) return;
                this._url.path = [];
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "path start"
                });
            }
            get search() {
                if (null === this._url.query || "" === this._url.query) return "";
                return "?" + this._url.query;
            }
            set search(v) {
                const url = this._url;
                if ("" === v) {
                    url.query = null;
                    return;
                }
                const input = "?" === v[0] ? v.substring(1) : v;
                url.query = "";
                usm.basicURLParse(input, {
                    url,
                    stateOverride: "query"
                });
            }
            get hash() {
                if (null === this._url.fragment || "" === this._url.fragment) return "";
                return "#" + this._url.fragment;
            }
            set hash(v) {
                if ("" === v) {
                    this._url.fragment = null;
                    return;
                }
                const input = "#" === v[0] ? v.substring(1) : v;
                this._url.fragment = "";
                usm.basicURLParse(input, {
                    url: this._url,
                    stateOverride: "fragment"
                });
            }
            toJSON() {
                return this.href;
            }
        };
    },
    "../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const conversions = __webpack_require__("../../../node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js");
        const utils = __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js");
        const Impl = __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js");
        const impl = utils.implSymbol;
        function URL1(url) {
            if (!this || this[impl] || !(this instanceof URL1)) throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
            if (arguments.length < 1) throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
            const args = [];
            for(let i = 0; i < arguments.length && i < 2; ++i)args[i] = arguments[i];
            args[0] = conversions["USVString"](args[0]);
            if (void 0 !== args[1]) args[1] = conversions["USVString"](args[1]);
            module.exports.setup(this, args);
        }
        URL1.prototype.toJSON = function() {
            if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
            const args = [];
            for(let i = 0; i < arguments.length && i < 0; ++i)args[i] = arguments[i];
            return this[impl].toJSON.apply(this[impl], args);
        };
        Object.defineProperty(URL1.prototype, "href", {
            get () {
                return this[impl].href;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].href = V;
            },
            enumerable: true,
            configurable: true
        });
        URL1.prototype.toString = function() {
            if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
            return this.href;
        };
        Object.defineProperty(URL1.prototype, "origin", {
            get () {
                return this[impl].origin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "protocol", {
            get () {
                return this[impl].protocol;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].protocol = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "username", {
            get () {
                return this[impl].username;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].username = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "password", {
            get () {
                return this[impl].password;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].password = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "host", {
            get () {
                return this[impl].host;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].host = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "hostname", {
            get () {
                return this[impl].hostname;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].hostname = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "port", {
            get () {
                return this[impl].port;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].port = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "pathname", {
            get () {
                return this[impl].pathname;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].pathname = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "search", {
            get () {
                return this[impl].search;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].search = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "hash", {
            get () {
                return this[impl].hash;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].hash = V;
            },
            enumerable: true,
            configurable: true
        });
        module.exports = {
            is (obj) {
                return !!obj && obj[impl] instanceof Impl.implementation;
            },
            create (constructorArgs, privateData) {
                let obj = Object.create(URL1.prototype);
                this.setup(obj, constructorArgs, privateData);
                return obj;
            },
            setup (obj, constructorArgs, privateData) {
                if (!privateData) privateData = {};
                privateData.wrapper = obj;
                obj[impl] = new Impl.implementation(constructorArgs, privateData);
                obj[impl][utils.wrapperSymbol] = obj;
            },
            interface: URL1,
            expose: {
                Window: {
                    URL: URL1
                },
                Worker: {
                    URL: URL1
                }
            }
        };
    },
    "../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js" (__unused_rspack_module, exports1, __webpack_require__) {
        "use strict";
        exports1.URL = __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js")["interface"];
        __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").serializeURL;
        __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").serializeURLOrigin;
        __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").basicURLParse;
        __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").setTheUsername;
        __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").setThePassword;
        __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").serializeHost;
        __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").serializeInteger;
        __webpack_require__("../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").parseURL;
    },
    "../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const punycode = __webpack_require__("punycode");
        const tr46 = __webpack_require__("../../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js");
        const specialSchemes = {
            ftp: 21,
            file: null,
            gopher: 70,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        };
        const failure = Symbol("failure");
        function countSymbols(str) {
            return punycode.ucs2.decode(str).length;
        }
        function at(input, idx) {
            const c = input[idx];
            return isNaN(c) ? void 0 : String.fromCodePoint(c);
        }
        function isASCIIDigit(c) {
            return c >= 0x30 && c <= 0x39;
        }
        function isASCIIAlpha(c) {
            return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A;
        }
        function isASCIIAlphanumeric(c) {
            return isASCIIAlpha(c) || isASCIIDigit(c);
        }
        function isASCIIHex(c) {
            return isASCIIDigit(c) || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;
        }
        function isSingleDot(buffer) {
            return "." === buffer || "%2e" === buffer.toLowerCase();
        }
        function isDoubleDot(buffer) {
            buffer = buffer.toLowerCase();
            return ".." === buffer || "%2e." === buffer || ".%2e" === buffer || "%2e%2e" === buffer;
        }
        function isWindowsDriveLetterCodePoints(cp1, cp2) {
            return isASCIIAlpha(cp1) && (58 === cp2 || 124 === cp2);
        }
        function isWindowsDriveLetterString(string) {
            return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && (":" === string[1] || "|" === string[1]);
        }
        function isNormalizedWindowsDriveLetterString(string) {
            return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && ":" === string[1];
        }
        function containsForbiddenHostCodePoint(string) {
            return -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/);
        }
        function containsForbiddenHostCodePointExcludingPercent(string) {
            return -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/);
        }
        function isSpecialScheme(scheme) {
            return void 0 !== specialSchemes[scheme];
        }
        function isSpecial(url) {
            return isSpecialScheme(url.scheme);
        }
        function defaultPort(scheme) {
            return specialSchemes[scheme];
        }
        function percentEncode(c) {
            let hex = c.toString(16).toUpperCase();
            if (1 === hex.length) hex = "0" + hex;
            return "%" + hex;
        }
        function utf8PercentEncode(c) {
            const buf = new Buffer(c);
            let str = "";
            for(let i = 0; i < buf.length; ++i)str += percentEncode(buf[i]);
            return str;
        }
        function utf8PercentDecode(str) {
            const input = new Buffer(str);
            const output = [];
            for(let i = 0; i < input.length; ++i)if (37 !== input[i]) output.push(input[i]);
            else if (37 === input[i] && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
                output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
                i += 2;
            } else output.push(input[i]);
            return new Buffer(output).toString();
        }
        function isC0ControlPercentEncode(c) {
            return c <= 0x1F || c > 0x7E;
        }
        const extraPathPercentEncodeSet = new Set([
            32,
            34,
            35,
            60,
            62,
            63,
            96,
            123,
            125
        ]);
        function isPathPercentEncode(c) {
            return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
        }
        const extraUserinfoPercentEncodeSet = new Set([
            47,
            58,
            59,
            61,
            64,
            91,
            92,
            93,
            94,
            124
        ]);
        function isUserinfoPercentEncode(c) {
            return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
        }
        function percentEncodeChar(c, encodeSetPredicate) {
            const cStr = String.fromCodePoint(c);
            if (encodeSetPredicate(c)) return utf8PercentEncode(cStr);
            return cStr;
        }
        function parseIPv4Number(input) {
            let R = 10;
            if (input.length >= 2 && "0" === input.charAt(0) && "x" === input.charAt(1).toLowerCase()) {
                input = input.substring(2);
                R = 16;
            } else if (input.length >= 2 && "0" === input.charAt(0)) {
                input = input.substring(1);
                R = 8;
            }
            if ("" === input) return 0;
            const regex = 10 === R ? /[^0-9]/ : 16 === R ? /[^0-9A-Fa-f]/ : /[^0-7]/;
            if (regex.test(input)) return failure;
            return parseInt(input, R);
        }
        function parseIPv4(input) {
            const parts = input.split(".");
            if ("" === parts[parts.length - 1]) {
                if (parts.length > 1) parts.pop();
            }
            if (parts.length > 4) return input;
            const numbers = [];
            for (const part of parts){
                if ("" === part) return input;
                const n = parseIPv4Number(part);
                if (n === failure) return input;
                numbers.push(n);
            }
            for(let i = 0; i < numbers.length - 1; ++i)if (numbers[i] > 255) return failure;
            if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) return failure;
            let ipv4 = numbers.pop();
            let counter = 0;
            for (const n of numbers){
                ipv4 += n * Math.pow(256, 3 - counter);
                ++counter;
            }
            return ipv4;
        }
        function serializeIPv4(address) {
            let output = "";
            let n = address;
            for(let i = 1; i <= 4; ++i){
                output = String(n % 256) + output;
                if (4 !== i) output = "." + output;
                n = Math.floor(n / 256);
            }
            return output;
        }
        function parseIPv6(input) {
            const address = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ];
            let pieceIndex = 0;
            let compress = null;
            let pointer = 0;
            input = punycode.ucs2.decode(input);
            if (58 === input[pointer]) {
                if (58 !== input[pointer + 1]) return failure;
                pointer += 2;
                ++pieceIndex;
                compress = pieceIndex;
            }
            while(pointer < input.length){
                if (8 === pieceIndex) return failure;
                if (58 === input[pointer]) {
                    if (null !== compress) return failure;
                    ++pointer;
                    ++pieceIndex;
                    compress = pieceIndex;
                    continue;
                }
                let value = 0;
                let length = 0;
                while(length < 4 && isASCIIHex(input[pointer])){
                    value = 0x10 * value + parseInt(at(input, pointer), 16);
                    ++pointer;
                    ++length;
                }
                if (46 === input[pointer]) {
                    if (0 === length) return failure;
                    pointer -= length;
                    if (pieceIndex > 6) return failure;
                    let numbersSeen = 0;
                    while(void 0 !== input[pointer]){
                        let ipv4Piece = null;
                        if (numbersSeen > 0) if (46 !== input[pointer] || !(numbersSeen < 4)) return failure;
                        else ++pointer;
                        if (!isASCIIDigit(input[pointer])) return failure;
                        while(isASCIIDigit(input[pointer])){
                            const number = parseInt(at(input, pointer));
                            if (null === ipv4Piece) ipv4Piece = number;
                            else {
                                if (0 === ipv4Piece) return failure;
                                ipv4Piece = 10 * ipv4Piece + number;
                            }
                            if (ipv4Piece > 255) return failure;
                            ++pointer;
                        }
                        address[pieceIndex] = 0x100 * address[pieceIndex] + ipv4Piece;
                        ++numbersSeen;
                        if (2 === numbersSeen || 4 === numbersSeen) ++pieceIndex;
                    }
                    if (4 !== numbersSeen) return failure;
                    break;
                }
                if (58 === input[pointer]) {
                    ++pointer;
                    if (void 0 === input[pointer]) return failure;
                } else if (void 0 !== input[pointer]) return failure;
                address[pieceIndex] = value;
                ++pieceIndex;
            }
            if (null !== compress) {
                let swaps = pieceIndex - compress;
                pieceIndex = 7;
                while(0 !== pieceIndex && swaps > 0){
                    const temp = address[compress + swaps - 1];
                    address[compress + swaps - 1] = address[pieceIndex];
                    address[pieceIndex] = temp;
                    --pieceIndex;
                    --swaps;
                }
            } else if (null === compress && 8 !== pieceIndex) return failure;
            return address;
        }
        function serializeIPv6(address) {
            let output = "";
            const seqResult = findLongestZeroSequence(address);
            const compress = seqResult.idx;
            let ignore0 = false;
            for(let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex)if (!ignore0 || 0 !== address[pieceIndex]) {
                if (ignore0) ignore0 = false;
                if (compress === pieceIndex) {
                    const separator = 0 === pieceIndex ? "::" : ":";
                    output += separator;
                    ignore0 = true;
                    continue;
                }
                output += address[pieceIndex].toString(16);
                if (7 !== pieceIndex) output += ":";
            }
            return output;
        }
        function parseHost(input, isSpecialArg) {
            if ("[" === input[0]) {
                if ("]" !== input[input.length - 1]) return failure;
                return parseIPv6(input.substring(1, input.length - 1));
            }
            if (!isSpecialArg) return parseOpaqueHost(input);
            const domain = utf8PercentDecode(input);
            const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
            if (null === asciiDomain) return failure;
            if (containsForbiddenHostCodePoint(asciiDomain)) return failure;
            const ipv4Host = parseIPv4(asciiDomain);
            if ("number" == typeof ipv4Host || ipv4Host === failure) return ipv4Host;
            return asciiDomain;
        }
        function parseOpaqueHost(input) {
            if (containsForbiddenHostCodePointExcludingPercent(input)) return failure;
            let output = "";
            const decoded = punycode.ucs2.decode(input);
            for(let i = 0; i < decoded.length; ++i)output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
            return output;
        }
        function findLongestZeroSequence(arr) {
            let maxIdx = null;
            let maxLen = 1;
            let currStart = null;
            let currLen = 0;
            for(let i = 0; i < arr.length; ++i)if (0 !== arr[i]) {
                if (currLen > maxLen) {
                    maxIdx = currStart;
                    maxLen = currLen;
                }
                currStart = null;
                currLen = 0;
            } else {
                if (null === currStart) currStart = i;
                ++currLen;
            }
            if (currLen > maxLen) {
                maxIdx = currStart;
                maxLen = currLen;
            }
            return {
                idx: maxIdx,
                len: maxLen
            };
        }
        function serializeHost(host) {
            if ("number" == typeof host) return serializeIPv4(host);
            if (host instanceof Array) return "[" + serializeIPv6(host) + "]";
            return host;
        }
        function trimControlChars(url) {
            return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
        }
        function trimTabAndNewline(url) {
            return url.replace(/\u0009|\u000A|\u000D/g, "");
        }
        function shortenPath(url) {
            const path = url.path;
            if (0 === path.length) return;
            if ("file" === url.scheme && 1 === path.length && isNormalizedWindowsDriveLetter(path[0])) return;
            path.pop();
        }
        function includesCredentials(url) {
            return "" !== url.username || "" !== url.password;
        }
        function cannotHaveAUsernamePasswordPort(url) {
            return null === url.host || "" === url.host || url.cannotBeABaseURL || "file" === url.scheme;
        }
        function isNormalizedWindowsDriveLetter(string) {
            return /^[A-Za-z]:$/.test(string);
        }
        function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
            this.pointer = 0;
            this.input = input;
            this.base = base || null;
            this.encodingOverride = encodingOverride || "utf-8";
            this.stateOverride = stateOverride;
            this.url = url;
            this.failure = false;
            this.parseError = false;
            if (!this.url) {
                this.url = {
                    scheme: "",
                    username: "",
                    password: "",
                    host: null,
                    port: null,
                    path: [],
                    query: null,
                    fragment: null,
                    cannotBeABaseURL: false
                };
                const res = trimControlChars(this.input);
                if (res !== this.input) this.parseError = true;
                this.input = res;
            }
            const res = trimTabAndNewline(this.input);
            if (res !== this.input) this.parseError = true;
            this.input = res;
            this.state = stateOverride || "scheme start";
            this.buffer = "";
            this.atFlag = false;
            this.arrFlag = false;
            this.passwordTokenSeenFlag = false;
            this.input = punycode.ucs2.decode(this.input);
            for(; this.pointer <= this.input.length; ++this.pointer){
                const c = this.input[this.pointer];
                const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
                const ret = this["parse " + this.state](c, cStr);
                if (ret) {
                    if (ret === failure) {
                        this.failure = true;
                        break;
                    }
                } else break;
            }
        }
        URLStateMachine.prototype["parse scheme start"] = function(c, cStr) {
            if (isASCIIAlpha(c)) {
                this.buffer += cStr.toLowerCase();
                this.state = "scheme";
            } else if (this.stateOverride) {
                this.parseError = true;
                return failure;
            } else {
                this.state = "no scheme";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse scheme"] = function(c, cStr) {
            if (isASCIIAlphanumeric(c) || 43 === c || 45 === c || 46 === c) this.buffer += cStr.toLowerCase();
            else if (58 === c) {
                if (this.stateOverride) {
                    if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) return false;
                    if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) return false;
                    if ((includesCredentials(this.url) || null !== this.url.port) && "file" === this.buffer) return false;
                    if ("file" === this.url.scheme && ("" === this.url.host || null === this.url.host)) return false;
                }
                this.url.scheme = this.buffer;
                this.buffer = "";
                if (this.stateOverride) return false;
                if ("file" === this.url.scheme) {
                    if (47 !== this.input[this.pointer + 1] || 47 !== this.input[this.pointer + 2]) this.parseError = true;
                    this.state = "file";
                } else if (isSpecial(this.url) && null !== this.base && this.base.scheme === this.url.scheme) this.state = "special relative or authority";
                else if (isSpecial(this.url)) this.state = "special authority slashes";
                else if (47 === this.input[this.pointer + 1]) {
                    this.state = "path or authority";
                    ++this.pointer;
                } else {
                    this.url.cannotBeABaseURL = true;
                    this.url.path.push("");
                    this.state = "cannot-be-a-base-URL path";
                }
            } else if (this.stateOverride) {
                this.parseError = true;
                return failure;
            } else {
                this.buffer = "";
                this.state = "no scheme";
                this.pointer = -1;
            }
            return true;
        };
        URLStateMachine.prototype["parse no scheme"] = function(c) {
            if (null === this.base || this.base.cannotBeABaseURL && 35 !== c) return failure;
            if (this.base.cannotBeABaseURL && 35 === c) {
                this.url.scheme = this.base.scheme;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.url.cannotBeABaseURL = true;
                this.state = "fragment";
            } else if ("file" === this.base.scheme) {
                this.state = "file";
                --this.pointer;
            } else {
                this.state = "relative";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special relative or authority"] = function(c) {
            if (47 === c && 47 === this.input[this.pointer + 1]) {
                this.state = "special authority ignore slashes";
                ++this.pointer;
            } else {
                this.parseError = true;
                this.state = "relative";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse path or authority"] = function(c) {
            if (47 === c) this.state = "authority";
            else {
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse relative"] = function(c) {
            this.url.scheme = this.base.scheme;
            if (isNaN(c)) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
            } else if (47 === c) this.state = "relative slash";
            else if (63 === c) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = "";
                this.state = "query";
            } else if (35 === c) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.state = "fragment";
            } else if (isSpecial(this.url) && 92 === c) {
                this.parseError = true;
                this.state = "relative slash";
            } else {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice(0, this.base.path.length - 1);
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse relative slash"] = function(c) {
            if (isSpecial(this.url) && (47 === c || 92 === c)) {
                if (92 === c) this.parseError = true;
                this.state = "special authority ignore slashes";
            } else if (47 === c) this.state = "authority";
            else {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special authority slashes"] = function(c) {
            if (47 === c && 47 === this.input[this.pointer + 1]) {
                this.state = "special authority ignore slashes";
                ++this.pointer;
            } else {
                this.parseError = true;
                this.state = "special authority ignore slashes";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special authority ignore slashes"] = function(c) {
            if (47 !== c && 92 !== c) {
                this.state = "authority";
                --this.pointer;
            } else this.parseError = true;
            return true;
        };
        URLStateMachine.prototype["parse authority"] = function(c, cStr) {
            if (64 === c) {
                this.parseError = true;
                if (this.atFlag) this.buffer = "%40" + this.buffer;
                this.atFlag = true;
                const len = countSymbols(this.buffer);
                for(let pointer = 0; pointer < len; ++pointer){
                    const codePoint = this.buffer.codePointAt(pointer);
                    if (58 === codePoint && !this.passwordTokenSeenFlag) {
                        this.passwordTokenSeenFlag = true;
                        continue;
                    }
                    const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
                    if (this.passwordTokenSeenFlag) this.url.password += encodedCodePoints;
                    else this.url.username += encodedCodePoints;
                }
                this.buffer = "";
            } else if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
                if (this.atFlag && "" === this.buffer) {
                    this.parseError = true;
                    return failure;
                }
                this.pointer -= countSymbols(this.buffer) + 1;
                this.buffer = "";
                this.state = "host";
            } else this.buffer += cStr;
            return true;
        };
        URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function(c, cStr) {
            if (this.stateOverride && "file" === this.url.scheme) {
                --this.pointer;
                this.state = "file host";
            } else if (58 !== c || this.arrFlag) if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
                --this.pointer;
                if (isSpecial(this.url) && "" === this.buffer) {
                    this.parseError = true;
                    return failure;
                }
                if (this.stateOverride && "" === this.buffer && (includesCredentials(this.url) || null !== this.url.port)) {
                    this.parseError = true;
                    return false;
                }
                const host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) return failure;
                this.url.host = host;
                this.buffer = "";
                this.state = "path start";
                if (this.stateOverride) return false;
            } else {
                if (91 === c) this.arrFlag = true;
                else if (93 === c) this.arrFlag = false;
                this.buffer += cStr;
            }
            else {
                if ("" === this.buffer) {
                    this.parseError = true;
                    return failure;
                }
                const host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) return failure;
                this.url.host = host;
                this.buffer = "";
                this.state = "port";
                if ("hostname" === this.stateOverride) return false;
            }
            return true;
        };
        URLStateMachine.prototype["parse port"] = function(c, cStr) {
            if (isASCIIDigit(c)) this.buffer += cStr;
            else if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c || this.stateOverride) {
                if ("" !== this.buffer) {
                    const port = parseInt(this.buffer);
                    if (port > Math.pow(2, 16) - 1) {
                        this.parseError = true;
                        return failure;
                    }
                    this.url.port = port === defaultPort(this.url.scheme) ? null : port;
                    this.buffer = "";
                }
                if (this.stateOverride) return false;
                this.state = "path start";
                --this.pointer;
            } else {
                this.parseError = true;
                return failure;
            }
            return true;
        };
        const fileOtherwiseCodePoints = new Set([
            47,
            92,
            63,
            35
        ]);
        URLStateMachine.prototype["parse file"] = function(c) {
            this.url.scheme = "file";
            if (47 === c || 92 === c) {
                if (92 === c) this.parseError = true;
                this.state = "file slash";
            } else if (null !== this.base && "file" === this.base.scheme) if (isNaN(c)) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
            } else if (63 === c) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                this.url.query = "";
                this.state = "query";
            } else if (35 === c) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.state = "fragment";
            } else {
                if (this.input.length - this.pointer - 1 !== 0 && isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) && (!(this.input.length - this.pointer - 1 >= 2) || fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) this.parseError = true;
                else {
                    this.url.host = this.base.host;
                    this.url.path = this.base.path.slice();
                    shortenPath(this.url);
                }
                this.state = "path";
                --this.pointer;
            }
            else {
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse file slash"] = function(c) {
            if (47 === c || 92 === c) {
                if (92 === c) this.parseError = true;
                this.state = "file host";
            } else {
                if (null !== this.base && "file" === this.base.scheme) if (isNormalizedWindowsDriveLetterString(this.base.path[0])) this.url.path.push(this.base.path[0]);
                else this.url.host = this.base.host;
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse file host"] = function(c, cStr) {
            if (isNaN(c) || 47 === c || 92 === c || 63 === c || 35 === c) {
                --this.pointer;
                if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
                    this.parseError = true;
                    this.state = "path";
                } else if ("" === this.buffer) {
                    this.url.host = "";
                    if (this.stateOverride) return false;
                    this.state = "path start";
                } else {
                    let host = parseHost(this.buffer, isSpecial(this.url));
                    if (host === failure) return failure;
                    if ("localhost" === host) host = "";
                    this.url.host = host;
                    if (this.stateOverride) return false;
                    this.buffer = "";
                    this.state = "path start";
                }
            } else this.buffer += cStr;
            return true;
        };
        URLStateMachine.prototype["parse path start"] = function(c) {
            if (isSpecial(this.url)) {
                if (92 === c) this.parseError = true;
                this.state = "path";
                if (47 !== c && 92 !== c) --this.pointer;
            } else if (this.stateOverride || 63 !== c) if (this.stateOverride || 35 !== c) {
                if (void 0 !== c) {
                    this.state = "path";
                    if (47 !== c) --this.pointer;
                }
            } else {
                this.url.fragment = "";
                this.state = "fragment";
            }
            else {
                this.url.query = "";
                this.state = "query";
            }
            return true;
        };
        URLStateMachine.prototype["parse path"] = function(c) {
            if (isNaN(c) || 47 === c || isSpecial(this.url) && 92 === c || !this.stateOverride && (63 === c || 35 === c)) {
                if (isSpecial(this.url) && 92 === c) this.parseError = true;
                if (isDoubleDot(this.buffer)) {
                    shortenPath(this.url);
                    if (47 !== c && !(isSpecial(this.url) && 92 === c)) this.url.path.push("");
                } else if (isSingleDot(this.buffer) && 47 !== c && !(isSpecial(this.url) && 92 === c)) this.url.path.push("");
                else if (!isSingleDot(this.buffer)) {
                    if ("file" === this.url.scheme && 0 === this.url.path.length && isWindowsDriveLetterString(this.buffer)) {
                        if ("" !== this.url.host && null !== this.url.host) {
                            this.parseError = true;
                            this.url.host = "";
                        }
                        this.buffer = this.buffer[0] + ":";
                    }
                    this.url.path.push(this.buffer);
                }
                this.buffer = "";
                if ("file" === this.url.scheme && (void 0 === c || 63 === c || 35 === c)) while(this.url.path.length > 1 && "" === this.url.path[0]){
                    this.parseError = true;
                    this.url.path.shift();
                }
                if (63 === c) {
                    this.url.query = "";
                    this.state = "query";
                }
                if (35 === c) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
            } else {
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                this.buffer += percentEncodeChar(c, isPathPercentEncode);
            }
            return true;
        };
        URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function(c) {
            if (63 === c) {
                this.url.query = "";
                this.state = "query";
            } else if (35 === c) {
                this.url.fragment = "";
                this.state = "fragment";
            } else {
                if (!isNaN(c) && 37 !== c) this.parseError = true;
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                if (!isNaN(c)) this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
            }
            return true;
        };
        URLStateMachine.prototype["parse query"] = function(c, cStr) {
            if (isNaN(c) || !this.stateOverride && 35 === c) {
                if (!isSpecial(this.url) || "ws" === this.url.scheme || "wss" === this.url.scheme) this.encodingOverride = "utf-8";
                const buffer = new Buffer(this.buffer);
                for(let i = 0; i < buffer.length; ++i)if (buffer[i] < 0x21 || buffer[i] > 0x7E || 0x22 === buffer[i] || 0x23 === buffer[i] || 0x3C === buffer[i] || 0x3E === buffer[i]) this.url.query += percentEncode(buffer[i]);
                else this.url.query += String.fromCodePoint(buffer[i]);
                this.buffer = "";
                if (35 === c) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
            } else {
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                this.buffer += cStr;
            }
            return true;
        };
        URLStateMachine.prototype["parse fragment"] = function(c) {
            if (isNaN(c)) ;
            else if (0x0 === c) this.parseError = true;
            else {
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
            }
            return true;
        };
        function serializeURL(url, excludeFragment) {
            let output = url.scheme + ":";
            if (null !== url.host) {
                output += "//";
                if ("" !== url.username || "" !== url.password) {
                    output += url.username;
                    if ("" !== url.password) output += ":" + url.password;
                    output += "@";
                }
                output += serializeHost(url.host);
                if (null !== url.port) output += ":" + url.port;
            } else if (null === url.host && "file" === url.scheme) output += "//";
            if (url.cannotBeABaseURL) output += url.path[0];
            else for (const string of url.path)output += "/" + string;
            if (null !== url.query) output += "?" + url.query;
            if (!excludeFragment && null !== url.fragment) output += "#" + url.fragment;
            return output;
        }
        function serializeOrigin(tuple) {
            let result = tuple.scheme + "://";
            result += serializeHost(tuple.host);
            if (null !== tuple.port) result += ":" + tuple.port;
            return result;
        }
        module.exports.serializeURL = serializeURL;
        module.exports.serializeURLOrigin = function(url) {
            switch(url.scheme){
                case "blob":
                    try {
                        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
                    } catch (e) {
                        return "null";
                    }
                case "ftp":
                case "gopher":
                case "http":
                case "https":
                case "ws":
                case "wss":
                    return serializeOrigin({
                        scheme: url.scheme,
                        host: url.host,
                        port: url.port
                    });
                case "file":
                    return "file://";
                default:
                    return "null";
            }
        };
        module.exports.basicURLParse = function(input, options) {
            if (void 0 === options) options = {};
            const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
            if (usm.failure) return "failure";
            return usm.url;
        };
        module.exports.setTheUsername = function(url, username) {
            url.username = "";
            const decoded = punycode.ucs2.decode(username);
            for(let i = 0; i < decoded.length; ++i)url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        };
        module.exports.setThePassword = function(url, password) {
            url.password = "";
            const decoded = punycode.ucs2.decode(password);
            for(let i = 0; i < decoded.length; ++i)url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        };
        module.exports.serializeHost = serializeHost;
        module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
        module.exports.serializeInteger = function(integer) {
            return String(integer);
        };
        module.exports.parseURL = function(input, options) {
            if (void 0 === options) options = {};
            return module.exports.basicURLParse(input, {
                baseURL: options.baseURL,
                encodingOverride: options.encodingOverride
            });
        };
    },
    "../../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js" (module) {
        "use strict";
        module.exports.mixin = function(target, source) {
            const keys = Object.getOwnPropertyNames(source);
            for(let i = 0; i < keys.length; ++i)Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
        };
        module.exports.wrapperSymbol = Symbol("wrapper");
        module.exports.implSymbol = Symbol("impl");
        module.exports.wrapperForImpl = function(impl) {
            return impl[module.exports.wrapperSymbol];
        };
        module.exports.implForWrapper = function(wrapper) {
            return wrapper[module.exports.implSymbol];
        };
    },
    "../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js" (module) {
        module.exports = wrappy;
        function wrappy(fn, cb) {
            if (fn && cb) return wrappy(fn)(cb);
            if ('function' != typeof fn) throw new TypeError('need wrapper function');
            Object.keys(fn).forEach(function(k) {
                wrapper[k] = fn[k];
            });
            return wrapper;
            function wrapper() {
                var args = new Array(arguments.length);
                for(var i = 0; i < args.length; i++)args[i] = arguments[i];
                var ret = fn.apply(this, args);
                var cb = args[args.length - 1];
                if ('function' == typeof ret && ret !== cb) Object.keys(cb).forEach(function(k) {
                    ret[k] = cb[k];
                });
                return ret;
            }
        }
    },
    "../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/bom.js" (__unused_rspack_module, exports1) {
        (function() {
            "use strict";
            exports1.stripBOM = function(str) {
                if ('\uFEFF' === str[0]) return str.substring(1);
                return str;
            };
        }).call(this);
    },
    "../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/builder.js" (__unused_rspack_module, exports1, __webpack_require__) {
        (function() {
            "use strict";
            var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
            builder = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/index.js");
            defaults = __webpack_require__("../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/defaults.js").defaults;
            requiresCDATA = function(entry) {
                return "string" == typeof entry && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
            };
            wrapCDATA = function(entry) {
                return "<![CDATA[" + escapeCDATA(entry) + "]]>";
            };
            escapeCDATA = function(entry) {
                return entry.replace(']]>', ']]]]><![CDATA[>');
            };
            exports1.Builder = function() {
                function Builder(opts) {
                    var key, ref, value;
                    this.options = {};
                    ref = defaults["0.2"];
                    for(key in ref)if (hasProp.call(ref, key)) {
                        value = ref[key];
                        this.options[key] = value;
                    }
                    for(key in opts)if (hasProp.call(opts, key)) {
                        value = opts[key];
                        this.options[key] = value;
                    }
                }
                Builder.prototype.buildObject = function(rootObj) {
                    var attrkey, charkey, render, rootElement, rootName;
                    attrkey = this.options.attrkey;
                    charkey = this.options.charkey;
                    if (1 === Object.keys(rootObj).length && this.options.rootName === defaults['0.2'].rootName) {
                        rootName = Object.keys(rootObj)[0];
                        rootObj = rootObj[rootName];
                    } else rootName = this.options.rootName;
                    render = function(_this) {
                        return function(element, obj) {
                            var attr, child, entry, index, key, value;
                            if ('object' != typeof obj) if (_this.options.cdata && requiresCDATA(obj)) element.raw(wrapCDATA(obj));
                            else element.txt(obj);
                            else if (Array.isArray(obj)) {
                                for(index in obj)if (hasProp.call(obj, index)) {
                                    child = obj[index];
                                    for(key in child){
                                        entry = child[key];
                                        element = render(element.ele(key), entry).up();
                                    }
                                }
                            } else for(key in obj)if (hasProp.call(obj, key)) {
                                child = obj[key];
                                if (key === attrkey) {
                                    if ("object" == typeof child) for(attr in child){
                                        value = child[attr];
                                        element = element.att(attr, value);
                                    }
                                } else if (key === charkey) element = _this.options.cdata && requiresCDATA(child) ? element.raw(wrapCDATA(child)) : element.txt(child);
                                else if (Array.isArray(child)) {
                                    for(index in child)if (hasProp.call(child, index)) {
                                        entry = child[index];
                                        element = 'string' == typeof entry ? _this.options.cdata && requiresCDATA(entry) ? element.ele(key).raw(wrapCDATA(entry)).up() : element.ele(key, entry).up() : render(element.ele(key), entry).up();
                                    }
                                } else if ("object" == typeof child) element = render(element.ele(key), child).up();
                                else if ('string' == typeof child && _this.options.cdata && requiresCDATA(child)) element = element.ele(key).raw(wrapCDATA(child)).up();
                                else {
                                    if (null == child) child = '';
                                    element = element.ele(key, child.toString()).up();
                                }
                            }
                            return element;
                        };
                    }(this);
                    rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                        headless: this.options.headless,
                        allowSurrogateChars: this.options.allowSurrogateChars
                    });
                    return render(rootElement, rootObj).end(this.options.renderOpts);
                };
                return Builder;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/defaults.js" (__unused_rspack_module, exports1) {
        (function() {
            exports1.defaults = {
                "0.1": {
                    explicitCharkey: false,
                    trim: true,
                    normalize: true,
                    normalizeTags: false,
                    attrkey: "@",
                    charkey: "#",
                    explicitArray: false,
                    ignoreAttrs: false,
                    mergeAttrs: false,
                    explicitRoot: false,
                    validator: null,
                    xmlns: false,
                    explicitChildren: false,
                    childkey: '@@',
                    charsAsChildren: false,
                    includeWhiteChars: false,
                    async: false,
                    strict: true,
                    attrNameProcessors: null,
                    attrValueProcessors: null,
                    tagNameProcessors: null,
                    valueProcessors: null,
                    emptyTag: ''
                },
                "0.2": {
                    explicitCharkey: false,
                    trim: false,
                    normalize: false,
                    normalizeTags: false,
                    attrkey: "$",
                    charkey: "_",
                    explicitArray: true,
                    ignoreAttrs: false,
                    mergeAttrs: false,
                    explicitRoot: true,
                    validator: null,
                    xmlns: false,
                    explicitChildren: false,
                    preserveChildrenOrder: false,
                    childkey: '$$',
                    charsAsChildren: false,
                    includeWhiteChars: false,
                    async: false,
                    strict: true,
                    attrNameProcessors: null,
                    attrValueProcessors: null,
                    tagNameProcessors: null,
                    valueProcessors: null,
                    rootName: 'root',
                    xmldec: {
                        version: '1.0',
                        encoding: 'UTF-8',
                        standalone: true
                    },
                    doctype: null,
                    renderOpts: {
                        pretty: true,
                        indent: '  ',
                        newline: '\n'
                    },
                    headless: false,
                    chunkSize: 10000,
                    emptyTag: '',
                    cdata: false
                }
            };
        }).call(this);
    },
    "../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/parser.js" (__unused_rspack_module, exports1, __webpack_require__) {
        (function() {
            "use strict";
            var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate1, bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            }, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            sax = __webpack_require__("../../../node_modules/.pnpm/sax@1.2.4/node_modules/sax/lib/sax.js");
            events = __webpack_require__("events");
            bom = __webpack_require__("../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/bom.js");
            processors = __webpack_require__("../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/processors.js");
            setImmediate1 = __webpack_require__("timers").setImmediate;
            defaults = __webpack_require__("../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/defaults.js").defaults;
            isEmpty = function(thing) {
                return "object" == typeof thing && null != thing && 0 === Object.keys(thing).length;
            };
            processItem = function(processors, item, key) {
                var i, len, process1;
                for(i = 0, len = processors.length; i < len; i++){
                    process1 = processors[i];
                    item = process1(item, key);
                }
                return item;
            };
            exports1.Parser = function(superClass) {
                extend(Parser, superClass);
                function Parser(opts) {
                    this.parseStringPromise = bind(this.parseStringPromise, this);
                    this.parseString = bind(this.parseString, this);
                    this.reset = bind(this.reset, this);
                    this.assignOrPush = bind(this.assignOrPush, this);
                    this.processAsync = bind(this.processAsync, this);
                    var key, ref, value;
                    if (!(this instanceof exports1.Parser)) return new exports1.Parser(opts);
                    this.options = {};
                    ref = defaults["0.2"];
                    for(key in ref)if (hasProp.call(ref, key)) {
                        value = ref[key];
                        this.options[key] = value;
                    }
                    for(key in opts)if (hasProp.call(opts, key)) {
                        value = opts[key];
                        this.options[key] = value;
                    }
                    if (this.options.xmlns) this.options.xmlnskey = this.options.attrkey + "ns";
                    if (this.options.normalizeTags) {
                        if (!this.options.tagNameProcessors) this.options.tagNameProcessors = [];
                        this.options.tagNameProcessors.unshift(processors.normalize);
                    }
                    this.reset();
                }
                Parser.prototype.processAsync = function() {
                    var chunk, err;
                    try {
                        if (this.remaining.length <= this.options.chunkSize) {
                            chunk = this.remaining;
                            this.remaining = '';
                            this.saxParser = this.saxParser.write(chunk);
                            return this.saxParser.close();
                        }
                        chunk = this.remaining.substr(0, this.options.chunkSize);
                        this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                        this.saxParser = this.saxParser.write(chunk);
                        return setImmediate1(this.processAsync);
                    } catch (error1) {
                        err = error1;
                        if (!this.saxParser.errThrown) {
                            this.saxParser.errThrown = true;
                            return this.emit(err);
                        }
                    }
                };
                Parser.prototype.assignOrPush = function(obj, key, newValue) {
                    if (key in obj) {
                        if (!(obj[key] instanceof Array)) obj[key] = [
                            obj[key]
                        ];
                        return obj[key].push(newValue);
                    }
                    if (!this.options.explicitArray) return obj[key] = newValue;
                    return obj[key] = [
                        newValue
                    ];
                };
                Parser.prototype.reset = function() {
                    var attrkey, charkey, ontext, stack;
                    this.removeAllListeners();
                    this.saxParser = sax.parser(this.options.strict, {
                        trim: false,
                        normalize: false,
                        xmlns: this.options.xmlns
                    });
                    this.saxParser.errThrown = false;
                    this.saxParser.onerror = function(_this) {
                        return function(error) {
                            _this.saxParser.resume();
                            if (!_this.saxParser.errThrown) {
                                _this.saxParser.errThrown = true;
                                return _this.emit("error", error);
                            }
                        };
                    }(this);
                    this.saxParser.onend = function(_this) {
                        return function() {
                            if (!_this.saxParser.ended) {
                                _this.saxParser.ended = true;
                                return _this.emit("end", _this.resultObject);
                            }
                        };
                    }(this);
                    this.saxParser.ended = false;
                    this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
                    this.resultObject = null;
                    stack = [];
                    attrkey = this.options.attrkey;
                    charkey = this.options.charkey;
                    this.saxParser.onopentag = function(_this) {
                        return function(node) {
                            var key, newValue, obj, processedKey, ref;
                            obj = Object.create(null);
                            obj[charkey] = "";
                            if (!_this.options.ignoreAttrs) {
                                ref = node.attributes;
                                for(key in ref)if (hasProp.call(ref, key)) {
                                    if (!(attrkey in obj) && !_this.options.mergeAttrs) obj[attrkey] = Object.create(null);
                                    newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                                    processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                                    if (_this.options.mergeAttrs) _this.assignOrPush(obj, processedKey, newValue);
                                    else obj[attrkey][processedKey] = newValue;
                                }
                            }
                            obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                            if (_this.options.xmlns) obj[_this.options.xmlnskey] = {
                                uri: node.uri,
                                local: node.local
                            };
                            return stack.push(obj);
                        };
                    }(this);
                    this.saxParser.onclosetag = function(_this) {
                        return function() {
                            var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                            obj = stack.pop();
                            nodeName = obj["#name"];
                            if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) delete obj["#name"];
                            if (true === obj.cdata) {
                                cdata = obj.cdata;
                                delete obj.cdata;
                            }
                            s = stack[stack.length - 1];
                            if (obj[charkey].match(/^\s*$/) && !cdata) {
                                emptyStr = obj[charkey];
                                delete obj[charkey];
                            } else {
                                if (_this.options.trim) obj[charkey] = obj[charkey].trim();
                                if (_this.options.normalize) obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                                if (1 === Object.keys(obj).length && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
                            }
                            if (isEmpty(obj)) obj = 'function' == typeof _this.options.emptyTag ? _this.options.emptyTag() : '' !== _this.options.emptyTag ? _this.options.emptyTag : emptyStr;
                            if (null != _this.options.validator) {
                                xpath = "/" + (function() {
                                    var i, len, results;
                                    results = [];
                                    for(i = 0, len = stack.length; i < len; i++){
                                        node = stack[i];
                                        results.push(node["#name"]);
                                    }
                                    return results;
                                })().concat(nodeName).join("/");
                                (function() {
                                    var err;
                                    try {
                                        return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                                    } catch (error1) {
                                        err = error1;
                                        return _this.emit("error", err);
                                    }
                                })();
                            }
                            if (_this.options.explicitChildren && !_this.options.mergeAttrs && 'object' == typeof obj) if (_this.options.preserveChildrenOrder) {
                                if (s) {
                                    s[_this.options.childkey] = s[_this.options.childkey] || [];
                                    objClone = Object.create(null);
                                    for(key in obj)if (hasProp.call(obj, key)) objClone[key] = obj[key];
                                    s[_this.options.childkey].push(objClone);
                                    delete obj["#name"];
                                    if (1 === Object.keys(obj).length && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
                                }
                            } else {
                                node = Object.create(null);
                                if (_this.options.attrkey in obj) {
                                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                                    delete obj[_this.options.attrkey];
                                }
                                if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                    node[_this.options.charkey] = obj[_this.options.charkey];
                                    delete obj[_this.options.charkey];
                                }
                                if (Object.getOwnPropertyNames(obj).length > 0) node[_this.options.childkey] = obj;
                                obj = node;
                            }
                            if (stack.length > 0) return _this.assignOrPush(s, nodeName, obj);
                            if (_this.options.explicitRoot) {
                                old = obj;
                                obj = Object.create(null);
                                obj[nodeName] = old;
                            }
                            _this.resultObject = obj;
                            _this.saxParser.ended = true;
                            return _this.emit("end", _this.resultObject);
                        };
                    }(this);
                    ontext = function(_this) {
                        return function(text) {
                            var charChild, s;
                            s = stack[stack.length - 1];
                            if (s) {
                                s[charkey] += text;
                                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || '' !== text.replace(/\\n/g, '').trim())) {
                                    s[_this.options.childkey] = s[_this.options.childkey] || [];
                                    charChild = {
                                        '#name': '__text__'
                                    };
                                    charChild[charkey] = text;
                                    if (_this.options.normalize) charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                                    s[_this.options.childkey].push(charChild);
                                }
                                return s;
                            }
                        };
                    }(this);
                    this.saxParser.ontext = ontext;
                    return this.saxParser.oncdata = function(_this) {
                        return function(text) {
                            var s;
                            s = ontext(text);
                            if (s) return s.cdata = true;
                        };
                    }(0);
                };
                Parser.prototype.parseString = function(str, cb) {
                    var err;
                    if (null != cb && "function" == typeof cb) {
                        this.on("end", function(result) {
                            this.reset();
                            return cb(null, result);
                        });
                        this.on("error", function(err) {
                            this.reset();
                            return cb(err);
                        });
                    }
                    try {
                        str = str.toString();
                        if ('' === str.trim()) {
                            this.emit("end", null);
                            return true;
                        }
                        str = bom.stripBOM(str);
                        if (this.options.async) {
                            this.remaining = str;
                            setImmediate1(this.processAsync);
                            return this.saxParser;
                        }
                        return this.saxParser.write(str).close();
                    } catch (error1) {
                        err = error1;
                        if (this.saxParser.errThrown || this.saxParser.ended) {
                            if (this.saxParser.ended) throw err;
                        } else {
                            this.emit('error', err);
                            return this.saxParser.errThrown = true;
                        }
                    }
                };
                Parser.prototype.parseStringPromise = function(str) {
                    return new Promise(function(_this) {
                        return function(resolve, reject) {
                            return _this.parseString(str, function(err, value) {
                                if (err) return reject(err);
                                return resolve(value);
                            });
                        };
                    }(this));
                };
                return Parser;
            }(events);
            exports1.parseString = function(str, a, b) {
                var cb, options, parser;
                if (null != b) {
                    if ('function' == typeof b) cb = b;
                    if ('object' == typeof a) options = a;
                } else {
                    if ('function' == typeof a) cb = a;
                    options = {};
                }
                parser = new exports1.Parser(options);
                return parser.parseString(str, cb);
            };
            exports1.parseStringPromise = function(str, a) {
                var options, parser;
                if ('object' == typeof a) options = a;
                parser = new exports1.Parser(options);
                return parser.parseStringPromise(str);
            };
        }).call(this);
    },
    "../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/processors.js" (__unused_rspack_module, exports1) {
        (function() {
            "use strict";
            var prefixMatch;
            prefixMatch = new RegExp(/(?!xmlns)^.*:/);
            exports1.normalize = function(str) {
                return str.toLowerCase();
            };
            exports1.firstCharLowerCase = function(str) {
                return str.charAt(0).toLowerCase() + str.slice(1);
            };
            exports1.stripPrefix = function(str) {
                return str.replace(prefixMatch, '');
            };
            exports1.parseNumbers = function(str) {
                if (!isNaN(str)) str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
                return str;
            };
            exports1.parseBooleans = function(str) {
                if (/^(?:true|false)$/i.test(str)) str = 'true' === str.toLowerCase();
                return str;
            };
        }).call(this);
    },
    "../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/xml2js.js" (__unused_rspack_module, exports1, __webpack_require__) {
        (function() {
            "use strict";
            var builder, defaults, parser, processors, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            defaults = __webpack_require__("../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/defaults.js");
            builder = __webpack_require__("../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/builder.js");
            parser = __webpack_require__("../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/parser.js");
            processors = __webpack_require__("../../../node_modules/.pnpm/xml2js@0.5.0/node_modules/xml2js/lib/processors.js");
            exports1.defaults = defaults.defaults;
            exports1.processors = processors;
            exports1.ValidationError = function(superClass) {
                extend(ValidationError, superClass);
                function ValidationError(message) {
                    this.message = message;
                }
                return ValidationError;
            }(Error);
            exports1.Builder = builder.Builder;
            exports1.Parser = parser.Parser;
            exports1.parseString = parser.parseString;
            exports1.parseStringPromise = parser.parseStringPromise;
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/DocumentPosition.js" (module) {
        (function() {
            module.exports = {
                Disconnected: 1,
                Preceding: 2,
                Following: 4,
                Contains: 8,
                ContainedBy: 16,
                ImplementationSpecific: 32
            };
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js" (module) {
        (function() {
            module.exports = {
                Element: 1,
                Attribute: 2,
                Text: 3,
                CData: 4,
                EntityReference: 5,
                EntityDeclaration: 6,
                ProcessingInstruction: 7,
                Comment: 8,
                Document: 9,
                DocType: 10,
                DocumentFragment: 11,
                NotationDeclaration: 12,
                Declaration: 201,
                Raw: 202,
                AttributeDeclaration: 203,
                ElementDeclaration: 204,
                Dummy: 205
            };
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js" (module) {
        (function() {
            var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
            assign = function() {
                var i, key, len, source, sources, target;
                target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
                if (isFunction(Object.assign)) Object.assign.apply(null, arguments);
                else for(i = 0, len = sources.length; i < len; i++){
                    source = sources[i];
                    if (null != source) {
                        for(key in source)if (hasProp.call(source, key)) target[key] = source[key];
                    }
                }
                return target;
            };
            isFunction = function(val) {
                return !!val && '[object Function]' === Object.prototype.toString.call(val);
            };
            isObject = function(val) {
                var ref;
                return !!val && ('function' === (ref = typeof val) || 'object' === ref);
            };
            isArray = function(val) {
                if (isFunction(Array.isArray)) return Array.isArray(val);
                return '[object Array]' === Object.prototype.toString.call(val);
            };
            isEmpty = function(val) {
                var key;
                if (isArray(val)) return !val.length;
                for(key in val)if (hasProp.call(val, key)) return false;
                return true;
            };
            isPlainObject = function(val) {
                var ctor, proto;
                return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && 'function' == typeof ctor && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
            };
            getValue = function(obj) {
                if (isFunction(obj.valueOf)) return obj.valueOf();
                return obj;
            };
            module.exports.assign = assign;
            module.exports.isFunction = isFunction;
            module.exports.isObject = isObject;
            module.exports.isArray = isArray;
            module.exports.isEmpty = isEmpty;
            module.exports.isPlainObject = isPlainObject;
            module.exports.getValue = getValue;
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/WriterState.js" (module) {
        (function() {
            module.exports = {
                None: 0,
                OpenTag: 1,
                InsideTag: 2,
                CloseTag: 3
            };
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLAttribute.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType;
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            module.exports = function() {
                function XMLAttribute(parent, name, value) {
                    this.parent = parent;
                    if (this.parent) {
                        this.options = this.parent.options;
                        this.stringify = this.parent.stringify;
                    }
                    if (null == name) throw new Error("Missing attribute name. " + this.debugInfo(name));
                    this.name = this.stringify.name(name);
                    this.value = this.stringify.attValue(value);
                    this.type = NodeType.Attribute;
                    this.isId = false;
                    this.schemaTypeInfo = null;
                }
                Object.defineProperty(XMLAttribute.prototype, 'nodeType', {
                    get: function() {
                        return this.type;
                    }
                });
                Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {
                    get: function() {
                        return this.parent;
                    }
                });
                Object.defineProperty(XMLAttribute.prototype, 'textContent', {
                    get: function() {
                        return this.value;
                    },
                    set: function(value) {
                        return this.value = value || '';
                    }
                });
                Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {
                    get: function() {
                        return '';
                    }
                });
                Object.defineProperty(XMLAttribute.prototype, 'prefix', {
                    get: function() {
                        return '';
                    }
                });
                Object.defineProperty(XMLAttribute.prototype, 'localName', {
                    get: function() {
                        return this.name;
                    }
                });
                Object.defineProperty(XMLAttribute.prototype, 'specified', {
                    get: function() {
                        return true;
                    }
                });
                XMLAttribute.prototype.clone = function() {
                    return Object.create(this);
                };
                XMLAttribute.prototype.toString = function(options) {
                    return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
                };
                XMLAttribute.prototype.debugInfo = function(name) {
                    name = name || this.name;
                    if (null == name) return "parent: <" + this.parent.name + ">";
                    return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
                };
                XMLAttribute.prototype.isEqualNode = function(node) {
                    if (node.namespaceURI !== this.namespaceURI) return false;
                    if (node.prefix !== this.prefix) return false;
                    if (node.localName !== this.localName) return false;
                    if (node.value !== this.value) return false;
                    return true;
                };
                return XMLAttribute;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCData.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLCharacterData, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLCharacterData = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCharacterData.js");
            module.exports = function(superClass) {
                extend(XMLCData, superClass);
                function XMLCData(parent, text) {
                    XMLCData.__super__.constructor.call(this, parent);
                    if (null == text) throw new Error("Missing CDATA text. " + this.debugInfo());
                    this.name = "#cdata-section";
                    this.type = NodeType.CData;
                    this.value = this.stringify.cdata(text);
                }
                XMLCData.prototype.clone = function() {
                    return Object.create(this);
                };
                XMLCData.prototype.toString = function(options) {
                    return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
                };
                return XMLCData;
            }(XMLCharacterData);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCharacterData.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var XMLNode, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            module.exports = function(superClass) {
                extend(XMLCharacterData, superClass);
                function XMLCharacterData(parent) {
                    XMLCharacterData.__super__.constructor.call(this, parent);
                    this.value = '';
                }
                Object.defineProperty(XMLCharacterData.prototype, 'data', {
                    get: function() {
                        return this.value;
                    },
                    set: function(value) {
                        return this.value = value || '';
                    }
                });
                Object.defineProperty(XMLCharacterData.prototype, 'length', {
                    get: function() {
                        return this.value.length;
                    }
                });
                Object.defineProperty(XMLCharacterData.prototype, 'textContent', {
                    get: function() {
                        return this.value;
                    },
                    set: function(value) {
                        return this.value = value || '';
                    }
                });
                XMLCharacterData.prototype.clone = function() {
                    return Object.create(this);
                };
                XMLCharacterData.prototype.substringData = function(offset, count) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLCharacterData.prototype.appendData = function(arg) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLCharacterData.prototype.insertData = function(offset, arg) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLCharacterData.prototype.deleteData = function(offset, count) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLCharacterData.prototype.replaceData = function(offset, count, arg) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLCharacterData.prototype.isEqualNode = function(node) {
                    if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
                    if (node.data !== this.data) return false;
                    return true;
                };
                return XMLCharacterData;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLComment.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLCharacterData, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLCharacterData = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCharacterData.js");
            module.exports = function(superClass) {
                extend(XMLComment, superClass);
                function XMLComment(parent, text) {
                    XMLComment.__super__.constructor.call(this, parent);
                    if (null == text) throw new Error("Missing comment text. " + this.debugInfo());
                    this.name = "#comment";
                    this.type = NodeType.Comment;
                    this.value = this.stringify.comment(text);
                }
                XMLComment.prototype.clone = function() {
                    return Object.create(this);
                };
                XMLComment.prototype.toString = function(options) {
                    return this.options.writer.comment(this, this.options.writer.filterOptions(options));
                };
                return XMLComment;
            }(XMLCharacterData);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMConfiguration.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var XMLDOMErrorHandler, XMLDOMStringList;
            XMLDOMErrorHandler = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js");
            XMLDOMStringList = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMStringList.js");
            module.exports = function() {
                function XMLDOMConfiguration() {
                    this.defaultParams = {
                        "canonical-form": false,
                        "cdata-sections": false,
                        comments: false,
                        "datatype-normalization": false,
                        "element-content-whitespace": true,
                        entities: true,
                        "error-handler": new XMLDOMErrorHandler(),
                        infoset: true,
                        "validate-if-schema": false,
                        namespaces: true,
                        "namespace-declarations": true,
                        "normalize-characters": false,
                        "schema-location": '',
                        "schema-type": '',
                        "split-cdata-sections": true,
                        validate: false,
                        "well-formed": true
                    };
                    this.params = Object.create(this.defaultParams);
                }
                Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {
                    get: function() {
                        return new XMLDOMStringList(Object.keys(this.defaultParams));
                    }
                });
                XMLDOMConfiguration.prototype.getParameter = function(name) {
                    if (this.params.hasOwnProperty(name)) return this.params[name];
                    return null;
                };
                XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
                    return true;
                };
                XMLDOMConfiguration.prototype.setParameter = function(name, value) {
                    if (null != value) return this.params[name] = value;
                    return delete this.params[name];
                };
                return XMLDOMConfiguration;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js" (module) {
        (function() {
            module.exports = function() {
                function XMLDOMErrorHandler() {}
                XMLDOMErrorHandler.prototype.handleError = function(error) {
                    throw new Error(error);
                };
                return XMLDOMErrorHandler;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMImplementation.js" (module) {
        (function() {
            module.exports = function() {
                function XMLDOMImplementation() {}
                XMLDOMImplementation.prototype.hasFeature = function(feature, version) {
                    return true;
                };
                XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
                    throw new Error("This DOM method is not implemented.");
                };
                XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
                    throw new Error("This DOM method is not implemented.");
                };
                XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
                    throw new Error("This DOM method is not implemented.");
                };
                XMLDOMImplementation.prototype.getFeature = function(feature, version) {
                    throw new Error("This DOM method is not implemented.");
                };
                return XMLDOMImplementation;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMStringList.js" (module) {
        (function() {
            module.exports = function() {
                function XMLDOMStringList(arr) {
                    this.arr = arr || [];
                }
                Object.defineProperty(XMLDOMStringList.prototype, 'length', {
                    get: function() {
                        return this.arr.length;
                    }
                });
                XMLDOMStringList.prototype.item = function(index) {
                    return this.arr[index] || null;
                };
                XMLDOMStringList.prototype.contains = function(str) {
                    return -1 !== this.arr.indexOf(str);
                };
                return XMLDOMStringList;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDAttList.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLNode, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            module.exports = function(superClass) {
                extend(XMLDTDAttList, superClass);
                function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                    XMLDTDAttList.__super__.constructor.call(this, parent);
                    if (null == elementName) throw new Error("Missing DTD element name. " + this.debugInfo());
                    if (null == attributeName) throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
                    if (!attributeType) throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
                    if (!defaultValueType) throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
                    if (0 !== defaultValueType.indexOf('#')) defaultValueType = '#' + defaultValueType;
                    if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
                    if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
                    this.elementName = this.stringify.name(elementName);
                    this.type = NodeType.AttributeDeclaration;
                    this.attributeName = this.stringify.name(attributeName);
                    this.attributeType = this.stringify.dtdAttType(attributeType);
                    if (defaultValue) this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
                    this.defaultValueType = defaultValueType;
                }
                XMLDTDAttList.prototype.toString = function(options) {
                    return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
                };
                return XMLDTDAttList;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDElement.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLNode, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            module.exports = function(superClass) {
                extend(XMLDTDElement, superClass);
                function XMLDTDElement(parent, name, value) {
                    XMLDTDElement.__super__.constructor.call(this, parent);
                    if (null == name) throw new Error("Missing DTD element name. " + this.debugInfo());
                    if (!value) value = '(#PCDATA)';
                    if (Array.isArray(value)) value = '(' + value.join(',') + ')';
                    this.name = this.stringify.name(name);
                    this.type = NodeType.ElementDeclaration;
                    this.value = this.stringify.dtdElementValue(value);
                }
                XMLDTDElement.prototype.toString = function(options) {
                    return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
                };
                return XMLDTDElement;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDEntity.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLNode, isObject, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            isObject = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js").isObject;
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            module.exports = function(superClass) {
                extend(XMLDTDEntity, superClass);
                function XMLDTDEntity(parent, pe, name, value) {
                    XMLDTDEntity.__super__.constructor.call(this, parent);
                    if (null == name) throw new Error("Missing DTD entity name. " + this.debugInfo(name));
                    if (null == value) throw new Error("Missing DTD entity value. " + this.debugInfo(name));
                    this.pe = !!pe;
                    this.name = this.stringify.name(name);
                    this.type = NodeType.EntityDeclaration;
                    if (isObject(value)) {
                        if (!value.pubID && !value.sysID) throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
                        if (value.pubID && !value.sysID) throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
                        this.internal = false;
                        if (null != value.pubID) this.pubID = this.stringify.dtdPubID(value.pubID);
                        if (null != value.sysID) this.sysID = this.stringify.dtdSysID(value.sysID);
                        if (null != value.nData) this.nData = this.stringify.dtdNData(value.nData);
                        if (this.pe && this.nData) throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
                    } else {
                        this.value = this.stringify.dtdEntityValue(value);
                        this.internal = true;
                    }
                }
                Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {
                    get: function() {
                        return this.pubID;
                    }
                });
                Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {
                    get: function() {
                        return this.sysID;
                    }
                });
                Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {
                    get: function() {
                        return this.nData || null;
                    }
                });
                Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {
                    get: function() {
                        return null;
                    }
                });
                Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {
                    get: function() {
                        return null;
                    }
                });
                Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {
                    get: function() {
                        return null;
                    }
                });
                XMLDTDEntity.prototype.toString = function(options) {
                    return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
                };
                return XMLDTDEntity;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDNotation.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLNode, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            module.exports = function(superClass) {
                extend(XMLDTDNotation, superClass);
                function XMLDTDNotation(parent, name, value) {
                    XMLDTDNotation.__super__.constructor.call(this, parent);
                    if (null == name) throw new Error("Missing DTD notation name. " + this.debugInfo(name));
                    if (!value.pubID && !value.sysID) throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
                    this.name = this.stringify.name(name);
                    this.type = NodeType.NotationDeclaration;
                    if (null != value.pubID) this.pubID = this.stringify.dtdPubID(value.pubID);
                    if (null != value.sysID) this.sysID = this.stringify.dtdSysID(value.sysID);
                }
                Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {
                    get: function() {
                        return this.pubID;
                    }
                });
                Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {
                    get: function() {
                        return this.sysID;
                    }
                });
                XMLDTDNotation.prototype.toString = function(options) {
                    return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
                };
                return XMLDTDNotation;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDeclaration.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLNode, isObject, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            isObject = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js").isObject;
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            module.exports = function(superClass) {
                extend(XMLDeclaration, superClass);
                function XMLDeclaration(parent, version, encoding, standalone) {
                    var ref;
                    XMLDeclaration.__super__.constructor.call(this, parent);
                    if (isObject(version)) ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
                    if (!version) version = '1.0';
                    this.type = NodeType.Declaration;
                    this.version = this.stringify.xmlVersion(version);
                    if (null != encoding) this.encoding = this.stringify.xmlEncoding(encoding);
                    if (null != standalone) this.standalone = this.stringify.xmlStandalone(standalone);
                }
                XMLDeclaration.prototype.toString = function(options) {
                    return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
                };
                return XMLDeclaration;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocType.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            isObject = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js").isObject;
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLDTDAttList = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDAttList.js");
            XMLDTDEntity = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDEntity.js");
            XMLDTDElement = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDElement.js");
            XMLDTDNotation = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDNotation.js");
            XMLNamedNodeMap = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");
            module.exports = function(superClass) {
                extend(XMLDocType, superClass);
                function XMLDocType(parent, pubID, sysID) {
                    var child, i, len, ref, ref1, ref2;
                    XMLDocType.__super__.constructor.call(this, parent);
                    this.type = NodeType.DocType;
                    if (parent.children) {
                        ref = parent.children;
                        for(i = 0, len = ref.length; i < len; i++){
                            child = ref[i];
                            if (child.type === NodeType.Element) {
                                this.name = child.name;
                                break;
                            }
                        }
                    }
                    this.documentObject = parent;
                    if (isObject(pubID)) ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
                    if (null == sysID) ref2 = [
                        pubID,
                        sysID
                    ], sysID = ref2[0], pubID = ref2[1];
                    if (null != pubID) this.pubID = this.stringify.dtdPubID(pubID);
                    if (null != sysID) this.sysID = this.stringify.dtdSysID(sysID);
                }
                Object.defineProperty(XMLDocType.prototype, 'entities', {
                    get: function() {
                        var child, i, len, nodes, ref;
                        nodes = {};
                        ref = this.children;
                        for(i = 0, len = ref.length; i < len; i++){
                            child = ref[i];
                            if (child.type === NodeType.EntityDeclaration && !child.pe) nodes[child.name] = child;
                        }
                        return new XMLNamedNodeMap(nodes);
                    }
                });
                Object.defineProperty(XMLDocType.prototype, 'notations', {
                    get: function() {
                        var child, i, len, nodes, ref;
                        nodes = {};
                        ref = this.children;
                        for(i = 0, len = ref.length; i < len; i++){
                            child = ref[i];
                            if (child.type === NodeType.NotationDeclaration) nodes[child.name] = child;
                        }
                        return new XMLNamedNodeMap(nodes);
                    }
                });
                Object.defineProperty(XMLDocType.prototype, 'publicId', {
                    get: function() {
                        return this.pubID;
                    }
                });
                Object.defineProperty(XMLDocType.prototype, 'systemId', {
                    get: function() {
                        return this.sysID;
                    }
                });
                Object.defineProperty(XMLDocType.prototype, 'internalSubset', {
                    get: function() {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    }
                });
                XMLDocType.prototype.element = function(name, value) {
                    var child;
                    child = new XMLDTDElement(this, name, value);
                    this.children.push(child);
                    return this;
                };
                XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                    var child;
                    child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
                    this.children.push(child);
                    return this;
                };
                XMLDocType.prototype.entity = function(name, value) {
                    var child;
                    child = new XMLDTDEntity(this, false, name, value);
                    this.children.push(child);
                    return this;
                };
                XMLDocType.prototype.pEntity = function(name, value) {
                    var child;
                    child = new XMLDTDEntity(this, true, name, value);
                    this.children.push(child);
                    return this;
                };
                XMLDocType.prototype.notation = function(name, value) {
                    var child;
                    child = new XMLDTDNotation(this, name, value);
                    this.children.push(child);
                    return this;
                };
                XMLDocType.prototype.toString = function(options) {
                    return this.options.writer.docType(this, this.options.writer.filterOptions(options));
                };
                XMLDocType.prototype.ele = function(name, value) {
                    return this.element(name, value);
                };
                XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                    return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
                };
                XMLDocType.prototype.ent = function(name, value) {
                    return this.entity(name, value);
                };
                XMLDocType.prototype.pent = function(name, value) {
                    return this.pEntity(name, value);
                };
                XMLDocType.prototype.not = function(name, value) {
                    return this.notation(name, value);
                };
                XMLDocType.prototype.up = function() {
                    return this.root() || this.documentObject;
                };
                XMLDocType.prototype.isEqualNode = function(node) {
                    if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
                    if (node.name !== this.name) return false;
                    if (node.publicId !== this.publicId) return false;
                    if (node.systemId !== this.systemId) return false;
                    return true;
                };
                return XMLDocType;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocument.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            isPlainObject = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js").isPlainObject;
            XMLDOMImplementation = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMImplementation.js");
            XMLDOMConfiguration = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMConfiguration.js");
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLStringifier = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringifier.js");
            XMLStringWriter = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringWriter.js");
            module.exports = function(superClass) {
                extend(XMLDocument, superClass);
                function XMLDocument(options) {
                    XMLDocument.__super__.constructor.call(this, null);
                    this.name = "#document";
                    this.type = NodeType.Document;
                    this.documentURI = null;
                    this.domConfig = new XMLDOMConfiguration();
                    options || (options = {});
                    if (!options.writer) options.writer = new XMLStringWriter();
                    this.options = options;
                    this.stringify = new XMLStringifier(options);
                }
                Object.defineProperty(XMLDocument.prototype, 'implementation', {
                    value: new XMLDOMImplementation()
                });
                Object.defineProperty(XMLDocument.prototype, 'doctype', {
                    get: function() {
                        var child, i, len, ref;
                        ref = this.children;
                        for(i = 0, len = ref.length; i < len; i++){
                            child = ref[i];
                            if (child.type === NodeType.DocType) return child;
                        }
                        return null;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'documentElement', {
                    get: function() {
                        return this.rootObject || null;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {
                    get: function() {
                        return null;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {
                    get: function() {
                        return false;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {
                    get: function() {
                        if (0 !== this.children.length && this.children[0].type === NodeType.Declaration) return this.children[0].encoding;
                        return null;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {
                    get: function() {
                        if (0 !== this.children.length && this.children[0].type === NodeType.Declaration) return 'yes' === this.children[0].standalone;
                        return false;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {
                    get: function() {
                        if (0 !== this.children.length && this.children[0].type === NodeType.Declaration) return this.children[0].version;
                        return "1.0";
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'URL', {
                    get: function() {
                        return this.documentURI;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'origin', {
                    get: function() {
                        return null;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'compatMode', {
                    get: function() {
                        return null;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'characterSet', {
                    get: function() {
                        return null;
                    }
                });
                Object.defineProperty(XMLDocument.prototype, 'contentType', {
                    get: function() {
                        return null;
                    }
                });
                XMLDocument.prototype.end = function(writer) {
                    var writerOptions;
                    writerOptions = {};
                    if (writer) {
                        if (isPlainObject(writer)) {
                            writerOptions = writer;
                            writer = this.options.writer;
                        }
                    } else writer = this.options.writer;
                    return writer.document(this, writer.filterOptions(writerOptions));
                };
                XMLDocument.prototype.toString = function(options) {
                    return this.options.writer.document(this, this.options.writer.filterOptions(options));
                };
                XMLDocument.prototype.createElement = function(tagName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createDocumentFragment = function() {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createTextNode = function(data) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createComment = function(data) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createCDATASection = function(data) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createProcessingInstruction = function(target, data) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createAttribute = function(name) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createEntityReference = function(name) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.getElementsByTagName = function(tagname) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.importNode = function(importedNode, deep) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.getElementById = function(elementId) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.adoptNode = function(source) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.normalizeDocument = function() {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.getElementsByClassName = function(classNames) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createEvent = function(eventInterface) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createRange = function() {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                return XMLDocument;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocumentCB.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
            ref = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLDocument = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocument.js");
            XMLElement = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLElement.js");
            XMLCData = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCData.js");
            XMLComment = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLComment.js");
            XMLRaw = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLRaw.js");
            XMLText = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLText.js");
            XMLProcessingInstruction = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
            XMLDeclaration = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDeclaration.js");
            XMLDocType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocType.js");
            XMLDTDAttList = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDAttList.js");
            XMLDTDEntity = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDEntity.js");
            XMLDTDElement = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDElement.js");
            XMLDTDNotation = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDNotation.js");
            XMLAttribute = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLAttribute.js");
            XMLStringifier = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringifier.js");
            XMLStringWriter = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringWriter.js");
            WriterState = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/WriterState.js");
            module.exports = function() {
                function XMLDocumentCB(options, onData, onEnd) {
                    var writerOptions;
                    this.name = "?xml";
                    this.type = NodeType.Document;
                    options || (options = {});
                    writerOptions = {};
                    if (options.writer) {
                        if (isPlainObject(options.writer)) {
                            writerOptions = options.writer;
                            options.writer = new XMLStringWriter();
                        }
                    } else options.writer = new XMLStringWriter();
                    this.options = options;
                    this.writer = options.writer;
                    this.writerOptions = this.writer.filterOptions(writerOptions);
                    this.stringify = new XMLStringifier(options);
                    this.onDataCallback = onData || function() {};
                    this.onEndCallback = onEnd || function() {};
                    this.currentNode = null;
                    this.currentLevel = -1;
                    this.openTags = {};
                    this.documentStarted = false;
                    this.documentCompleted = false;
                    this.root = null;
                }
                XMLDocumentCB.prototype.createChildNode = function(node) {
                    var att, attName, attributes, child, i, len, ref1, ref2;
                    switch(node.type){
                        case NodeType.CData:
                            this.cdata(node.value);
                            break;
                        case NodeType.Comment:
                            this.comment(node.value);
                            break;
                        case NodeType.Element:
                            attributes = {};
                            ref1 = node.attribs;
                            for(attName in ref1)if (hasProp.call(ref1, attName)) {
                                att = ref1[attName];
                                attributes[attName] = att.value;
                            }
                            this.node(node.name, attributes);
                            break;
                        case NodeType.Dummy:
                            this.dummy();
                            break;
                        case NodeType.Raw:
                            this.raw(node.value);
                            break;
                        case NodeType.Text:
                            this.text(node.value);
                            break;
                        case NodeType.ProcessingInstruction:
                            this.instruction(node.target, node.value);
                            break;
                        default:
                            throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
                    }
                    ref2 = node.children;
                    for(i = 0, len = ref2.length; i < len; i++){
                        child = ref2[i];
                        this.createChildNode(child);
                        if (child.type === NodeType.Element) this.up();
                    }
                    return this;
                };
                XMLDocumentCB.prototype.dummy = function() {
                    return this;
                };
                XMLDocumentCB.prototype.node = function(name, attributes, text) {
                    var ref1;
                    if (null == name) throw new Error("Missing node name.");
                    if (this.root && -1 === this.currentLevel) throw new Error("Document can only have one root node. " + this.debugInfo(name));
                    this.openCurrent();
                    name = getValue(name);
                    if (null == attributes) attributes = {};
                    attributes = getValue(attributes);
                    if (!isObject(attributes)) ref1 = [
                        attributes,
                        text
                    ], text = ref1[0], attributes = ref1[1];
                    this.currentNode = new XMLElement(this, name, attributes);
                    this.currentNode.children = false;
                    this.currentLevel++;
                    this.openTags[this.currentLevel] = this.currentNode;
                    if (null != text) this.text(text);
                    return this;
                };
                XMLDocumentCB.prototype.element = function(name, attributes, text) {
                    var child, i, len, oldValidationFlag, ref1, root;
                    if (this.currentNode && this.currentNode.type === NodeType.DocType) this.dtdElement.apply(this, arguments);
                    else if (Array.isArray(name) || isObject(name) || isFunction(name)) {
                        oldValidationFlag = this.options.noValidation;
                        this.options.noValidation = true;
                        root = new XMLDocument(this.options).element('TEMP_ROOT');
                        root.element(name);
                        this.options.noValidation = oldValidationFlag;
                        ref1 = root.children;
                        for(i = 0, len = ref1.length; i < len; i++){
                            child = ref1[i];
                            this.createChildNode(child);
                            if (child.type === NodeType.Element) this.up();
                        }
                    } else this.node(name, attributes, text);
                    return this;
                };
                XMLDocumentCB.prototype.attribute = function(name, value) {
                    var attName, attValue;
                    if (!this.currentNode || this.currentNode.children) throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
                    if (null != name) name = getValue(name);
                    if (isObject(name)) {
                        for(attName in name)if (hasProp.call(name, attName)) {
                            attValue = name[attName];
                            this.attribute(attName, attValue);
                        }
                    } else {
                        if (isFunction(value)) value = value.apply();
                        if (this.options.keepNullAttributes && null == value) this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
                        else if (null != value) this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
                    }
                    return this;
                };
                XMLDocumentCB.prototype.text = function(value) {
                    var node;
                    this.openCurrent();
                    node = new XMLText(this, value);
                    this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.cdata = function(value) {
                    var node;
                    this.openCurrent();
                    node = new XMLCData(this, value);
                    this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.comment = function(value) {
                    var node;
                    this.openCurrent();
                    node = new XMLComment(this, value);
                    this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.raw = function(value) {
                    var node;
                    this.openCurrent();
                    node = new XMLRaw(this, value);
                    this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.instruction = function(target, value) {
                    var i, insTarget, insValue, len, node;
                    this.openCurrent();
                    if (null != target) target = getValue(target);
                    if (null != value) value = getValue(value);
                    if (Array.isArray(target)) for(i = 0, len = target.length; i < len; i++){
                        insTarget = target[i];
                        this.instruction(insTarget);
                    }
                    else if (isObject(target)) {
                        for(insTarget in target)if (hasProp.call(target, insTarget)) {
                            insValue = target[insTarget];
                            this.instruction(insTarget, insValue);
                        }
                    } else {
                        if (isFunction(value)) value = value.apply();
                        node = new XMLProcessingInstruction(this, target, value);
                        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    }
                    return this;
                };
                XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
                    var node;
                    this.openCurrent();
                    if (this.documentStarted) throw new Error("declaration() must be the first node.");
                    node = new XMLDeclaration(this, version, encoding, standalone);
                    this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
                    this.openCurrent();
                    if (null == root) throw new Error("Missing root node name.");
                    if (this.root) throw new Error("dtd() must come before the root node.");
                    this.currentNode = new XMLDocType(this, pubID, sysID);
                    this.currentNode.rootNodeName = root;
                    this.currentNode.children = false;
                    this.currentLevel++;
                    this.openTags[this.currentLevel] = this.currentNode;
                    return this;
                };
                XMLDocumentCB.prototype.dtdElement = function(name, value) {
                    var node;
                    this.openCurrent();
                    node = new XMLDTDElement(this, name, value);
                    this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                    var node;
                    this.openCurrent();
                    node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
                    this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.entity = function(name, value) {
                    var node;
                    this.openCurrent();
                    node = new XMLDTDEntity(this, false, name, value);
                    this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.pEntity = function(name, value) {
                    var node;
                    this.openCurrent();
                    node = new XMLDTDEntity(this, true, name, value);
                    this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.notation = function(name, value) {
                    var node;
                    this.openCurrent();
                    node = new XMLDTDNotation(this, name, value);
                    this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
                    return this;
                };
                XMLDocumentCB.prototype.up = function() {
                    if (this.currentLevel < 0) throw new Error("The document node has no parent.");
                    if (this.currentNode) {
                        if (this.currentNode.children) this.closeNode(this.currentNode);
                        else this.openNode(this.currentNode);
                        this.currentNode = null;
                    } else this.closeNode(this.openTags[this.currentLevel]);
                    delete this.openTags[this.currentLevel];
                    this.currentLevel--;
                    return this;
                };
                XMLDocumentCB.prototype.end = function() {
                    while(this.currentLevel >= 0)this.up();
                    return this.onEnd();
                };
                XMLDocumentCB.prototype.openCurrent = function() {
                    if (this.currentNode) {
                        this.currentNode.children = true;
                        return this.openNode(this.currentNode);
                    }
                };
                XMLDocumentCB.prototype.openNode = function(node) {
                    var att, chunk, name, ref1;
                    if (!node.isOpen) {
                        if (!this.root && 0 === this.currentLevel && node.type === NodeType.Element) this.root = node;
                        chunk = '';
                        if (node.type === NodeType.Element) {
                            this.writerOptions.state = WriterState.OpenTag;
                            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
                            ref1 = node.attribs;
                            for(name in ref1)if (hasProp.call(ref1, name)) {
                                att = ref1[name];
                                chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                            }
                            chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
                            this.writerOptions.state = WriterState.InsideTag;
                        } else {
                            this.writerOptions.state = WriterState.OpenTag;
                            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;
                            if (node.pubID && node.sysID) chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                            else if (node.sysID) chunk += ' SYSTEM "' + node.sysID + '"';
                            if (node.children) {
                                chunk += ' [';
                                this.writerOptions.state = WriterState.InsideTag;
                            } else {
                                this.writerOptions.state = WriterState.CloseTag;
                                chunk += '>';
                            }
                            chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
                        }
                        this.onData(chunk, this.currentLevel);
                        return node.isOpen = true;
                    }
                };
                XMLDocumentCB.prototype.closeNode = function(node) {
                    var chunk;
                    if (!node.isClosed) {
                        chunk = '';
                        this.writerOptions.state = WriterState.CloseTag;
                        chunk = node.type === NodeType.Element ? this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel) : this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
                        this.writerOptions.state = WriterState.None;
                        this.onData(chunk, this.currentLevel);
                        return node.isClosed = true;
                    }
                };
                XMLDocumentCB.prototype.onData = function(chunk, level) {
                    this.documentStarted = true;
                    return this.onDataCallback(chunk, level + 1);
                };
                XMLDocumentCB.prototype.onEnd = function() {
                    this.documentCompleted = true;
                    return this.onEndCallback();
                };
                XMLDocumentCB.prototype.debugInfo = function(name) {
                    if (null == name) return "";
                    return "node: <" + name + ">";
                };
                XMLDocumentCB.prototype.ele = function() {
                    return this.element.apply(this, arguments);
                };
                XMLDocumentCB.prototype.nod = function(name, attributes, text) {
                    return this.node(name, attributes, text);
                };
                XMLDocumentCB.prototype.txt = function(value) {
                    return this.text(value);
                };
                XMLDocumentCB.prototype.dat = function(value) {
                    return this.cdata(value);
                };
                XMLDocumentCB.prototype.com = function(value) {
                    return this.comment(value);
                };
                XMLDocumentCB.prototype.ins = function(target, value) {
                    return this.instruction(target, value);
                };
                XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
                    return this.declaration(version, encoding, standalone);
                };
                XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
                    return this.doctype(root, pubID, sysID);
                };
                XMLDocumentCB.prototype.e = function(name, attributes, text) {
                    return this.element(name, attributes, text);
                };
                XMLDocumentCB.prototype.n = function(name, attributes, text) {
                    return this.node(name, attributes, text);
                };
                XMLDocumentCB.prototype.t = function(value) {
                    return this.text(value);
                };
                XMLDocumentCB.prototype.d = function(value) {
                    return this.cdata(value);
                };
                XMLDocumentCB.prototype.c = function(value) {
                    return this.comment(value);
                };
                XMLDocumentCB.prototype.r = function(value) {
                    return this.raw(value);
                };
                XMLDocumentCB.prototype.i = function(target, value) {
                    return this.instruction(target, value);
                };
                XMLDocumentCB.prototype.att = function() {
                    if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
                    return this.attribute.apply(this, arguments);
                };
                XMLDocumentCB.prototype.a = function() {
                    if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
                    return this.attribute.apply(this, arguments);
                };
                XMLDocumentCB.prototype.ent = function(name, value) {
                    return this.entity(name, value);
                };
                XMLDocumentCB.prototype.pent = function(name, value) {
                    return this.pEntity(name, value);
                };
                XMLDocumentCB.prototype.not = function(name, value) {
                    return this.notation(name, value);
                };
                return XMLDocumentCB;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDummy.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLNode, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            module.exports = function(superClass) {
                extend(XMLDummy, superClass);
                function XMLDummy(parent) {
                    XMLDummy.__super__.constructor.call(this, parent);
                    this.type = NodeType.Dummy;
                }
                XMLDummy.prototype.clone = function() {
                    return Object.create(this);
                };
                XMLDummy.prototype.toString = function(options) {
                    return '';
                };
                return XMLDummy;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLElement.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLAttribute, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            ref = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js"), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLAttribute = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLAttribute.js");
            XMLNamedNodeMap = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");
            module.exports = function(superClass) {
                extend(XMLElement, superClass);
                function XMLElement(parent, name, attributes) {
                    var child, j, len, ref1;
                    XMLElement.__super__.constructor.call(this, parent);
                    if (null == name) throw new Error("Missing element name. " + this.debugInfo());
                    this.name = this.stringify.name(name);
                    this.type = NodeType.Element;
                    this.attribs = {};
                    this.schemaTypeInfo = null;
                    if (null != attributes) this.attribute(attributes);
                    if (parent.type === NodeType.Document) {
                        this.isRoot = true;
                        this.documentObject = parent;
                        parent.rootObject = this;
                        if (parent.children) {
                            ref1 = parent.children;
                            for(j = 0, len = ref1.length; j < len; j++){
                                child = ref1[j];
                                if (child.type === NodeType.DocType) {
                                    child.name = this.name;
                                    break;
                                }
                            }
                        }
                    }
                }
                Object.defineProperty(XMLElement.prototype, 'tagName', {
                    get: function() {
                        return this.name;
                    }
                });
                Object.defineProperty(XMLElement.prototype, 'namespaceURI', {
                    get: function() {
                        return '';
                    }
                });
                Object.defineProperty(XMLElement.prototype, 'prefix', {
                    get: function() {
                        return '';
                    }
                });
                Object.defineProperty(XMLElement.prototype, 'localName', {
                    get: function() {
                        return this.name;
                    }
                });
                Object.defineProperty(XMLElement.prototype, 'id', {
                    get: function() {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    }
                });
                Object.defineProperty(XMLElement.prototype, 'className', {
                    get: function() {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    }
                });
                Object.defineProperty(XMLElement.prototype, 'classList', {
                    get: function() {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    }
                });
                Object.defineProperty(XMLElement.prototype, 'attributes', {
                    get: function() {
                        if (!this.attributeMap || !this.attributeMap.nodes) this.attributeMap = new XMLNamedNodeMap(this.attribs);
                        return this.attributeMap;
                    }
                });
                XMLElement.prototype.clone = function() {
                    var att, attName, clonedSelf, ref1;
                    clonedSelf = Object.create(this);
                    if (clonedSelf.isRoot) clonedSelf.documentObject = null;
                    clonedSelf.attribs = {};
                    ref1 = this.attribs;
                    for(attName in ref1)if (hasProp.call(ref1, attName)) {
                        att = ref1[attName];
                        clonedSelf.attribs[attName] = att.clone();
                    }
                    clonedSelf.children = [];
                    this.children.forEach(function(child) {
                        var clonedChild;
                        clonedChild = child.clone();
                        clonedChild.parent = clonedSelf;
                        return clonedSelf.children.push(clonedChild);
                    });
                    return clonedSelf;
                };
                XMLElement.prototype.attribute = function(name, value) {
                    var attName, attValue;
                    if (null != name) name = getValue(name);
                    if (isObject(name)) {
                        for(attName in name)if (hasProp.call(name, attName)) {
                            attValue = name[attName];
                            this.attribute(attName, attValue);
                        }
                    } else {
                        if (isFunction(value)) value = value.apply();
                        if (this.options.keepNullAttributes && null == value) this.attribs[name] = new XMLAttribute(this, name, "");
                        else if (null != value) this.attribs[name] = new XMLAttribute(this, name, value);
                    }
                    return this;
                };
                XMLElement.prototype.removeAttribute = function(name) {
                    var attName, j, len;
                    if (null == name) throw new Error("Missing attribute name. " + this.debugInfo());
                    name = getValue(name);
                    if (Array.isArray(name)) for(j = 0, len = name.length; j < len; j++){
                        attName = name[j];
                        delete this.attribs[attName];
                    }
                    else delete this.attribs[name];
                    return this;
                };
                XMLElement.prototype.toString = function(options) {
                    return this.options.writer.element(this, this.options.writer.filterOptions(options));
                };
                XMLElement.prototype.att = function(name, value) {
                    return this.attribute(name, value);
                };
                XMLElement.prototype.a = function(name, value) {
                    return this.attribute(name, value);
                };
                XMLElement.prototype.getAttribute = function(name) {
                    if (this.attribs.hasOwnProperty(name)) return this.attribs[name].value;
                    return null;
                };
                XMLElement.prototype.setAttribute = function(name, value) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.getAttributeNode = function(name) {
                    if (this.attribs.hasOwnProperty(name)) return this.attribs[name];
                    return null;
                };
                XMLElement.prototype.setAttributeNode = function(newAttr) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.removeAttributeNode = function(oldAttr) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.getElementsByTagName = function(name) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.hasAttribute = function(name) {
                    return this.attribs.hasOwnProperty(name);
                };
                XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.setIdAttribute = function(name, isId) {
                    if (this.attribs.hasOwnProperty(name)) return this.attribs[name].isId;
                    return isId;
                };
                XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.getElementsByTagName = function(tagname) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.getElementsByClassName = function(classNames) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLElement.prototype.isEqualNode = function(node) {
                    var i, j, ref1;
                    if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
                    if (node.namespaceURI !== this.namespaceURI) return false;
                    if (node.prefix !== this.prefix) return false;
                    if (node.localName !== this.localName) return false;
                    if (node.attribs.length !== this.attribs.length) return false;
                    for(i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j)if (!this.attribs[i].isEqualNode(node.attribs[i])) return false;
                    return true;
                };
                return XMLElement;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js" (module) {
        (function() {
            module.exports = function() {
                function XMLNamedNodeMap(nodes) {
                    this.nodes = nodes;
                }
                Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {
                    get: function() {
                        return Object.keys(this.nodes).length || 0;
                    }
                });
                XMLNamedNodeMap.prototype.clone = function() {
                    return this.nodes = null;
                };
                XMLNamedNodeMap.prototype.getNamedItem = function(name) {
                    return this.nodes[name];
                };
                XMLNamedNodeMap.prototype.setNamedItem = function(node) {
                    var oldNode;
                    oldNode = this.nodes[node.nodeName];
                    this.nodes[node.nodeName] = node;
                    return oldNode || null;
                };
                XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
                    var oldNode;
                    oldNode = this.nodes[name];
                    delete this.nodes[name];
                    return oldNode || null;
                };
                XMLNamedNodeMap.prototype.item = function(index) {
                    return this.nodes[Object.keys(this.nodes)[index]] || null;
                };
                XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
                    throw new Error("This DOM method is not implemented.");
                };
                XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
                    throw new Error("This DOM method is not implemented.");
                };
                XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
                    throw new Error("This DOM method is not implemented.");
                };
                return XMLNamedNodeMap;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
            ref1 = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js"), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
            XMLElement = null;
            XMLCData = null;
            XMLComment = null;
            XMLDeclaration = null;
            XMLDocType = null;
            XMLRaw = null;
            XMLText = null;
            XMLProcessingInstruction = null;
            XMLDummy = null;
            NodeType = null;
            XMLNodeList = null;
            DocumentPosition = null;
            module.exports = function() {
                function XMLNode(parent1) {
                    this.parent = parent1;
                    if (this.parent) {
                        this.options = this.parent.options;
                        this.stringify = this.parent.stringify;
                    }
                    this.value = null;
                    this.children = [];
                    this.baseURI = null;
                    if (!XMLElement) {
                        XMLElement = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLElement.js");
                        XMLCData = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCData.js");
                        XMLComment = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLComment.js");
                        XMLDeclaration = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDeclaration.js");
                        XMLDocType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocType.js");
                        XMLRaw = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLRaw.js");
                        XMLText = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLText.js");
                        XMLProcessingInstruction = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
                        XMLDummy = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDummy.js");
                        NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
                        XMLNodeList = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNodeList.js");
                        __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");
                        DocumentPosition = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/DocumentPosition.js");
                    }
                }
                Object.defineProperty(XMLNode.prototype, 'nodeName', {
                    get: function() {
                        return this.name;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'nodeType', {
                    get: function() {
                        return this.type;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'nodeValue', {
                    get: function() {
                        return this.value;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'parentNode', {
                    get: function() {
                        return this.parent;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'childNodes', {
                    get: function() {
                        if (!this.childNodeList || !this.childNodeList.nodes) this.childNodeList = new XMLNodeList(this.children);
                        return this.childNodeList;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'firstChild', {
                    get: function() {
                        return this.children[0] || null;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'lastChild', {
                    get: function() {
                        return this.children[this.children.length - 1] || null;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'previousSibling', {
                    get: function() {
                        var i;
                        i = this.parent.children.indexOf(this);
                        return this.parent.children[i - 1] || null;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'nextSibling', {
                    get: function() {
                        var i;
                        i = this.parent.children.indexOf(this);
                        return this.parent.children[i + 1] || null;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'ownerDocument', {
                    get: function() {
                        return this.document() || null;
                    }
                });
                Object.defineProperty(XMLNode.prototype, 'textContent', {
                    get: function() {
                        var child, j, len, ref2, str;
                        if (this.nodeType !== NodeType.Element && this.nodeType !== NodeType.DocumentFragment) return null;
                        str = '';
                        ref2 = this.children;
                        for(j = 0, len = ref2.length; j < len; j++){
                            child = ref2[j];
                            if (child.textContent) str += child.textContent;
                        }
                        return str;
                    },
                    set: function(value) {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    }
                });
                XMLNode.prototype.setParent = function(parent) {
                    var child, j, len, ref2, results;
                    this.parent = parent;
                    if (parent) {
                        this.options = parent.options;
                        this.stringify = parent.stringify;
                    }
                    ref2 = this.children;
                    results = [];
                    for(j = 0, len = ref2.length; j < len; j++){
                        child = ref2[j];
                        results.push(child.setParent(this));
                    }
                    return results;
                };
                XMLNode.prototype.element = function(name, attributes, text) {
                    var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
                    lastChild = null;
                    if (null === attributes && null == text) ref2 = [
                        {},
                        null
                    ], attributes = ref2[0], text = ref2[1];
                    if (null == attributes) attributes = {};
                    attributes = getValue(attributes);
                    if (!isObject(attributes)) ref3 = [
                        attributes,
                        text
                    ], text = ref3[0], attributes = ref3[1];
                    if (null != name) name = getValue(name);
                    if (Array.isArray(name)) for(j = 0, len = name.length; j < len; j++){
                        item = name[j];
                        lastChild = this.element(item);
                    }
                    else if (isFunction(name)) lastChild = this.element(name.apply());
                    else if (isObject(name)) {
                        for(key in name)if (hasProp.call(name, key)) {
                            val = name[key];
                            if (isFunction(val)) val = val.apply();
                            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && 0 === key.indexOf(this.stringify.convertAttKey)) lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                            else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) lastChild = this.dummy();
                            else if (isObject(val) && isEmpty(val)) lastChild = this.element(key);
                            else if (this.options.keepNullNodes || null != val) if (!this.options.separateArrayItems && Array.isArray(val)) for(k = 0, len1 = val.length; k < len1; k++){
                                item = val[k];
                                childNode = {};
                                childNode[key] = item;
                                lastChild = this.element(childNode);
                            }
                            else if (isObject(val)) if (!this.options.ignoreDecorators && this.stringify.convertTextKey && 0 === key.indexOf(this.stringify.convertTextKey)) lastChild = this.element(val);
                            else {
                                lastChild = this.element(key);
                                lastChild.element(val);
                            }
                            else lastChild = this.element(key, val);
                            else lastChild = this.dummy();
                        }
                    } else lastChild = this.options.keepNullNodes || null !== text ? !this.options.ignoreDecorators && this.stringify.convertTextKey && 0 === name.indexOf(this.stringify.convertTextKey) ? this.text(text) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && 0 === name.indexOf(this.stringify.convertCDataKey) ? this.cdata(text) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && 0 === name.indexOf(this.stringify.convertCommentKey) ? this.comment(text) : !this.options.ignoreDecorators && this.stringify.convertRawKey && 0 === name.indexOf(this.stringify.convertRawKey) ? this.raw(text) : !this.options.ignoreDecorators && this.stringify.convertPIKey && 0 === name.indexOf(this.stringify.convertPIKey) ? this.instruction(name.substr(this.stringify.convertPIKey.length), text) : this.node(name, attributes, text) : this.dummy();
                    if (null == lastChild) throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
                    return lastChild;
                };
                XMLNode.prototype.insertBefore = function(name, attributes, text) {
                    var child, i, newChild, refChild, removed;
                    if (null != name ? name.type : void 0) {
                        newChild = name;
                        refChild = attributes;
                        newChild.setParent(this);
                        if (refChild) {
                            i = children.indexOf(refChild);
                            removed = children.splice(i);
                            children.push(newChild);
                            Array.prototype.push.apply(children, removed);
                        } else children.push(newChild);
                        return newChild;
                    }
                    if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                    i = this.parent.children.indexOf(this);
                    removed = this.parent.children.splice(i);
                    child = this.parent.element(name, attributes, text);
                    Array.prototype.push.apply(this.parent.children, removed);
                    return child;
                };
                XMLNode.prototype.insertAfter = function(name, attributes, text) {
                    var child, i, removed;
                    if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                    i = this.parent.children.indexOf(this);
                    removed = this.parent.children.splice(i + 1);
                    child = this.parent.element(name, attributes, text);
                    Array.prototype.push.apply(this.parent.children, removed);
                    return child;
                };
                XMLNode.prototype.remove = function() {
                    var i;
                    if (this.isRoot) throw new Error("Cannot remove the root element. " + this.debugInfo());
                    i = this.parent.children.indexOf(this);
                    [].splice.apply(this.parent.children, [
                        i,
                        i - i + 1
                    ].concat([]));
                    return this.parent;
                };
                XMLNode.prototype.node = function(name, attributes, text) {
                    var child, ref2;
                    if (null != name) name = getValue(name);
                    attributes || (attributes = {});
                    attributes = getValue(attributes);
                    if (!isObject(attributes)) ref2 = [
                        attributes,
                        text
                    ], text = ref2[0], attributes = ref2[1];
                    child = new XMLElement(this, name, attributes);
                    if (null != text) child.text(text);
                    this.children.push(child);
                    return child;
                };
                XMLNode.prototype.text = function(value) {
                    var child;
                    if (isObject(value)) this.element(value);
                    child = new XMLText(this, value);
                    this.children.push(child);
                    return this;
                };
                XMLNode.prototype.cdata = function(value) {
                    var child;
                    child = new XMLCData(this, value);
                    this.children.push(child);
                    return this;
                };
                XMLNode.prototype.comment = function(value) {
                    var child;
                    child = new XMLComment(this, value);
                    this.children.push(child);
                    return this;
                };
                XMLNode.prototype.commentBefore = function(value) {
                    var i, removed;
                    i = this.parent.children.indexOf(this);
                    removed = this.parent.children.splice(i);
                    this.parent.comment(value);
                    Array.prototype.push.apply(this.parent.children, removed);
                    return this;
                };
                XMLNode.prototype.commentAfter = function(value) {
                    var i, removed;
                    i = this.parent.children.indexOf(this);
                    removed = this.parent.children.splice(i + 1);
                    this.parent.comment(value);
                    Array.prototype.push.apply(this.parent.children, removed);
                    return this;
                };
                XMLNode.prototype.raw = function(value) {
                    var child;
                    child = new XMLRaw(this, value);
                    this.children.push(child);
                    return this;
                };
                XMLNode.prototype.dummy = function() {
                    var child;
                    child = new XMLDummy(this);
                    return child;
                };
                XMLNode.prototype.instruction = function(target, value) {
                    var insTarget, insValue, instruction, j, len;
                    if (null != target) target = getValue(target);
                    if (null != value) value = getValue(value);
                    if (Array.isArray(target)) for(j = 0, len = target.length; j < len; j++){
                        insTarget = target[j];
                        this.instruction(insTarget);
                    }
                    else if (isObject(target)) {
                        for(insTarget in target)if (hasProp.call(target, insTarget)) {
                            insValue = target[insTarget];
                            this.instruction(insTarget, insValue);
                        }
                    } else {
                        if (isFunction(value)) value = value.apply();
                        instruction = new XMLProcessingInstruction(this, target, value);
                        this.children.push(instruction);
                    }
                    return this;
                };
                XMLNode.prototype.instructionBefore = function(target, value) {
                    var i, removed;
                    i = this.parent.children.indexOf(this);
                    removed = this.parent.children.splice(i);
                    this.parent.instruction(target, value);
                    Array.prototype.push.apply(this.parent.children, removed);
                    return this;
                };
                XMLNode.prototype.instructionAfter = function(target, value) {
                    var i, removed;
                    i = this.parent.children.indexOf(this);
                    removed = this.parent.children.splice(i + 1);
                    this.parent.instruction(target, value);
                    Array.prototype.push.apply(this.parent.children, removed);
                    return this;
                };
                XMLNode.prototype.declaration = function(version, encoding, standalone) {
                    var doc, xmldec;
                    doc = this.document();
                    xmldec = new XMLDeclaration(doc, version, encoding, standalone);
                    if (0 === doc.children.length) doc.children.unshift(xmldec);
                    else if (doc.children[0].type === NodeType.Declaration) doc.children[0] = xmldec;
                    else doc.children.unshift(xmldec);
                    return doc.root() || doc;
                };
                XMLNode.prototype.dtd = function(pubID, sysID) {
                    var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
                    doc = this.document();
                    doctype = new XMLDocType(doc, pubID, sysID);
                    ref2 = doc.children;
                    for(i = j = 0, len = ref2.length; j < len; i = ++j){
                        child = ref2[i];
                        if (child.type === NodeType.DocType) {
                            doc.children[i] = doctype;
                            return doctype;
                        }
                    }
                    ref3 = doc.children;
                    for(i = k = 0, len1 = ref3.length; k < len1; i = ++k){
                        child = ref3[i];
                        if (child.isRoot) {
                            doc.children.splice(i, 0, doctype);
                            return doctype;
                        }
                    }
                    doc.children.push(doctype);
                    return doctype;
                };
                XMLNode.prototype.up = function() {
                    if (this.isRoot) throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
                    return this.parent;
                };
                XMLNode.prototype.root = function() {
                    var node;
                    node = this;
                    while(node)if (node.type === NodeType.Document) return node.rootObject;
                    else {
                        if (node.isRoot) return node;
                        node = node.parent;
                    }
                };
                XMLNode.prototype.document = function() {
                    var node;
                    node = this;
                    while(node)if (node.type === NodeType.Document) return node;
                    else node = node.parent;
                };
                XMLNode.prototype.end = function(options) {
                    return this.document().end(options);
                };
                XMLNode.prototype.prev = function() {
                    var i;
                    i = this.parent.children.indexOf(this);
                    if (i < 1) throw new Error("Already at the first node. " + this.debugInfo());
                    return this.parent.children[i - 1];
                };
                XMLNode.prototype.next = function() {
                    var i;
                    i = this.parent.children.indexOf(this);
                    if (-1 === i || i === this.parent.children.length - 1) throw new Error("Already at the last node. " + this.debugInfo());
                    return this.parent.children[i + 1];
                };
                XMLNode.prototype.importDocument = function(doc) {
                    var clonedRoot;
                    clonedRoot = doc.root().clone();
                    clonedRoot.parent = this;
                    clonedRoot.isRoot = false;
                    this.children.push(clonedRoot);
                    return this;
                };
                XMLNode.prototype.debugInfo = function(name) {
                    var ref2, ref3;
                    name = name || this.name;
                    if (null == name && !(null != (ref2 = this.parent) ? ref2.name : void 0)) return "";
                    if (null == name) return "parent: <" + this.parent.name + ">";
                    if (!(null != (ref3 = this.parent) ? ref3.name : void 0)) return "node: <" + name + ">";
                    return "node: <" + name + ">, parent: <" + this.parent.name + ">";
                };
                XMLNode.prototype.ele = function(name, attributes, text) {
                    return this.element(name, attributes, text);
                };
                XMLNode.prototype.nod = function(name, attributes, text) {
                    return this.node(name, attributes, text);
                };
                XMLNode.prototype.txt = function(value) {
                    return this.text(value);
                };
                XMLNode.prototype.dat = function(value) {
                    return this.cdata(value);
                };
                XMLNode.prototype.com = function(value) {
                    return this.comment(value);
                };
                XMLNode.prototype.ins = function(target, value) {
                    return this.instruction(target, value);
                };
                XMLNode.prototype.doc = function() {
                    return this.document();
                };
                XMLNode.prototype.dec = function(version, encoding, standalone) {
                    return this.declaration(version, encoding, standalone);
                };
                XMLNode.prototype.e = function(name, attributes, text) {
                    return this.element(name, attributes, text);
                };
                XMLNode.prototype.n = function(name, attributes, text) {
                    return this.node(name, attributes, text);
                };
                XMLNode.prototype.t = function(value) {
                    return this.text(value);
                };
                XMLNode.prototype.d = function(value) {
                    return this.cdata(value);
                };
                XMLNode.prototype.c = function(value) {
                    return this.comment(value);
                };
                XMLNode.prototype.r = function(value) {
                    return this.raw(value);
                };
                XMLNode.prototype.i = function(target, value) {
                    return this.instruction(target, value);
                };
                XMLNode.prototype.u = function() {
                    return this.up();
                };
                XMLNode.prototype.importXMLBuilder = function(doc) {
                    return this.importDocument(doc);
                };
                XMLNode.prototype.replaceChild = function(newChild, oldChild) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.removeChild = function(oldChild) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.appendChild = function(newChild) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.hasChildNodes = function() {
                    return 0 !== this.children.length;
                };
                XMLNode.prototype.cloneNode = function(deep) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.normalize = function() {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.isSupported = function(feature, version) {
                    return true;
                };
                XMLNode.prototype.hasAttributes = function() {
                    return 0 !== this.attribs.length;
                };
                XMLNode.prototype.compareDocumentPosition = function(other) {
                    var ref, res;
                    ref = this;
                    if (ref === other) return 0;
                    if (this.document() !== other.document()) {
                        res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
                        if (Math.random() < 0.5) res |= DocumentPosition.Preceding;
                        else res |= DocumentPosition.Following;
                        return res;
                    }
                    if (ref.isAncestor(other)) return DocumentPosition.Contains | DocumentPosition.Preceding;
                    if (ref.isDescendant(other)) return DocumentPosition.Contains | DocumentPosition.Following;
                    if (ref.isPreceding(other)) return DocumentPosition.Preceding;
                    else return DocumentPosition.Following;
                };
                XMLNode.prototype.isSameNode = function(other) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.lookupPrefix = function(namespaceURI) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.lookupNamespaceURI = function(prefix) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.isEqualNode = function(node) {
                    var i, j, ref2;
                    if (node.nodeType !== this.nodeType) return false;
                    if (node.children.length !== this.children.length) return false;
                    for(i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j)if (!this.children[i].isEqualNode(node.children[i])) return false;
                    return true;
                };
                XMLNode.prototype.getFeature = function(feature, version) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.setUserData = function(key, data, handler) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.getUserData = function(key) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLNode.prototype.contains = function(other) {
                    if (!other) return false;
                    return other === this || this.isDescendant(other);
                };
                XMLNode.prototype.isDescendant = function(node) {
                    var child, isDescendantChild, j, len, ref2;
                    ref2 = this.children;
                    for(j = 0, len = ref2.length; j < len; j++){
                        child = ref2[j];
                        if (node === child) return true;
                        isDescendantChild = child.isDescendant(node);
                        if (isDescendantChild) return true;
                    }
                    return false;
                };
                XMLNode.prototype.isAncestor = function(node) {
                    return node.isDescendant(this);
                };
                XMLNode.prototype.isPreceding = function(node) {
                    var nodePos, thisPos;
                    nodePos = this.treePosition(node);
                    thisPos = this.treePosition(this);
                    if (-1 === nodePos || -1 === thisPos) return false;
                    return nodePos < thisPos;
                };
                XMLNode.prototype.isFollowing = function(node) {
                    var nodePos, thisPos;
                    nodePos = this.treePosition(node);
                    thisPos = this.treePosition(this);
                    if (-1 === nodePos || -1 === thisPos) return false;
                    return nodePos > thisPos;
                };
                XMLNode.prototype.treePosition = function(node) {
                    var found, pos;
                    pos = 0;
                    found = false;
                    this.foreachTreeNode(this.document(), function(childNode) {
                        pos++;
                        if (!found && childNode === node) return found = true;
                    });
                    if (found) return pos;
                    return -1;
                };
                XMLNode.prototype.foreachTreeNode = function(node, func) {
                    var child, j, len, ref2, res;
                    node || (node = this.document());
                    ref2 = node.children;
                    for(j = 0, len = ref2.length; j < len; j++){
                        child = ref2[j];
                        if (res = func(child)) return res;
                        res = this.foreachTreeNode(child, func);
                        if (res) return res;
                    }
                };
                return XMLNode;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNodeList.js" (module) {
        (function() {
            module.exports = function() {
                function XMLNodeList(nodes) {
                    this.nodes = nodes;
                }
                Object.defineProperty(XMLNodeList.prototype, 'length', {
                    get: function() {
                        return this.nodes.length || 0;
                    }
                });
                XMLNodeList.prototype.clone = function() {
                    return this.nodes = null;
                };
                XMLNodeList.prototype.item = function(index) {
                    return this.nodes[index] || null;
                };
                return XMLNodeList;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLCharacterData, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLCharacterData = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCharacterData.js");
            module.exports = function(superClass) {
                extend(XMLProcessingInstruction, superClass);
                function XMLProcessingInstruction(parent, target, value) {
                    XMLProcessingInstruction.__super__.constructor.call(this, parent);
                    if (null == target) throw new Error("Missing instruction target. " + this.debugInfo());
                    this.type = NodeType.ProcessingInstruction;
                    this.target = this.stringify.insTarget(target);
                    this.name = this.target;
                    if (value) this.value = this.stringify.insValue(value);
                }
                XMLProcessingInstruction.prototype.clone = function() {
                    return Object.create(this);
                };
                XMLProcessingInstruction.prototype.toString = function(options) {
                    return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
                };
                XMLProcessingInstruction.prototype.isEqualNode = function(node) {
                    if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
                    if (node.target !== this.target) return false;
                    return true;
                };
                return XMLProcessingInstruction;
            }(XMLCharacterData);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLRaw.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLNode, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLNode = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLNode.js");
            module.exports = function(superClass) {
                extend(XMLRaw, superClass);
                function XMLRaw(parent, text) {
                    XMLRaw.__super__.constructor.call(this, parent);
                    if (null == text) throw new Error("Missing raw text. " + this.debugInfo());
                    this.type = NodeType.Raw;
                    this.value = this.stringify.raw(text);
                }
                XMLRaw.prototype.clone = function() {
                    return Object.create(this);
                };
                XMLRaw.prototype.toString = function(options) {
                    return this.options.writer.raw(this, this.options.writer.filterOptions(options));
                };
                return XMLRaw;
            }(XMLNode);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStreamWriter.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, WriterState, XMLWriterBase, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLWriterBase = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLWriterBase.js");
            WriterState = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/WriterState.js");
            module.exports = function(superClass) {
                extend(XMLStreamWriter, superClass);
                function XMLStreamWriter(stream, options) {
                    this.stream = stream;
                    XMLStreamWriter.__super__.constructor.call(this, options);
                }
                XMLStreamWriter.prototype.endline = function(node, options, level) {
                    if (node.isLastRootNode && options.state === WriterState.CloseTag) return '';
                    return XMLStreamWriter.__super__.endline.call(this, node, options, level);
                };
                XMLStreamWriter.prototype.document = function(doc, options) {
                    var child, i, j, k, len, len1, ref, ref1, results;
                    ref = doc.children;
                    for(i = j = 0, len = ref.length; j < len; i = ++j){
                        child = ref[i];
                        child.isLastRootNode = i === doc.children.length - 1;
                    }
                    options = this.filterOptions(options);
                    ref1 = doc.children;
                    results = [];
                    for(k = 0, len1 = ref1.length; k < len1; k++){
                        child = ref1[k];
                        results.push(this.writeChildNode(child, options, 0));
                    }
                    return results;
                };
                XMLStreamWriter.prototype.attribute = function(att, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
                };
                XMLStreamWriter.prototype.cdata = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
                };
                XMLStreamWriter.prototype.comment = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
                };
                XMLStreamWriter.prototype.declaration = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
                };
                XMLStreamWriter.prototype.docType = function(node, options, level) {
                    var child, j, len, ref;
                    level || (level = 0);
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    this.stream.write(this.indent(node, options, level));
                    this.stream.write('<!DOCTYPE ' + node.root().name);
                    if (node.pubID && node.sysID) this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
                    else if (node.sysID) this.stream.write(' SYSTEM "' + node.sysID + '"');
                    if (node.children.length > 0) {
                        this.stream.write(' [');
                        this.stream.write(this.endline(node, options, level));
                        options.state = WriterState.InsideTag;
                        ref = node.children;
                        for(j = 0, len = ref.length; j < len; j++){
                            child = ref[j];
                            this.writeChildNode(child, options, level + 1);
                        }
                        options.state = WriterState.CloseTag;
                        this.stream.write(']');
                    }
                    options.state = WriterState.CloseTag;
                    this.stream.write(options.spaceBeforeSlash + '>');
                    this.stream.write(this.endline(node, options, level));
                    options.state = WriterState.None;
                    return this.closeNode(node, options, level);
                };
                XMLStreamWriter.prototype.element = function(node, options, level) {
                    var att, child, childNodeCount, firstChildNode, j, len, name, ref, ref1;
                    level || (level = 0);
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    this.stream.write(this.indent(node, options, level) + '<' + node.name);
                    ref = node.attribs;
                    for(name in ref)if (hasProp.call(ref, name)) {
                        att = ref[name];
                        this.attribute(att, options, level);
                    }
                    childNodeCount = node.children.length;
                    firstChildNode = 0 === childNodeCount ? null : node.children[0];
                    if (0 === childNodeCount || node.children.every(function(e) {
                        return (e.type === NodeType.Text || e.type === NodeType.Raw) && '' === e.value;
                    })) if (options.allowEmpty) {
                        this.stream.write('>');
                        options.state = WriterState.CloseTag;
                        this.stream.write('</' + node.name + '>');
                    } else {
                        options.state = WriterState.CloseTag;
                        this.stream.write(options.spaceBeforeSlash + '/>');
                    }
                    else if (options.pretty && 1 === childNodeCount && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && null != firstChildNode.value) {
                        this.stream.write('>');
                        options.state = WriterState.InsideTag;
                        options.suppressPrettyCount++;
                        this.writeChildNode(firstChildNode, options, level + 1);
                        options.suppressPrettyCount--;
                        options.state = WriterState.CloseTag;
                        this.stream.write('</' + node.name + '>');
                    } else {
                        this.stream.write('>' + this.endline(node, options, level));
                        options.state = WriterState.InsideTag;
                        ref1 = node.children;
                        for(j = 0, len = ref1.length; j < len; j++){
                            child = ref1[j];
                            this.writeChildNode(child, options, level + 1);
                        }
                        options.state = WriterState.CloseTag;
                        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
                    }
                    this.stream.write(this.endline(node, options, level));
                    options.state = WriterState.None;
                    return this.closeNode(node, options, level);
                };
                XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
                };
                XMLStreamWriter.prototype.raw = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
                };
                XMLStreamWriter.prototype.text = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
                };
                XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
                };
                XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
                };
                XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
                };
                XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
                    return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
                };
                return XMLStreamWriter;
            }(XMLWriterBase);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringWriter.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var XMLWriterBase, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            XMLWriterBase = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLWriterBase.js");
            module.exports = function(superClass) {
                extend(XMLStringWriter, superClass);
                function XMLStringWriter(options) {
                    XMLStringWriter.__super__.constructor.call(this, options);
                }
                XMLStringWriter.prototype.document = function(doc, options) {
                    var child, i, len, r, ref;
                    options = this.filterOptions(options);
                    r = '';
                    ref = doc.children;
                    for(i = 0, len = ref.length; i < len; i++){
                        child = ref[i];
                        r += this.writeChildNode(child, options, 0);
                    }
                    if (options.pretty && r.slice(-options.newline.length) === options.newline) r = r.slice(0, -options.newline.length);
                    return r;
                };
                return XMLStringWriter;
            }(XMLWriterBase);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringifier.js" (module) {
        (function() {
            var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            }, hasProp = {}.hasOwnProperty;
            module.exports = function() {
                function XMLStringifier(options) {
                    this.assertLegalName = bind(this.assertLegalName, this);
                    this.assertLegalChar = bind(this.assertLegalChar, this);
                    var key, ref, value;
                    options || (options = {});
                    this.options = options;
                    if (!this.options.version) this.options.version = '1.0';
                    ref = options.stringify || {};
                    for(key in ref)if (hasProp.call(ref, key)) {
                        value = ref[key];
                        this[key] = value;
                    }
                }
                XMLStringifier.prototype.name = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalName('' + val || '');
                };
                XMLStringifier.prototype.text = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar(this.textEscape('' + val || ''));
                };
                XMLStringifier.prototype.cdata = function(val) {
                    if (this.options.noValidation) return val;
                    val = '' + val || '';
                    val = val.replace(']]>', ']]]]><![CDATA[>');
                    return this.assertLegalChar(val);
                };
                XMLStringifier.prototype.comment = function(val) {
                    if (this.options.noValidation) return val;
                    val = '' + val || '';
                    if (val.match(/--/)) throw new Error("Comment text cannot contain double-hypen: " + val);
                    return this.assertLegalChar(val);
                };
                XMLStringifier.prototype.raw = function(val) {
                    if (this.options.noValidation) return val;
                    return '' + val || '';
                };
                XMLStringifier.prototype.attValue = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar(this.attEscape(val = '' + val || ''));
                };
                XMLStringifier.prototype.insTarget = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar('' + val || '');
                };
                XMLStringifier.prototype.insValue = function(val) {
                    if (this.options.noValidation) return val;
                    val = '' + val || '';
                    if (val.match(/\?>/)) throw new Error("Invalid processing instruction value: " + val);
                    return this.assertLegalChar(val);
                };
                XMLStringifier.prototype.xmlVersion = function(val) {
                    if (this.options.noValidation) return val;
                    val = '' + val || '';
                    if (!val.match(/1\.[0-9]+/)) throw new Error("Invalid version number: " + val);
                    return val;
                };
                XMLStringifier.prototype.xmlEncoding = function(val) {
                    if (this.options.noValidation) return val;
                    val = '' + val || '';
                    if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) throw new Error("Invalid encoding: " + val);
                    return this.assertLegalChar(val);
                };
                XMLStringifier.prototype.xmlStandalone = function(val) {
                    if (this.options.noValidation) return val;
                    if (val) return "yes";
                    return "no";
                };
                XMLStringifier.prototype.dtdPubID = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar('' + val || '');
                };
                XMLStringifier.prototype.dtdSysID = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar('' + val || '');
                };
                XMLStringifier.prototype.dtdElementValue = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar('' + val || '');
                };
                XMLStringifier.prototype.dtdAttType = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar('' + val || '');
                };
                XMLStringifier.prototype.dtdAttDefault = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar('' + val || '');
                };
                XMLStringifier.prototype.dtdEntityValue = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar('' + val || '');
                };
                XMLStringifier.prototype.dtdNData = function(val) {
                    if (this.options.noValidation) return val;
                    return this.assertLegalChar('' + val || '');
                };
                XMLStringifier.prototype.convertAttKey = '@';
                XMLStringifier.prototype.convertPIKey = '?';
                XMLStringifier.prototype.convertTextKey = '#text';
                XMLStringifier.prototype.convertCDataKey = '#cdata';
                XMLStringifier.prototype.convertCommentKey = '#comment';
                XMLStringifier.prototype.convertRawKey = '#raw';
                XMLStringifier.prototype.assertLegalChar = function(str) {
                    var regex, res;
                    if (this.options.noValidation) return str;
                    regex = '';
                    if ('1.0' === this.options.version) {
                        regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                        if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
                    } else if ('1.1' === this.options.version) {
                        regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                        if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
                    }
                    return str;
                };
                XMLStringifier.prototype.assertLegalName = function(str) {
                    var regex;
                    if (this.options.noValidation) return str;
                    this.assertLegalChar(str);
                    regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
                    if (!str.match(regex)) throw new Error("Invalid character in name");
                    return str;
                };
                XMLStringifier.prototype.textEscape = function(str) {
                    var ampregex;
                    if (this.options.noValidation) return str;
                    ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
                    return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
                };
                XMLStringifier.prototype.attEscape = function(str) {
                    var ampregex;
                    if (this.options.noValidation) return str;
                    ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
                    return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
                };
                return XMLStringifier;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLText.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, XMLCharacterData, extend = function(child, parent) {
                for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            }, hasProp = {}.hasOwnProperty;
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            XMLCharacterData = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCharacterData.js");
            module.exports = function(superClass) {
                extend(XMLText, superClass);
                function XMLText(parent, text) {
                    XMLText.__super__.constructor.call(this, parent);
                    if (null == text) throw new Error("Missing element text. " + this.debugInfo());
                    this.name = "#text";
                    this.type = NodeType.Text;
                    this.value = this.stringify.text(text);
                }
                Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {
                    get: function() {
                        throw new Error("This DOM method is not implemented." + this.debugInfo());
                    }
                });
                Object.defineProperty(XMLText.prototype, 'wholeText', {
                    get: function() {
                        var next, prev, str;
                        str = '';
                        prev = this.previousSibling;
                        while(prev){
                            str = prev.data + str;
                            prev = prev.previousSibling;
                        }
                        str += this.data;
                        next = this.nextSibling;
                        while(next){
                            str += next.data;
                            next = next.nextSibling;
                        }
                        return str;
                    }
                });
                XMLText.prototype.clone = function() {
                    return Object.create(this);
                };
                XMLText.prototype.toString = function(options) {
                    return this.options.writer.text(this, this.options.writer.filterOptions(options));
                };
                XMLText.prototype.splitText = function(offset) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                XMLText.prototype.replaceWholeText = function(content) {
                    throw new Error("This DOM method is not implemented." + this.debugInfo());
                };
                return XMLText;
            }(XMLCharacterData);
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLWriterBase.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, WriterState, assign, hasProp = {}.hasOwnProperty;
            assign = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js").assign;
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDeclaration.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocType.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLCData.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLComment.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLElement.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLRaw.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLText.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDummy.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDAttList.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDElement.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDEntity.js");
            __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDTDNotation.js");
            WriterState = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/WriterState.js");
            module.exports = function() {
                function XMLWriterBase(options) {
                    var key, ref, value;
                    options || (options = {});
                    this.options = options;
                    ref = options.writer || {};
                    for(key in ref)if (hasProp.call(ref, key)) {
                        value = ref[key];
                        this["_" + key] = this[key];
                        this[key] = value;
                    }
                }
                XMLWriterBase.prototype.filterOptions = function(options) {
                    var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
                    options || (options = {});
                    options = assign({}, this.options, options);
                    filteredOptions = {
                        writer: this
                    };
                    filteredOptions.pretty = options.pretty || false;
                    filteredOptions.allowEmpty = options.allowEmpty || false;
                    filteredOptions.indent = null != (ref = options.indent) ? ref : '  ';
                    filteredOptions.newline = null != (ref1 = options.newline) ? ref1 : '\n';
                    filteredOptions.offset = null != (ref2 = options.offset) ? ref2 : 0;
                    filteredOptions.dontPrettyTextNodes = null != (ref3 = null != (ref4 = options.dontPrettyTextNodes) ? ref4 : options.dontprettytextnodes) ? ref3 : 0;
                    filteredOptions.spaceBeforeSlash = null != (ref5 = null != (ref6 = options.spaceBeforeSlash) ? ref6 : options.spacebeforeslash) ? ref5 : '';
                    if (true === filteredOptions.spaceBeforeSlash) filteredOptions.spaceBeforeSlash = ' ';
                    filteredOptions.suppressPrettyCount = 0;
                    filteredOptions.user = {};
                    filteredOptions.state = WriterState.None;
                    return filteredOptions;
                };
                XMLWriterBase.prototype.indent = function(node, options, level) {
                    var indentLevel;
                    if (!options.pretty || options.suppressPrettyCount) ;
                    else if (options.pretty) {
                        indentLevel = (level || 0) + options.offset + 1;
                        if (indentLevel > 0) return new Array(indentLevel).join(options.indent);
                    }
                    return '';
                };
                XMLWriterBase.prototype.endline = function(node, options, level) {
                    if (!options.pretty || options.suppressPrettyCount) return '';
                    return options.newline;
                };
                XMLWriterBase.prototype.attribute = function(att, options, level) {
                    var r;
                    this.openAttribute(att, options, level);
                    r = ' ' + att.name + '="' + att.value + '"';
                    this.closeAttribute(att, options, level);
                    return r;
                };
                XMLWriterBase.prototype.cdata = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level) + '<![CDATA[';
                    options.state = WriterState.InsideTag;
                    r += node.value;
                    options.state = WriterState.CloseTag;
                    r += ']]>' + this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.comment = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level) + '<!-- ';
                    options.state = WriterState.InsideTag;
                    r += node.value;
                    options.state = WriterState.CloseTag;
                    r += ' -->' + this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.declaration = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level) + '<?xml';
                    options.state = WriterState.InsideTag;
                    r += ' version="' + node.version + '"';
                    if (null != node.encoding) r += ' encoding="' + node.encoding + '"';
                    if (null != node.standalone) r += ' standalone="' + node.standalone + '"';
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + '?>';
                    r += this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.docType = function(node, options, level) {
                    var child, i, len, r, ref;
                    level || (level = 0);
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level);
                    r += '<!DOCTYPE ' + node.root().name;
                    if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                    else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
                    if (node.children.length > 0) {
                        r += ' [';
                        r += this.endline(node, options, level);
                        options.state = WriterState.InsideTag;
                        ref = node.children;
                        for(i = 0, len = ref.length; i < len; i++){
                            child = ref[i];
                            r += this.writeChildNode(child, options, level + 1);
                        }
                        options.state = WriterState.CloseTag;
                        r += ']';
                    }
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + '>';
                    r += this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.element = function(node, options, level) {
                    var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
                    level || (level = 0);
                    prettySuppressed = false;
                    r = '';
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r += this.indent(node, options, level) + '<' + node.name;
                    ref = node.attribs;
                    for(name in ref)if (hasProp.call(ref, name)) {
                        att = ref[name];
                        r += this.attribute(att, options, level);
                    }
                    childNodeCount = node.children.length;
                    firstChildNode = 0 === childNodeCount ? null : node.children[0];
                    if (0 === childNodeCount || node.children.every(function(e) {
                        return (e.type === NodeType.Text || e.type === NodeType.Raw) && '' === e.value;
                    })) if (options.allowEmpty) {
                        r += '>';
                        options.state = WriterState.CloseTag;
                        r += '</' + node.name + '>' + this.endline(node, options, level);
                    } else {
                        options.state = WriterState.CloseTag;
                        r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
                    }
                    else if (options.pretty && 1 === childNodeCount && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && null != firstChildNode.value) {
                        r += '>';
                        options.state = WriterState.InsideTag;
                        options.suppressPrettyCount++;
                        prettySuppressed = true;
                        r += this.writeChildNode(firstChildNode, options, level + 1);
                        options.suppressPrettyCount--;
                        prettySuppressed = false;
                        options.state = WriterState.CloseTag;
                        r += '</' + node.name + '>' + this.endline(node, options, level);
                    } else {
                        if (options.dontPrettyTextNodes) {
                            ref1 = node.children;
                            for(i = 0, len = ref1.length; i < len; i++){
                                child = ref1[i];
                                if ((child.type === NodeType.Text || child.type === NodeType.Raw) && null != child.value) {
                                    options.suppressPrettyCount++;
                                    prettySuppressed = true;
                                    break;
                                }
                            }
                        }
                        r += '>' + this.endline(node, options, level);
                        options.state = WriterState.InsideTag;
                        ref2 = node.children;
                        for(j = 0, len1 = ref2.length; j < len1; j++){
                            child = ref2[j];
                            r += this.writeChildNode(child, options, level + 1);
                        }
                        options.state = WriterState.CloseTag;
                        r += this.indent(node, options, level) + '</' + node.name + '>';
                        if (prettySuppressed) options.suppressPrettyCount--;
                        r += this.endline(node, options, level);
                        options.state = WriterState.None;
                    }
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
                    switch(node.type){
                        case NodeType.CData:
                            return this.cdata(node, options, level);
                        case NodeType.Comment:
                            return this.comment(node, options, level);
                        case NodeType.Element:
                            return this.element(node, options, level);
                        case NodeType.Raw:
                            return this.raw(node, options, level);
                        case NodeType.Text:
                            return this.text(node, options, level);
                        case NodeType.ProcessingInstruction:
                            return this.processingInstruction(node, options, level);
                        case NodeType.Dummy:
                            return '';
                        case NodeType.Declaration:
                            return this.declaration(node, options, level);
                        case NodeType.DocType:
                            return this.docType(node, options, level);
                        case NodeType.AttributeDeclaration:
                            return this.dtdAttList(node, options, level);
                        case NodeType.ElementDeclaration:
                            return this.dtdElement(node, options, level);
                        case NodeType.EntityDeclaration:
                            return this.dtdEntity(node, options, level);
                        case NodeType.NotationDeclaration:
                            return this.dtdNotation(node, options, level);
                        default:
                            throw new Error("Unknown XML node type: " + node.constructor.name);
                    }
                };
                XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level) + '<?';
                    options.state = WriterState.InsideTag;
                    r += node.target;
                    if (node.value) r += ' ' + node.value;
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + '?>';
                    r += this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.raw = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level);
                    options.state = WriterState.InsideTag;
                    r += node.value;
                    options.state = WriterState.CloseTag;
                    r += this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.text = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level);
                    options.state = WriterState.InsideTag;
                    r += node.value;
                    options.state = WriterState.CloseTag;
                    r += this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level) + '<!ATTLIST';
                    options.state = WriterState.InsideTag;
                    r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
                    if ('#DEFAULT' !== node.defaultValueType) r += ' ' + node.defaultValueType;
                    if (node.defaultValue) r += ' "' + node.defaultValue + '"';
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.dtdElement = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level) + '<!ELEMENT';
                    options.state = WriterState.InsideTag;
                    r += ' ' + node.name + ' ' + node.value;
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level) + '<!ENTITY';
                    options.state = WriterState.InsideTag;
                    if (node.pe) r += ' %';
                    r += ' ' + node.name;
                    if (node.value) r += ' "' + node.value + '"';
                    else {
                        if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                        else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
                        if (node.nData) r += ' NDATA ' + node.nData;
                    }
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
                    var r;
                    this.openNode(node, options, level);
                    options.state = WriterState.OpenTag;
                    r = this.indent(node, options, level) + '<!NOTATION';
                    options.state = WriterState.InsideTag;
                    r += ' ' + node.name;
                    if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                    else if (node.pubID) r += ' PUBLIC "' + node.pubID + '"';
                    else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
                    options.state = WriterState.None;
                    this.closeNode(node, options, level);
                    return r;
                };
                XMLWriterBase.prototype.openNode = function(node, options, level) {};
                XMLWriterBase.prototype.closeNode = function(node, options, level) {};
                XMLWriterBase.prototype.openAttribute = function(att, options, level) {};
                XMLWriterBase.prototype.closeAttribute = function(att, options, level) {};
                return XMLWriterBase;
            }();
        }).call(this);
    },
    "../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/index.js" (module, __unused_rspack_exports, __webpack_require__) {
        (function() {
            var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
            ref = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/Utility.js"), assign = ref.assign, isFunction = ref.isFunction;
            XMLDOMImplementation = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDOMImplementation.js");
            XMLDocument = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocument.js");
            XMLDocumentCB = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLDocumentCB.js");
            XMLStringWriter = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStringWriter.js");
            XMLStreamWriter = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/XMLStreamWriter.js");
            NodeType = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/NodeType.js");
            WriterState = __webpack_require__("../../../node_modules/.pnpm/xmlbuilder@11.0.1/node_modules/xmlbuilder/lib/WriterState.js");
            module.exports.create = function(name, xmldec, doctype, options) {
                var doc, root;
                if (null == name) throw new Error("Root element needs a name.");
                options = assign({}, xmldec, doctype, options);
                doc = new XMLDocument(options);
                root = doc.element(name);
                if (!options.headless) {
                    doc.declaration(options);
                    if (null != options.pubID || null != options.sysID) doc.dtd(options);
                }
                return root;
            };
            module.exports.begin = function(options, onData, onEnd) {
                var ref1;
                if (isFunction(options)) {
                    ref1 = [
                        options,
                        onData
                    ], onData = ref1[0], onEnd = ref1[1];
                    options = {};
                }
                if (onData) return new XMLDocumentCB(options, onData, onEnd);
                return new XMLDocument(options);
            };
            module.exports.stringWriter = function(options) {
                return new XMLStringWriter(options);
            };
            module.exports.streamWriter = function(stream, options) {
                return new XMLStreamWriter(stream, options);
            };
            module.exports.implementation = new XMLDOMImplementation();
            module.exports.nodeType = NodeType;
            module.exports.writerState = WriterState;
        }).call(this);
    },
    assert (module) {
        "use strict";
        module.exports = require("assert");
    },
    async_hooks (module) {
        "use strict";
        module.exports = require("async_hooks");
    },
    buffer (module) {
        "use strict";
        module.exports = require("buffer");
    },
    child_process (module) {
        "use strict";
        module.exports = require("child_process");
    },
    console (module) {
        "use strict";
        module.exports = require("console");
    },
    crypto (module) {
        "use strict";
        module.exports = require("crypto");
    },
    diagnostics_channel (module) {
        "use strict";
        module.exports = require("diagnostics_channel");
    },
    events (module) {
        "use strict";
        module.exports = require("events");
    },
    fs (module) {
        "use strict";
        module.exports = require("fs");
    },
    http (module) {
        "use strict";
        module.exports = require("http");
    },
    http2 (module) {
        "use strict";
        module.exports = require("http2");
    },
    https (module) {
        "use strict";
        module.exports = require("https");
    },
    net (module) {
        "use strict";
        module.exports = require("net");
    },
    "node:buffer" (module) {
        "use strict";
        module.exports = require("node:buffer");
    },
    "node:crypto" (module) {
        "use strict";
        module.exports = require("node:crypto");
    },
    "node:events" (module) {
        "use strict";
        module.exports = require("node:events");
    },
    "node:fs" (module) {
        "use strict";
        module.exports = require("node:fs");
    },
    "node:http" (module) {
        "use strict";
        module.exports = require("node:http");
    },
    "node:net" (module) {
        "use strict";
        module.exports = require("node:net");
    },
    "node:path" (module) {
        "use strict";
        module.exports = require("node:path");
    },
    "node:querystring" (module) {
        "use strict";
        module.exports = require("node:querystring");
    },
    "node:stream" (module) {
        "use strict";
        module.exports = require("node:stream");
    },
    "node:util" (module) {
        "use strict";
        module.exports = require("node:util");
    },
    "node:zlib" (module) {
        "use strict";
        module.exports = require("node:zlib");
    },
    os (module) {
        "use strict";
        module.exports = require("os");
    },
    path (module) {
        "use strict";
        module.exports = require("path");
    },
    perf_hooks (module) {
        "use strict";
        module.exports = require("perf_hooks");
    },
    punycode (module) {
        "use strict";
        module.exports = require("punycode");
    },
    querystring (module) {
        "use strict";
        module.exports = require("querystring");
    },
    stream (module) {
        "use strict";
        module.exports = require("stream");
    },
    "stream/web" (module) {
        "use strict";
        module.exports = require("stream/web");
    },
    string_decoder (module) {
        "use strict";
        module.exports = require("string_decoder");
    },
    timers (module) {
        "use strict";
        module.exports = require("timers");
    },
    tls (module) {
        "use strict";
        module.exports = require("tls");
    },
    tty (module) {
        "use strict";
        module.exports = require("tty");
    },
    url (module) {
        "use strict";
        module.exports = require("url");
    },
    util (module) {
        "use strict";
        module.exports = require("util");
    },
    "util/types" (module) {
        "use strict";
        module.exports = require("util/types");
    },
    worker_threads (module) {
        "use strict";
        module.exports = require("worker_threads");
    },
    zlib (module) {
        "use strict";
        module.exports = require("zlib");
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const WritableStream = __webpack_require__("node:stream").Writable;
        const inherits = __webpack_require__("node:util").inherits;
        const StreamSearch = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js");
        const PartStream = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js");
        const HeaderParser = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js");
        const DASH = 45;
        const B_ONEDASH = Buffer.from('-');
        const B_CRLF = Buffer.from('\r\n');
        const EMPTY_FN = function() {};
        function Dicer(cfg) {
            if (!(this instanceof Dicer)) return new Dicer(cfg);
            WritableStream.call(this, cfg);
            if (!cfg || !cfg.headerFirst && 'string' != typeof cfg.boundary) throw new TypeError('Boundary required');
            if ('string' == typeof cfg.boundary) this.setBoundary(cfg.boundary);
            else this._bparser = void 0;
            this._headerFirst = cfg.headerFirst;
            this._dashes = 0;
            this._parts = 0;
            this._finished = false;
            this._realFinish = false;
            this._isPreamble = true;
            this._justMatched = false;
            this._firstWrite = true;
            this._inHeader = true;
            this._part = void 0;
            this._cb = void 0;
            this._ignoreData = false;
            this._partOpts = {
                highWaterMark: cfg.partHwm
            };
            this._pause = false;
            const self1 = this;
            this._hparser = new HeaderParser(cfg);
            this._hparser.on('header', function(header) {
                self1._inHeader = false;
                self1._part.emit('header', header);
            });
        }
        inherits(Dicer, WritableStream);
        Dicer.prototype.emit = function(ev) {
            if ('finish' !== ev || this._realFinish) WritableStream.prototype.emit.apply(this, arguments);
            else if (!this._finished) {
                const self1 = this;
                process.nextTick(function() {
                    self1.emit('error', new Error('Unexpected end of multipart data'));
                    if (self1._part && !self1._ignoreData) {
                        const type = self1._isPreamble ? 'Preamble' : 'Part';
                        self1._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));
                        self1._part.push(null);
                        process.nextTick(function() {
                            self1._realFinish = true;
                            self1.emit('finish');
                            self1._realFinish = false;
                        });
                        return;
                    }
                    self1._realFinish = true;
                    self1.emit('finish');
                    self1._realFinish = false;
                });
            }
        };
        Dicer.prototype._write = function(data, encoding, cb) {
            if (!this._hparser && !this._bparser) return cb();
            if (this._headerFirst && this._isPreamble) {
                if (!this._part) {
                    this._part = new PartStream(this._partOpts);
                    if (0 !== this.listenerCount('preamble')) this.emit('preamble', this._part);
                    else this._ignore();
                }
                const r = this._hparser.push(data);
                if (!!this._inHeader || void 0 === r || !(r < data.length)) return cb();
                data = data.slice(r);
            }
            if (this._firstWrite) {
                this._bparser.push(B_CRLF);
                this._firstWrite = false;
            }
            this._bparser.push(data);
            if (this._pause) this._cb = cb;
            else cb();
        };
        Dicer.prototype.reset = function() {
            this._part = void 0;
            this._bparser = void 0;
            this._hparser = void 0;
        };
        Dicer.prototype.setBoundary = function(boundary) {
            const self1 = this;
            this._bparser = new StreamSearch('\r\n--' + boundary);
            this._bparser.on('info', function(isMatch, data, start, end) {
                self1._oninfo(isMatch, data, start, end);
            });
        };
        Dicer.prototype._ignore = function() {
            if (this._part && !this._ignoreData) {
                this._ignoreData = true;
                this._part.on('error', EMPTY_FN);
                this._part.resume();
            }
        };
        Dicer.prototype._oninfo = function(isMatch, data, start, end) {
            let buf;
            const self1 = this;
            let i = 0;
            let r;
            let shouldWriteMore = true;
            if (!this._part && this._justMatched && data) {
                while(this._dashes < 2 && start + i < end)if (data[start + i] === DASH) {
                    ++i;
                    ++this._dashes;
                } else {
                    if (this._dashes) buf = B_ONEDASH;
                    this._dashes = 0;
                    break;
                }
                if (2 === this._dashes) {
                    if (start + i < end && 0 !== this.listenerCount('trailer')) this.emit('trailer', data.slice(start + i, end));
                    this.reset();
                    this._finished = true;
                    if (0 === self1._parts) {
                        self1._realFinish = true;
                        self1.emit('finish');
                        self1._realFinish = false;
                    }
                }
                if (this._dashes) return;
            }
            if (this._justMatched) this._justMatched = false;
            if (!this._part) {
                this._part = new PartStream(this._partOpts);
                this._part._read = function(n) {
                    self1._unpause();
                };
                if (this._isPreamble && 0 !== this.listenerCount('preamble')) this.emit('preamble', this._part);
                else if (true !== this._isPreamble && 0 !== this.listenerCount('part')) this.emit('part', this._part);
                else this._ignore();
                if (!this._isPreamble) this._inHeader = true;
            }
            if (data && start < end && !this._ignoreData) {
                if (this._isPreamble || !this._inHeader) {
                    if (buf) shouldWriteMore = this._part.push(buf);
                    shouldWriteMore = this._part.push(data.slice(start, end));
                    if (!shouldWriteMore) this._pause = true;
                } else if (!this._isPreamble && this._inHeader) {
                    if (buf) this._hparser.push(buf);
                    r = this._hparser.push(data.slice(start, end));
                    if (!this._inHeader && void 0 !== r && r < end) this._oninfo(false, data, start + r, end);
                }
            }
            if (isMatch) {
                this._hparser.reset();
                if (this._isPreamble) this._isPreamble = false;
                else if (start !== end) {
                    ++this._parts;
                    this._part.on('end', function() {
                        if (0 === --self1._parts) if (self1._finished) {
                            self1._realFinish = true;
                            self1.emit('finish');
                            self1._realFinish = false;
                        } else self1._unpause();
                    });
                }
                this._part.push(null);
                this._part = void 0;
                this._ignoreData = false;
                this._justMatched = true;
                this._dashes = 0;
            }
        };
        Dicer.prototype._unpause = function() {
            if (!this._pause) return;
            this._pause = false;
            if (this._cb) {
                const cb = this._cb;
                this._cb = void 0;
                cb();
            }
        };
        module.exports = Dicer;
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const EventEmitter = __webpack_require__("node:events").EventEmitter;
        const inherits = __webpack_require__("node:util").inherits;
        const getLimit = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js");
        const StreamSearch = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js");
        const B_DCRLF = Buffer.from('\r\n\r\n');
        const RE_CRLF = /\r\n/g;
        const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
        function HeaderParser(cfg) {
            EventEmitter.call(this);
            cfg = cfg || {};
            const self1 = this;
            this.nread = 0;
            this.maxed = false;
            this.npairs = 0;
            this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000);
            this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 81920);
            this.buffer = '';
            this.header = {};
            this.finished = false;
            this.ss = new StreamSearch(B_DCRLF);
            this.ss.on('info', function(isMatch, data, start, end) {
                if (data && !self1.maxed) {
                    if (self1.nread + end - start >= self1.maxHeaderSize) {
                        end = self1.maxHeaderSize - self1.nread + start;
                        self1.nread = self1.maxHeaderSize;
                        self1.maxed = true;
                    } else self1.nread += end - start;
                    self1.buffer += data.toString('binary', start, end);
                }
                if (isMatch) self1._finish();
            });
        }
        inherits(HeaderParser, EventEmitter);
        HeaderParser.prototype.push = function(data) {
            const r = this.ss.push(data);
            if (this.finished) return r;
        };
        HeaderParser.prototype.reset = function() {
            this.finished = false;
            this.buffer = '';
            this.header = {};
            this.ss.reset();
        };
        HeaderParser.prototype._finish = function() {
            if (this.buffer) this._parseHeader();
            this.ss.matches = this.ss.maxMatches;
            const header = this.header;
            this.header = {};
            this.buffer = '';
            this.finished = true;
            this.nread = this.npairs = 0;
            this.maxed = false;
            this.emit('header', header);
        };
        HeaderParser.prototype._parseHeader = function() {
            if (this.npairs === this.maxHeaderPairs) return;
            const lines = this.buffer.split(RE_CRLF);
            const len = lines.length;
            let m, h;
            for(var i = 0; i < len; ++i){
                if (0 === lines[i].length) continue;
                if ('\t' === lines[i][0] || ' ' === lines[i][0]) {
                    if (h) {
                        this.header[h][this.header[h].length - 1] += lines[i];
                        continue;
                    }
                }
                const posColon = lines[i].indexOf(':');
                if (-1 === posColon || 0 === posColon) return;
                m = RE_HDR.exec(lines[i]);
                h = m[1].toLowerCase();
                this.header[h] = this.header[h] || [];
                this.header[h].push(m[2] || '');
                if (++this.npairs === this.maxHeaderPairs) break;
            }
        };
        module.exports = HeaderParser;
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const inherits = __webpack_require__("node:util").inherits;
        const ReadableStream = __webpack_require__("node:stream").Readable;
        function PartStream(opts) {
            ReadableStream.call(this, opts);
        }
        inherits(PartStream, ReadableStream);
        PartStream.prototype._read = function(n) {};
        module.exports = PartStream;
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const EventEmitter = __webpack_require__("node:events").EventEmitter;
        const inherits = __webpack_require__("node:util").inherits;
        function SBMH(needle) {
            if ('string' == typeof needle) needle = Buffer.from(needle);
            if (!Buffer.isBuffer(needle)) throw new TypeError('The needle has to be a String or a Buffer.');
            const needleLength = needle.length;
            if (0 === needleLength) throw new Error('The needle cannot be an empty String/Buffer.');
            if (needleLength > 256) throw new Error('The needle cannot have a length bigger than 256.');
            this.maxMatches = 1 / 0;
            this.matches = 0;
            this._occ = new Array(256).fill(needleLength);
            this._lookbehind_size = 0;
            this._needle = needle;
            this._bufpos = 0;
            this._lookbehind = Buffer.alloc(needleLength);
            for(var i = 0; i < needleLength - 1; ++i)this._occ[needle[i]] = needleLength - 1 - i;
        }
        inherits(SBMH, EventEmitter);
        SBMH.prototype.reset = function() {
            this._lookbehind_size = 0;
            this.matches = 0;
            this._bufpos = 0;
        };
        SBMH.prototype.push = function(chunk, pos) {
            if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, 'binary');
            const chlen = chunk.length;
            this._bufpos = pos || 0;
            let r;
            while(r !== chlen && this.matches < this.maxMatches)r = this._sbmh_feed(chunk);
            return r;
        };
        SBMH.prototype._sbmh_feed = function(data) {
            const len = data.length;
            const needle = this._needle;
            const needleLength = needle.length;
            const lastNeedleChar = needle[needleLength - 1];
            let pos = -this._lookbehind_size;
            let ch;
            if (pos < 0) {
                while(pos < 0 && pos <= len - needleLength){
                    ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
                    if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
                        this._lookbehind_size = 0;
                        ++this.matches;
                        this.emit('info', true);
                        return this._bufpos = pos + needleLength;
                    }
                    pos += this._occ[ch];
                }
                if (pos < 0) while(pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))++pos;
                if (pos >= 0) {
                    this.emit('info', false, this._lookbehind, 0, this._lookbehind_size);
                    this._lookbehind_size = 0;
                } else {
                    const bytesToCutOff = this._lookbehind_size + pos;
                    if (bytesToCutOff > 0) this.emit('info', false, this._lookbehind, 0, bytesToCutOff);
                    this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
                    this._lookbehind_size -= bytesToCutOff;
                    data.copy(this._lookbehind, this._lookbehind_size);
                    this._lookbehind_size += len;
                    this._bufpos = len;
                    return len;
                }
            }
            pos += (pos >= 0) * this._bufpos;
            if (-1 !== data.indexOf(needle, pos)) {
                pos = data.indexOf(needle, pos);
                ++this.matches;
                if (pos > 0) this.emit('info', true, data, this._bufpos, pos);
                else this.emit('info', true);
                return this._bufpos = pos + needleLength;
            }
            pos = len - needleLength;
            while(pos < len && (data[pos] !== needle[0] || 0 !== Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos))))++pos;
            if (pos < len) {
                data.copy(this._lookbehind, 0, pos, pos + (len - pos));
                this._lookbehind_size = len - pos;
            }
            if (pos > 0) this.emit('info', false, data, this._bufpos, pos < len ? pos : len);
            this._bufpos = len;
            return len;
        };
        SBMH.prototype._sbmh_lookup_char = function(data, pos) {
            return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
        };
        SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
            for(var i = 0; i < len; ++i)if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) return false;
            return true;
        };
        module.exports = SBMH;
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const WritableStream = __webpack_require__("node:stream").Writable;
        const { inherits } = __webpack_require__("node:util");
        const Dicer = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js");
        const MultipartParser = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js");
        const UrlencodedParser = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js");
        const parseParams = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js");
        function Busboy(opts) {
            if (!(this instanceof Busboy)) return new Busboy(opts);
            if ('object' != typeof opts) throw new TypeError('Busboy expected an options-Object.');
            if ('object' != typeof opts.headers) throw new TypeError('Busboy expected an options-Object with headers-attribute.');
            if ('string' != typeof opts.headers['content-type']) throw new TypeError('Missing Content-Type-header.');
            const { headers, ...streamOptions } = opts;
            this.opts = {
                autoDestroy: false,
                ...streamOptions
            };
            WritableStream.call(this, this.opts);
            this._done = false;
            this._parser = this.getParserByHeaders(headers);
            this._finished = false;
        }
        inherits(Busboy, WritableStream);
        Busboy.prototype.emit = function(ev) {
            if ('finish' === ev) {
                if (!this._done) return void this._parser?.end();
                if (this._finished) return;
                this._finished = true;
            }
            WritableStream.prototype.emit.apply(this, arguments);
        };
        Busboy.prototype.getParserByHeaders = function(headers) {
            const parsed = parseParams(headers['content-type']);
            const cfg = {
                defCharset: this.opts.defCharset,
                fileHwm: this.opts.fileHwm,
                headers,
                highWaterMark: this.opts.highWaterMark,
                isPartAFile: this.opts.isPartAFile,
                limits: this.opts.limits,
                parsedConType: parsed,
                preservePath: this.opts.preservePath
            };
            if (MultipartParser.detect.test(parsed[0])) return new MultipartParser(this, cfg);
            if (UrlencodedParser.detect.test(parsed[0])) return new UrlencodedParser(this, cfg);
            throw new Error('Unsupported Content-Type.');
        };
        Busboy.prototype._write = function(chunk, encoding, cb) {
            this._parser.write(chunk, cb);
        };
        module.exports = Busboy;
        module.exports["default"] = Busboy;
        module.exports.Busboy = Busboy;
        module.exports.Dicer = Dicer;
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const { Readable } = __webpack_require__("node:stream");
        const { inherits } = __webpack_require__("node:util");
        const Dicer = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js");
        const parseParams = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js");
        const decodeText = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js");
        const basename = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js");
        const getLimit = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js");
        const RE_BOUNDARY = /^boundary$/i;
        const RE_FIELD = /^form-data$/i;
        const RE_CHARSET = /^charset$/i;
        const RE_FILENAME = /^filename$/i;
        const RE_NAME = /^name$/i;
        Multipart.detect = /^multipart\/form-data/i;
        function Multipart(boy, cfg) {
            let i;
            let len;
            const self1 = this;
            let boundary;
            const limits = cfg.limits;
            const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName)=>'application/octet-stream' === contentType || void 0 !== fileName);
            const parsedConType = cfg.parsedConType || [];
            const defCharset = cfg.defCharset || 'utf8';
            const preservePath = cfg.preservePath;
            const fileOpts = {
                highWaterMark: cfg.fileHwm
            };
            for(i = 0, len = parsedConType.length; i < len; ++i)if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
                boundary = parsedConType[i][1];
                break;
            }
            function checkFinished() {
                if (0 === nends && finished && !boy._done) {
                    finished = false;
                    self1.end();
                }
            }
            if ('string' != typeof boundary) throw new Error('Multipart: Boundary not found');
            const fieldSizeLimit = getLimit(limits, 'fieldSize', 1048576);
            const fileSizeLimit = getLimit(limits, 'fileSize', 1 / 0);
            const filesLimit = getLimit(limits, 'files', 1 / 0);
            const fieldsLimit = getLimit(limits, 'fields', 1 / 0);
            const partsLimit = getLimit(limits, 'parts', 1 / 0);
            const headerPairsLimit = getLimit(limits, 'headerPairs', 2000);
            const headerSizeLimit = getLimit(limits, 'headerSize', 81920);
            let nfiles = 0;
            let nfields = 0;
            let nends = 0;
            let curFile;
            let curField;
            let finished = false;
            this._needDrain = false;
            this._pause = false;
            this._cb = void 0;
            this._nparts = 0;
            this._boy = boy;
            const parserCfg = {
                boundary,
                maxHeaderPairs: headerPairsLimit,
                maxHeaderSize: headerSizeLimit,
                partHwm: fileOpts.highWaterMark,
                highWaterMark: cfg.highWaterMark
            };
            this.parser = new Dicer(parserCfg);
            this.parser.on('drain', function() {
                self1._needDrain = false;
                if (self1._cb && !self1._pause) {
                    const cb = self1._cb;
                    self1._cb = void 0;
                    cb();
                }
            }).on('part', function onPart(part) {
                if (++self1._nparts > partsLimit) {
                    self1.parser.removeListener('part', onPart);
                    self1.parser.on('part', skipPart);
                    boy.hitPartsLimit = true;
                    boy.emit('partsLimit');
                    return skipPart(part);
                }
                if (curField) {
                    const field = curField;
                    field.emit('end');
                    field.removeAllListeners('end');
                }
                part.on('header', function(header) {
                    let contype;
                    let fieldname;
                    let parsed;
                    let charset;
                    let encoding;
                    let filename;
                    let nsize = 0;
                    if (header['content-type']) {
                        parsed = parseParams(header['content-type'][0]);
                        if (parsed[0]) {
                            contype = parsed[0].toLowerCase();
                            for(i = 0, len = parsed.length; i < len; ++i)if (RE_CHARSET.test(parsed[i][0])) {
                                charset = parsed[i][1].toLowerCase();
                                break;
                            }
                        }
                    }
                    if (void 0 === contype) contype = 'text/plain';
                    if (void 0 === charset) charset = defCharset;
                    if (!header['content-disposition']) return skipPart(part);
                    parsed = parseParams(header['content-disposition'][0]);
                    if (!RE_FIELD.test(parsed[0])) return skipPart(part);
                    for(i = 0, len = parsed.length; i < len; ++i)if (RE_NAME.test(parsed[i][0])) fieldname = parsed[i][1];
                    else if (RE_FILENAME.test(parsed[i][0])) {
                        filename = parsed[i][1];
                        if (!preservePath) filename = basename(filename);
                    }
                    encoding = header['content-transfer-encoding'] ? header['content-transfer-encoding'][0].toLowerCase() : '7bit';
                    let onData, onEnd;
                    if (isPartAFile(fieldname, contype, filename)) {
                        if (nfiles === filesLimit) {
                            if (!boy.hitFilesLimit) {
                                boy.hitFilesLimit = true;
                                boy.emit('filesLimit');
                            }
                            return skipPart(part);
                        }
                        ++nfiles;
                        if (0 === boy.listenerCount('file')) return void self1.parser._ignore();
                        ++nends;
                        const file = new FileStream(fileOpts);
                        curFile = file;
                        file.on('end', function() {
                            --nends;
                            self1._pause = false;
                            checkFinished();
                            if (self1._cb && !self1._needDrain) {
                                const cb = self1._cb;
                                self1._cb = void 0;
                                cb();
                            }
                        });
                        file._read = function(n) {
                            if (!self1._pause) return;
                            self1._pause = false;
                            if (self1._cb && !self1._needDrain) {
                                const cb = self1._cb;
                                self1._cb = void 0;
                                cb();
                            }
                        };
                        boy.emit('file', fieldname, file, filename, encoding, contype);
                        onData = function(data) {
                            if ((nsize += data.length) > fileSizeLimit) {
                                const extralen = fileSizeLimit - nsize + data.length;
                                if (extralen > 0) file.push(data.slice(0, extralen));
                                file.truncated = true;
                                file.bytesRead = fileSizeLimit;
                                part.removeAllListeners('data');
                                file.emit('limit');
                                return;
                            }
                            if (!file.push(data)) self1._pause = true;
                            file.bytesRead = nsize;
                        };
                        onEnd = function() {
                            curFile = void 0;
                            file.push(null);
                        };
                    } else {
                        if (nfields === fieldsLimit) {
                            if (!boy.hitFieldsLimit) {
                                boy.hitFieldsLimit = true;
                                boy.emit('fieldsLimit');
                            }
                            return skipPart(part);
                        }
                        ++nfields;
                        ++nends;
                        let buffer = '';
                        let truncated = false;
                        curField = part;
                        onData = function(data) {
                            if ((nsize += data.length) > fieldSizeLimit) {
                                const extralen = fieldSizeLimit - (nsize - data.length);
                                buffer += data.toString('binary', 0, extralen);
                                truncated = true;
                                part.removeAllListeners('data');
                            } else buffer += data.toString('binary');
                        };
                        onEnd = function() {
                            curField = void 0;
                            if (buffer.length) buffer = decodeText(buffer, 'binary', charset);
                            boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);
                            --nends;
                            checkFinished();
                        };
                    }
                    part._readableState.sync = false;
                    part.on('data', onData);
                    part.on('end', onEnd);
                }).on('error', function(err) {
                    if (curFile) curFile.emit('error', err);
                });
            }).on('error', function(err) {
                boy.emit('error', err);
            }).on('finish', function() {
                finished = true;
                checkFinished();
            });
        }
        Multipart.prototype.write = function(chunk, cb) {
            const r = this.parser.write(chunk);
            if (r && !this._pause) cb();
            else {
                this._needDrain = !r;
                this._cb = cb;
            }
        };
        Multipart.prototype.end = function() {
            const self1 = this;
            if (self1.parser.writable) self1.parser.end();
            else if (!self1._boy._done) process.nextTick(function() {
                self1._boy._done = true;
                self1._boy.emit('finish');
            });
        };
        function skipPart(part) {
            part.resume();
        }
        function FileStream(opts) {
            Readable.call(this, opts);
            this.bytesRead = 0;
            this.truncated = false;
        }
        inherits(FileStream, Readable);
        FileStream.prototype._read = function(n) {};
        module.exports = Multipart;
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const Decoder = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js");
        const decodeText = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js");
        const getLimit = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js");
        const RE_CHARSET = /^charset$/i;
        UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
        function UrlEncoded(boy, cfg) {
            const limits = cfg.limits;
            const parsedConType = cfg.parsedConType;
            this.boy = boy;
            this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1048576);
            this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100);
            this.fieldsLimit = getLimit(limits, 'fields', 1 / 0);
            let charset;
            for(var i = 0, len = parsedConType.length; i < len; ++i)if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
                charset = parsedConType[i][1].toLowerCase();
                break;
            }
            if (void 0 === charset) charset = cfg.defCharset || 'utf8';
            this.decoder = new Decoder();
            this.charset = charset;
            this._fields = 0;
            this._state = 'key';
            this._checkingBytes = true;
            this._bytesKey = 0;
            this._bytesVal = 0;
            this._key = '';
            this._val = '';
            this._keyTrunc = false;
            this._valTrunc = false;
            this._hitLimit = false;
        }
        UrlEncoded.prototype.write = function(data, cb) {
            if (this._fields === this.fieldsLimit) {
                if (!this.boy.hitFieldsLimit) {
                    this.boy.hitFieldsLimit = true;
                    this.boy.emit('fieldsLimit');
                }
                return cb();
            }
            let idxeq;
            let idxamp;
            let i;
            let p = 0;
            const len = data.length;
            while(p < len)if ('key' === this._state) {
                idxeq = idxamp = void 0;
                for(i = p; i < len; ++i){
                    if (!this._checkingBytes) ++p;
                    if (0x3D === data[i]) {
                        idxeq = i;
                        break;
                    }
                    if (0x26 === data[i]) {
                        idxamp = i;
                        break;
                    }
                    if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
                        this._hitLimit = true;
                        break;
                    }
                    if (this._checkingBytes) ++this._bytesKey;
                }
                if (void 0 !== idxeq) {
                    if (idxeq > p) this._key += this.decoder.write(data.toString('binary', p, idxeq));
                    this._state = 'val';
                    this._hitLimit = false;
                    this._checkingBytes = true;
                    this._val = '';
                    this._bytesVal = 0;
                    this._valTrunc = false;
                    this.decoder.reset();
                    p = idxeq + 1;
                } else if (void 0 !== idxamp) {
                    ++this._fields;
                    let key;
                    const keyTrunc = this._keyTrunc;
                    key = idxamp > p ? this._key += this.decoder.write(data.toString('binary', p, idxamp)) : this._key;
                    this._hitLimit = false;
                    this._checkingBytes = true;
                    this._key = '';
                    this._bytesKey = 0;
                    this._keyTrunc = false;
                    this.decoder.reset();
                    if (key.length) this.boy.emit('field', decodeText(key, 'binary', this.charset), '', keyTrunc, false);
                    p = idxamp + 1;
                    if (this._fields === this.fieldsLimit) return cb();
                } else if (this._hitLimit) {
                    if (i > p) this._key += this.decoder.write(data.toString('binary', p, i));
                    p = i;
                    if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
                        this._checkingBytes = false;
                        this._keyTrunc = true;
                    }
                } else {
                    if (p < len) this._key += this.decoder.write(data.toString('binary', p));
                    p = len;
                }
            } else {
                idxamp = void 0;
                for(i = p; i < len; ++i){
                    if (!this._checkingBytes) ++p;
                    if (0x26 === data[i]) {
                        idxamp = i;
                        break;
                    }
                    if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
                        this._hitLimit = true;
                        break;
                    }
                    if (this._checkingBytes) ++this._bytesVal;
                }
                if (void 0 !== idxamp) {
                    ++this._fields;
                    if (idxamp > p) this._val += this.decoder.write(data.toString('binary', p, idxamp));
                    this.boy.emit('field', decodeText(this._key, 'binary', this.charset), decodeText(this._val, 'binary', this.charset), this._keyTrunc, this._valTrunc);
                    this._state = 'key';
                    this._hitLimit = false;
                    this._checkingBytes = true;
                    this._key = '';
                    this._bytesKey = 0;
                    this._keyTrunc = false;
                    this.decoder.reset();
                    p = idxamp + 1;
                    if (this._fields === this.fieldsLimit) return cb();
                } else if (this._hitLimit) {
                    if (i > p) this._val += this.decoder.write(data.toString('binary', p, i));
                    p = i;
                    if ('' === this._val && 0 === this.fieldSizeLimit || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
                        this._checkingBytes = false;
                        this._valTrunc = true;
                    }
                } else {
                    if (p < len) this._val += this.decoder.write(data.toString('binary', p));
                    p = len;
                }
            }
            cb();
        };
        UrlEncoded.prototype.end = function() {
            if (this.boy._done) return;
            if ('key' === this._state && this._key.length > 0) this.boy.emit('field', decodeText(this._key, 'binary', this.charset), '', this._keyTrunc, false);
            else if ('val' === this._state) this.boy.emit('field', decodeText(this._key, 'binary', this.charset), decodeText(this._val, 'binary', this.charset), this._keyTrunc, this._valTrunc);
            this.boy._done = true;
            this.boy.emit('finish');
        };
        module.exports = UrlEncoded;
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js" (module) {
        "use strict";
        const RE_PLUS = /\+/g;
        const HEX = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ];
        function Decoder() {
            this.buffer = void 0;
        }
        Decoder.prototype.write = function(str) {
            str = str.replace(RE_PLUS, ' ');
            let res = '';
            let i = 0;
            let p = 0;
            const len = str.length;
            for(; i < len; ++i)if (void 0 !== this.buffer) if (HEX[str.charCodeAt(i)]) {
                this.buffer += str[i];
                ++p;
                if (2 === this.buffer.length) {
                    res += String.fromCharCode(parseInt(this.buffer, 16));
                    this.buffer = void 0;
                }
            } else {
                res += '%' + this.buffer;
                this.buffer = void 0;
                --i;
            }
            else if ('%' === str[i]) {
                if (i > p) {
                    res += str.substring(p, i);
                    p = i;
                }
                this.buffer = '';
                ++p;
            }
            if (p < len && void 0 === this.buffer) res += str.substring(p);
            return res;
        };
        Decoder.prototype.reset = function() {
            this.buffer = void 0;
        };
        module.exports = Decoder;
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js" (module) {
        "use strict";
        module.exports = function(path) {
            if ('string' != typeof path) return '';
            for(var i = path.length - 1; i >= 0; --i)switch(path.charCodeAt(i)){
                case 0x2F:
                case 0x5C:
                    path = path.slice(i + 1);
                    return '..' === path || '.' === path ? '' : path;
            }
            return '..' === path || '.' === path ? '' : path;
        };
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js" (module) {
        "use strict";
        const utf8Decoder = new TextDecoder('utf-8');
        const textDecoders = new Map([
            [
                'utf-8',
                utf8Decoder
            ],
            [
                'utf8',
                utf8Decoder
            ]
        ]);
        function getDecoder(charset) {
            let lc;
            while(true)switch(charset){
                case 'utf-8':
                case 'utf8':
                    return decoders.utf8;
                case 'latin1':
                case 'ascii':
                case 'us-ascii':
                case 'iso-8859-1':
                case 'iso8859-1':
                case 'iso88591':
                case 'iso_8859-1':
                case 'windows-1252':
                case 'iso_8859-1:1987':
                case 'cp1252':
                case 'x-cp1252':
                    return decoders.latin1;
                case 'utf16le':
                case 'utf-16le':
                case 'ucs2':
                case 'ucs-2':
                    return decoders.utf16le;
                case 'base64':
                    return decoders.base64;
                default:
                    if (void 0 === lc) {
                        lc = true;
                        charset = charset.toLowerCase();
                        continue;
                    }
                    return decoders.other.bind(charset);
            }
        }
        const decoders = {
            utf8: (data, sourceEncoding)=>{
                if (0 === data.length) return '';
                if ('string' == typeof data) data = Buffer.from(data, sourceEncoding);
                return data.utf8Slice(0, data.length);
            },
            latin1: (data, sourceEncoding)=>{
                if (0 === data.length) return '';
                if ('string' == typeof data) return data;
                return data.latin1Slice(0, data.length);
            },
            utf16le: (data, sourceEncoding)=>{
                if (0 === data.length) return '';
                if ('string' == typeof data) data = Buffer.from(data, sourceEncoding);
                return data.ucs2Slice(0, data.length);
            },
            base64: (data, sourceEncoding)=>{
                if (0 === data.length) return '';
                if ('string' == typeof data) data = Buffer.from(data, sourceEncoding);
                return data.base64Slice(0, data.length);
            },
            other: (data, sourceEncoding)=>{
                if (0 === data.length) return '';
                if ('string' == typeof data) data = Buffer.from(data, sourceEncoding);
                if (textDecoders.has(this.toString())) try {
                    return textDecoders.get(this).decode(data);
                } catch  {}
                return 'string' == typeof data ? data : data.toString();
            }
        };
        function decodeText(text, sourceEncoding, destEncoding) {
            if (text) return getDecoder(destEncoding)(text, sourceEncoding);
            return text;
        }
        module.exports = decodeText;
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js" (module) {
        "use strict";
        module.exports = function(limits, name, defaultLimit) {
            if (!limits || void 0 === limits[name] || null === limits[name]) return defaultLimit;
            if ('number' != typeof limits[name] || isNaN(limits[name])) throw new TypeError('Limit ' + name + ' is not a valid number');
            return limits[name];
        };
    },
    "../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js" (module, __unused_rspack_exports, __webpack_require__) {
        "use strict";
        const decodeText = __webpack_require__("../../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js");
        const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
        const EncodedLookup = {
            '%00': '\x00',
            '%01': '\x01',
            '%02': '\x02',
            '%03': '\x03',
            '%04': '\x04',
            '%05': '\x05',
            '%06': '\x06',
            '%07': '\x07',
            '%08': '\x08',
            '%09': '\x09',
            '%0a': '\x0a',
            '%0A': '\x0a',
            '%0b': '\x0b',
            '%0B': '\x0b',
            '%0c': '\x0c',
            '%0C': '\x0c',
            '%0d': '\x0d',
            '%0D': '\x0d',
            '%0e': '\x0e',
            '%0E': '\x0e',
            '%0f': '\x0f',
            '%0F': '\x0f',
            '%10': '\x10',
            '%11': '\x11',
            '%12': '\x12',
            '%13': '\x13',
            '%14': '\x14',
            '%15': '\x15',
            '%16': '\x16',
            '%17': '\x17',
            '%18': '\x18',
            '%19': '\x19',
            '%1a': '\x1a',
            '%1A': '\x1a',
            '%1b': '\x1b',
            '%1B': '\x1b',
            '%1c': '\x1c',
            '%1C': '\x1c',
            '%1d': '\x1d',
            '%1D': '\x1d',
            '%1e': '\x1e',
            '%1E': '\x1e',
            '%1f': '\x1f',
            '%1F': '\x1f',
            '%20': '\x20',
            '%21': '\x21',
            '%22': '\x22',
            '%23': '\x23',
            '%24': '\x24',
            '%25': '\x25',
            '%26': '\x26',
            '%27': '\x27',
            '%28': '\x28',
            '%29': '\x29',
            '%2a': '\x2a',
            '%2A': '\x2a',
            '%2b': '\x2b',
            '%2B': '\x2b',
            '%2c': '\x2c',
            '%2C': '\x2c',
            '%2d': '\x2d',
            '%2D': '\x2d',
            '%2e': '\x2e',
            '%2E': '\x2e',
            '%2f': '\x2f',
            '%2F': '\x2f',
            '%30': '\x30',
            '%31': '\x31',
            '%32': '\x32',
            '%33': '\x33',
            '%34': '\x34',
            '%35': '\x35',
            '%36': '\x36',
            '%37': '\x37',
            '%38': '\x38',
            '%39': '\x39',
            '%3a': '\x3a',
            '%3A': '\x3a',
            '%3b': '\x3b',
            '%3B': '\x3b',
            '%3c': '\x3c',
            '%3C': '\x3c',
            '%3d': '\x3d',
            '%3D': '\x3d',
            '%3e': '\x3e',
            '%3E': '\x3e',
            '%3f': '\x3f',
            '%3F': '\x3f',
            '%40': '\x40',
            '%41': '\x41',
            '%42': '\x42',
            '%43': '\x43',
            '%44': '\x44',
            '%45': '\x45',
            '%46': '\x46',
            '%47': '\x47',
            '%48': '\x48',
            '%49': '\x49',
            '%4a': '\x4a',
            '%4A': '\x4a',
            '%4b': '\x4b',
            '%4B': '\x4b',
            '%4c': '\x4c',
            '%4C': '\x4c',
            '%4d': '\x4d',
            '%4D': '\x4d',
            '%4e': '\x4e',
            '%4E': '\x4e',
            '%4f': '\x4f',
            '%4F': '\x4f',
            '%50': '\x50',
            '%51': '\x51',
            '%52': '\x52',
            '%53': '\x53',
            '%54': '\x54',
            '%55': '\x55',
            '%56': '\x56',
            '%57': '\x57',
            '%58': '\x58',
            '%59': '\x59',
            '%5a': '\x5a',
            '%5A': '\x5a',
            '%5b': '\x5b',
            '%5B': '\x5b',
            '%5c': '\x5c',
            '%5C': '\x5c',
            '%5d': '\x5d',
            '%5D': '\x5d',
            '%5e': '\x5e',
            '%5E': '\x5e',
            '%5f': '\x5f',
            '%5F': '\x5f',
            '%60': '\x60',
            '%61': '\x61',
            '%62': '\x62',
            '%63': '\x63',
            '%64': '\x64',
            '%65': '\x65',
            '%66': '\x66',
            '%67': '\x67',
            '%68': '\x68',
            '%69': '\x69',
            '%6a': '\x6a',
            '%6A': '\x6a',
            '%6b': '\x6b',
            '%6B': '\x6b',
            '%6c': '\x6c',
            '%6C': '\x6c',
            '%6d': '\x6d',
            '%6D': '\x6d',
            '%6e': '\x6e',
            '%6E': '\x6e',
            '%6f': '\x6f',
            '%6F': '\x6f',
            '%70': '\x70',
            '%71': '\x71',
            '%72': '\x72',
            '%73': '\x73',
            '%74': '\x74',
            '%75': '\x75',
            '%76': '\x76',
            '%77': '\x77',
            '%78': '\x78',
            '%79': '\x79',
            '%7a': '\x7a',
            '%7A': '\x7a',
            '%7b': '\x7b',
            '%7B': '\x7b',
            '%7c': '\x7c',
            '%7C': '\x7c',
            '%7d': '\x7d',
            '%7D': '\x7d',
            '%7e': '\x7e',
            '%7E': '\x7e',
            '%7f': '\x7f',
            '%7F': '\x7f',
            '%80': '\x80',
            '%81': '\x81',
            '%82': '\x82',
            '%83': '\x83',
            '%84': '\x84',
            '%85': '\x85',
            '%86': '\x86',
            '%87': '\x87',
            '%88': '\x88',
            '%89': '\x89',
            '%8a': '\x8a',
            '%8A': '\x8a',
            '%8b': '\x8b',
            '%8B': '\x8b',
            '%8c': '\x8c',
            '%8C': '\x8c',
            '%8d': '\x8d',
            '%8D': '\x8d',
            '%8e': '\x8e',
            '%8E': '\x8e',
            '%8f': '\x8f',
            '%8F': '\x8f',
            '%90': '\x90',
            '%91': '\x91',
            '%92': '\x92',
            '%93': '\x93',
            '%94': '\x94',
            '%95': '\x95',
            '%96': '\x96',
            '%97': '\x97',
            '%98': '\x98',
            '%99': '\x99',
            '%9a': '\x9a',
            '%9A': '\x9a',
            '%9b': '\x9b',
            '%9B': '\x9b',
            '%9c': '\x9c',
            '%9C': '\x9c',
            '%9d': '\x9d',
            '%9D': '\x9d',
            '%9e': '\x9e',
            '%9E': '\x9e',
            '%9f': '\x9f',
            '%9F': '\x9f',
            '%a0': '\xa0',
            '%A0': '\xa0',
            '%a1': '\xa1',
            '%A1': '\xa1',
            '%a2': '\xa2',
            '%A2': '\xa2',
            '%a3': '\xa3',
            '%A3': '\xa3',
            '%a4': '\xa4',
            '%A4': '\xa4',
            '%a5': '\xa5',
            '%A5': '\xa5',
            '%a6': '\xa6',
            '%A6': '\xa6',
            '%a7': '\xa7',
            '%A7': '\xa7',
            '%a8': '\xa8',
            '%A8': '\xa8',
            '%a9': '\xa9',
            '%A9': '\xa9',
            '%aa': '\xaa',
            '%Aa': '\xaa',
            '%aA': '\xaa',
            '%AA': '\xaa',
            '%ab': '\xab',
            '%Ab': '\xab',
            '%aB': '\xab',
            '%AB': '\xab',
            '%ac': '\xac',
            '%Ac': '\xac',
            '%aC': '\xac',
            '%AC': '\xac',
            '%ad': '\xad',
            '%Ad': '\xad',
            '%aD': '\xad',
            '%AD': '\xad',
            '%ae': '\xae',
            '%Ae': '\xae',
            '%aE': '\xae',
            '%AE': '\xae',
            '%af': '\xaf',
            '%Af': '\xaf',
            '%aF': '\xaf',
            '%AF': '\xaf',
            '%b0': '\xb0',
            '%B0': '\xb0',
            '%b1': '\xb1',
            '%B1': '\xb1',
            '%b2': '\xb2',
            '%B2': '\xb2',
            '%b3': '\xb3',
            '%B3': '\xb3',
            '%b4': '\xb4',
            '%B4': '\xb4',
            '%b5': '\xb5',
            '%B5': '\xb5',
            '%b6': '\xb6',
            '%B6': '\xb6',
            '%b7': '\xb7',
            '%B7': '\xb7',
            '%b8': '\xb8',
            '%B8': '\xb8',
            '%b9': '\xb9',
            '%B9': '\xb9',
            '%ba': '\xba',
            '%Ba': '\xba',
            '%bA': '\xba',
            '%BA': '\xba',
            '%bb': '\xbb',
            '%Bb': '\xbb',
            '%bB': '\xbb',
            '%BB': '\xbb',
            '%bc': '\xbc',
            '%Bc': '\xbc',
            '%bC': '\xbc',
            '%BC': '\xbc',
            '%bd': '\xbd',
            '%Bd': '\xbd',
            '%bD': '\xbd',
            '%BD': '\xbd',
            '%be': '\xbe',
            '%Be': '\xbe',
            '%bE': '\xbe',
            '%BE': '\xbe',
            '%bf': '\xbf',
            '%Bf': '\xbf',
            '%bF': '\xbf',
            '%BF': '\xbf',
            '%c0': '\xc0',
            '%C0': '\xc0',
            '%c1': '\xc1',
            '%C1': '\xc1',
            '%c2': '\xc2',
            '%C2': '\xc2',
            '%c3': '\xc3',
            '%C3': '\xc3',
            '%c4': '\xc4',
            '%C4': '\xc4',
            '%c5': '\xc5',
            '%C5': '\xc5',
            '%c6': '\xc6',
            '%C6': '\xc6',
            '%c7': '\xc7',
            '%C7': '\xc7',
            '%c8': '\xc8',
            '%C8': '\xc8',
            '%c9': '\xc9',
            '%C9': '\xc9',
            '%ca': '\xca',
            '%Ca': '\xca',
            '%cA': '\xca',
            '%CA': '\xca',
            '%cb': '\xcb',
            '%Cb': '\xcb',
            '%cB': '\xcb',
            '%CB': '\xcb',
            '%cc': '\xcc',
            '%Cc': '\xcc',
            '%cC': '\xcc',
            '%CC': '\xcc',
            '%cd': '\xcd',
            '%Cd': '\xcd',
            '%cD': '\xcd',
            '%CD': '\xcd',
            '%ce': '\xce',
            '%Ce': '\xce',
            '%cE': '\xce',
            '%CE': '\xce',
            '%cf': '\xcf',
            '%Cf': '\xcf',
            '%cF': '\xcf',
            '%CF': '\xcf',
            '%d0': '\xd0',
            '%D0': '\xd0',
            '%d1': '\xd1',
            '%D1': '\xd1',
            '%d2': '\xd2',
            '%D2': '\xd2',
            '%d3': '\xd3',
            '%D3': '\xd3',
            '%d4': '\xd4',
            '%D4': '\xd4',
            '%d5': '\xd5',
            '%D5': '\xd5',
            '%d6': '\xd6',
            '%D6': '\xd6',
            '%d7': '\xd7',
            '%D7': '\xd7',
            '%d8': '\xd8',
            '%D8': '\xd8',
            '%d9': '\xd9',
            '%D9': '\xd9',
            '%da': '\xda',
            '%Da': '\xda',
            '%dA': '\xda',
            '%DA': '\xda',
            '%db': '\xdb',
            '%Db': '\xdb',
            '%dB': '\xdb',
            '%DB': '\xdb',
            '%dc': '\xdc',
            '%Dc': '\xdc',
            '%dC': '\xdc',
            '%DC': '\xdc',
            '%dd': '\xdd',
            '%Dd': '\xdd',
            '%dD': '\xdd',
            '%DD': '\xdd',
            '%de': '\xde',
            '%De': '\xde',
            '%dE': '\xde',
            '%DE': '\xde',
            '%df': '\xdf',
            '%Df': '\xdf',
            '%dF': '\xdf',
            '%DF': '\xdf',
            '%e0': '\xe0',
            '%E0': '\xe0',
            '%e1': '\xe1',
            '%E1': '\xe1',
            '%e2': '\xe2',
            '%E2': '\xe2',
            '%e3': '\xe3',
            '%E3': '\xe3',
            '%e4': '\xe4',
            '%E4': '\xe4',
            '%e5': '\xe5',
            '%E5': '\xe5',
            '%e6': '\xe6',
            '%E6': '\xe6',
            '%e7': '\xe7',
            '%E7': '\xe7',
            '%e8': '\xe8',
            '%E8': '\xe8',
            '%e9': '\xe9',
            '%E9': '\xe9',
            '%ea': '\xea',
            '%Ea': '\xea',
            '%eA': '\xea',
            '%EA': '\xea',
            '%eb': '\xeb',
            '%Eb': '\xeb',
            '%eB': '\xeb',
            '%EB': '\xeb',
            '%ec': '\xec',
            '%Ec': '\xec',
            '%eC': '\xec',
            '%EC': '\xec',
            '%ed': '\xed',
            '%Ed': '\xed',
            '%eD': '\xed',
            '%ED': '\xed',
            '%ee': '\xee',
            '%Ee': '\xee',
            '%eE': '\xee',
            '%EE': '\xee',
            '%ef': '\xef',
            '%Ef': '\xef',
            '%eF': '\xef',
            '%EF': '\xef',
            '%f0': '\xf0',
            '%F0': '\xf0',
            '%f1': '\xf1',
            '%F1': '\xf1',
            '%f2': '\xf2',
            '%F2': '\xf2',
            '%f3': '\xf3',
            '%F3': '\xf3',
            '%f4': '\xf4',
            '%F4': '\xf4',
            '%f5': '\xf5',
            '%F5': '\xf5',
            '%f6': '\xf6',
            '%F6': '\xf6',
            '%f7': '\xf7',
            '%F7': '\xf7',
            '%f8': '\xf8',
            '%F8': '\xf8',
            '%f9': '\xf9',
            '%F9': '\xf9',
            '%fa': '\xfa',
            '%Fa': '\xfa',
            '%fA': '\xfa',
            '%FA': '\xfa',
            '%fb': '\xfb',
            '%Fb': '\xfb',
            '%fB': '\xfb',
            '%FB': '\xfb',
            '%fc': '\xfc',
            '%Fc': '\xfc',
            '%fC': '\xfc',
            '%FC': '\xfc',
            '%fd': '\xfd',
            '%Fd': '\xfd',
            '%fD': '\xfd',
            '%FD': '\xfd',
            '%fe': '\xfe',
            '%Fe': '\xfe',
            '%fE': '\xfe',
            '%FE': '\xfe',
            '%ff': '\xff',
            '%Ff': '\xff',
            '%fF': '\xff',
            '%FF': '\xff'
        };
        function encodedReplacer(match) {
            return EncodedLookup[match];
        }
        const STATE_KEY = 0;
        const STATE_VALUE = 1;
        const STATE_CHARSET = 2;
        const STATE_LANG = 3;
        function parseParams(str) {
            const res = [];
            let state = STATE_KEY;
            let charset = '';
            let inquote = false;
            let escaping = false;
            let p = 0;
            let tmp = '';
            const len = str.length;
            for(var i = 0; i < len; ++i){
                const char = str[i];
                if ('\\' === char && inquote) if (escaping) escaping = false;
                else {
                    escaping = true;
                    continue;
                }
                else if ('"' === char) if (escaping) escaping = false;
                else {
                    if (inquote) {
                        inquote = false;
                        state = STATE_KEY;
                    } else inquote = true;
                    continue;
                }
                else {
                    if (escaping && inquote) tmp += '\\';
                    escaping = false;
                    if ((state === STATE_CHARSET || state === STATE_LANG) && "'" === char) {
                        if (state === STATE_CHARSET) {
                            state = STATE_LANG;
                            charset = tmp.substring(1);
                        } else state = STATE_VALUE;
                        tmp = '';
                        continue;
                    }
                    if (state === STATE_KEY && ('*' === char || '=' === char) && res.length) {
                        state = '*' === char ? STATE_CHARSET : STATE_VALUE;
                        res[p] = [
                            tmp,
                            void 0
                        ];
                        tmp = '';
                        continue;
                    }
                    if (inquote || ';' !== char) {
                        if (!inquote && (' ' === char || '\t' === char)) continue;
                    } else {
                        state = STATE_KEY;
                        if (charset) {
                            if (tmp.length) tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), 'binary', charset);
                            charset = '';
                        } else if (tmp.length) tmp = decodeText(tmp, 'binary', 'utf8');
                        if (void 0 === res[p]) res[p] = tmp;
                        else res[p][1] = tmp;
                        tmp = '';
                        ++p;
                        continue;
                    }
                }
                tmp += char;
            }
            if (charset && tmp.length) tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), 'binary', charset);
            else if (tmp) tmp = decodeText(tmp, 'binary', 'utf8');
            if (void 0 === res[p]) {
                if (tmp) res[p] = tmp;
            } else res[p][1] = tmp;
            return res;
        }
        module.exports = parseParams;
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/big5-added.json" (module) {
        "use strict";
        module.exports = JSON.parse('[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]');
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp936.json" (module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp949.json" (module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp950.json" (module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/eucjp.json" (module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json" (module) {
        "use strict";
        module.exports = JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gbk-added.json" (module) {
        "use strict";
        module.exports = JSON.parse('[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93],["8135f437",""]]');
    },
    "../../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/shiftjis.json" (module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]');
    },
    "../../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json" (module) {
        "use strict";
        module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');
    },
    "../../../node_modules/.pnpm/mime-db@1.54.0/node_modules/mime-db/db.json" (module) {
        "use strict";
        module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/ace+json":{"source":"iana","compressible":true},"application/ace-groupcomm+cbor":{"source":"iana"},"application/ace-trl+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/aif+cbor":{"source":"iana"},"application/aif+json":{"source":"iana","compressible":true},"application/alto-cdni+json":{"source":"iana","compressible":true},"application/alto-cdnifilter+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-propmap+json":{"source":"iana","compressible":true},"application/alto-propmapparams+json":{"source":"iana","compressible":true},"application/alto-tips+json":{"source":"iana","compressible":true},"application/alto-tipsparams+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/appinstaller":{"compressible":false,"extensions":["appinstaller"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/appx":{"compressible":false,"extensions":["appx"]},"application/appxbundle":{"compressible":false,"extensions":["appxbundle"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/automationml-aml+xml":{"source":"iana","compressible":true,"extensions":["aml"]},"application/automationml-amlx+zip":{"source":"iana","compressible":false,"extensions":["amlx"]},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/bufr":{"source":"iana"},"application/c2pa":{"source":"iana"},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/ce+cbor":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/cid-edhoc+cbor-seq":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/city+json-seq":{"source":"iana"},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-eap":{"source":"iana"},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/concise-problem-details+cbor":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cose-x509":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwl":{"source":"iana","extensions":["cwl"]},"application/cwl+json":{"source":"iana","compressible":true},"application/cwl+yaml":{"source":"iana"},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana","extensions":["dcm"]},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dpop+jwt":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/eat+cwt":{"source":"iana"},"application/eat+jwt":{"source":"iana"},"application/eat-bun+cbor":{"source":"iana"},"application/eat-bun+json":{"source":"iana","compressible":true},"application/eat-ucs+cbor":{"source":"iana"},"application/eat-ucs+json":{"source":"iana","compressible":true},"application/ecmascript":{"source":"apache","compressible":true,"extensions":["ecma"]},"application/edhoc+cbor-seq":{"source":"iana"},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.legacyesn+json":{"source":"iana","compressible":true},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/entity-statement+jwt":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdf":{"source":"iana","extensions":["fdf"]},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geopose+json":{"source":"iana","compressible":true},"application/geoxacml+json":{"source":"iana","compressible":true},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gnap-binding-jws":{"source":"iana"},"application/gnap-binding-jwsd":{"source":"iana"},"application/gnap-binding-rotation-jws":{"source":"iana"},"application/gnap-binding-rotation-jwsd":{"source":"iana"},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/grib":{"source":"iana"},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"iana","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"apache","charset":"UTF-8","compressible":true,"extensions":["js"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/jscontact+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jsonpath":{"source":"iana"},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwk-set+jwt":{"source":"iana"},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/linkset":{"source":"iana"},"application/linkset+json":{"source":"iana","compressible":true},"application/load-control+xml":{"source":"iana","compressible":true},"application/logout+jwt":{"source":"iana"},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4","mpg4","mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msix":{"compressible":false,"extensions":["msix"]},"application/msixbundle":{"compressible":false,"extensions":["msixbundle"]},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":true,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/ohttp-keys":{"source":"iana"},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg","one","onea"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["sig","asc"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/private-token-issuer-directory":{"source":"iana"},"application/private-token-request":{"source":"iana"},"application/private-token-response":{"source":"iana"},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/provided-claims+jwt":{"source":"iana"},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.implied-document+xml":{"source":"iana","compressible":true},"application/prs.implied-executable":{"source":"iana"},"application/prs.implied-object+json":{"source":"iana","compressible":true},"application/prs.implied-object+json-seq":{"source":"iana"},"application/prs.implied-object+yaml":{"source":"iana"},"application/prs.implied-structure":{"source":"iana"},"application/prs.mayfile":{"source":"iana"},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.vcfbzip2":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true,"extensions":["xsf"]},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"apache"},"application/reputon+json":{"source":"iana","compressible":true},"application/resolve-response+jwt":{"source":"iana"},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-checklist":{"source":"iana"},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-signed-tal":{"source":"iana"},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"apache"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana","extensions":["sql"]},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/sslkeylogfile":{"source":"iana"},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/st2110-41":{"source":"iana"},"application/stix+json":{"source":"iana","compressible":true},"application/stratum":{"source":"iana"},"application/swid+cbor":{"source":"iana"},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tm+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/toc+cbor":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"source":"iana","compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/trust-chain+json":{"source":"iana","compressible":true},"application/trust-mark+jwt":{"source":"iana"},"application/trust-mark-delegation+jwt":{"source":"iana"},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/uccs+cbor":{"source":"iana"},"application/ujcs+json":{"source":"iana","compressible":true},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vc":{"source":"iana"},"application/vc+cose":{"source":"iana"},"application/vc+jwt":{"source":"iana"},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.1ob":{"source":"iana"},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3a+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ach+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc8+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.5gsa2x":{"source":"iana"},"application/vnd.3gpp.5gsa2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gsv2x":{"source":"iana"},"application/vnd.3gpp.5gsv2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.crs+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.current-location-discovery+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-regroup+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-regroup+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-regroup+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.pinapp-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.seal-group-doc+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-network-qos-management-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-ue-config-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-unicast-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-user-profile-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.v2x":{"source":"iana"},"application/vnd.3gpp.vae-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acm.addressxfer+json":{"source":"iana","compressible":true},"application/vnd.acm.chatbot+json":{"source":"iana","compressible":true},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"apache","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"apache"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.parquet":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.apexlang":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"apache"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autodesk.fbx":{"extensions":["fbx"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.belightsoft.lhzd+zip":{"source":"iana","compressible":false},"application/vnd.belightsoft.lhzl+zip":{"source":"iana","compressible":false},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.bzip3":{"source":"iana"},"application/vnd.c3voc.schedule+xml":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.cncf.helm.chart.content.v1.tar+gzip":{"source":"iana"},"application/vnd.cncf.helm.chart.provenance.v1.prov":{"source":"iana"},"application/vnd.cncf.helm.config.v1+json":{"source":"iana","compressible":true},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datalog":{"source":"iana"},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.dcmp+xml":{"source":"iana","compressible":true,"extensions":["dcmp"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.eln+zip":{"source":"iana","compressible":false},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.erofs":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"apache","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.fdsn.stationxml+xml":{"source":"iana","charset":"XML-BASED","compressible":true},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.freelog.comic":{"source":"iana"},"application/vnd.frogans.fnc":{"source":"apache","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"apache","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.ga4gh.passport+jwt":{"source":"iana"},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.genozip":{"source":"iana"},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.gentoo.catmetadata+xml":{"source":"iana","compressible":true},"application/vnd.gentoo.ebuild":{"source":"iana"},"application/vnd.gentoo.eclass":{"source":"iana"},"application/vnd.gentoo.gpkg":{"source":"iana"},"application/vnd.gentoo.manifest":{"source":"iana"},"application/vnd.gentoo.pkgmetadata+xml":{"source":"iana","compressible":true},"application/vnd.gentoo.xpak":{"source":"iana"},"application/vnd.geo+json":{"source":"apache","compressible":true},"application/vnd.geocube+xml":{"source":"apache","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.pinboard":{"source":"iana"},"application/vnd.geogebra.slides":{"source":"iana","extensions":["ggs"]},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.gnu.taler.exchange+json":{"source":"iana","compressible":true},"application/vnd.gnu.taler.merchant+json":{"source":"iana","compressible":true},"application/vnd.google-apps.audio":{},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.drawing":{"compressible":false,"extensions":["gdraw"]},"application/vnd.google-apps.drive-sdk":{"compressible":false},"application/vnd.google-apps.file":{},"application/vnd.google-apps.folder":{"compressible":false},"application/vnd.google-apps.form":{"compressible":false,"extensions":["gform"]},"application/vnd.google-apps.fusiontable":{},"application/vnd.google-apps.jam":{"compressible":false,"extensions":["gjam"]},"application/vnd.google-apps.mail-layout":{},"application/vnd.google-apps.map":{"compressible":false,"extensions":["gmap"]},"application/vnd.google-apps.photo":{},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.script":{"compressible":false,"extensions":["gscript"]},"application/vnd.google-apps.shortcut":{},"application/vnd.google-apps.site":{"compressible":false,"extensions":["gsite"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-apps.unknown":{},"application/vnd.google-apps.video":{},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"apache","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true,"extensions":["xdcf"]},"application/vnd.gpxsee.map+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.hsl":{"source":"iana"},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"apache"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"apache","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"apache"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.ipfs.ipns-record":{"source":"iana"},"application/vnd.ipld.car":{"source":"iana"},"application/vnd.ipld.dag-cbor":{"source":"iana"},"application/vnd.ipld.dag-json":{"source":"iana"},"application/vnd.ipld.raw":{"source":"iana"},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kdl":{"source":"iana"},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.keyman.kmp+zip":{"source":"iana","compressible":false},"application/vnd.keyman.kmx":{"source":"iana"},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.ldev.productlicensing":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.mdl":{"source":"iana"},"application/vnd.mdl-mbsdf":{"source":"iana"},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.medicalholodeck.recordxr":{"source":"iana"},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mermaid":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.modl":{"source":"iana"},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-visio.viewer":{"extensions":["vdx"]},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msgpack":{"source":"iana"},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.nato.bindingdataobject+cbor":{"source":"iana"},"application/vnd.nato.bindingdataobject+json":{"source":"iana","compressible":true},"application/vnd.nato.bindingdataobject+xml":{"source":"iana","compressible":true,"extensions":["bdo"]},"application/vnd.nato.openxmlformats-package.iepd+zip":{"source":"iana","compressible":false},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"apache","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oai.workflows":{"source":"iana"},"application/vnd.oai.workflows+json":{"source":"iana","compressible":true},"application/vnd.oai.workflows+yaml":{"source":"iana"},"application/vnd.oasis.opendocument.base":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"apache","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-master-template":{"source":"iana"},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"apache","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"apache","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.onvif.metadata":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openvpi.dspx+json":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.procrate.brushset":{"extensions":["brushset"]},"application/vnd.procreate.brush":{"extensions":["brush"]},"application/vnd.procreate.dream":{"extensions":["drm"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.pt.mundusmundi":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true,"extensions":["xhtm"]},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.relpipe":{"source":"iana"},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.sketchometry":{"source":"iana"},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.smintio.portals.archive":{"source":"iana"},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sybyl.mol2":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uic.osdm+json":{"source":"iana","compressible":true},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml","uo"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.veraison.tsm-report+cbor":{"source":"iana"},"application/vnd.veraison.tsm-report+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw","vsdx","vtx"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vocalshaper.vsp4":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.wasmflow.wafl":{"source":"iana"},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordlift":{"source":"iana"},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xarin.cpj":{"source":"iana"},"application/vnd.xecrets-encrypted":{"source":"iana"},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/voucher-jws+json":{"source":"iana","compressible":true},"application/vp":{"source":"iana"},"application/vp+cose":{"source":"iana"},"application/vp+jwt":{"source":"iana"},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blender":{"extensions":["blend"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-compressed":{"extensions":["rar"]},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-ipynb+json":{"compressible":true,"extensions":["ipynb"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zip-compressed":{"extensions":["zip"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xfdf":{"source":"iana","extensions":["xfdf"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yaml":{"source":"iana"},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+cbor":{"source":"iana"},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yang-sid+json":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zip+dotlottie":{"extensions":["lottie"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana","extensions":["adts","aac"]},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flac":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/matroska":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/midi-clip":{"source":"iana"},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a","m4b"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"apache"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"source":"iana","compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp","dib"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/dpx":{"source":"iana","extensions":["dpx"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/j2c":{"source":"iana"},"image/jaii":{"source":"iana","extensions":["jaii"]},"image/jais":{"source":"iana","extensions":["jais"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpg","jpeg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm","jpgm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxl":{"source":"iana","extensions":["jxl"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false,"extensions":["jfif"]},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif","btf"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.clip":{"source":"iana"},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"iana","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-adobe-dng":{"extensions":["dng"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-emf":{"source":"iana"},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-wmf":{"source":"iana"},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/bhttp":{"source":"iana"},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/mls":{"source":"iana"},"message/news":{"source":"apache"},"message/ohttp-req":{"source":"iana"},"message/ohttp-res":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime","mht","mhtml"]},"message/s-http":{"source":"apache"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"apache"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/jt":{"source":"iana","extensions":["jt"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/prc":{"source":"iana","extensions":["prc"]},"model/step":{"source":"iana","extensions":["step","stp","stpnc","p21","210"]},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/u3d":{"source":"iana","extensions":["u3d"]},"model/vnd.bary":{"source":"iana","extensions":["bary"]},"model/vnd.cld":{"source":"iana","extensions":["cld"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana","extensions":["pyo","pyox"]},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usda":{"source":"iana","extensions":["usda"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"apache"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/hl7v2":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["md","markdown"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/prs.texi":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.exchangeable":{"source":"iana"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"apache"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.vcf":{"source":"iana"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vnd.zoo.kcl":{"source":"iana"},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/wgsl":{"source":"iana","extensions":["wgsl"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/evc":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/h266":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/lottie+json":{"source":"iana","compressible":true},"video/matroska":{"source":"iana"},"video/matroska-3d":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts","m2t","m2ts","mts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.planar":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"apache"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');
    },
    "../../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json" (module) {
        "use strict";
        module.exports = JSON.parse('{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a Teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Too Early","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}');
    },
    "../../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json" (module) {
        "use strict";
        module.exports = JSON.parse('[[[0,44],"disallowed_STD3_valid"],[[45,46],"valid"],[[47,47],"disallowed_STD3_valid"],[[48,57],"valid"],[[58,64],"disallowed_STD3_valid"],[[65,65],"mapped",[97]],[[66,66],"mapped",[98]],[[67,67],"mapped",[99]],[[68,68],"mapped",[100]],[[69,69],"mapped",[101]],[[70,70],"mapped",[102]],[[71,71],"mapped",[103]],[[72,72],"mapped",[104]],[[73,73],"mapped",[105]],[[74,74],"mapped",[106]],[[75,75],"mapped",[107]],[[76,76],"mapped",[108]],[[77,77],"mapped",[109]],[[78,78],"mapped",[110]],[[79,79],"mapped",[111]],[[80,80],"mapped",[112]],[[81,81],"mapped",[113]],[[82,82],"mapped",[114]],[[83,83],"mapped",[115]],[[84,84],"mapped",[116]],[[85,85],"mapped",[117]],[[86,86],"mapped",[118]],[[87,87],"mapped",[119]],[[88,88],"mapped",[120]],[[89,89],"mapped",[121]],[[90,90],"mapped",[122]],[[91,96],"disallowed_STD3_valid"],[[97,122],"valid"],[[123,127],"disallowed_STD3_valid"],[[128,159],"disallowed"],[[160,160],"disallowed_STD3_mapped",[32]],[[161,167],"valid",[],"NV8"],[[168,168],"disallowed_STD3_mapped",[32,776]],[[169,169],"valid",[],"NV8"],[[170,170],"mapped",[97]],[[171,172],"valid",[],"NV8"],[[173,173],"ignored"],[[174,174],"valid",[],"NV8"],[[175,175],"disallowed_STD3_mapped",[32,772]],[[176,177],"valid",[],"NV8"],[[178,178],"mapped",[50]],[[179,179],"mapped",[51]],[[180,180],"disallowed_STD3_mapped",[32,769]],[[181,181],"mapped",[956]],[[182,182],"valid",[],"NV8"],[[183,183],"valid"],[[184,184],"disallowed_STD3_mapped",[32,807]],[[185,185],"mapped",[49]],[[186,186],"mapped",[111]],[[187,187],"valid",[],"NV8"],[[188,188],"mapped",[49,8260,52]],[[189,189],"mapped",[49,8260,50]],[[190,190],"mapped",[51,8260,52]],[[191,191],"valid",[],"NV8"],[[192,192],"mapped",[224]],[[193,193],"mapped",[225]],[[194,194],"mapped",[226]],[[195,195],"mapped",[227]],[[196,196],"mapped",[228]],[[197,197],"mapped",[229]],[[198,198],"mapped",[230]],[[199,199],"mapped",[231]],[[200,200],"mapped",[232]],[[201,201],"mapped",[233]],[[202,202],"mapped",[234]],[[203,203],"mapped",[235]],[[204,204],"mapped",[236]],[[205,205],"mapped",[237]],[[206,206],"mapped",[238]],[[207,207],"mapped",[239]],[[208,208],"mapped",[240]],[[209,209],"mapped",[241]],[[210,210],"mapped",[242]],[[211,211],"mapped",[243]],[[212,212],"mapped",[244]],[[213,213],"mapped",[245]],[[214,214],"mapped",[246]],[[215,215],"valid",[],"NV8"],[[216,216],"mapped",[248]],[[217,217],"mapped",[249]],[[218,218],"mapped",[250]],[[219,219],"mapped",[251]],[[220,220],"mapped",[252]],[[221,221],"mapped",[253]],[[222,222],"mapped",[254]],[[223,223],"deviation",[115,115]],[[224,246],"valid"],[[247,247],"valid",[],"NV8"],[[248,255],"valid"],[[256,256],"mapped",[257]],[[257,257],"valid"],[[258,258],"mapped",[259]],[[259,259],"valid"],[[260,260],"mapped",[261]],[[261,261],"valid"],[[262,262],"mapped",[263]],[[263,263],"valid"],[[264,264],"mapped",[265]],[[265,265],"valid"],[[266,266],"mapped",[267]],[[267,267],"valid"],[[268,268],"mapped",[269]],[[269,269],"valid"],[[270,270],"mapped",[271]],[[271,271],"valid"],[[272,272],"mapped",[273]],[[273,273],"valid"],[[274,274],"mapped",[275]],[[275,275],"valid"],[[276,276],"mapped",[277]],[[277,277],"valid"],[[278,278],"mapped",[279]],[[279,279],"valid"],[[280,280],"mapped",[281]],[[281,281],"valid"],[[282,282],"mapped",[283]],[[283,283],"valid"],[[284,284],"mapped",[285]],[[285,285],"valid"],[[286,286],"mapped",[287]],[[287,287],"valid"],[[288,288],"mapped",[289]],[[289,289],"valid"],[[290,290],"mapped",[291]],[[291,291],"valid"],[[292,292],"mapped",[293]],[[293,293],"valid"],[[294,294],"mapped",[295]],[[295,295],"valid"],[[296,296],"mapped",[297]],[[297,297],"valid"],[[298,298],"mapped",[299]],[[299,299],"valid"],[[300,300],"mapped",[301]],[[301,301],"valid"],[[302,302],"mapped",[303]],[[303,303],"valid"],[[304,304],"mapped",[105,775]],[[305,305],"valid"],[[306,307],"mapped",[105,106]],[[308,308],"mapped",[309]],[[309,309],"valid"],[[310,310],"mapped",[311]],[[311,312],"valid"],[[313,313],"mapped",[314]],[[314,314],"valid"],[[315,315],"mapped",[316]],[[316,316],"valid"],[[317,317],"mapped",[318]],[[318,318],"valid"],[[319,320],"mapped",[108,183]],[[321,321],"mapped",[322]],[[322,322],"valid"],[[323,323],"mapped",[324]],[[324,324],"valid"],[[325,325],"mapped",[326]],[[326,326],"valid"],[[327,327],"mapped",[328]],[[328,328],"valid"],[[329,329],"mapped",[700,110]],[[330,330],"mapped",[331]],[[331,331],"valid"],[[332,332],"mapped",[333]],[[333,333],"valid"],[[334,334],"mapped",[335]],[[335,335],"valid"],[[336,336],"mapped",[337]],[[337,337],"valid"],[[338,338],"mapped",[339]],[[339,339],"valid"],[[340,340],"mapped",[341]],[[341,341],"valid"],[[342,342],"mapped",[343]],[[343,343],"valid"],[[344,344],"mapped",[345]],[[345,345],"valid"],[[346,346],"mapped",[347]],[[347,347],"valid"],[[348,348],"mapped",[349]],[[349,349],"valid"],[[350,350],"mapped",[351]],[[351,351],"valid"],[[352,352],"mapped",[353]],[[353,353],"valid"],[[354,354],"mapped",[355]],[[355,355],"valid"],[[356,356],"mapped",[357]],[[357,357],"valid"],[[358,358],"mapped",[359]],[[359,359],"valid"],[[360,360],"mapped",[361]],[[361,361],"valid"],[[362,362],"mapped",[363]],[[363,363],"valid"],[[364,364],"mapped",[365]],[[365,365],"valid"],[[366,366],"mapped",[367]],[[367,367],"valid"],[[368,368],"mapped",[369]],[[369,369],"valid"],[[370,370],"mapped",[371]],[[371,371],"valid"],[[372,372],"mapped",[373]],[[373,373],"valid"],[[374,374],"mapped",[375]],[[375,375],"valid"],[[376,376],"mapped",[255]],[[377,377],"mapped",[378]],[[378,378],"valid"],[[379,379],"mapped",[380]],[[380,380],"valid"],[[381,381],"mapped",[382]],[[382,382],"valid"],[[383,383],"mapped",[115]],[[384,384],"valid"],[[385,385],"mapped",[595]],[[386,386],"mapped",[387]],[[387,387],"valid"],[[388,388],"mapped",[389]],[[389,389],"valid"],[[390,390],"mapped",[596]],[[391,391],"mapped",[392]],[[392,392],"valid"],[[393,393],"mapped",[598]],[[394,394],"mapped",[599]],[[395,395],"mapped",[396]],[[396,397],"valid"],[[398,398],"mapped",[477]],[[399,399],"mapped",[601]],[[400,400],"mapped",[603]],[[401,401],"mapped",[402]],[[402,402],"valid"],[[403,403],"mapped",[608]],[[404,404],"mapped",[611]],[[405,405],"valid"],[[406,406],"mapped",[617]],[[407,407],"mapped",[616]],[[408,408],"mapped",[409]],[[409,411],"valid"],[[412,412],"mapped",[623]],[[413,413],"mapped",[626]],[[414,414],"valid"],[[415,415],"mapped",[629]],[[416,416],"mapped",[417]],[[417,417],"valid"],[[418,418],"mapped",[419]],[[419,419],"valid"],[[420,420],"mapped",[421]],[[421,421],"valid"],[[422,422],"mapped",[640]],[[423,423],"mapped",[424]],[[424,424],"valid"],[[425,425],"mapped",[643]],[[426,427],"valid"],[[428,428],"mapped",[429]],[[429,429],"valid"],[[430,430],"mapped",[648]],[[431,431],"mapped",[432]],[[432,432],"valid"],[[433,433],"mapped",[650]],[[434,434],"mapped",[651]],[[435,435],"mapped",[436]],[[436,436],"valid"],[[437,437],"mapped",[438]],[[438,438],"valid"],[[439,439],"mapped",[658]],[[440,440],"mapped",[441]],[[441,443],"valid"],[[444,444],"mapped",[445]],[[445,451],"valid"],[[452,454],"mapped",[100,382]],[[455,457],"mapped",[108,106]],[[458,460],"mapped",[110,106]],[[461,461],"mapped",[462]],[[462,462],"valid"],[[463,463],"mapped",[464]],[[464,464],"valid"],[[465,465],"mapped",[466]],[[466,466],"valid"],[[467,467],"mapped",[468]],[[468,468],"valid"],[[469,469],"mapped",[470]],[[470,470],"valid"],[[471,471],"mapped",[472]],[[472,472],"valid"],[[473,473],"mapped",[474]],[[474,474],"valid"],[[475,475],"mapped",[476]],[[476,477],"valid"],[[478,478],"mapped",[479]],[[479,479],"valid"],[[480,480],"mapped",[481]],[[481,481],"valid"],[[482,482],"mapped",[483]],[[483,483],"valid"],[[484,484],"mapped",[485]],[[485,485],"valid"],[[486,486],"mapped",[487]],[[487,487],"valid"],[[488,488],"mapped",[489]],[[489,489],"valid"],[[490,490],"mapped",[491]],[[491,491],"valid"],[[492,492],"mapped",[493]],[[493,493],"valid"],[[494,494],"mapped",[495]],[[495,496],"valid"],[[497,499],"mapped",[100,122]],[[500,500],"mapped",[501]],[[501,501],"valid"],[[502,502],"mapped",[405]],[[503,503],"mapped",[447]],[[504,504],"mapped",[505]],[[505,505],"valid"],[[506,506],"mapped",[507]],[[507,507],"valid"],[[508,508],"mapped",[509]],[[509,509],"valid"],[[510,510],"mapped",[511]],[[511,511],"valid"],[[512,512],"mapped",[513]],[[513,513],"valid"],[[514,514],"mapped",[515]],[[515,515],"valid"],[[516,516],"mapped",[517]],[[517,517],"valid"],[[518,518],"mapped",[519]],[[519,519],"valid"],[[520,520],"mapped",[521]],[[521,521],"valid"],[[522,522],"mapped",[523]],[[523,523],"valid"],[[524,524],"mapped",[525]],[[525,525],"valid"],[[526,526],"mapped",[527]],[[527,527],"valid"],[[528,528],"mapped",[529]],[[529,529],"valid"],[[530,530],"mapped",[531]],[[531,531],"valid"],[[532,532],"mapped",[533]],[[533,533],"valid"],[[534,534],"mapped",[535]],[[535,535],"valid"],[[536,536],"mapped",[537]],[[537,537],"valid"],[[538,538],"mapped",[539]],[[539,539],"valid"],[[540,540],"mapped",[541]],[[541,541],"valid"],[[542,542],"mapped",[543]],[[543,543],"valid"],[[544,544],"mapped",[414]],[[545,545],"valid"],[[546,546],"mapped",[547]],[[547,547],"valid"],[[548,548],"mapped",[549]],[[549,549],"valid"],[[550,550],"mapped",[551]],[[551,551],"valid"],[[552,552],"mapped",[553]],[[553,553],"valid"],[[554,554],"mapped",[555]],[[555,555],"valid"],[[556,556],"mapped",[557]],[[557,557],"valid"],[[558,558],"mapped",[559]],[[559,559],"valid"],[[560,560],"mapped",[561]],[[561,561],"valid"],[[562,562],"mapped",[563]],[[563,563],"valid"],[[564,566],"valid"],[[567,569],"valid"],[[570,570],"mapped",[11365]],[[571,571],"mapped",[572]],[[572,572],"valid"],[[573,573],"mapped",[410]],[[574,574],"mapped",[11366]],[[575,576],"valid"],[[577,577],"mapped",[578]],[[578,578],"valid"],[[579,579],"mapped",[384]],[[580,580],"mapped",[649]],[[581,581],"mapped",[652]],[[582,582],"mapped",[583]],[[583,583],"valid"],[[584,584],"mapped",[585]],[[585,585],"valid"],[[586,586],"mapped",[587]],[[587,587],"valid"],[[588,588],"mapped",[589]],[[589,589],"valid"],[[590,590],"mapped",[591]],[[591,591],"valid"],[[592,680],"valid"],[[681,685],"valid"],[[686,687],"valid"],[[688,688],"mapped",[104]],[[689,689],"mapped",[614]],[[690,690],"mapped",[106]],[[691,691],"mapped",[114]],[[692,692],"mapped",[633]],[[693,693],"mapped",[635]],[[694,694],"mapped",[641]],[[695,695],"mapped",[119]],[[696,696],"mapped",[121]],[[697,705],"valid"],[[706,709],"valid",[],"NV8"],[[710,721],"valid"],[[722,727],"valid",[],"NV8"],[[728,728],"disallowed_STD3_mapped",[32,774]],[[729,729],"disallowed_STD3_mapped",[32,775]],[[730,730],"disallowed_STD3_mapped",[32,778]],[[731,731],"disallowed_STD3_mapped",[32,808]],[[732,732],"disallowed_STD3_mapped",[32,771]],[[733,733],"disallowed_STD3_mapped",[32,779]],[[734,734],"valid",[],"NV8"],[[735,735],"valid",[],"NV8"],[[736,736],"mapped",[611]],[[737,737],"mapped",[108]],[[738,738],"mapped",[115]],[[739,739],"mapped",[120]],[[740,740],"mapped",[661]],[[741,745],"valid",[],"NV8"],[[746,747],"valid",[],"NV8"],[[748,748],"valid"],[[749,749],"valid",[],"NV8"],[[750,750],"valid"],[[751,767],"valid",[],"NV8"],[[768,831],"valid"],[[832,832],"mapped",[768]],[[833,833],"mapped",[769]],[[834,834],"valid"],[[835,835],"mapped",[787]],[[836,836],"mapped",[776,769]],[[837,837],"mapped",[953]],[[838,846],"valid"],[[847,847],"ignored"],[[848,855],"valid"],[[856,860],"valid"],[[861,863],"valid"],[[864,865],"valid"],[[866,866],"valid"],[[867,879],"valid"],[[880,880],"mapped",[881]],[[881,881],"valid"],[[882,882],"mapped",[883]],[[883,883],"valid"],[[884,884],"mapped",[697]],[[885,885],"valid"],[[886,886],"mapped",[887]],[[887,887],"valid"],[[888,889],"disallowed"],[[890,890],"disallowed_STD3_mapped",[32,953]],[[891,893],"valid"],[[894,894],"disallowed_STD3_mapped",[59]],[[895,895],"mapped",[1011]],[[896,899],"disallowed"],[[900,900],"disallowed_STD3_mapped",[32,769]],[[901,901],"disallowed_STD3_mapped",[32,776,769]],[[902,902],"mapped",[940]],[[903,903],"mapped",[183]],[[904,904],"mapped",[941]],[[905,905],"mapped",[942]],[[906,906],"mapped",[943]],[[907,907],"disallowed"],[[908,908],"mapped",[972]],[[909,909],"disallowed"],[[910,910],"mapped",[973]],[[911,911],"mapped",[974]],[[912,912],"valid"],[[913,913],"mapped",[945]],[[914,914],"mapped",[946]],[[915,915],"mapped",[947]],[[916,916],"mapped",[948]],[[917,917],"mapped",[949]],[[918,918],"mapped",[950]],[[919,919],"mapped",[951]],[[920,920],"mapped",[952]],[[921,921],"mapped",[953]],[[922,922],"mapped",[954]],[[923,923],"mapped",[955]],[[924,924],"mapped",[956]],[[925,925],"mapped",[957]],[[926,926],"mapped",[958]],[[927,927],"mapped",[959]],[[928,928],"mapped",[960]],[[929,929],"mapped",[961]],[[930,930],"disallowed"],[[931,931],"mapped",[963]],[[932,932],"mapped",[964]],[[933,933],"mapped",[965]],[[934,934],"mapped",[966]],[[935,935],"mapped",[967]],[[936,936],"mapped",[968]],[[937,937],"mapped",[969]],[[938,938],"mapped",[970]],[[939,939],"mapped",[971]],[[940,961],"valid"],[[962,962],"deviation",[963]],[[963,974],"valid"],[[975,975],"mapped",[983]],[[976,976],"mapped",[946]],[[977,977],"mapped",[952]],[[978,978],"mapped",[965]],[[979,979],"mapped",[973]],[[980,980],"mapped",[971]],[[981,981],"mapped",[966]],[[982,982],"mapped",[960]],[[983,983],"valid"],[[984,984],"mapped",[985]],[[985,985],"valid"],[[986,986],"mapped",[987]],[[987,987],"valid"],[[988,988],"mapped",[989]],[[989,989],"valid"],[[990,990],"mapped",[991]],[[991,991],"valid"],[[992,992],"mapped",[993]],[[993,993],"valid"],[[994,994],"mapped",[995]],[[995,995],"valid"],[[996,996],"mapped",[997]],[[997,997],"valid"],[[998,998],"mapped",[999]],[[999,999],"valid"],[[1000,1000],"mapped",[1001]],[[1001,1001],"valid"],[[1002,1002],"mapped",[1003]],[[1003,1003],"valid"],[[1004,1004],"mapped",[1005]],[[1005,1005],"valid"],[[1006,1006],"mapped",[1007]],[[1007,1007],"valid"],[[1008,1008],"mapped",[954]],[[1009,1009],"mapped",[961]],[[1010,1010],"mapped",[963]],[[1011,1011],"valid"],[[1012,1012],"mapped",[952]],[[1013,1013],"mapped",[949]],[[1014,1014],"valid",[],"NV8"],[[1015,1015],"mapped",[1016]],[[1016,1016],"valid"],[[1017,1017],"mapped",[963]],[[1018,1018],"mapped",[1019]],[[1019,1019],"valid"],[[1020,1020],"valid"],[[1021,1021],"mapped",[891]],[[1022,1022],"mapped",[892]],[[1023,1023],"mapped",[893]],[[1024,1024],"mapped",[1104]],[[1025,1025],"mapped",[1105]],[[1026,1026],"mapped",[1106]],[[1027,1027],"mapped",[1107]],[[1028,1028],"mapped",[1108]],[[1029,1029],"mapped",[1109]],[[1030,1030],"mapped",[1110]],[[1031,1031],"mapped",[1111]],[[1032,1032],"mapped",[1112]],[[1033,1033],"mapped",[1113]],[[1034,1034],"mapped",[1114]],[[1035,1035],"mapped",[1115]],[[1036,1036],"mapped",[1116]],[[1037,1037],"mapped",[1117]],[[1038,1038],"mapped",[1118]],[[1039,1039],"mapped",[1119]],[[1040,1040],"mapped",[1072]],[[1041,1041],"mapped",[1073]],[[1042,1042],"mapped",[1074]],[[1043,1043],"mapped",[1075]],[[1044,1044],"mapped",[1076]],[[1045,1045],"mapped",[1077]],[[1046,1046],"mapped",[1078]],[[1047,1047],"mapped",[1079]],[[1048,1048],"mapped",[1080]],[[1049,1049],"mapped",[1081]],[[1050,1050],"mapped",[1082]],[[1051,1051],"mapped",[1083]],[[1052,1052],"mapped",[1084]],[[1053,1053],"mapped",[1085]],[[1054,1054],"mapped",[1086]],[[1055,1055],"mapped",[1087]],[[1056,1056],"mapped",[1088]],[[1057,1057],"mapped",[1089]],[[1058,1058],"mapped",[1090]],[[1059,1059],"mapped",[1091]],[[1060,1060],"mapped",[1092]],[[1061,1061],"mapped",[1093]],[[1062,1062],"mapped",[1094]],[[1063,1063],"mapped",[1095]],[[1064,1064],"mapped",[1096]],[[1065,1065],"mapped",[1097]],[[1066,1066],"mapped",[1098]],[[1067,1067],"mapped",[1099]],[[1068,1068],"mapped",[1100]],[[1069,1069],"mapped",[1101]],[[1070,1070],"mapped",[1102]],[[1071,1071],"mapped",[1103]],[[1072,1103],"valid"],[[1104,1104],"valid"],[[1105,1116],"valid"],[[1117,1117],"valid"],[[1118,1119],"valid"],[[1120,1120],"mapped",[1121]],[[1121,1121],"valid"],[[1122,1122],"mapped",[1123]],[[1123,1123],"valid"],[[1124,1124],"mapped",[1125]],[[1125,1125],"valid"],[[1126,1126],"mapped",[1127]],[[1127,1127],"valid"],[[1128,1128],"mapped",[1129]],[[1129,1129],"valid"],[[1130,1130],"mapped",[1131]],[[1131,1131],"valid"],[[1132,1132],"mapped",[1133]],[[1133,1133],"valid"],[[1134,1134],"mapped",[1135]],[[1135,1135],"valid"],[[1136,1136],"mapped",[1137]],[[1137,1137],"valid"],[[1138,1138],"mapped",[1139]],[[1139,1139],"valid"],[[1140,1140],"mapped",[1141]],[[1141,1141],"valid"],[[1142,1142],"mapped",[1143]],[[1143,1143],"valid"],[[1144,1144],"mapped",[1145]],[[1145,1145],"valid"],[[1146,1146],"mapped",[1147]],[[1147,1147],"valid"],[[1148,1148],"mapped",[1149]],[[1149,1149],"valid"],[[1150,1150],"mapped",[1151]],[[1151,1151],"valid"],[[1152,1152],"mapped",[1153]],[[1153,1153],"valid"],[[1154,1154],"valid",[],"NV8"],[[1155,1158],"valid"],[[1159,1159],"valid"],[[1160,1161],"valid",[],"NV8"],[[1162,1162],"mapped",[1163]],[[1163,1163],"valid"],[[1164,1164],"mapped",[1165]],[[1165,1165],"valid"],[[1166,1166],"mapped",[1167]],[[1167,1167],"valid"],[[1168,1168],"mapped",[1169]],[[1169,1169],"valid"],[[1170,1170],"mapped",[1171]],[[1171,1171],"valid"],[[1172,1172],"mapped",[1173]],[[1173,1173],"valid"],[[1174,1174],"mapped",[1175]],[[1175,1175],"valid"],[[1176,1176],"mapped",[1177]],[[1177,1177],"valid"],[[1178,1178],"mapped",[1179]],[[1179,1179],"valid"],[[1180,1180],"mapped",[1181]],[[1181,1181],"valid"],[[1182,1182],"mapped",[1183]],[[1183,1183],"valid"],[[1184,1184],"mapped",[1185]],[[1185,1185],"valid"],[[1186,1186],"mapped",[1187]],[[1187,1187],"valid"],[[1188,1188],"mapped",[1189]],[[1189,1189],"valid"],[[1190,1190],"mapped",[1191]],[[1191,1191],"valid"],[[1192,1192],"mapped",[1193]],[[1193,1193],"valid"],[[1194,1194],"mapped",[1195]],[[1195,1195],"valid"],[[1196,1196],"mapped",[1197]],[[1197,1197],"valid"],[[1198,1198],"mapped",[1199]],[[1199,1199],"valid"],[[1200,1200],"mapped",[1201]],[[1201,1201],"valid"],[[1202,1202],"mapped",[1203]],[[1203,1203],"valid"],[[1204,1204],"mapped",[1205]],[[1205,1205],"valid"],[[1206,1206],"mapped",[1207]],[[1207,1207],"valid"],[[1208,1208],"mapped",[1209]],[[1209,1209],"valid"],[[1210,1210],"mapped",[1211]],[[1211,1211],"valid"],[[1212,1212],"mapped",[1213]],[[1213,1213],"valid"],[[1214,1214],"mapped",[1215]],[[1215,1215],"valid"],[[1216,1216],"disallowed"],[[1217,1217],"mapped",[1218]],[[1218,1218],"valid"],[[1219,1219],"mapped",[1220]],[[1220,1220],"valid"],[[1221,1221],"mapped",[1222]],[[1222,1222],"valid"],[[1223,1223],"mapped",[1224]],[[1224,1224],"valid"],[[1225,1225],"mapped",[1226]],[[1226,1226],"valid"],[[1227,1227],"mapped",[1228]],[[1228,1228],"valid"],[[1229,1229],"mapped",[1230]],[[1230,1230],"valid"],[[1231,1231],"valid"],[[1232,1232],"mapped",[1233]],[[1233,1233],"valid"],[[1234,1234],"mapped",[1235]],[[1235,1235],"valid"],[[1236,1236],"mapped",[1237]],[[1237,1237],"valid"],[[1238,1238],"mapped",[1239]],[[1239,1239],"valid"],[[1240,1240],"mapped",[1241]],[[1241,1241],"valid"],[[1242,1242],"mapped",[1243]],[[1243,1243],"valid"],[[1244,1244],"mapped",[1245]],[[1245,1245],"valid"],[[1246,1246],"mapped",[1247]],[[1247,1247],"valid"],[[1248,1248],"mapped",[1249]],[[1249,1249],"valid"],[[1250,1250],"mapped",[1251]],[[1251,1251],"valid"],[[1252,1252],"mapped",[1253]],[[1253,1253],"valid"],[[1254,1254],"mapped",[1255]],[[1255,1255],"valid"],[[1256,1256],"mapped",[1257]],[[1257,1257],"valid"],[[1258,1258],"mapped",[1259]],[[1259,1259],"valid"],[[1260,1260],"mapped",[1261]],[[1261,1261],"valid"],[[1262,1262],"mapped",[1263]],[[1263,1263],"valid"],[[1264,1264],"mapped",[1265]],[[1265,1265],"valid"],[[1266,1266],"mapped",[1267]],[[1267,1267],"valid"],[[1268,1268],"mapped",[1269]],[[1269,1269],"valid"],[[1270,1270],"mapped",[1271]],[[1271,1271],"valid"],[[1272,1272],"mapped",[1273]],[[1273,1273],"valid"],[[1274,1274],"mapped",[1275]],[[1275,1275],"valid"],[[1276,1276],"mapped",[1277]],[[1277,1277],"valid"],[[1278,1278],"mapped",[1279]],[[1279,1279],"valid"],[[1280,1280],"mapped",[1281]],[[1281,1281],"valid"],[[1282,1282],"mapped",[1283]],[[1283,1283],"valid"],[[1284,1284],"mapped",[1285]],[[1285,1285],"valid"],[[1286,1286],"mapped",[1287]],[[1287,1287],"valid"],[[1288,1288],"mapped",[1289]],[[1289,1289],"valid"],[[1290,1290],"mapped",[1291]],[[1291,1291],"valid"],[[1292,1292],"mapped",[1293]],[[1293,1293],"valid"],[[1294,1294],"mapped",[1295]],[[1295,1295],"valid"],[[1296,1296],"mapped",[1297]],[[1297,1297],"valid"],[[1298,1298],"mapped",[1299]],[[1299,1299],"valid"],[[1300,1300],"mapped",[1301]],[[1301,1301],"valid"],[[1302,1302],"mapped",[1303]],[[1303,1303],"valid"],[[1304,1304],"mapped",[1305]],[[1305,1305],"valid"],[[1306,1306],"mapped",[1307]],[[1307,1307],"valid"],[[1308,1308],"mapped",[1309]],[[1309,1309],"valid"],[[1310,1310],"mapped",[1311]],[[1311,1311],"valid"],[[1312,1312],"mapped",[1313]],[[1313,1313],"valid"],[[1314,1314],"mapped",[1315]],[[1315,1315],"valid"],[[1316,1316],"mapped",[1317]],[[1317,1317],"valid"],[[1318,1318],"mapped",[1319]],[[1319,1319],"valid"],[[1320,1320],"mapped",[1321]],[[1321,1321],"valid"],[[1322,1322],"mapped",[1323]],[[1323,1323],"valid"],[[1324,1324],"mapped",[1325]],[[1325,1325],"valid"],[[1326,1326],"mapped",[1327]],[[1327,1327],"valid"],[[1328,1328],"disallowed"],[[1329,1329],"mapped",[1377]],[[1330,1330],"mapped",[1378]],[[1331,1331],"mapped",[1379]],[[1332,1332],"mapped",[1380]],[[1333,1333],"mapped",[1381]],[[1334,1334],"mapped",[1382]],[[1335,1335],"mapped",[1383]],[[1336,1336],"mapped",[1384]],[[1337,1337],"mapped",[1385]],[[1338,1338],"mapped",[1386]],[[1339,1339],"mapped",[1387]],[[1340,1340],"mapped",[1388]],[[1341,1341],"mapped",[1389]],[[1342,1342],"mapped",[1390]],[[1343,1343],"mapped",[1391]],[[1344,1344],"mapped",[1392]],[[1345,1345],"mapped",[1393]],[[1346,1346],"mapped",[1394]],[[1347,1347],"mapped",[1395]],[[1348,1348],"mapped",[1396]],[[1349,1349],"mapped",[1397]],[[1350,1350],"mapped",[1398]],[[1351,1351],"mapped",[1399]],[[1352,1352],"mapped",[1400]],[[1353,1353],"mapped",[1401]],[[1354,1354],"mapped",[1402]],[[1355,1355],"mapped",[1403]],[[1356,1356],"mapped",[1404]],[[1357,1357],"mapped",[1405]],[[1358,1358],"mapped",[1406]],[[1359,1359],"mapped",[1407]],[[1360,1360],"mapped",[1408]],[[1361,1361],"mapped",[1409]],[[1362,1362],"mapped",[1410]],[[1363,1363],"mapped",[1411]],[[1364,1364],"mapped",[1412]],[[1365,1365],"mapped",[1413]],[[1366,1366],"mapped",[1414]],[[1367,1368],"disallowed"],[[1369,1369],"valid"],[[1370,1375],"valid",[],"NV8"],[[1376,1376],"disallowed"],[[1377,1414],"valid"],[[1415,1415],"mapped",[1381,1410]],[[1416,1416],"disallowed"],[[1417,1417],"valid",[],"NV8"],[[1418,1418],"valid",[],"NV8"],[[1419,1420],"disallowed"],[[1421,1422],"valid",[],"NV8"],[[1423,1423],"valid",[],"NV8"],[[1424,1424],"disallowed"],[[1425,1441],"valid"],[[1442,1442],"valid"],[[1443,1455],"valid"],[[1456,1465],"valid"],[[1466,1466],"valid"],[[1467,1469],"valid"],[[1470,1470],"valid",[],"NV8"],[[1471,1471],"valid"],[[1472,1472],"valid",[],"NV8"],[[1473,1474],"valid"],[[1475,1475],"valid",[],"NV8"],[[1476,1476],"valid"],[[1477,1477],"valid"],[[1478,1478],"valid",[],"NV8"],[[1479,1479],"valid"],[[1480,1487],"disallowed"],[[1488,1514],"valid"],[[1515,1519],"disallowed"],[[1520,1524],"valid"],[[1525,1535],"disallowed"],[[1536,1539],"disallowed"],[[1540,1540],"disallowed"],[[1541,1541],"disallowed"],[[1542,1546],"valid",[],"NV8"],[[1547,1547],"valid",[],"NV8"],[[1548,1548],"valid",[],"NV8"],[[1549,1551],"valid",[],"NV8"],[[1552,1557],"valid"],[[1558,1562],"valid"],[[1563,1563],"valid",[],"NV8"],[[1564,1564],"disallowed"],[[1565,1565],"disallowed"],[[1566,1566],"valid",[],"NV8"],[[1567,1567],"valid",[],"NV8"],[[1568,1568],"valid"],[[1569,1594],"valid"],[[1595,1599],"valid"],[[1600,1600],"valid",[],"NV8"],[[1601,1618],"valid"],[[1619,1621],"valid"],[[1622,1624],"valid"],[[1625,1630],"valid"],[[1631,1631],"valid"],[[1632,1641],"valid"],[[1642,1645],"valid",[],"NV8"],[[1646,1647],"valid"],[[1648,1652],"valid"],[[1653,1653],"mapped",[1575,1652]],[[1654,1654],"mapped",[1608,1652]],[[1655,1655],"mapped",[1735,1652]],[[1656,1656],"mapped",[1610,1652]],[[1657,1719],"valid"],[[1720,1721],"valid"],[[1722,1726],"valid"],[[1727,1727],"valid"],[[1728,1742],"valid"],[[1743,1743],"valid"],[[1744,1747],"valid"],[[1748,1748],"valid",[],"NV8"],[[1749,1756],"valid"],[[1757,1757],"disallowed"],[[1758,1758],"valid",[],"NV8"],[[1759,1768],"valid"],[[1769,1769],"valid",[],"NV8"],[[1770,1773],"valid"],[[1774,1775],"valid"],[[1776,1785],"valid"],[[1786,1790],"valid"],[[1791,1791],"valid"],[[1792,1805],"valid",[],"NV8"],[[1806,1806],"disallowed"],[[1807,1807],"disallowed"],[[1808,1836],"valid"],[[1837,1839],"valid"],[[1840,1866],"valid"],[[1867,1868],"disallowed"],[[1869,1871],"valid"],[[1872,1901],"valid"],[[1902,1919],"valid"],[[1920,1968],"valid"],[[1969,1969],"valid"],[[1970,1983],"disallowed"],[[1984,2037],"valid"],[[2038,2042],"valid",[],"NV8"],[[2043,2047],"disallowed"],[[2048,2093],"valid"],[[2094,2095],"disallowed"],[[2096,2110],"valid",[],"NV8"],[[2111,2111],"disallowed"],[[2112,2139],"valid"],[[2140,2141],"disallowed"],[[2142,2142],"valid",[],"NV8"],[[2143,2207],"disallowed"],[[2208,2208],"valid"],[[2209,2209],"valid"],[[2210,2220],"valid"],[[2221,2226],"valid"],[[2227,2228],"valid"],[[2229,2274],"disallowed"],[[2275,2275],"valid"],[[2276,2302],"valid"],[[2303,2303],"valid"],[[2304,2304],"valid"],[[2305,2307],"valid"],[[2308,2308],"valid"],[[2309,2361],"valid"],[[2362,2363],"valid"],[[2364,2381],"valid"],[[2382,2382],"valid"],[[2383,2383],"valid"],[[2384,2388],"valid"],[[2389,2389],"valid"],[[2390,2391],"valid"],[[2392,2392],"mapped",[2325,2364]],[[2393,2393],"mapped",[2326,2364]],[[2394,2394],"mapped",[2327,2364]],[[2395,2395],"mapped",[2332,2364]],[[2396,2396],"mapped",[2337,2364]],[[2397,2397],"mapped",[2338,2364]],[[2398,2398],"mapped",[2347,2364]],[[2399,2399],"mapped",[2351,2364]],[[2400,2403],"valid"],[[2404,2405],"valid",[],"NV8"],[[2406,2415],"valid"],[[2416,2416],"valid",[],"NV8"],[[2417,2418],"valid"],[[2419,2423],"valid"],[[2424,2424],"valid"],[[2425,2426],"valid"],[[2427,2428],"valid"],[[2429,2429],"valid"],[[2430,2431],"valid"],[[2432,2432],"valid"],[[2433,2435],"valid"],[[2436,2436],"disallowed"],[[2437,2444],"valid"],[[2445,2446],"disallowed"],[[2447,2448],"valid"],[[2449,2450],"disallowed"],[[2451,2472],"valid"],[[2473,2473],"disallowed"],[[2474,2480],"valid"],[[2481,2481],"disallowed"],[[2482,2482],"valid"],[[2483,2485],"disallowed"],[[2486,2489],"valid"],[[2490,2491],"disallowed"],[[2492,2492],"valid"],[[2493,2493],"valid"],[[2494,2500],"valid"],[[2501,2502],"disallowed"],[[2503,2504],"valid"],[[2505,2506],"disallowed"],[[2507,2509],"valid"],[[2510,2510],"valid"],[[2511,2518],"disallowed"],[[2519,2519],"valid"],[[2520,2523],"disallowed"],[[2524,2524],"mapped",[2465,2492]],[[2525,2525],"mapped",[2466,2492]],[[2526,2526],"disallowed"],[[2527,2527],"mapped",[2479,2492]],[[2528,2531],"valid"],[[2532,2533],"disallowed"],[[2534,2545],"valid"],[[2546,2554],"valid",[],"NV8"],[[2555,2555],"valid",[],"NV8"],[[2556,2560],"disallowed"],[[2561,2561],"valid"],[[2562,2562],"valid"],[[2563,2563],"valid"],[[2564,2564],"disallowed"],[[2565,2570],"valid"],[[2571,2574],"disallowed"],[[2575,2576],"valid"],[[2577,2578],"disallowed"],[[2579,2600],"valid"],[[2601,2601],"disallowed"],[[2602,2608],"valid"],[[2609,2609],"disallowed"],[[2610,2610],"valid"],[[2611,2611],"mapped",[2610,2620]],[[2612,2612],"disallowed"],[[2613,2613],"valid"],[[2614,2614],"mapped",[2616,2620]],[[2615,2615],"disallowed"],[[2616,2617],"valid"],[[2618,2619],"disallowed"],[[2620,2620],"valid"],[[2621,2621],"disallowed"],[[2622,2626],"valid"],[[2627,2630],"disallowed"],[[2631,2632],"valid"],[[2633,2634],"disallowed"],[[2635,2637],"valid"],[[2638,2640],"disallowed"],[[2641,2641],"valid"],[[2642,2648],"disallowed"],[[2649,2649],"mapped",[2582,2620]],[[2650,2650],"mapped",[2583,2620]],[[2651,2651],"mapped",[2588,2620]],[[2652,2652],"valid"],[[2653,2653],"disallowed"],[[2654,2654],"mapped",[2603,2620]],[[2655,2661],"disallowed"],[[2662,2676],"valid"],[[2677,2677],"valid"],[[2678,2688],"disallowed"],[[2689,2691],"valid"],[[2692,2692],"disallowed"],[[2693,2699],"valid"],[[2700,2700],"valid"],[[2701,2701],"valid"],[[2702,2702],"disallowed"],[[2703,2705],"valid"],[[2706,2706],"disallowed"],[[2707,2728],"valid"],[[2729,2729],"disallowed"],[[2730,2736],"valid"],[[2737,2737],"disallowed"],[[2738,2739],"valid"],[[2740,2740],"disallowed"],[[2741,2745],"valid"],[[2746,2747],"disallowed"],[[2748,2757],"valid"],[[2758,2758],"disallowed"],[[2759,2761],"valid"],[[2762,2762],"disallowed"],[[2763,2765],"valid"],[[2766,2767],"disallowed"],[[2768,2768],"valid"],[[2769,2783],"disallowed"],[[2784,2784],"valid"],[[2785,2787],"valid"],[[2788,2789],"disallowed"],[[2790,2799],"valid"],[[2800,2800],"valid",[],"NV8"],[[2801,2801],"valid",[],"NV8"],[[2802,2808],"disallowed"],[[2809,2809],"valid"],[[2810,2816],"disallowed"],[[2817,2819],"valid"],[[2820,2820],"disallowed"],[[2821,2828],"valid"],[[2829,2830],"disallowed"],[[2831,2832],"valid"],[[2833,2834],"disallowed"],[[2835,2856],"valid"],[[2857,2857],"disallowed"],[[2858,2864],"valid"],[[2865,2865],"disallowed"],[[2866,2867],"valid"],[[2868,2868],"disallowed"],[[2869,2869],"valid"],[[2870,2873],"valid"],[[2874,2875],"disallowed"],[[2876,2883],"valid"],[[2884,2884],"valid"],[[2885,2886],"disallowed"],[[2887,2888],"valid"],[[2889,2890],"disallowed"],[[2891,2893],"valid"],[[2894,2901],"disallowed"],[[2902,2903],"valid"],[[2904,2907],"disallowed"],[[2908,2908],"mapped",[2849,2876]],[[2909,2909],"mapped",[2850,2876]],[[2910,2910],"disallowed"],[[2911,2913],"valid"],[[2914,2915],"valid"],[[2916,2917],"disallowed"],[[2918,2927],"valid"],[[2928,2928],"valid",[],"NV8"],[[2929,2929],"valid"],[[2930,2935],"valid",[],"NV8"],[[2936,2945],"disallowed"],[[2946,2947],"valid"],[[2948,2948],"disallowed"],[[2949,2954],"valid"],[[2955,2957],"disallowed"],[[2958,2960],"valid"],[[2961,2961],"disallowed"],[[2962,2965],"valid"],[[2966,2968],"disallowed"],[[2969,2970],"valid"],[[2971,2971],"disallowed"],[[2972,2972],"valid"],[[2973,2973],"disallowed"],[[2974,2975],"valid"],[[2976,2978],"disallowed"],[[2979,2980],"valid"],[[2981,2983],"disallowed"],[[2984,2986],"valid"],[[2987,2989],"disallowed"],[[2990,2997],"valid"],[[2998,2998],"valid"],[[2999,3001],"valid"],[[3002,3005],"disallowed"],[[3006,3010],"valid"],[[3011,3013],"disallowed"],[[3014,3016],"valid"],[[3017,3017],"disallowed"],[[3018,3021],"valid"],[[3022,3023],"disallowed"],[[3024,3024],"valid"],[[3025,3030],"disallowed"],[[3031,3031],"valid"],[[3032,3045],"disallowed"],[[3046,3046],"valid"],[[3047,3055],"valid"],[[3056,3058],"valid",[],"NV8"],[[3059,3066],"valid",[],"NV8"],[[3067,3071],"disallowed"],[[3072,3072],"valid"],[[3073,3075],"valid"],[[3076,3076],"disallowed"],[[3077,3084],"valid"],[[3085,3085],"disallowed"],[[3086,3088],"valid"],[[3089,3089],"disallowed"],[[3090,3112],"valid"],[[3113,3113],"disallowed"],[[3114,3123],"valid"],[[3124,3124],"valid"],[[3125,3129],"valid"],[[3130,3132],"disallowed"],[[3133,3133],"valid"],[[3134,3140],"valid"],[[3141,3141],"disallowed"],[[3142,3144],"valid"],[[3145,3145],"disallowed"],[[3146,3149],"valid"],[[3150,3156],"disallowed"],[[3157,3158],"valid"],[[3159,3159],"disallowed"],[[3160,3161],"valid"],[[3162,3162],"valid"],[[3163,3167],"disallowed"],[[3168,3169],"valid"],[[3170,3171],"valid"],[[3172,3173],"disallowed"],[[3174,3183],"valid"],[[3184,3191],"disallowed"],[[3192,3199],"valid",[],"NV8"],[[3200,3200],"disallowed"],[[3201,3201],"valid"],[[3202,3203],"valid"],[[3204,3204],"disallowed"],[[3205,3212],"valid"],[[3213,3213],"disallowed"],[[3214,3216],"valid"],[[3217,3217],"disallowed"],[[3218,3240],"valid"],[[3241,3241],"disallowed"],[[3242,3251],"valid"],[[3252,3252],"disallowed"],[[3253,3257],"valid"],[[3258,3259],"disallowed"],[[3260,3261],"valid"],[[3262,3268],"valid"],[[3269,3269],"disallowed"],[[3270,3272],"valid"],[[3273,3273],"disallowed"],[[3274,3277],"valid"],[[3278,3284],"disallowed"],[[3285,3286],"valid"],[[3287,3293],"disallowed"],[[3294,3294],"valid"],[[3295,3295],"disallowed"],[[3296,3297],"valid"],[[3298,3299],"valid"],[[3300,3301],"disallowed"],[[3302,3311],"valid"],[[3312,3312],"disallowed"],[[3313,3314],"valid"],[[3315,3328],"disallowed"],[[3329,3329],"valid"],[[3330,3331],"valid"],[[3332,3332],"disallowed"],[[3333,3340],"valid"],[[3341,3341],"disallowed"],[[3342,3344],"valid"],[[3345,3345],"disallowed"],[[3346,3368],"valid"],[[3369,3369],"valid"],[[3370,3385],"valid"],[[3386,3386],"valid"],[[3387,3388],"disallowed"],[[3389,3389],"valid"],[[3390,3395],"valid"],[[3396,3396],"valid"],[[3397,3397],"disallowed"],[[3398,3400],"valid"],[[3401,3401],"disallowed"],[[3402,3405],"valid"],[[3406,3406],"valid"],[[3407,3414],"disallowed"],[[3415,3415],"valid"],[[3416,3422],"disallowed"],[[3423,3423],"valid"],[[3424,3425],"valid"],[[3426,3427],"valid"],[[3428,3429],"disallowed"],[[3430,3439],"valid"],[[3440,3445],"valid",[],"NV8"],[[3446,3448],"disallowed"],[[3449,3449],"valid",[],"NV8"],[[3450,3455],"valid"],[[3456,3457],"disallowed"],[[3458,3459],"valid"],[[3460,3460],"disallowed"],[[3461,3478],"valid"],[[3479,3481],"disallowed"],[[3482,3505],"valid"],[[3506,3506],"disallowed"],[[3507,3515],"valid"],[[3516,3516],"disallowed"],[[3517,3517],"valid"],[[3518,3519],"disallowed"],[[3520,3526],"valid"],[[3527,3529],"disallowed"],[[3530,3530],"valid"],[[3531,3534],"disallowed"],[[3535,3540],"valid"],[[3541,3541],"disallowed"],[[3542,3542],"valid"],[[3543,3543],"disallowed"],[[3544,3551],"valid"],[[3552,3557],"disallowed"],[[3558,3567],"valid"],[[3568,3569],"disallowed"],[[3570,3571],"valid"],[[3572,3572],"valid",[],"NV8"],[[3573,3584],"disallowed"],[[3585,3634],"valid"],[[3635,3635],"mapped",[3661,3634]],[[3636,3642],"valid"],[[3643,3646],"disallowed"],[[3647,3647],"valid",[],"NV8"],[[3648,3662],"valid"],[[3663,3663],"valid",[],"NV8"],[[3664,3673],"valid"],[[3674,3675],"valid",[],"NV8"],[[3676,3712],"disallowed"],[[3713,3714],"valid"],[[3715,3715],"disallowed"],[[3716,3716],"valid"],[[3717,3718],"disallowed"],[[3719,3720],"valid"],[[3721,3721],"disallowed"],[[3722,3722],"valid"],[[3723,3724],"disallowed"],[[3725,3725],"valid"],[[3726,3731],"disallowed"],[[3732,3735],"valid"],[[3736,3736],"disallowed"],[[3737,3743],"valid"],[[3744,3744],"disallowed"],[[3745,3747],"valid"],[[3748,3748],"disallowed"],[[3749,3749],"valid"],[[3750,3750],"disallowed"],[[3751,3751],"valid"],[[3752,3753],"disallowed"],[[3754,3755],"valid"],[[3756,3756],"disallowed"],[[3757,3762],"valid"],[[3763,3763],"mapped",[3789,3762]],[[3764,3769],"valid"],[[3770,3770],"disallowed"],[[3771,3773],"valid"],[[3774,3775],"disallowed"],[[3776,3780],"valid"],[[3781,3781],"disallowed"],[[3782,3782],"valid"],[[3783,3783],"disallowed"],[[3784,3789],"valid"],[[3790,3791],"disallowed"],[[3792,3801],"valid"],[[3802,3803],"disallowed"],[[3804,3804],"mapped",[3755,3737]],[[3805,3805],"mapped",[3755,3745]],[[3806,3807],"valid"],[[3808,3839],"disallowed"],[[3840,3840],"valid"],[[3841,3850],"valid",[],"NV8"],[[3851,3851],"valid"],[[3852,3852],"mapped",[3851]],[[3853,3863],"valid",[],"NV8"],[[3864,3865],"valid"],[[3866,3871],"valid",[],"NV8"],[[3872,3881],"valid"],[[3882,3892],"valid",[],"NV8"],[[3893,3893],"valid"],[[3894,3894],"valid",[],"NV8"],[[3895,3895],"valid"],[[3896,3896],"valid",[],"NV8"],[[3897,3897],"valid"],[[3898,3901],"valid",[],"NV8"],[[3902,3906],"valid"],[[3907,3907],"mapped",[3906,4023]],[[3908,3911],"valid"],[[3912,3912],"disallowed"],[[3913,3916],"valid"],[[3917,3917],"mapped",[3916,4023]],[[3918,3921],"valid"],[[3922,3922],"mapped",[3921,4023]],[[3923,3926],"valid"],[[3927,3927],"mapped",[3926,4023]],[[3928,3931],"valid"],[[3932,3932],"mapped",[3931,4023]],[[3933,3944],"valid"],[[3945,3945],"mapped",[3904,4021]],[[3946,3946],"valid"],[[3947,3948],"valid"],[[3949,3952],"disallowed"],[[3953,3954],"valid"],[[3955,3955],"mapped",[3953,3954]],[[3956,3956],"valid"],[[3957,3957],"mapped",[3953,3956]],[[3958,3958],"mapped",[4018,3968]],[[3959,3959],"mapped",[4018,3953,3968]],[[3960,3960],"mapped",[4019,3968]],[[3961,3961],"mapped",[4019,3953,3968]],[[3962,3968],"valid"],[[3969,3969],"mapped",[3953,3968]],[[3970,3972],"valid"],[[3973,3973],"valid",[],"NV8"],[[3974,3979],"valid"],[[3980,3983],"valid"],[[3984,3986],"valid"],[[3987,3987],"mapped",[3986,4023]],[[3988,3989],"valid"],[[3990,3990],"valid"],[[3991,3991],"valid"],[[3992,3992],"disallowed"],[[3993,3996],"valid"],[[3997,3997],"mapped",[3996,4023]],[[3998,4001],"valid"],[[4002,4002],"mapped",[4001,4023]],[[4003,4006],"valid"],[[4007,4007],"mapped",[4006,4023]],[[4008,4011],"valid"],[[4012,4012],"mapped",[4011,4023]],[[4013,4013],"valid"],[[4014,4016],"valid"],[[4017,4023],"valid"],[[4024,4024],"valid"],[[4025,4025],"mapped",[3984,4021]],[[4026,4028],"valid"],[[4029,4029],"disallowed"],[[4030,4037],"valid",[],"NV8"],[[4038,4038],"valid"],[[4039,4044],"valid",[],"NV8"],[[4045,4045],"disallowed"],[[4046,4046],"valid",[],"NV8"],[[4047,4047],"valid",[],"NV8"],[[4048,4049],"valid",[],"NV8"],[[4050,4052],"valid",[],"NV8"],[[4053,4056],"valid",[],"NV8"],[[4057,4058],"valid",[],"NV8"],[[4059,4095],"disallowed"],[[4096,4129],"valid"],[[4130,4130],"valid"],[[4131,4135],"valid"],[[4136,4136],"valid"],[[4137,4138],"valid"],[[4139,4139],"valid"],[[4140,4146],"valid"],[[4147,4149],"valid"],[[4150,4153],"valid"],[[4154,4159],"valid"],[[4160,4169],"valid"],[[4170,4175],"valid",[],"NV8"],[[4176,4185],"valid"],[[4186,4249],"valid"],[[4250,4253],"valid"],[[4254,4255],"valid",[],"NV8"],[[4256,4293],"disallowed"],[[4294,4294],"disallowed"],[[4295,4295],"mapped",[11559]],[[4296,4300],"disallowed"],[[4301,4301],"mapped",[11565]],[[4302,4303],"disallowed"],[[4304,4342],"valid"],[[4343,4344],"valid"],[[4345,4346],"valid"],[[4347,4347],"valid",[],"NV8"],[[4348,4348],"mapped",[4316]],[[4349,4351],"valid"],[[4352,4441],"valid",[],"NV8"],[[4442,4446],"valid",[],"NV8"],[[4447,4448],"disallowed"],[[4449,4514],"valid",[],"NV8"],[[4515,4519],"valid",[],"NV8"],[[4520,4601],"valid",[],"NV8"],[[4602,4607],"valid",[],"NV8"],[[4608,4614],"valid"],[[4615,4615],"valid"],[[4616,4678],"valid"],[[4679,4679],"valid"],[[4680,4680],"valid"],[[4681,4681],"disallowed"],[[4682,4685],"valid"],[[4686,4687],"disallowed"],[[4688,4694],"valid"],[[4695,4695],"disallowed"],[[4696,4696],"valid"],[[4697,4697],"disallowed"],[[4698,4701],"valid"],[[4702,4703],"disallowed"],[[4704,4742],"valid"],[[4743,4743],"valid"],[[4744,4744],"valid"],[[4745,4745],"disallowed"],[[4746,4749],"valid"],[[4750,4751],"disallowed"],[[4752,4782],"valid"],[[4783,4783],"valid"],[[4784,4784],"valid"],[[4785,4785],"disallowed"],[[4786,4789],"valid"],[[4790,4791],"disallowed"],[[4792,4798],"valid"],[[4799,4799],"disallowed"],[[4800,4800],"valid"],[[4801,4801],"disallowed"],[[4802,4805],"valid"],[[4806,4807],"disallowed"],[[4808,4814],"valid"],[[4815,4815],"valid"],[[4816,4822],"valid"],[[4823,4823],"disallowed"],[[4824,4846],"valid"],[[4847,4847],"valid"],[[4848,4878],"valid"],[[4879,4879],"valid"],[[4880,4880],"valid"],[[4881,4881],"disallowed"],[[4882,4885],"valid"],[[4886,4887],"disallowed"],[[4888,4894],"valid"],[[4895,4895],"valid"],[[4896,4934],"valid"],[[4935,4935],"valid"],[[4936,4954],"valid"],[[4955,4956],"disallowed"],[[4957,4958],"valid"],[[4959,4959],"valid"],[[4960,4960],"valid",[],"NV8"],[[4961,4988],"valid",[],"NV8"],[[4989,4991],"disallowed"],[[4992,5007],"valid"],[[5008,5017],"valid",[],"NV8"],[[5018,5023],"disallowed"],[[5024,5108],"valid"],[[5109,5109],"valid"],[[5110,5111],"disallowed"],[[5112,5112],"mapped",[5104]],[[5113,5113],"mapped",[5105]],[[5114,5114],"mapped",[5106]],[[5115,5115],"mapped",[5107]],[[5116,5116],"mapped",[5108]],[[5117,5117],"mapped",[5109]],[[5118,5119],"disallowed"],[[5120,5120],"valid",[],"NV8"],[[5121,5740],"valid"],[[5741,5742],"valid",[],"NV8"],[[5743,5750],"valid"],[[5751,5759],"valid"],[[5760,5760],"disallowed"],[[5761,5786],"valid"],[[5787,5788],"valid",[],"NV8"],[[5789,5791],"disallowed"],[[5792,5866],"valid"],[[5867,5872],"valid",[],"NV8"],[[5873,5880],"valid"],[[5881,5887],"disallowed"],[[5888,5900],"valid"],[[5901,5901],"disallowed"],[[5902,5908],"valid"],[[5909,5919],"disallowed"],[[5920,5940],"valid"],[[5941,5942],"valid",[],"NV8"],[[5943,5951],"disallowed"],[[5952,5971],"valid"],[[5972,5983],"disallowed"],[[5984,5996],"valid"],[[5997,5997],"disallowed"],[[5998,6000],"valid"],[[6001,6001],"disallowed"],[[6002,6003],"valid"],[[6004,6015],"disallowed"],[[6016,6067],"valid"],[[6068,6069],"disallowed"],[[6070,6099],"valid"],[[6100,6102],"valid",[],"NV8"],[[6103,6103],"valid"],[[6104,6107],"valid",[],"NV8"],[[6108,6108],"valid"],[[6109,6109],"valid"],[[6110,6111],"disallowed"],[[6112,6121],"valid"],[[6122,6127],"disallowed"],[[6128,6137],"valid",[],"NV8"],[[6138,6143],"disallowed"],[[6144,6149],"valid",[],"NV8"],[[6150,6150],"disallowed"],[[6151,6154],"valid",[],"NV8"],[[6155,6157],"ignored"],[[6158,6158],"disallowed"],[[6159,6159],"disallowed"],[[6160,6169],"valid"],[[6170,6175],"disallowed"],[[6176,6263],"valid"],[[6264,6271],"disallowed"],[[6272,6313],"valid"],[[6314,6314],"valid"],[[6315,6319],"disallowed"],[[6320,6389],"valid"],[[6390,6399],"disallowed"],[[6400,6428],"valid"],[[6429,6430],"valid"],[[6431,6431],"disallowed"],[[6432,6443],"valid"],[[6444,6447],"disallowed"],[[6448,6459],"valid"],[[6460,6463],"disallowed"],[[6464,6464],"valid",[],"NV8"],[[6465,6467],"disallowed"],[[6468,6469],"valid",[],"NV8"],[[6470,6509],"valid"],[[6510,6511],"disallowed"],[[6512,6516],"valid"],[[6517,6527],"disallowed"],[[6528,6569],"valid"],[[6570,6571],"valid"],[[6572,6575],"disallowed"],[[6576,6601],"valid"],[[6602,6607],"disallowed"],[[6608,6617],"valid"],[[6618,6618],"valid",[],"XV8"],[[6619,6621],"disallowed"],[[6622,6623],"valid",[],"NV8"],[[6624,6655],"valid",[],"NV8"],[[6656,6683],"valid"],[[6684,6685],"disallowed"],[[6686,6687],"valid",[],"NV8"],[[6688,6750],"valid"],[[6751,6751],"disallowed"],[[6752,6780],"valid"],[[6781,6782],"disallowed"],[[6783,6793],"valid"],[[6794,6799],"disallowed"],[[6800,6809],"valid"],[[6810,6815],"disallowed"],[[6816,6822],"valid",[],"NV8"],[[6823,6823],"valid"],[[6824,6829],"valid",[],"NV8"],[[6830,6831],"disallowed"],[[6832,6845],"valid"],[[6846,6846],"valid",[],"NV8"],[[6847,6911],"disallowed"],[[6912,6987],"valid"],[[6988,6991],"disallowed"],[[6992,7001],"valid"],[[7002,7018],"valid",[],"NV8"],[[7019,7027],"valid"],[[7028,7036],"valid",[],"NV8"],[[7037,7039],"disallowed"],[[7040,7082],"valid"],[[7083,7085],"valid"],[[7086,7097],"valid"],[[7098,7103],"valid"],[[7104,7155],"valid"],[[7156,7163],"disallowed"],[[7164,7167],"valid",[],"NV8"],[[7168,7223],"valid"],[[7224,7226],"disallowed"],[[7227,7231],"valid",[],"NV8"],[[7232,7241],"valid"],[[7242,7244],"disallowed"],[[7245,7293],"valid"],[[7294,7295],"valid",[],"NV8"],[[7296,7359],"disallowed"],[[7360,7367],"valid",[],"NV8"],[[7368,7375],"disallowed"],[[7376,7378],"valid"],[[7379,7379],"valid",[],"NV8"],[[7380,7410],"valid"],[[7411,7414],"valid"],[[7415,7415],"disallowed"],[[7416,7417],"valid"],[[7418,7423],"disallowed"],[[7424,7467],"valid"],[[7468,7468],"mapped",[97]],[[7469,7469],"mapped",[230]],[[7470,7470],"mapped",[98]],[[7471,7471],"valid"],[[7472,7472],"mapped",[100]],[[7473,7473],"mapped",[101]],[[7474,7474],"mapped",[477]],[[7475,7475],"mapped",[103]],[[7476,7476],"mapped",[104]],[[7477,7477],"mapped",[105]],[[7478,7478],"mapped",[106]],[[7479,7479],"mapped",[107]],[[7480,7480],"mapped",[108]],[[7481,7481],"mapped",[109]],[[7482,7482],"mapped",[110]],[[7483,7483],"valid"],[[7484,7484],"mapped",[111]],[[7485,7485],"mapped",[547]],[[7486,7486],"mapped",[112]],[[7487,7487],"mapped",[114]],[[7488,7488],"mapped",[116]],[[7489,7489],"mapped",[117]],[[7490,7490],"mapped",[119]],[[7491,7491],"mapped",[97]],[[7492,7492],"mapped",[592]],[[7493,7493],"mapped",[593]],[[7494,7494],"mapped",[7426]],[[7495,7495],"mapped",[98]],[[7496,7496],"mapped",[100]],[[7497,7497],"mapped",[101]],[[7498,7498],"mapped",[601]],[[7499,7499],"mapped",[603]],[[7500,7500],"mapped",[604]],[[7501,7501],"mapped",[103]],[[7502,7502],"valid"],[[7503,7503],"mapped",[107]],[[7504,7504],"mapped",[109]],[[7505,7505],"mapped",[331]],[[7506,7506],"mapped",[111]],[[7507,7507],"mapped",[596]],[[7508,7508],"mapped",[7446]],[[7509,7509],"mapped",[7447]],[[7510,7510],"mapped",[112]],[[7511,7511],"mapped",[116]],[[7512,7512],"mapped",[117]],[[7513,7513],"mapped",[7453]],[[7514,7514],"mapped",[623]],[[7515,7515],"mapped",[118]],[[7516,7516],"mapped",[7461]],[[7517,7517],"mapped",[946]],[[7518,7518],"mapped",[947]],[[7519,7519],"mapped",[948]],[[7520,7520],"mapped",[966]],[[7521,7521],"mapped",[967]],[[7522,7522],"mapped",[105]],[[7523,7523],"mapped",[114]],[[7524,7524],"mapped",[117]],[[7525,7525],"mapped",[118]],[[7526,7526],"mapped",[946]],[[7527,7527],"mapped",[947]],[[7528,7528],"mapped",[961]],[[7529,7529],"mapped",[966]],[[7530,7530],"mapped",[967]],[[7531,7531],"valid"],[[7532,7543],"valid"],[[7544,7544],"mapped",[1085]],[[7545,7578],"valid"],[[7579,7579],"mapped",[594]],[[7580,7580],"mapped",[99]],[[7581,7581],"mapped",[597]],[[7582,7582],"mapped",[240]],[[7583,7583],"mapped",[604]],[[7584,7584],"mapped",[102]],[[7585,7585],"mapped",[607]],[[7586,7586],"mapped",[609]],[[7587,7587],"mapped",[613]],[[7588,7588],"mapped",[616]],[[7589,7589],"mapped",[617]],[[7590,7590],"mapped",[618]],[[7591,7591],"mapped",[7547]],[[7592,7592],"mapped",[669]],[[7593,7593],"mapped",[621]],[[7594,7594],"mapped",[7557]],[[7595,7595],"mapped",[671]],[[7596,7596],"mapped",[625]],[[7597,7597],"mapped",[624]],[[7598,7598],"mapped",[626]],[[7599,7599],"mapped",[627]],[[7600,7600],"mapped",[628]],[[7601,7601],"mapped",[629]],[[7602,7602],"mapped",[632]],[[7603,7603],"mapped",[642]],[[7604,7604],"mapped",[643]],[[7605,7605],"mapped",[427]],[[7606,7606],"mapped",[649]],[[7607,7607],"mapped",[650]],[[7608,7608],"mapped",[7452]],[[7609,7609],"mapped",[651]],[[7610,7610],"mapped",[652]],[[7611,7611],"mapped",[122]],[[7612,7612],"mapped",[656]],[[7613,7613],"mapped",[657]],[[7614,7614],"mapped",[658]],[[7615,7615],"mapped",[952]],[[7616,7619],"valid"],[[7620,7626],"valid"],[[7627,7654],"valid"],[[7655,7669],"valid"],[[7670,7675],"disallowed"],[[7676,7676],"valid"],[[7677,7677],"valid"],[[7678,7679],"valid"],[[7680,7680],"mapped",[7681]],[[7681,7681],"valid"],[[7682,7682],"mapped",[7683]],[[7683,7683],"valid"],[[7684,7684],"mapped",[7685]],[[7685,7685],"valid"],[[7686,7686],"mapped",[7687]],[[7687,7687],"valid"],[[7688,7688],"mapped",[7689]],[[7689,7689],"valid"],[[7690,7690],"mapped",[7691]],[[7691,7691],"valid"],[[7692,7692],"mapped",[7693]],[[7693,7693],"valid"],[[7694,7694],"mapped",[7695]],[[7695,7695],"valid"],[[7696,7696],"mapped",[7697]],[[7697,7697],"valid"],[[7698,7698],"mapped",[7699]],[[7699,7699],"valid"],[[7700,7700],"mapped",[7701]],[[7701,7701],"valid"],[[7702,7702],"mapped",[7703]],[[7703,7703],"valid"],[[7704,7704],"mapped",[7705]],[[7705,7705],"valid"],[[7706,7706],"mapped",[7707]],[[7707,7707],"valid"],[[7708,7708],"mapped",[7709]],[[7709,7709],"valid"],[[7710,7710],"mapped",[7711]],[[7711,7711],"valid"],[[7712,7712],"mapped",[7713]],[[7713,7713],"valid"],[[7714,7714],"mapped",[7715]],[[7715,7715],"valid"],[[7716,7716],"mapped",[7717]],[[7717,7717],"valid"],[[7718,7718],"mapped",[7719]],[[7719,7719],"valid"],[[7720,7720],"mapped",[7721]],[[7721,7721],"valid"],[[7722,7722],"mapped",[7723]],[[7723,7723],"valid"],[[7724,7724],"mapped",[7725]],[[7725,7725],"valid"],[[7726,7726],"mapped",[7727]],[[7727,7727],"valid"],[[7728,7728],"mapped",[7729]],[[7729,7729],"valid"],[[7730,7730],"mapped",[7731]],[[7731,7731],"valid"],[[7732,7732],"mapped",[7733]],[[7733,7733],"valid"],[[7734,7734],"mapped",[7735]],[[7735,7735],"valid"],[[7736,7736],"mapped",[7737]],[[7737,7737],"valid"],[[7738,7738],"mapped",[7739]],[[7739,7739],"valid"],[[7740,7740],"mapped",[7741]],[[7741,7741],"valid"],[[7742,7742],"mapped",[7743]],[[7743,7743],"valid"],[[7744,7744],"mapped",[7745]],[[7745,7745],"valid"],[[7746,7746],"mapped",[7747]],[[7747,7747],"valid"],[[7748,7748],"mapped",[7749]],[[7749,7749],"valid"],[[7750,7750],"mapped",[7751]],[[7751,7751],"valid"],[[7752,7752],"mapped",[7753]],[[7753,7753],"valid"],[[7754,7754],"mapped",[7755]],[[7755,7755],"valid"],[[7756,7756],"mapped",[7757]],[[7757,7757],"valid"],[[7758,7758],"mapped",[7759]],[[7759,7759],"valid"],[[7760,7760],"mapped",[7761]],[[7761,7761],"valid"],[[7762,7762],"mapped",[7763]],[[7763,7763],"valid"],[[7764,7764],"mapped",[7765]],[[7765,7765],"valid"],[[7766,7766],"mapped",[7767]],[[7767,7767],"valid"],[[7768,7768],"mapped",[7769]],[[7769,7769],"valid"],[[7770,7770],"mapped",[7771]],[[7771,7771],"valid"],[[7772,7772],"mapped",[7773]],[[7773,7773],"valid"],[[7774,7774],"mapped",[7775]],[[7775,7775],"valid"],[[7776,7776],"mapped",[7777]],[[7777,7777],"valid"],[[7778,7778],"mapped",[7779]],[[7779,7779],"valid"],[[7780,7780],"mapped",[7781]],[[7781,7781],"valid"],[[7782,7782],"mapped",[7783]],[[7783,7783],"valid"],[[7784,7784],"mapped",[7785]],[[7785,7785],"valid"],[[7786,7786],"mapped",[7787]],[[7787,7787],"valid"],[[7788,7788],"mapped",[7789]],[[7789,7789],"valid"],[[7790,7790],"mapped",[7791]],[[7791,7791],"valid"],[[7792,7792],"mapped",[7793]],[[7793,7793],"valid"],[[7794,7794],"mapped",[7795]],[[7795,7795],"valid"],[[7796,7796],"mapped",[7797]],[[7797,7797],"valid"],[[7798,7798],"mapped",[7799]],[[7799,7799],"valid"],[[7800,7800],"mapped",[7801]],[[7801,7801],"valid"],[[7802,7802],"mapped",[7803]],[[7803,7803],"valid"],[[7804,7804],"mapped",[7805]],[[7805,7805],"valid"],[[7806,7806],"mapped",[7807]],[[7807,7807],"valid"],[[7808,7808],"mapped",[7809]],[[7809,7809],"valid"],[[7810,7810],"mapped",[7811]],[[7811,7811],"valid"],[[7812,7812],"mapped",[7813]],[[7813,7813],"valid"],[[7814,7814],"mapped",[7815]],[[7815,7815],"valid"],[[7816,7816],"mapped",[7817]],[[7817,7817],"valid"],[[7818,7818],"mapped",[7819]],[[7819,7819],"valid"],[[7820,7820],"mapped",[7821]],[[7821,7821],"valid"],[[7822,7822],"mapped",[7823]],[[7823,7823],"valid"],[[7824,7824],"mapped",[7825]],[[7825,7825],"valid"],[[7826,7826],"mapped",[7827]],[[7827,7827],"valid"],[[7828,7828],"mapped",[7829]],[[7829,7833],"valid"],[[7834,7834],"mapped",[97,702]],[[7835,7835],"mapped",[7777]],[[7836,7837],"valid"],[[7838,7838],"mapped",[115,115]],[[7839,7839],"valid"],[[7840,7840],"mapped",[7841]],[[7841,7841],"valid"],[[7842,7842],"mapped",[7843]],[[7843,7843],"valid"],[[7844,7844],"mapped",[7845]],[[7845,7845],"valid"],[[7846,7846],"mapped",[7847]],[[7847,7847],"valid"],[[7848,7848],"mapped",[7849]],[[7849,7849],"valid"],[[7850,7850],"mapped",[7851]],[[7851,7851],"valid"],[[7852,7852],"mapped",[7853]],[[7853,7853],"valid"],[[7854,7854],"mapped",[7855]],[[7855,7855],"valid"],[[7856,7856],"mapped",[7857]],[[7857,7857],"valid"],[[7858,7858],"mapped",[7859]],[[7859,7859],"valid"],[[7860,7860],"mapped",[7861]],[[7861,7861],"valid"],[[7862,7862],"mapped",[7863]],[[7863,7863],"valid"],[[7864,7864],"mapped",[7865]],[[7865,7865],"valid"],[[7866,7866],"mapped",[7867]],[[7867,7867],"valid"],[[7868,7868],"mapped",[7869]],[[7869,7869],"valid"],[[7870,7870],"mapped",[7871]],[[7871,7871],"valid"],[[7872,7872],"mapped",[7873]],[[7873,7873],"valid"],[[7874,7874],"mapped",[7875]],[[7875,7875],"valid"],[[7876,7876],"mapped",[7877]],[[7877,7877],"valid"],[[7878,7878],"mapped",[7879]],[[7879,7879],"valid"],[[7880,7880],"mapped",[7881]],[[7881,7881],"valid"],[[7882,7882],"mapped",[7883]],[[7883,7883],"valid"],[[7884,7884],"mapped",[7885]],[[7885,7885],"valid"],[[7886,7886],"mapped",[7887]],[[7887,7887],"valid"],[[7888,7888],"mapped",[7889]],[[7889,7889],"valid"],[[7890,7890],"mapped",[7891]],[[7891,7891],"valid"],[[7892,7892],"mapped",[7893]],[[7893,7893],"valid"],[[7894,7894],"mapped",[7895]],[[7895,7895],"valid"],[[7896,7896],"mapped",[7897]],[[7897,7897],"valid"],[[7898,7898],"mapped",[7899]],[[7899,7899],"valid"],[[7900,7900],"mapped",[7901]],[[7901,7901],"valid"],[[7902,7902],"mapped",[7903]],[[7903,7903],"valid"],[[7904,7904],"mapped",[7905]],[[7905,7905],"valid"],[[7906,7906],"mapped",[7907]],[[7907,7907],"valid"],[[7908,7908],"mapped",[7909]],[[7909,7909],"valid"],[[7910,7910],"mapped",[7911]],[[7911,7911],"valid"],[[7912,7912],"mapped",[7913]],[[7913,7913],"valid"],[[7914,7914],"mapped",[7915]],[[7915,7915],"valid"],[[7916,7916],"mapped",[7917]],[[7917,7917],"valid"],[[7918,7918],"mapped",[7919]],[[7919,7919],"valid"],[[7920,7920],"mapped",[7921]],[[7921,7921],"valid"],[[7922,7922],"mapped",[7923]],[[7923,7923],"valid"],[[7924,7924],"mapped",[7925]],[[7925,7925],"valid"],[[7926,7926],"mapped",[7927]],[[7927,7927],"valid"],[[7928,7928],"mapped",[7929]],[[7929,7929],"valid"],[[7930,7930],"mapped",[7931]],[[7931,7931],"valid"],[[7932,7932],"mapped",[7933]],[[7933,7933],"valid"],[[7934,7934],"mapped",[7935]],[[7935,7935],"valid"],[[7936,7943],"valid"],[[7944,7944],"mapped",[7936]],[[7945,7945],"mapped",[7937]],[[7946,7946],"mapped",[7938]],[[7947,7947],"mapped",[7939]],[[7948,7948],"mapped",[7940]],[[7949,7949],"mapped",[7941]],[[7950,7950],"mapped",[7942]],[[7951,7951],"mapped",[7943]],[[7952,7957],"valid"],[[7958,7959],"disallowed"],[[7960,7960],"mapped",[7952]],[[7961,7961],"mapped",[7953]],[[7962,7962],"mapped",[7954]],[[7963,7963],"mapped",[7955]],[[7964,7964],"mapped",[7956]],[[7965,7965],"mapped",[7957]],[[7966,7967],"disallowed"],[[7968,7975],"valid"],[[7976,7976],"mapped",[7968]],[[7977,7977],"mapped",[7969]],[[7978,7978],"mapped",[7970]],[[7979,7979],"mapped",[7971]],[[7980,7980],"mapped",[7972]],[[7981,7981],"mapped",[7973]],[[7982,7982],"mapped",[7974]],[[7983,7983],"mapped",[7975]],[[7984,7991],"valid"],[[7992,7992],"mapped",[7984]],[[7993,7993],"mapped",[7985]],[[7994,7994],"mapped",[7986]],[[7995,7995],"mapped",[7987]],[[7996,7996],"mapped",[7988]],[[7997,7997],"mapped",[7989]],[[7998,7998],"mapped",[7990]],[[7999,7999],"mapped",[7991]],[[8000,8005],"valid"],[[8006,8007],"disallowed"],[[8008,8008],"mapped",[8000]],[[8009,8009],"mapped",[8001]],[[8010,8010],"mapped",[8002]],[[8011,8011],"mapped",[8003]],[[8012,8012],"mapped",[8004]],[[8013,8013],"mapped",[8005]],[[8014,8015],"disallowed"],[[8016,8023],"valid"],[[8024,8024],"disallowed"],[[8025,8025],"mapped",[8017]],[[8026,8026],"disallowed"],[[8027,8027],"mapped",[8019]],[[8028,8028],"disallowed"],[[8029,8029],"mapped",[8021]],[[8030,8030],"disallowed"],[[8031,8031],"mapped",[8023]],[[8032,8039],"valid"],[[8040,8040],"mapped",[8032]],[[8041,8041],"mapped",[8033]],[[8042,8042],"mapped",[8034]],[[8043,8043],"mapped",[8035]],[[8044,8044],"mapped",[8036]],[[8045,8045],"mapped",[8037]],[[8046,8046],"mapped",[8038]],[[8047,8047],"mapped",[8039]],[[8048,8048],"valid"],[[8049,8049],"mapped",[940]],[[8050,8050],"valid"],[[8051,8051],"mapped",[941]],[[8052,8052],"valid"],[[8053,8053],"mapped",[942]],[[8054,8054],"valid"],[[8055,8055],"mapped",[943]],[[8056,8056],"valid"],[[8057,8057],"mapped",[972]],[[8058,8058],"valid"],[[8059,8059],"mapped",[973]],[[8060,8060],"valid"],[[8061,8061],"mapped",[974]],[[8062,8063],"disallowed"],[[8064,8064],"mapped",[7936,953]],[[8065,8065],"mapped",[7937,953]],[[8066,8066],"mapped",[7938,953]],[[8067,8067],"mapped",[7939,953]],[[8068,8068],"mapped",[7940,953]],[[8069,8069],"mapped",[7941,953]],[[8070,8070],"mapped",[7942,953]],[[8071,8071],"mapped",[7943,953]],[[8072,8072],"mapped",[7936,953]],[[8073,8073],"mapped",[7937,953]],[[8074,8074],"mapped",[7938,953]],[[8075,8075],"mapped",[7939,953]],[[8076,8076],"mapped",[7940,953]],[[8077,8077],"mapped",[7941,953]],[[8078,8078],"mapped",[7942,953]],[[8079,8079],"mapped",[7943,953]],[[8080,8080],"mapped",[7968,953]],[[8081,8081],"mapped",[7969,953]],[[8082,8082],"mapped",[7970,953]],[[8083,8083],"mapped",[7971,953]],[[8084,8084],"mapped",[7972,953]],[[8085,8085],"mapped",[7973,953]],[[8086,8086],"mapped",[7974,953]],[[8087,8087],"mapped",[7975,953]],[[8088,8088],"mapped",[7968,953]],[[8089,8089],"mapped",[7969,953]],[[8090,8090],"mapped",[7970,953]],[[8091,8091],"mapped",[7971,953]],[[8092,8092],"mapped",[7972,953]],[[8093,8093],"mapped",[7973,953]],[[8094,8094],"mapped",[7974,953]],[[8095,8095],"mapped",[7975,953]],[[8096,8096],"mapped",[8032,953]],[[8097,8097],"mapped",[8033,953]],[[8098,8098],"mapped",[8034,953]],[[8099,8099],"mapped",[8035,953]],[[8100,8100],"mapped",[8036,953]],[[8101,8101],"mapped",[8037,953]],[[8102,8102],"mapped",[8038,953]],[[8103,8103],"mapped",[8039,953]],[[8104,8104],"mapped",[8032,953]],[[8105,8105],"mapped",[8033,953]],[[8106,8106],"mapped",[8034,953]],[[8107,8107],"mapped",[8035,953]],[[8108,8108],"mapped",[8036,953]],[[8109,8109],"mapped",[8037,953]],[[8110,8110],"mapped",[8038,953]],[[8111,8111],"mapped",[8039,953]],[[8112,8113],"valid"],[[8114,8114],"mapped",[8048,953]],[[8115,8115],"mapped",[945,953]],[[8116,8116],"mapped",[940,953]],[[8117,8117],"disallowed"],[[8118,8118],"valid"],[[8119,8119],"mapped",[8118,953]],[[8120,8120],"mapped",[8112]],[[8121,8121],"mapped",[8113]],[[8122,8122],"mapped",[8048]],[[8123,8123],"mapped",[940]],[[8124,8124],"mapped",[945,953]],[[8125,8125],"disallowed_STD3_mapped",[32,787]],[[8126,8126],"mapped",[953]],[[8127,8127],"disallowed_STD3_mapped",[32,787]],[[8128,8128],"disallowed_STD3_mapped",[32,834]],[[8129,8129],"disallowed_STD3_mapped",[32,776,834]],[[8130,8130],"mapped",[8052,953]],[[8131,8131],"mapped",[951,953]],[[8132,8132],"mapped",[942,953]],[[8133,8133],"disallowed"],[[8134,8134],"valid"],[[8135,8135],"mapped",[8134,953]],[[8136,8136],"mapped",[8050]],[[8137,8137],"mapped",[941]],[[8138,8138],"mapped",[8052]],[[8139,8139],"mapped",[942]],[[8140,8140],"mapped",[951,953]],[[8141,8141],"disallowed_STD3_mapped",[32,787,768]],[[8142,8142],"disallowed_STD3_mapped",[32,787,769]],[[8143,8143],"disallowed_STD3_mapped",[32,787,834]],[[8144,8146],"valid"],[[8147,8147],"mapped",[912]],[[8148,8149],"disallowed"],[[8150,8151],"valid"],[[8152,8152],"mapped",[8144]],[[8153,8153],"mapped",[8145]],[[8154,8154],"mapped",[8054]],[[8155,8155],"mapped",[943]],[[8156,8156],"disallowed"],[[8157,8157],"disallowed_STD3_mapped",[32,788,768]],[[8158,8158],"disallowed_STD3_mapped",[32,788,769]],[[8159,8159],"disallowed_STD3_mapped",[32,788,834]],[[8160,8162],"valid"],[[8163,8163],"mapped",[944]],[[8164,8167],"valid"],[[8168,8168],"mapped",[8160]],[[8169,8169],"mapped",[8161]],[[8170,8170],"mapped",[8058]],[[8171,8171],"mapped",[973]],[[8172,8172],"mapped",[8165]],[[8173,8173],"disallowed_STD3_mapped",[32,776,768]],[[8174,8174],"disallowed_STD3_mapped",[32,776,769]],[[8175,8175],"disallowed_STD3_mapped",[96]],[[8176,8177],"disallowed"],[[8178,8178],"mapped",[8060,953]],[[8179,8179],"mapped",[969,953]],[[8180,8180],"mapped",[974,953]],[[8181,8181],"disallowed"],[[8182,8182],"valid"],[[8183,8183],"mapped",[8182,953]],[[8184,8184],"mapped",[8056]],[[8185,8185],"mapped",[972]],[[8186,8186],"mapped",[8060]],[[8187,8187],"mapped",[974]],[[8188,8188],"mapped",[969,953]],[[8189,8189],"disallowed_STD3_mapped",[32,769]],[[8190,8190],"disallowed_STD3_mapped",[32,788]],[[8191,8191],"disallowed"],[[8192,8202],"disallowed_STD3_mapped",[32]],[[8203,8203],"ignored"],[[8204,8205],"deviation",[]],[[8206,8207],"disallowed"],[[8208,8208],"valid",[],"NV8"],[[8209,8209],"mapped",[8208]],[[8210,8214],"valid",[],"NV8"],[[8215,8215],"disallowed_STD3_mapped",[32,819]],[[8216,8227],"valid",[],"NV8"],[[8228,8230],"disallowed"],[[8231,8231],"valid",[],"NV8"],[[8232,8238],"disallowed"],[[8239,8239],"disallowed_STD3_mapped",[32]],[[8240,8242],"valid",[],"NV8"],[[8243,8243],"mapped",[8242,8242]],[[8244,8244],"mapped",[8242,8242,8242]],[[8245,8245],"valid",[],"NV8"],[[8246,8246],"mapped",[8245,8245]],[[8247,8247],"mapped",[8245,8245,8245]],[[8248,8251],"valid",[],"NV8"],[[8252,8252],"disallowed_STD3_mapped",[33,33]],[[8253,8253],"valid",[],"NV8"],[[8254,8254],"disallowed_STD3_mapped",[32,773]],[[8255,8262],"valid",[],"NV8"],[[8263,8263],"disallowed_STD3_mapped",[63,63]],[[8264,8264],"disallowed_STD3_mapped",[63,33]],[[8265,8265],"disallowed_STD3_mapped",[33,63]],[[8266,8269],"valid",[],"NV8"],[[8270,8274],"valid",[],"NV8"],[[8275,8276],"valid",[],"NV8"],[[8277,8278],"valid",[],"NV8"],[[8279,8279],"mapped",[8242,8242,8242,8242]],[[8280,8286],"valid",[],"NV8"],[[8287,8287],"disallowed_STD3_mapped",[32]],[[8288,8288],"ignored"],[[8289,8291],"disallowed"],[[8292,8292],"ignored"],[[8293,8293],"disallowed"],[[8294,8297],"disallowed"],[[8298,8303],"disallowed"],[[8304,8304],"mapped",[48]],[[8305,8305],"mapped",[105]],[[8306,8307],"disallowed"],[[8308,8308],"mapped",[52]],[[8309,8309],"mapped",[53]],[[8310,8310],"mapped",[54]],[[8311,8311],"mapped",[55]],[[8312,8312],"mapped",[56]],[[8313,8313],"mapped",[57]],[[8314,8314],"disallowed_STD3_mapped",[43]],[[8315,8315],"mapped",[8722]],[[8316,8316],"disallowed_STD3_mapped",[61]],[[8317,8317],"disallowed_STD3_mapped",[40]],[[8318,8318],"disallowed_STD3_mapped",[41]],[[8319,8319],"mapped",[110]],[[8320,8320],"mapped",[48]],[[8321,8321],"mapped",[49]],[[8322,8322],"mapped",[50]],[[8323,8323],"mapped",[51]],[[8324,8324],"mapped",[52]],[[8325,8325],"mapped",[53]],[[8326,8326],"mapped",[54]],[[8327,8327],"mapped",[55]],[[8328,8328],"mapped",[56]],[[8329,8329],"mapped",[57]],[[8330,8330],"disallowed_STD3_mapped",[43]],[[8331,8331],"mapped",[8722]],[[8332,8332],"disallowed_STD3_mapped",[61]],[[8333,8333],"disallowed_STD3_mapped",[40]],[[8334,8334],"disallowed_STD3_mapped",[41]],[[8335,8335],"disallowed"],[[8336,8336],"mapped",[97]],[[8337,8337],"mapped",[101]],[[8338,8338],"mapped",[111]],[[8339,8339],"mapped",[120]],[[8340,8340],"mapped",[601]],[[8341,8341],"mapped",[104]],[[8342,8342],"mapped",[107]],[[8343,8343],"mapped",[108]],[[8344,8344],"mapped",[109]],[[8345,8345],"mapped",[110]],[[8346,8346],"mapped",[112]],[[8347,8347],"mapped",[115]],[[8348,8348],"mapped",[116]],[[8349,8351],"disallowed"],[[8352,8359],"valid",[],"NV8"],[[8360,8360],"mapped",[114,115]],[[8361,8362],"valid",[],"NV8"],[[8363,8363],"valid",[],"NV8"],[[8364,8364],"valid",[],"NV8"],[[8365,8367],"valid",[],"NV8"],[[8368,8369],"valid",[],"NV8"],[[8370,8373],"valid",[],"NV8"],[[8374,8376],"valid",[],"NV8"],[[8377,8377],"valid",[],"NV8"],[[8378,8378],"valid",[],"NV8"],[[8379,8381],"valid",[],"NV8"],[[8382,8382],"valid",[],"NV8"],[[8383,8399],"disallowed"],[[8400,8417],"valid",[],"NV8"],[[8418,8419],"valid",[],"NV8"],[[8420,8426],"valid",[],"NV8"],[[8427,8427],"valid",[],"NV8"],[[8428,8431],"valid",[],"NV8"],[[8432,8432],"valid",[],"NV8"],[[8433,8447],"disallowed"],[[8448,8448],"disallowed_STD3_mapped",[97,47,99]],[[8449,8449],"disallowed_STD3_mapped",[97,47,115]],[[8450,8450],"mapped",[99]],[[8451,8451],"mapped",[176,99]],[[8452,8452],"valid",[],"NV8"],[[8453,8453],"disallowed_STD3_mapped",[99,47,111]],[[8454,8454],"disallowed_STD3_mapped",[99,47,117]],[[8455,8455],"mapped",[603]],[[8456,8456],"valid",[],"NV8"],[[8457,8457],"mapped",[176,102]],[[8458,8458],"mapped",[103]],[[8459,8462],"mapped",[104]],[[8463,8463],"mapped",[295]],[[8464,8465],"mapped",[105]],[[8466,8467],"mapped",[108]],[[8468,8468],"valid",[],"NV8"],[[8469,8469],"mapped",[110]],[[8470,8470],"mapped",[110,111]],[[8471,8472],"valid",[],"NV8"],[[8473,8473],"mapped",[112]],[[8474,8474],"mapped",[113]],[[8475,8477],"mapped",[114]],[[8478,8479],"valid",[],"NV8"],[[8480,8480],"mapped",[115,109]],[[8481,8481],"mapped",[116,101,108]],[[8482,8482],"mapped",[116,109]],[[8483,8483],"valid",[],"NV8"],[[8484,8484],"mapped",[122]],[[8485,8485],"valid",[],"NV8"],[[8486,8486],"mapped",[969]],[[8487,8487],"valid",[],"NV8"],[[8488,8488],"mapped",[122]],[[8489,8489],"valid",[],"NV8"],[[8490,8490],"mapped",[107]],[[8491,8491],"mapped",[229]],[[8492,8492],"mapped",[98]],[[8493,8493],"mapped",[99]],[[8494,8494],"valid",[],"NV8"],[[8495,8496],"mapped",[101]],[[8497,8497],"mapped",[102]],[[8498,8498],"disallowed"],[[8499,8499],"mapped",[109]],[[8500,8500],"mapped",[111]],[[8501,8501],"mapped",[1488]],[[8502,8502],"mapped",[1489]],[[8503,8503],"mapped",[1490]],[[8504,8504],"mapped",[1491]],[[8505,8505],"mapped",[105]],[[8506,8506],"valid",[],"NV8"],[[8507,8507],"mapped",[102,97,120]],[[8508,8508],"mapped",[960]],[[8509,8510],"mapped",[947]],[[8511,8511],"mapped",[960]],[[8512,8512],"mapped",[8721]],[[8513,8516],"valid",[],"NV8"],[[8517,8518],"mapped",[100]],[[8519,8519],"mapped",[101]],[[8520,8520],"mapped",[105]],[[8521,8521],"mapped",[106]],[[8522,8523],"valid",[],"NV8"],[[8524,8524],"valid",[],"NV8"],[[8525,8525],"valid",[],"NV8"],[[8526,8526],"valid"],[[8527,8527],"valid",[],"NV8"],[[8528,8528],"mapped",[49,8260,55]],[[8529,8529],"mapped",[49,8260,57]],[[8530,8530],"mapped",[49,8260,49,48]],[[8531,8531],"mapped",[49,8260,51]],[[8532,8532],"mapped",[50,8260,51]],[[8533,8533],"mapped",[49,8260,53]],[[8534,8534],"mapped",[50,8260,53]],[[8535,8535],"mapped",[51,8260,53]],[[8536,8536],"mapped",[52,8260,53]],[[8537,8537],"mapped",[49,8260,54]],[[8538,8538],"mapped",[53,8260,54]],[[8539,8539],"mapped",[49,8260,56]],[[8540,8540],"mapped",[51,8260,56]],[[8541,8541],"mapped",[53,8260,56]],[[8542,8542],"mapped",[55,8260,56]],[[8543,8543],"mapped",[49,8260]],[[8544,8544],"mapped",[105]],[[8545,8545],"mapped",[105,105]],[[8546,8546],"mapped",[105,105,105]],[[8547,8547],"mapped",[105,118]],[[8548,8548],"mapped",[118]],[[8549,8549],"mapped",[118,105]],[[8550,8550],"mapped",[118,105,105]],[[8551,8551],"mapped",[118,105,105,105]],[[8552,8552],"mapped",[105,120]],[[8553,8553],"mapped",[120]],[[8554,8554],"mapped",[120,105]],[[8555,8555],"mapped",[120,105,105]],[[8556,8556],"mapped",[108]],[[8557,8557],"mapped",[99]],[[8558,8558],"mapped",[100]],[[8559,8559],"mapped",[109]],[[8560,8560],"mapped",[105]],[[8561,8561],"mapped",[105,105]],[[8562,8562],"mapped",[105,105,105]],[[8563,8563],"mapped",[105,118]],[[8564,8564],"mapped",[118]],[[8565,8565],"mapped",[118,105]],[[8566,8566],"mapped",[118,105,105]],[[8567,8567],"mapped",[118,105,105,105]],[[8568,8568],"mapped",[105,120]],[[8569,8569],"mapped",[120]],[[8570,8570],"mapped",[120,105]],[[8571,8571],"mapped",[120,105,105]],[[8572,8572],"mapped",[108]],[[8573,8573],"mapped",[99]],[[8574,8574],"mapped",[100]],[[8575,8575],"mapped",[109]],[[8576,8578],"valid",[],"NV8"],[[8579,8579],"disallowed"],[[8580,8580],"valid"],[[8581,8584],"valid",[],"NV8"],[[8585,8585],"mapped",[48,8260,51]],[[8586,8587],"valid",[],"NV8"],[[8588,8591],"disallowed"],[[8592,8682],"valid",[],"NV8"],[[8683,8691],"valid",[],"NV8"],[[8692,8703],"valid",[],"NV8"],[[8704,8747],"valid",[],"NV8"],[[8748,8748],"mapped",[8747,8747]],[[8749,8749],"mapped",[8747,8747,8747]],[[8750,8750],"valid",[],"NV8"],[[8751,8751],"mapped",[8750,8750]],[[8752,8752],"mapped",[8750,8750,8750]],[[8753,8799],"valid",[],"NV8"],[[8800,8800],"disallowed_STD3_valid"],[[8801,8813],"valid",[],"NV8"],[[8814,8815],"disallowed_STD3_valid"],[[8816,8945],"valid",[],"NV8"],[[8946,8959],"valid",[],"NV8"],[[8960,8960],"valid",[],"NV8"],[[8961,8961],"valid",[],"NV8"],[[8962,9000],"valid",[],"NV8"],[[9001,9001],"mapped",[12296]],[[9002,9002],"mapped",[12297]],[[9003,9082],"valid",[],"NV8"],[[9083,9083],"valid",[],"NV8"],[[9084,9084],"valid",[],"NV8"],[[9085,9114],"valid",[],"NV8"],[[9115,9166],"valid",[],"NV8"],[[9167,9168],"valid",[],"NV8"],[[9169,9179],"valid",[],"NV8"],[[9180,9191],"valid",[],"NV8"],[[9192,9192],"valid",[],"NV8"],[[9193,9203],"valid",[],"NV8"],[[9204,9210],"valid",[],"NV8"],[[9211,9215],"disallowed"],[[9216,9252],"valid",[],"NV8"],[[9253,9254],"valid",[],"NV8"],[[9255,9279],"disallowed"],[[9280,9290],"valid",[],"NV8"],[[9291,9311],"disallowed"],[[9312,9312],"mapped",[49]],[[9313,9313],"mapped",[50]],[[9314,9314],"mapped",[51]],[[9315,9315],"mapped",[52]],[[9316,9316],"mapped",[53]],[[9317,9317],"mapped",[54]],[[9318,9318],"mapped",[55]],[[9319,9319],"mapped",[56]],[[9320,9320],"mapped",[57]],[[9321,9321],"mapped",[49,48]],[[9322,9322],"mapped",[49,49]],[[9323,9323],"mapped",[49,50]],[[9324,9324],"mapped",[49,51]],[[9325,9325],"mapped",[49,52]],[[9326,9326],"mapped",[49,53]],[[9327,9327],"mapped",[49,54]],[[9328,9328],"mapped",[49,55]],[[9329,9329],"mapped",[49,56]],[[9330,9330],"mapped",[49,57]],[[9331,9331],"mapped",[50,48]],[[9332,9332],"disallowed_STD3_mapped",[40,49,41]],[[9333,9333],"disallowed_STD3_mapped",[40,50,41]],[[9334,9334],"disallowed_STD3_mapped",[40,51,41]],[[9335,9335],"disallowed_STD3_mapped",[40,52,41]],[[9336,9336],"disallowed_STD3_mapped",[40,53,41]],[[9337,9337],"disallowed_STD3_mapped",[40,54,41]],[[9338,9338],"disallowed_STD3_mapped",[40,55,41]],[[9339,9339],"disallowed_STD3_mapped",[40,56,41]],[[9340,9340],"disallowed_STD3_mapped",[40,57,41]],[[9341,9341],"disallowed_STD3_mapped",[40,49,48,41]],[[9342,9342],"disallowed_STD3_mapped",[40,49,49,41]],[[9343,9343],"disallowed_STD3_mapped",[40,49,50,41]],[[9344,9344],"disallowed_STD3_mapped",[40,49,51,41]],[[9345,9345],"disallowed_STD3_mapped",[40,49,52,41]],[[9346,9346],"disallowed_STD3_mapped",[40,49,53,41]],[[9347,9347],"disallowed_STD3_mapped",[40,49,54,41]],[[9348,9348],"disallowed_STD3_mapped",[40,49,55,41]],[[9349,9349],"disallowed_STD3_mapped",[40,49,56,41]],[[9350,9350],"disallowed_STD3_mapped",[40,49,57,41]],[[9351,9351],"disallowed_STD3_mapped",[40,50,48,41]],[[9352,9371],"disallowed"],[[9372,9372],"disallowed_STD3_mapped",[40,97,41]],[[9373,9373],"disallowed_STD3_mapped",[40,98,41]],[[9374,9374],"disallowed_STD3_mapped",[40,99,41]],[[9375,9375],"disallowed_STD3_mapped",[40,100,41]],[[9376,9376],"disallowed_STD3_mapped",[40,101,41]],[[9377,9377],"disallowed_STD3_mapped",[40,102,41]],[[9378,9378],"disallowed_STD3_mapped",[40,103,41]],[[9379,9379],"disallowed_STD3_mapped",[40,104,41]],[[9380,9380],"disallowed_STD3_mapped",[40,105,41]],[[9381,9381],"disallowed_STD3_mapped",[40,106,41]],[[9382,9382],"disallowed_STD3_mapped",[40,107,41]],[[9383,9383],"disallowed_STD3_mapped",[40,108,41]],[[9384,9384],"disallowed_STD3_mapped",[40,109,41]],[[9385,9385],"disallowed_STD3_mapped",[40,110,41]],[[9386,9386],"disallowed_STD3_mapped",[40,111,41]],[[9387,9387],"disallowed_STD3_mapped",[40,112,41]],[[9388,9388],"disallowed_STD3_mapped",[40,113,41]],[[9389,9389],"disallowed_STD3_mapped",[40,114,41]],[[9390,9390],"disallowed_STD3_mapped",[40,115,41]],[[9391,9391],"disallowed_STD3_mapped",[40,116,41]],[[9392,9392],"disallowed_STD3_mapped",[40,117,41]],[[9393,9393],"disallowed_STD3_mapped",[40,118,41]],[[9394,9394],"disallowed_STD3_mapped",[40,119,41]],[[9395,9395],"disallowed_STD3_mapped",[40,120,41]],[[9396,9396],"disallowed_STD3_mapped",[40,121,41]],[[9397,9397],"disallowed_STD3_mapped",[40,122,41]],[[9398,9398],"mapped",[97]],[[9399,9399],"mapped",[98]],[[9400,9400],"mapped",[99]],[[9401,9401],"mapped",[100]],[[9402,9402],"mapped",[101]],[[9403,9403],"mapped",[102]],[[9404,9404],"mapped",[103]],[[9405,9405],"mapped",[104]],[[9406,9406],"mapped",[105]],[[9407,9407],"mapped",[106]],[[9408,9408],"mapped",[107]],[[9409,9409],"mapped",[108]],[[9410,9410],"mapped",[109]],[[9411,9411],"mapped",[110]],[[9412,9412],"mapped",[111]],[[9413,9413],"mapped",[112]],[[9414,9414],"mapped",[113]],[[9415,9415],"mapped",[114]],[[9416,9416],"mapped",[115]],[[9417,9417],"mapped",[116]],[[9418,9418],"mapped",[117]],[[9419,9419],"mapped",[118]],[[9420,9420],"mapped",[119]],[[9421,9421],"mapped",[120]],[[9422,9422],"mapped",[121]],[[9423,9423],"mapped",[122]],[[9424,9424],"mapped",[97]],[[9425,9425],"mapped",[98]],[[9426,9426],"mapped",[99]],[[9427,9427],"mapped",[100]],[[9428,9428],"mapped",[101]],[[9429,9429],"mapped",[102]],[[9430,9430],"mapped",[103]],[[9431,9431],"mapped",[104]],[[9432,9432],"mapped",[105]],[[9433,9433],"mapped",[106]],[[9434,9434],"mapped",[107]],[[9435,9435],"mapped",[108]],[[9436,9436],"mapped",[109]],[[9437,9437],"mapped",[110]],[[9438,9438],"mapped",[111]],[[9439,9439],"mapped",[112]],[[9440,9440],"mapped",[113]],[[9441,9441],"mapped",[114]],[[9442,9442],"mapped",[115]],[[9443,9443],"mapped",[116]],[[9444,9444],"mapped",[117]],[[9445,9445],"mapped",[118]],[[9446,9446],"mapped",[119]],[[9447,9447],"mapped",[120]],[[9448,9448],"mapped",[121]],[[9449,9449],"mapped",[122]],[[9450,9450],"mapped",[48]],[[9451,9470],"valid",[],"NV8"],[[9471,9471],"valid",[],"NV8"],[[9472,9621],"valid",[],"NV8"],[[9622,9631],"valid",[],"NV8"],[[9632,9711],"valid",[],"NV8"],[[9712,9719],"valid",[],"NV8"],[[9720,9727],"valid",[],"NV8"],[[9728,9747],"valid",[],"NV8"],[[9748,9749],"valid",[],"NV8"],[[9750,9751],"valid",[],"NV8"],[[9752,9752],"valid",[],"NV8"],[[9753,9753],"valid",[],"NV8"],[[9754,9839],"valid",[],"NV8"],[[9840,9841],"valid",[],"NV8"],[[9842,9853],"valid",[],"NV8"],[[9854,9855],"valid",[],"NV8"],[[9856,9865],"valid",[],"NV8"],[[9866,9873],"valid",[],"NV8"],[[9874,9884],"valid",[],"NV8"],[[9885,9885],"valid",[],"NV8"],[[9886,9887],"valid",[],"NV8"],[[9888,9889],"valid",[],"NV8"],[[9890,9905],"valid",[],"NV8"],[[9906,9906],"valid",[],"NV8"],[[9907,9916],"valid",[],"NV8"],[[9917,9919],"valid",[],"NV8"],[[9920,9923],"valid",[],"NV8"],[[9924,9933],"valid",[],"NV8"],[[9934,9934],"valid",[],"NV8"],[[9935,9953],"valid",[],"NV8"],[[9954,9954],"valid",[],"NV8"],[[9955,9955],"valid",[],"NV8"],[[9956,9959],"valid",[],"NV8"],[[9960,9983],"valid",[],"NV8"],[[9984,9984],"valid",[],"NV8"],[[9985,9988],"valid",[],"NV8"],[[9989,9989],"valid",[],"NV8"],[[9990,9993],"valid",[],"NV8"],[[9994,9995],"valid",[],"NV8"],[[9996,10023],"valid",[],"NV8"],[[10024,10024],"valid",[],"NV8"],[[10025,10059],"valid",[],"NV8"],[[10060,10060],"valid",[],"NV8"],[[10061,10061],"valid",[],"NV8"],[[10062,10062],"valid",[],"NV8"],[[10063,10066],"valid",[],"NV8"],[[10067,10069],"valid",[],"NV8"],[[10070,10070],"valid",[],"NV8"],[[10071,10071],"valid",[],"NV8"],[[10072,10078],"valid",[],"NV8"],[[10079,10080],"valid",[],"NV8"],[[10081,10087],"valid",[],"NV8"],[[10088,10101],"valid",[],"NV8"],[[10102,10132],"valid",[],"NV8"],[[10133,10135],"valid",[],"NV8"],[[10136,10159],"valid",[],"NV8"],[[10160,10160],"valid",[],"NV8"],[[10161,10174],"valid",[],"NV8"],[[10175,10175],"valid",[],"NV8"],[[10176,10182],"valid",[],"NV8"],[[10183,10186],"valid",[],"NV8"],[[10187,10187],"valid",[],"NV8"],[[10188,10188],"valid",[],"NV8"],[[10189,10189],"valid",[],"NV8"],[[10190,10191],"valid",[],"NV8"],[[10192,10219],"valid",[],"NV8"],[[10220,10223],"valid",[],"NV8"],[[10224,10239],"valid",[],"NV8"],[[10240,10495],"valid",[],"NV8"],[[10496,10763],"valid",[],"NV8"],[[10764,10764],"mapped",[8747,8747,8747,8747]],[[10765,10867],"valid",[],"NV8"],[[10868,10868],"disallowed_STD3_mapped",[58,58,61]],[[10869,10869],"disallowed_STD3_mapped",[61,61]],[[10870,10870],"disallowed_STD3_mapped",[61,61,61]],[[10871,10971],"valid",[],"NV8"],[[10972,10972],"mapped",[10973,824]],[[10973,11007],"valid",[],"NV8"],[[11008,11021],"valid",[],"NV8"],[[11022,11027],"valid",[],"NV8"],[[11028,11034],"valid",[],"NV8"],[[11035,11039],"valid",[],"NV8"],[[11040,11043],"valid",[],"NV8"],[[11044,11084],"valid",[],"NV8"],[[11085,11087],"valid",[],"NV8"],[[11088,11092],"valid",[],"NV8"],[[11093,11097],"valid",[],"NV8"],[[11098,11123],"valid",[],"NV8"],[[11124,11125],"disallowed"],[[11126,11157],"valid",[],"NV8"],[[11158,11159],"disallowed"],[[11160,11193],"valid",[],"NV8"],[[11194,11196],"disallowed"],[[11197,11208],"valid",[],"NV8"],[[11209,11209],"disallowed"],[[11210,11217],"valid",[],"NV8"],[[11218,11243],"disallowed"],[[11244,11247],"valid",[],"NV8"],[[11248,11263],"disallowed"],[[11264,11264],"mapped",[11312]],[[11265,11265],"mapped",[11313]],[[11266,11266],"mapped",[11314]],[[11267,11267],"mapped",[11315]],[[11268,11268],"mapped",[11316]],[[11269,11269],"mapped",[11317]],[[11270,11270],"mapped",[11318]],[[11271,11271],"mapped",[11319]],[[11272,11272],"mapped",[11320]],[[11273,11273],"mapped",[11321]],[[11274,11274],"mapped",[11322]],[[11275,11275],"mapped",[11323]],[[11276,11276],"mapped",[11324]],[[11277,11277],"mapped",[11325]],[[11278,11278],"mapped",[11326]],[[11279,11279],"mapped",[11327]],[[11280,11280],"mapped",[11328]],[[11281,11281],"mapped",[11329]],[[11282,11282],"mapped",[11330]],[[11283,11283],"mapped",[11331]],[[11284,11284],"mapped",[11332]],[[11285,11285],"mapped",[11333]],[[11286,11286],"mapped",[11334]],[[11287,11287],"mapped",[11335]],[[11288,11288],"mapped",[11336]],[[11289,11289],"mapped",[11337]],[[11290,11290],"mapped",[11338]],[[11291,11291],"mapped",[11339]],[[11292,11292],"mapped",[11340]],[[11293,11293],"mapped",[11341]],[[11294,11294],"mapped",[11342]],[[11295,11295],"mapped",[11343]],[[11296,11296],"mapped",[11344]],[[11297,11297],"mapped",[11345]],[[11298,11298],"mapped",[11346]],[[11299,11299],"mapped",[11347]],[[11300,11300],"mapped",[11348]],[[11301,11301],"mapped",[11349]],[[11302,11302],"mapped",[11350]],[[11303,11303],"mapped",[11351]],[[11304,11304],"mapped",[11352]],[[11305,11305],"mapped",[11353]],[[11306,11306],"mapped",[11354]],[[11307,11307],"mapped",[11355]],[[11308,11308],"mapped",[11356]],[[11309,11309],"mapped",[11357]],[[11310,11310],"mapped",[11358]],[[11311,11311],"disallowed"],[[11312,11358],"valid"],[[11359,11359],"disallowed"],[[11360,11360],"mapped",[11361]],[[11361,11361],"valid"],[[11362,11362],"mapped",[619]],[[11363,11363],"mapped",[7549]],[[11364,11364],"mapped",[637]],[[11365,11366],"valid"],[[11367,11367],"mapped",[11368]],[[11368,11368],"valid"],[[11369,11369],"mapped",[11370]],[[11370,11370],"valid"],[[11371,11371],"mapped",[11372]],[[11372,11372],"valid"],[[11373,11373],"mapped",[593]],[[11374,11374],"mapped",[625]],[[11375,11375],"mapped",[592]],[[11376,11376],"mapped",[594]],[[11377,11377],"valid"],[[11378,11378],"mapped",[11379]],[[11379,11379],"valid"],[[11380,11380],"valid"],[[11381,11381],"mapped",[11382]],[[11382,11383],"valid"],[[11384,11387],"valid"],[[11388,11388],"mapped",[106]],[[11389,11389],"mapped",[118]],[[11390,11390],"mapped",[575]],[[11391,11391],"mapped",[576]],[[11392,11392],"mapped",[11393]],[[11393,11393],"valid"],[[11394,11394],"mapped",[11395]],[[11395,11395],"valid"],[[11396,11396],"mapped",[11397]],[[11397,11397],"valid"],[[11398,11398],"mapped",[11399]],[[11399,11399],"valid"],[[11400,11400],"mapped",[11401]],[[11401,11401],"valid"],[[11402,11402],"mapped",[11403]],[[11403,11403],"valid"],[[11404,11404],"mapped",[11405]],[[11405,11405],"valid"],[[11406,11406],"mapped",[11407]],[[11407,11407],"valid"],[[11408,11408],"mapped",[11409]],[[11409,11409],"valid"],[[11410,11410],"mapped",[11411]],[[11411,11411],"valid"],[[11412,11412],"mapped",[11413]],[[11413,11413],"valid"],[[11414,11414],"mapped",[11415]],[[11415,11415],"valid"],[[11416,11416],"mapped",[11417]],[[11417,11417],"valid"],[[11418,11418],"mapped",[11419]],[[11419,11419],"valid"],[[11420,11420],"mapped",[11421]],[[11421,11421],"valid"],[[11422,11422],"mapped",[11423]],[[11423,11423],"valid"],[[11424,11424],"mapped",[11425]],[[11425,11425],"valid"],[[11426,11426],"mapped",[11427]],[[11427,11427],"valid"],[[11428,11428],"mapped",[11429]],[[11429,11429],"valid"],[[11430,11430],"mapped",[11431]],[[11431,11431],"valid"],[[11432,11432],"mapped",[11433]],[[11433,11433],"valid"],[[11434,11434],"mapped",[11435]],[[11435,11435],"valid"],[[11436,11436],"mapped",[11437]],[[11437,11437],"valid"],[[11438,11438],"mapped",[11439]],[[11439,11439],"valid"],[[11440,11440],"mapped",[11441]],[[11441,11441],"valid"],[[11442,11442],"mapped",[11443]],[[11443,11443],"valid"],[[11444,11444],"mapped",[11445]],[[11445,11445],"valid"],[[11446,11446],"mapped",[11447]],[[11447,11447],"valid"],[[11448,11448],"mapped",[11449]],[[11449,11449],"valid"],[[11450,11450],"mapped",[11451]],[[11451,11451],"valid"],[[11452,11452],"mapped",[11453]],[[11453,11453],"valid"],[[11454,11454],"mapped",[11455]],[[11455,11455],"valid"],[[11456,11456],"mapped",[11457]],[[11457,11457],"valid"],[[11458,11458],"mapped",[11459]],[[11459,11459],"valid"],[[11460,11460],"mapped",[11461]],[[11461,11461],"valid"],[[11462,11462],"mapped",[11463]],[[11463,11463],"valid"],[[11464,11464],"mapped",[11465]],[[11465,11465],"valid"],[[11466,11466],"mapped",[11467]],[[11467,11467],"valid"],[[11468,11468],"mapped",[11469]],[[11469,11469],"valid"],[[11470,11470],"mapped",[11471]],[[11471,11471],"valid"],[[11472,11472],"mapped",[11473]],[[11473,11473],"valid"],[[11474,11474],"mapped",[11475]],[[11475,11475],"valid"],[[11476,11476],"mapped",[11477]],[[11477,11477],"valid"],[[11478,11478],"mapped",[11479]],[[11479,11479],"valid"],[[11480,11480],"mapped",[11481]],[[11481,11481],"valid"],[[11482,11482],"mapped",[11483]],[[11483,11483],"valid"],[[11484,11484],"mapped",[11485]],[[11485,11485],"valid"],[[11486,11486],"mapped",[11487]],[[11487,11487],"valid"],[[11488,11488],"mapped",[11489]],[[11489,11489],"valid"],[[11490,11490],"mapped",[11491]],[[11491,11492],"valid"],[[11493,11498],"valid",[],"NV8"],[[11499,11499],"mapped",[11500]],[[11500,11500],"valid"],[[11501,11501],"mapped",[11502]],[[11502,11505],"valid"],[[11506,11506],"mapped",[11507]],[[11507,11507],"valid"],[[11508,11512],"disallowed"],[[11513,11519],"valid",[],"NV8"],[[11520,11557],"valid"],[[11558,11558],"disallowed"],[[11559,11559],"valid"],[[11560,11564],"disallowed"],[[11565,11565],"valid"],[[11566,11567],"disallowed"],[[11568,11621],"valid"],[[11622,11623],"valid"],[[11624,11630],"disallowed"],[[11631,11631],"mapped",[11617]],[[11632,11632],"valid",[],"NV8"],[[11633,11646],"disallowed"],[[11647,11647],"valid"],[[11648,11670],"valid"],[[11671,11679],"disallowed"],[[11680,11686],"valid"],[[11687,11687],"disallowed"],[[11688,11694],"valid"],[[11695,11695],"disallowed"],[[11696,11702],"valid"],[[11703,11703],"disallowed"],[[11704,11710],"valid"],[[11711,11711],"disallowed"],[[11712,11718],"valid"],[[11719,11719],"disallowed"],[[11720,11726],"valid"],[[11727,11727],"disallowed"],[[11728,11734],"valid"],[[11735,11735],"disallowed"],[[11736,11742],"valid"],[[11743,11743],"disallowed"],[[11744,11775],"valid"],[[11776,11799],"valid",[],"NV8"],[[11800,11803],"valid",[],"NV8"],[[11804,11805],"valid",[],"NV8"],[[11806,11822],"valid",[],"NV8"],[[11823,11823],"valid"],[[11824,11824],"valid",[],"NV8"],[[11825,11825],"valid",[],"NV8"],[[11826,11835],"valid",[],"NV8"],[[11836,11842],"valid",[],"NV8"],[[11843,11903],"disallowed"],[[11904,11929],"valid",[],"NV8"],[[11930,11930],"disallowed"],[[11931,11934],"valid",[],"NV8"],[[11935,11935],"mapped",[27597]],[[11936,12018],"valid",[],"NV8"],[[12019,12019],"mapped",[40863]],[[12020,12031],"disallowed"],[[12032,12032],"mapped",[19968]],[[12033,12033],"mapped",[20008]],[[12034,12034],"mapped",[20022]],[[12035,12035],"mapped",[20031]],[[12036,12036],"mapped",[20057]],[[12037,12037],"mapped",[20101]],[[12038,12038],"mapped",[20108]],[[12039,12039],"mapped",[20128]],[[12040,12040],"mapped",[20154]],[[12041,12041],"mapped",[20799]],[[12042,12042],"mapped",[20837]],[[12043,12043],"mapped",[20843]],[[12044,12044],"mapped",[20866]],[[12045,12045],"mapped",[20886]],[[12046,12046],"mapped",[20907]],[[12047,12047],"mapped",[20960]],[[12048,12048],"mapped",[20981]],[[12049,12049],"mapped",[20992]],[[12050,12050],"mapped",[21147]],[[12051,12051],"mapped",[21241]],[[12052,12052],"mapped",[21269]],[[12053,12053],"mapped",[21274]],[[12054,12054],"mapped",[21304]],[[12055,12055],"mapped",[21313]],[[12056,12056],"mapped",[21340]],[[12057,12057],"mapped",[21353]],[[12058,12058],"mapped",[21378]],[[12059,12059],"mapped",[21430]],[[12060,12060],"mapped",[21448]],[[12061,12061],"mapped",[21475]],[[12062,12062],"mapped",[22231]],[[12063,12063],"mapped",[22303]],[[12064,12064],"mapped",[22763]],[[12065,12065],"mapped",[22786]],[[12066,12066],"mapped",[22794]],[[12067,12067],"mapped",[22805]],[[12068,12068],"mapped",[22823]],[[12069,12069],"mapped",[22899]],[[12070,12070],"mapped",[23376]],[[12071,12071],"mapped",[23424]],[[12072,12072],"mapped",[23544]],[[12073,12073],"mapped",[23567]],[[12074,12074],"mapped",[23586]],[[12075,12075],"mapped",[23608]],[[12076,12076],"mapped",[23662]],[[12077,12077],"mapped",[23665]],[[12078,12078],"mapped",[24027]],[[12079,12079],"mapped",[24037]],[[12080,12080],"mapped",[24049]],[[12081,12081],"mapped",[24062]],[[12082,12082],"mapped",[24178]],[[12083,12083],"mapped",[24186]],[[12084,12084],"mapped",[24191]],[[12085,12085],"mapped",[24308]],[[12086,12086],"mapped",[24318]],[[12087,12087],"mapped",[24331]],[[12088,12088],"mapped",[24339]],[[12089,12089],"mapped",[24400]],[[12090,12090],"mapped",[24417]],[[12091,12091],"mapped",[24435]],[[12092,12092],"mapped",[24515]],[[12093,12093],"mapped",[25096]],[[12094,12094],"mapped",[25142]],[[12095,12095],"mapped",[25163]],[[12096,12096],"mapped",[25903]],[[12097,12097],"mapped",[25908]],[[12098,12098],"mapped",[25991]],[[12099,12099],"mapped",[26007]],[[12100,12100],"mapped",[26020]],[[12101,12101],"mapped",[26041]],[[12102,12102],"mapped",[26080]],[[12103,12103],"mapped",[26085]],[[12104,12104],"mapped",[26352]],[[12105,12105],"mapped",[26376]],[[12106,12106],"mapped",[26408]],[[12107,12107],"mapped",[27424]],[[12108,12108],"mapped",[27490]],[[12109,12109],"mapped",[27513]],[[12110,12110],"mapped",[27571]],[[12111,12111],"mapped",[27595]],[[12112,12112],"mapped",[27604]],[[12113,12113],"mapped",[27611]],[[12114,12114],"mapped",[27663]],[[12115,12115],"mapped",[27668]],[[12116,12116],"mapped",[27700]],[[12117,12117],"mapped",[28779]],[[12118,12118],"mapped",[29226]],[[12119,12119],"mapped",[29238]],[[12120,12120],"mapped",[29243]],[[12121,12121],"mapped",[29247]],[[12122,12122],"mapped",[29255]],[[12123,12123],"mapped",[29273]],[[12124,12124],"mapped",[29275]],[[12125,12125],"mapped",[29356]],[[12126,12126],"mapped",[29572]],[[12127,12127],"mapped",[29577]],[[12128,12128],"mapped",[29916]],[[12129,12129],"mapped",[29926]],[[12130,12130],"mapped",[29976]],[[12131,12131],"mapped",[29983]],[[12132,12132],"mapped",[29992]],[[12133,12133],"mapped",[30000]],[[12134,12134],"mapped",[30091]],[[12135,12135],"mapped",[30098]],[[12136,12136],"mapped",[30326]],[[12137,12137],"mapped",[30333]],[[12138,12138],"mapped",[30382]],[[12139,12139],"mapped",[30399]],[[12140,12140],"mapped",[30446]],[[12141,12141],"mapped",[30683]],[[12142,12142],"mapped",[30690]],[[12143,12143],"mapped",[30707]],[[12144,12144],"mapped",[31034]],[[12145,12145],"mapped",[31160]],[[12146,12146],"mapped",[31166]],[[12147,12147],"mapped",[31348]],[[12148,12148],"mapped",[31435]],[[12149,12149],"mapped",[31481]],[[12150,12150],"mapped",[31859]],[[12151,12151],"mapped",[31992]],[[12152,12152],"mapped",[32566]],[[12153,12153],"mapped",[32593]],[[12154,12154],"mapped",[32650]],[[12155,12155],"mapped",[32701]],[[12156,12156],"mapped",[32769]],[[12157,12157],"mapped",[32780]],[[12158,12158],"mapped",[32786]],[[12159,12159],"mapped",[32819]],[[12160,12160],"mapped",[32895]],[[12161,12161],"mapped",[32905]],[[12162,12162],"mapped",[33251]],[[12163,12163],"mapped",[33258]],[[12164,12164],"mapped",[33267]],[[12165,12165],"mapped",[33276]],[[12166,12166],"mapped",[33292]],[[12167,12167],"mapped",[33307]],[[12168,12168],"mapped",[33311]],[[12169,12169],"mapped",[33390]],[[12170,12170],"mapped",[33394]],[[12171,12171],"mapped",[33400]],[[12172,12172],"mapped",[34381]],[[12173,12173],"mapped",[34411]],[[12174,12174],"mapped",[34880]],[[12175,12175],"mapped",[34892]],[[12176,12176],"mapped",[34915]],[[12177,12177],"mapped",[35198]],[[12178,12178],"mapped",[35211]],[[12179,12179],"mapped",[35282]],[[12180,12180],"mapped",[35328]],[[12181,12181],"mapped",[35895]],[[12182,12182],"mapped",[35910]],[[12183,12183],"mapped",[35925]],[[12184,12184],"mapped",[35960]],[[12185,12185],"mapped",[35997]],[[12186,12186],"mapped",[36196]],[[12187,12187],"mapped",[36208]],[[12188,12188],"mapped",[36275]],[[12189,12189],"mapped",[36523]],[[12190,12190],"mapped",[36554]],[[12191,12191],"mapped",[36763]],[[12192,12192],"mapped",[36784]],[[12193,12193],"mapped",[36789]],[[12194,12194],"mapped",[37009]],[[12195,12195],"mapped",[37193]],[[12196,12196],"mapped",[37318]],[[12197,12197],"mapped",[37324]],[[12198,12198],"mapped",[37329]],[[12199,12199],"mapped",[38263]],[[12200,12200],"mapped",[38272]],[[12201,12201],"mapped",[38428]],[[12202,12202],"mapped",[38582]],[[12203,12203],"mapped",[38585]],[[12204,12204],"mapped",[38632]],[[12205,12205],"mapped",[38737]],[[12206,12206],"mapped",[38750]],[[12207,12207],"mapped",[38754]],[[12208,12208],"mapped",[38761]],[[12209,12209],"mapped",[38859]],[[12210,12210],"mapped",[38893]],[[12211,12211],"mapped",[38899]],[[12212,12212],"mapped",[38913]],[[12213,12213],"mapped",[39080]],[[12214,12214],"mapped",[39131]],[[12215,12215],"mapped",[39135]],[[12216,12216],"mapped",[39318]],[[12217,12217],"mapped",[39321]],[[12218,12218],"mapped",[39340]],[[12219,12219],"mapped",[39592]],[[12220,12220],"mapped",[39640]],[[12221,12221],"mapped",[39647]],[[12222,12222],"mapped",[39717]],[[12223,12223],"mapped",[39727]],[[12224,12224],"mapped",[39730]],[[12225,12225],"mapped",[39740]],[[12226,12226],"mapped",[39770]],[[12227,12227],"mapped",[40165]],[[12228,12228],"mapped",[40565]],[[12229,12229],"mapped",[40575]],[[12230,12230],"mapped",[40613]],[[12231,12231],"mapped",[40635]],[[12232,12232],"mapped",[40643]],[[12233,12233],"mapped",[40653]],[[12234,12234],"mapped",[40657]],[[12235,12235],"mapped",[40697]],[[12236,12236],"mapped",[40701]],[[12237,12237],"mapped",[40718]],[[12238,12238],"mapped",[40723]],[[12239,12239],"mapped",[40736]],[[12240,12240],"mapped",[40763]],[[12241,12241],"mapped",[40778]],[[12242,12242],"mapped",[40786]],[[12243,12243],"mapped",[40845]],[[12244,12244],"mapped",[40860]],[[12245,12245],"mapped",[40864]],[[12246,12271],"disallowed"],[[12272,12283],"disallowed"],[[12284,12287],"disallowed"],[[12288,12288],"disallowed_STD3_mapped",[32]],[[12289,12289],"valid",[],"NV8"],[[12290,12290],"mapped",[46]],[[12291,12292],"valid",[],"NV8"],[[12293,12295],"valid"],[[12296,12329],"valid",[],"NV8"],[[12330,12333],"valid"],[[12334,12341],"valid",[],"NV8"],[[12342,12342],"mapped",[12306]],[[12343,12343],"valid",[],"NV8"],[[12344,12344],"mapped",[21313]],[[12345,12345],"mapped",[21316]],[[12346,12346],"mapped",[21317]],[[12347,12347],"valid",[],"NV8"],[[12348,12348],"valid"],[[12349,12349],"valid",[],"NV8"],[[12350,12350],"valid",[],"NV8"],[[12351,12351],"valid",[],"NV8"],[[12352,12352],"disallowed"],[[12353,12436],"valid"],[[12437,12438],"valid"],[[12439,12440],"disallowed"],[[12441,12442],"valid"],[[12443,12443],"disallowed_STD3_mapped",[32,12441]],[[12444,12444],"disallowed_STD3_mapped",[32,12442]],[[12445,12446],"valid"],[[12447,12447],"mapped",[12424,12426]],[[12448,12448],"valid",[],"NV8"],[[12449,12542],"valid"],[[12543,12543],"mapped",[12467,12488]],[[12544,12548],"disallowed"],[[12549,12588],"valid"],[[12589,12589],"valid"],[[12590,12592],"disallowed"],[[12593,12593],"mapped",[4352]],[[12594,12594],"mapped",[4353]],[[12595,12595],"mapped",[4522]],[[12596,12596],"mapped",[4354]],[[12597,12597],"mapped",[4524]],[[12598,12598],"mapped",[4525]],[[12599,12599],"mapped",[4355]],[[12600,12600],"mapped",[4356]],[[12601,12601],"mapped",[4357]],[[12602,12602],"mapped",[4528]],[[12603,12603],"mapped",[4529]],[[12604,12604],"mapped",[4530]],[[12605,12605],"mapped",[4531]],[[12606,12606],"mapped",[4532]],[[12607,12607],"mapped",[4533]],[[12608,12608],"mapped",[4378]],[[12609,12609],"mapped",[4358]],[[12610,12610],"mapped",[4359]],[[12611,12611],"mapped",[4360]],[[12612,12612],"mapped",[4385]],[[12613,12613],"mapped",[4361]],[[12614,12614],"mapped",[4362]],[[12615,12615],"mapped",[4363]],[[12616,12616],"mapped",[4364]],[[12617,12617],"mapped",[4365]],[[12618,12618],"mapped",[4366]],[[12619,12619],"mapped",[4367]],[[12620,12620],"mapped",[4368]],[[12621,12621],"mapped",[4369]],[[12622,12622],"mapped",[4370]],[[12623,12623],"mapped",[4449]],[[12624,12624],"mapped",[4450]],[[12625,12625],"mapped",[4451]],[[12626,12626],"mapped",[4452]],[[12627,12627],"mapped",[4453]],[[12628,12628],"mapped",[4454]],[[12629,12629],"mapped",[4455]],[[12630,12630],"mapped",[4456]],[[12631,12631],"mapped",[4457]],[[12632,12632],"mapped",[4458]],[[12633,12633],"mapped",[4459]],[[12634,12634],"mapped",[4460]],[[12635,12635],"mapped",[4461]],[[12636,12636],"mapped",[4462]],[[12637,12637],"mapped",[4463]],[[12638,12638],"mapped",[4464]],[[12639,12639],"mapped",[4465]],[[12640,12640],"mapped",[4466]],[[12641,12641],"mapped",[4467]],[[12642,12642],"mapped",[4468]],[[12643,12643],"mapped",[4469]],[[12644,12644],"disallowed"],[[12645,12645],"mapped",[4372]],[[12646,12646],"mapped",[4373]],[[12647,12647],"mapped",[4551]],[[12648,12648],"mapped",[4552]],[[12649,12649],"mapped",[4556]],[[12650,12650],"mapped",[4558]],[[12651,12651],"mapped",[4563]],[[12652,12652],"mapped",[4567]],[[12653,12653],"mapped",[4569]],[[12654,12654],"mapped",[4380]],[[12655,12655],"mapped",[4573]],[[12656,12656],"mapped",[4575]],[[12657,12657],"mapped",[4381]],[[12658,12658],"mapped",[4382]],[[12659,12659],"mapped",[4384]],[[12660,12660],"mapped",[4386]],[[12661,12661],"mapped",[4387]],[[12662,12662],"mapped",[4391]],[[12663,12663],"mapped",[4393]],[[12664,12664],"mapped",[4395]],[[12665,12665],"mapped",[4396]],[[12666,12666],"mapped",[4397]],[[12667,12667],"mapped",[4398]],[[12668,12668],"mapped",[4399]],[[12669,12669],"mapped",[4402]],[[12670,12670],"mapped",[4406]],[[12671,12671],"mapped",[4416]],[[12672,12672],"mapped",[4423]],[[12673,12673],"mapped",[4428]],[[12674,12674],"mapped",[4593]],[[12675,12675],"mapped",[4594]],[[12676,12676],"mapped",[4439]],[[12677,12677],"mapped",[4440]],[[12678,12678],"mapped",[4441]],[[12679,12679],"mapped",[4484]],[[12680,12680],"mapped",[4485]],[[12681,12681],"mapped",[4488]],[[12682,12682],"mapped",[4497]],[[12683,12683],"mapped",[4498]],[[12684,12684],"mapped",[4500]],[[12685,12685],"mapped",[4510]],[[12686,12686],"mapped",[4513]],[[12687,12687],"disallowed"],[[12688,12689],"valid",[],"NV8"],[[12690,12690],"mapped",[19968]],[[12691,12691],"mapped",[20108]],[[12692,12692],"mapped",[19977]],[[12693,12693],"mapped",[22235]],[[12694,12694],"mapped",[19978]],[[12695,12695],"mapped",[20013]],[[12696,12696],"mapped",[19979]],[[12697,12697],"mapped",[30002]],[[12698,12698],"mapped",[20057]],[[12699,12699],"mapped",[19993]],[[12700,12700],"mapped",[19969]],[[12701,12701],"mapped",[22825]],[[12702,12702],"mapped",[22320]],[[12703,12703],"mapped",[20154]],[[12704,12727],"valid"],[[12728,12730],"valid"],[[12731,12735],"disallowed"],[[12736,12751],"valid",[],"NV8"],[[12752,12771],"valid",[],"NV8"],[[12772,12783],"disallowed"],[[12784,12799],"valid"],[[12800,12800],"disallowed_STD3_mapped",[40,4352,41]],[[12801,12801],"disallowed_STD3_mapped",[40,4354,41]],[[12802,12802],"disallowed_STD3_mapped",[40,4355,41]],[[12803,12803],"disallowed_STD3_mapped",[40,4357,41]],[[12804,12804],"disallowed_STD3_mapped",[40,4358,41]],[[12805,12805],"disallowed_STD3_mapped",[40,4359,41]],[[12806,12806],"disallowed_STD3_mapped",[40,4361,41]],[[12807,12807],"disallowed_STD3_mapped",[40,4363,41]],[[12808,12808],"disallowed_STD3_mapped",[40,4364,41]],[[12809,12809],"disallowed_STD3_mapped",[40,4366,41]],[[12810,12810],"disallowed_STD3_mapped",[40,4367,41]],[[12811,12811],"disallowed_STD3_mapped",[40,4368,41]],[[12812,12812],"disallowed_STD3_mapped",[40,4369,41]],[[12813,12813],"disallowed_STD3_mapped",[40,4370,41]],[[12814,12814],"disallowed_STD3_mapped",[40,44032,41]],[[12815,12815],"disallowed_STD3_mapped",[40,45208,41]],[[12816,12816],"disallowed_STD3_mapped",[40,45796,41]],[[12817,12817],"disallowed_STD3_mapped",[40,46972,41]],[[12818,12818],"disallowed_STD3_mapped",[40,47560,41]],[[12819,12819],"disallowed_STD3_mapped",[40,48148,41]],[[12820,12820],"disallowed_STD3_mapped",[40,49324,41]],[[12821,12821],"disallowed_STD3_mapped",[40,50500,41]],[[12822,12822],"disallowed_STD3_mapped",[40,51088,41]],[[12823,12823],"disallowed_STD3_mapped",[40,52264,41]],[[12824,12824],"disallowed_STD3_mapped",[40,52852,41]],[[12825,12825],"disallowed_STD3_mapped",[40,53440,41]],[[12826,12826],"disallowed_STD3_mapped",[40,54028,41]],[[12827,12827],"disallowed_STD3_mapped",[40,54616,41]],[[12828,12828],"disallowed_STD3_mapped",[40,51452,41]],[[12829,12829],"disallowed_STD3_mapped",[40,50724,51204,41]],[[12830,12830],"disallowed_STD3_mapped",[40,50724,54980,41]],[[12831,12831],"disallowed"],[[12832,12832],"disallowed_STD3_mapped",[40,19968,41]],[[12833,12833],"disallowed_STD3_mapped",[40,20108,41]],[[12834,12834],"disallowed_STD3_mapped",[40,19977,41]],[[12835,12835],"disallowed_STD3_mapped",[40,22235,41]],[[12836,12836],"disallowed_STD3_mapped",[40,20116,41]],[[12837,12837],"disallowed_STD3_mapped",[40,20845,41]],[[12838,12838],"disallowed_STD3_mapped",[40,19971,41]],[[12839,12839],"disallowed_STD3_mapped",[40,20843,41]],[[12840,12840],"disallowed_STD3_mapped",[40,20061,41]],[[12841,12841],"disallowed_STD3_mapped",[40,21313,41]],[[12842,12842],"disallowed_STD3_mapped",[40,26376,41]],[[12843,12843],"disallowed_STD3_mapped",[40,28779,41]],[[12844,12844],"disallowed_STD3_mapped",[40,27700,41]],[[12845,12845],"disallowed_STD3_mapped",[40,26408,41]],[[12846,12846],"disallowed_STD3_mapped",[40,37329,41]],[[12847,12847],"disallowed_STD3_mapped",[40,22303,41]],[[12848,12848],"disallowed_STD3_mapped",[40,26085,41]],[[12849,12849],"disallowed_STD3_mapped",[40,26666,41]],[[12850,12850],"disallowed_STD3_mapped",[40,26377,41]],[[12851,12851],"disallowed_STD3_mapped",[40,31038,41]],[[12852,12852],"disallowed_STD3_mapped",[40,21517,41]],[[12853,12853],"disallowed_STD3_mapped",[40,29305,41]],[[12854,12854],"disallowed_STD3_mapped",[40,36001,41]],[[12855,12855],"disallowed_STD3_mapped",[40,31069,41]],[[12856,12856],"disallowed_STD3_mapped",[40,21172,41]],[[12857,12857],"disallowed_STD3_mapped",[40,20195,41]],[[12858,12858],"disallowed_STD3_mapped",[40,21628,41]],[[12859,12859],"disallowed_STD3_mapped",[40,23398,41]],[[12860,12860],"disallowed_STD3_mapped",[40,30435,41]],[[12861,12861],"disallowed_STD3_mapped",[40,20225,41]],[[12862,12862],"disallowed_STD3_mapped",[40,36039,41]],[[12863,12863],"disallowed_STD3_mapped",[40,21332,41]],[[12864,12864],"disallowed_STD3_mapped",[40,31085,41]],[[12865,12865],"disallowed_STD3_mapped",[40,20241,41]],[[12866,12866],"disallowed_STD3_mapped",[40,33258,41]],[[12867,12867],"disallowed_STD3_mapped",[40,33267,41]],[[12868,12868],"mapped",[21839]],[[12869,12869],"mapped",[24188]],[[12870,12870],"mapped",[25991]],[[12871,12871],"mapped",[31631]],[[12872,12879],"valid",[],"NV8"],[[12880,12880],"mapped",[112,116,101]],[[12881,12881],"mapped",[50,49]],[[12882,12882],"mapped",[50,50]],[[12883,12883],"mapped",[50,51]],[[12884,12884],"mapped",[50,52]],[[12885,12885],"mapped",[50,53]],[[12886,12886],"mapped",[50,54]],[[12887,12887],"mapped",[50,55]],[[12888,12888],"mapped",[50,56]],[[12889,12889],"mapped",[50,57]],[[12890,12890],"mapped",[51,48]],[[12891,12891],"mapped",[51,49]],[[12892,12892],"mapped",[51,50]],[[12893,12893],"mapped",[51,51]],[[12894,12894],"mapped",[51,52]],[[12895,12895],"mapped",[51,53]],[[12896,12896],"mapped",[4352]],[[12897,12897],"mapped",[4354]],[[12898,12898],"mapped",[4355]],[[12899,12899],"mapped",[4357]],[[12900,12900],"mapped",[4358]],[[12901,12901],"mapped",[4359]],[[12902,12902],"mapped",[4361]],[[12903,12903],"mapped",[4363]],[[12904,12904],"mapped",[4364]],[[12905,12905],"mapped",[4366]],[[12906,12906],"mapped",[4367]],[[12907,12907],"mapped",[4368]],[[12908,12908],"mapped",[4369]],[[12909,12909],"mapped",[4370]],[[12910,12910],"mapped",[44032]],[[12911,12911],"mapped",[45208]],[[12912,12912],"mapped",[45796]],[[12913,12913],"mapped",[46972]],[[12914,12914],"mapped",[47560]],[[12915,12915],"mapped",[48148]],[[12916,12916],"mapped",[49324]],[[12917,12917],"mapped",[50500]],[[12918,12918],"mapped",[51088]],[[12919,12919],"mapped",[52264]],[[12920,12920],"mapped",[52852]],[[12921,12921],"mapped",[53440]],[[12922,12922],"mapped",[54028]],[[12923,12923],"mapped",[54616]],[[12924,12924],"mapped",[52280,44256]],[[12925,12925],"mapped",[51452,51032]],[[12926,12926],"mapped",[50864]],[[12927,12927],"valid",[],"NV8"],[[12928,12928],"mapped",[19968]],[[12929,12929],"mapped",[20108]],[[12930,12930],"mapped",[19977]],[[12931,12931],"mapped",[22235]],[[12932,12932],"mapped",[20116]],[[12933,12933],"mapped",[20845]],[[12934,12934],"mapped",[19971]],[[12935,12935],"mapped",[20843]],[[12936,12936],"mapped",[20061]],[[12937,12937],"mapped",[21313]],[[12938,12938],"mapped",[26376]],[[12939,12939],"mapped",[28779]],[[12940,12940],"mapped",[27700]],[[12941,12941],"mapped",[26408]],[[12942,12942],"mapped",[37329]],[[12943,12943],"mapped",[22303]],[[12944,12944],"mapped",[26085]],[[12945,12945],"mapped",[26666]],[[12946,12946],"mapped",[26377]],[[12947,12947],"mapped",[31038]],[[12948,12948],"mapped",[21517]],[[12949,12949],"mapped",[29305]],[[12950,12950],"mapped",[36001]],[[12951,12951],"mapped",[31069]],[[12952,12952],"mapped",[21172]],[[12953,12953],"mapped",[31192]],[[12954,12954],"mapped",[30007]],[[12955,12955],"mapped",[22899]],[[12956,12956],"mapped",[36969]],[[12957,12957],"mapped",[20778]],[[12958,12958],"mapped",[21360]],[[12959,12959],"mapped",[27880]],[[12960,12960],"mapped",[38917]],[[12961,12961],"mapped",[20241]],[[12962,12962],"mapped",[20889]],[[12963,12963],"mapped",[27491]],[[12964,12964],"mapped",[19978]],[[12965,12965],"mapped",[20013]],[[12966,12966],"mapped",[19979]],[[12967,12967],"mapped",[24038]],[[12968,12968],"mapped",[21491]],[[12969,12969],"mapped",[21307]],[[12970,12970],"mapped",[23447]],[[12971,12971],"mapped",[23398]],[[12972,12972],"mapped",[30435]],[[12973,12973],"mapped",[20225]],[[12974,12974],"mapped",[36039]],[[12975,12975],"mapped",[21332]],[[12976,12976],"mapped",[22812]],[[12977,12977],"mapped",[51,54]],[[12978,12978],"mapped",[51,55]],[[12979,12979],"mapped",[51,56]],[[12980,12980],"mapped",[51,57]],[[12981,12981],"mapped",[52,48]],[[12982,12982],"mapped",[52,49]],[[12983,12983],"mapped",[52,50]],[[12984,12984],"mapped",[52,51]],[[12985,12985],"mapped",[52,52]],[[12986,12986],"mapped",[52,53]],[[12987,12987],"mapped",[52,54]],[[12988,12988],"mapped",[52,55]],[[12989,12989],"mapped",[52,56]],[[12990,12990],"mapped",[52,57]],[[12991,12991],"mapped",[53,48]],[[12992,12992],"mapped",[49,26376]],[[12993,12993],"mapped",[50,26376]],[[12994,12994],"mapped",[51,26376]],[[12995,12995],"mapped",[52,26376]],[[12996,12996],"mapped",[53,26376]],[[12997,12997],"mapped",[54,26376]],[[12998,12998],"mapped",[55,26376]],[[12999,12999],"mapped",[56,26376]],[[13000,13000],"mapped",[57,26376]],[[13001,13001],"mapped",[49,48,26376]],[[13002,13002],"mapped",[49,49,26376]],[[13003,13003],"mapped",[49,50,26376]],[[13004,13004],"mapped",[104,103]],[[13005,13005],"mapped",[101,114,103]],[[13006,13006],"mapped",[101,118]],[[13007,13007],"mapped",[108,116,100]],[[13008,13008],"mapped",[12450]],[[13009,13009],"mapped",[12452]],[[13010,13010],"mapped",[12454]],[[13011,13011],"mapped",[12456]],[[13012,13012],"mapped",[12458]],[[13013,13013],"mapped",[12459]],[[13014,13014],"mapped",[12461]],[[13015,13015],"mapped",[12463]],[[13016,13016],"mapped",[12465]],[[13017,13017],"mapped",[12467]],[[13018,13018],"mapped",[12469]],[[13019,13019],"mapped",[12471]],[[13020,13020],"mapped",[12473]],[[13021,13021],"mapped",[12475]],[[13022,13022],"mapped",[12477]],[[13023,13023],"mapped",[12479]],[[13024,13024],"mapped",[12481]],[[13025,13025],"mapped",[12484]],[[13026,13026],"mapped",[12486]],[[13027,13027],"mapped",[12488]],[[13028,13028],"mapped",[12490]],[[13029,13029],"mapped",[12491]],[[13030,13030],"mapped",[12492]],[[13031,13031],"mapped",[12493]],[[13032,13032],"mapped",[12494]],[[13033,13033],"mapped",[12495]],[[13034,13034],"mapped",[12498]],[[13035,13035],"mapped",[12501]],[[13036,13036],"mapped",[12504]],[[13037,13037],"mapped",[12507]],[[13038,13038],"mapped",[12510]],[[13039,13039],"mapped",[12511]],[[13040,13040],"mapped",[12512]],[[13041,13041],"mapped",[12513]],[[13042,13042],"mapped",[12514]],[[13043,13043],"mapped",[12516]],[[13044,13044],"mapped",[12518]],[[13045,13045],"mapped",[12520]],[[13046,13046],"mapped",[12521]],[[13047,13047],"mapped",[12522]],[[13048,13048],"mapped",[12523]],[[13049,13049],"mapped",[12524]],[[13050,13050],"mapped",[12525]],[[13051,13051],"mapped",[12527]],[[13052,13052],"mapped",[12528]],[[13053,13053],"mapped",[12529]],[[13054,13054],"mapped",[12530]],[[13055,13055],"disallowed"],[[13056,13056],"mapped",[12450,12497,12540,12488]],[[13057,13057],"mapped",[12450,12523,12501,12449]],[[13058,13058],"mapped",[12450,12531,12506,12450]],[[13059,13059],"mapped",[12450,12540,12523]],[[13060,13060],"mapped",[12452,12491,12531,12464]],[[13061,13061],"mapped",[12452,12531,12481]],[[13062,13062],"mapped",[12454,12457,12531]],[[13063,13063],"mapped",[12456,12473,12463,12540,12489]],[[13064,13064],"mapped",[12456,12540,12459,12540]],[[13065,13065],"mapped",[12458,12531,12473]],[[13066,13066],"mapped",[12458,12540,12512]],[[13067,13067],"mapped",[12459,12452,12522]],[[13068,13068],"mapped",[12459,12521,12483,12488]],[[13069,13069],"mapped",[12459,12525,12522,12540]],[[13070,13070],"mapped",[12460,12525,12531]],[[13071,13071],"mapped",[12460,12531,12510]],[[13072,13072],"mapped",[12462,12460]],[[13073,13073],"mapped",[12462,12491,12540]],[[13074,13074],"mapped",[12461,12517,12522,12540]],[[13075,13075],"mapped",[12462,12523,12480,12540]],[[13076,13076],"mapped",[12461,12525]],[[13077,13077],"mapped",[12461,12525,12464,12521,12512]],[[13078,13078],"mapped",[12461,12525,12513,12540,12488,12523]],[[13079,13079],"mapped",[12461,12525,12527,12483,12488]],[[13080,13080],"mapped",[12464,12521,12512]],[[13081,13081],"mapped",[12464,12521,12512,12488,12531]],[[13082,13082],"mapped",[12463,12523,12476,12452,12525]],[[13083,13083],"mapped",[12463,12525,12540,12493]],[[13084,13084],"mapped",[12465,12540,12473]],[[13085,13085],"mapped",[12467,12523,12490]],[[13086,13086],"mapped",[12467,12540,12509]],[[13087,13087],"mapped",[12469,12452,12463,12523]],[[13088,13088],"mapped",[12469,12531,12481,12540,12512]],[[13089,13089],"mapped",[12471,12522,12531,12464]],[[13090,13090],"mapped",[12475,12531,12481]],[[13091,13091],"mapped",[12475,12531,12488]],[[13092,13092],"mapped",[12480,12540,12473]],[[13093,13093],"mapped",[12487,12471]],[[13094,13094],"mapped",[12489,12523]],[[13095,13095],"mapped",[12488,12531]],[[13096,13096],"mapped",[12490,12494]],[[13097,13097],"mapped",[12494,12483,12488]],[[13098,13098],"mapped",[12495,12452,12484]],[[13099,13099],"mapped",[12497,12540,12475,12531,12488]],[[13100,13100],"mapped",[12497,12540,12484]],[[13101,13101],"mapped",[12496,12540,12524,12523]],[[13102,13102],"mapped",[12500,12450,12473,12488,12523]],[[13103,13103],"mapped",[12500,12463,12523]],[[13104,13104],"mapped",[12500,12467]],[[13105,13105],"mapped",[12499,12523]],[[13106,13106],"mapped",[12501,12449,12521,12483,12489]],[[13107,13107],"mapped",[12501,12451,12540,12488]],[[13108,13108],"mapped",[12502,12483,12471,12455,12523]],[[13109,13109],"mapped",[12501,12521,12531]],[[13110,13110],"mapped",[12504,12463,12479,12540,12523]],[[13111,13111],"mapped",[12506,12477]],[[13112,13112],"mapped",[12506,12491,12498]],[[13113,13113],"mapped",[12504,12523,12484]],[[13114,13114],"mapped",[12506,12531,12473]],[[13115,13115],"mapped",[12506,12540,12472]],[[13116,13116],"mapped",[12505,12540,12479]],[[13117,13117],"mapped",[12509,12452,12531,12488]],[[13118,13118],"mapped",[12508,12523,12488]],[[13119,13119],"mapped",[12507,12531]],[[13120,13120],"mapped",[12509,12531,12489]],[[13121,13121],"mapped",[12507,12540,12523]],[[13122,13122],"mapped",[12507,12540,12531]],[[13123,13123],"mapped",[12510,12452,12463,12525]],[[13124,13124],"mapped",[12510,12452,12523]],[[13125,13125],"mapped",[12510,12483,12495]],[[13126,13126],"mapped",[12510,12523,12463]],[[13127,13127],"mapped",[12510,12531,12471,12519,12531]],[[13128,13128],"mapped",[12511,12463,12525,12531]],[[13129,13129],"mapped",[12511,12522]],[[13130,13130],"mapped",[12511,12522,12496,12540,12523]],[[13131,13131],"mapped",[12513,12460]],[[13132,13132],"mapped",[12513,12460,12488,12531]],[[13133,13133],"mapped",[12513,12540,12488,12523]],[[13134,13134],"mapped",[12516,12540,12489]],[[13135,13135],"mapped",[12516,12540,12523]],[[13136,13136],"mapped",[12518,12450,12531]],[[13137,13137],"mapped",[12522,12483,12488,12523]],[[13138,13138],"mapped",[12522,12521]],[[13139,13139],"mapped",[12523,12500,12540]],[[13140,13140],"mapped",[12523,12540,12502,12523]],[[13141,13141],"mapped",[12524,12512]],[[13142,13142],"mapped",[12524,12531,12488,12466,12531]],[[13143,13143],"mapped",[12527,12483,12488]],[[13144,13144],"mapped",[48,28857]],[[13145,13145],"mapped",[49,28857]],[[13146,13146],"mapped",[50,28857]],[[13147,13147],"mapped",[51,28857]],[[13148,13148],"mapped",[52,28857]],[[13149,13149],"mapped",[53,28857]],[[13150,13150],"mapped",[54,28857]],[[13151,13151],"mapped",[55,28857]],[[13152,13152],"mapped",[56,28857]],[[13153,13153],"mapped",[57,28857]],[[13154,13154],"mapped",[49,48,28857]],[[13155,13155],"mapped",[49,49,28857]],[[13156,13156],"mapped",[49,50,28857]],[[13157,13157],"mapped",[49,51,28857]],[[13158,13158],"mapped",[49,52,28857]],[[13159,13159],"mapped",[49,53,28857]],[[13160,13160],"mapped",[49,54,28857]],[[13161,13161],"mapped",[49,55,28857]],[[13162,13162],"mapped",[49,56,28857]],[[13163,13163],"mapped",[49,57,28857]],[[13164,13164],"mapped",[50,48,28857]],[[13165,13165],"mapped",[50,49,28857]],[[13166,13166],"mapped",[50,50,28857]],[[13167,13167],"mapped",[50,51,28857]],[[13168,13168],"mapped",[50,52,28857]],[[13169,13169],"mapped",[104,112,97]],[[13170,13170],"mapped",[100,97]],[[13171,13171],"mapped",[97,117]],[[13172,13172],"mapped",[98,97,114]],[[13173,13173],"mapped",[111,118]],[[13174,13174],"mapped",[112,99]],[[13175,13175],"mapped",[100,109]],[[13176,13176],"mapped",[100,109,50]],[[13177,13177],"mapped",[100,109,51]],[[13178,13178],"mapped",[105,117]],[[13179,13179],"mapped",[24179,25104]],[[13180,13180],"mapped",[26157,21644]],[[13181,13181],"mapped",[22823,27491]],[[13182,13182],"mapped",[26126,27835]],[[13183,13183],"mapped",[26666,24335,20250,31038]],[[13184,13184],"mapped",[112,97]],[[13185,13185],"mapped",[110,97]],[[13186,13186],"mapped",[956,97]],[[13187,13187],"mapped",[109,97]],[[13188,13188],"mapped",[107,97]],[[13189,13189],"mapped",[107,98]],[[13190,13190],"mapped",[109,98]],[[13191,13191],"mapped",[103,98]],[[13192,13192],"mapped",[99,97,108]],[[13193,13193],"mapped",[107,99,97,108]],[[13194,13194],"mapped",[112,102]],[[13195,13195],"mapped",[110,102]],[[13196,13196],"mapped",[956,102]],[[13197,13197],"mapped",[956,103]],[[13198,13198],"mapped",[109,103]],[[13199,13199],"mapped",[107,103]],[[13200,13200],"mapped",[104,122]],[[13201,13201],"mapped",[107,104,122]],[[13202,13202],"mapped",[109,104,122]],[[13203,13203],"mapped",[103,104,122]],[[13204,13204],"mapped",[116,104,122]],[[13205,13205],"mapped",[956,108]],[[13206,13206],"mapped",[109,108]],[[13207,13207],"mapped",[100,108]],[[13208,13208],"mapped",[107,108]],[[13209,13209],"mapped",[102,109]],[[13210,13210],"mapped",[110,109]],[[13211,13211],"mapped",[956,109]],[[13212,13212],"mapped",[109,109]],[[13213,13213],"mapped",[99,109]],[[13214,13214],"mapped",[107,109]],[[13215,13215],"mapped",[109,109,50]],[[13216,13216],"mapped",[99,109,50]],[[13217,13217],"mapped",[109,50]],[[13218,13218],"mapped",[107,109,50]],[[13219,13219],"mapped",[109,109,51]],[[13220,13220],"mapped",[99,109,51]],[[13221,13221],"mapped",[109,51]],[[13222,13222],"mapped",[107,109,51]],[[13223,13223],"mapped",[109,8725,115]],[[13224,13224],"mapped",[109,8725,115,50]],[[13225,13225],"mapped",[112,97]],[[13226,13226],"mapped",[107,112,97]],[[13227,13227],"mapped",[109,112,97]],[[13228,13228],"mapped",[103,112,97]],[[13229,13229],"mapped",[114,97,100]],[[13230,13230],"mapped",[114,97,100,8725,115]],[[13231,13231],"mapped",[114,97,100,8725,115,50]],[[13232,13232],"mapped",[112,115]],[[13233,13233],"mapped",[110,115]],[[13234,13234],"mapped",[956,115]],[[13235,13235],"mapped",[109,115]],[[13236,13236],"mapped",[112,118]],[[13237,13237],"mapped",[110,118]],[[13238,13238],"mapped",[956,118]],[[13239,13239],"mapped",[109,118]],[[13240,13240],"mapped",[107,118]],[[13241,13241],"mapped",[109,118]],[[13242,13242],"mapped",[112,119]],[[13243,13243],"mapped",[110,119]],[[13244,13244],"mapped",[956,119]],[[13245,13245],"mapped",[109,119]],[[13246,13246],"mapped",[107,119]],[[13247,13247],"mapped",[109,119]],[[13248,13248],"mapped",[107,969]],[[13249,13249],"mapped",[109,969]],[[13250,13250],"disallowed"],[[13251,13251],"mapped",[98,113]],[[13252,13252],"mapped",[99,99]],[[13253,13253],"mapped",[99,100]],[[13254,13254],"mapped",[99,8725,107,103]],[[13255,13255],"disallowed"],[[13256,13256],"mapped",[100,98]],[[13257,13257],"mapped",[103,121]],[[13258,13258],"mapped",[104,97]],[[13259,13259],"mapped",[104,112]],[[13260,13260],"mapped",[105,110]],[[13261,13261],"mapped",[107,107]],[[13262,13262],"mapped",[107,109]],[[13263,13263],"mapped",[107,116]],[[13264,13264],"mapped",[108,109]],[[13265,13265],"mapped",[108,110]],[[13266,13266],"mapped",[108,111,103]],[[13267,13267],"mapped",[108,120]],[[13268,13268],"mapped",[109,98]],[[13269,13269],"mapped",[109,105,108]],[[13270,13270],"mapped",[109,111,108]],[[13271,13271],"mapped",[112,104]],[[13272,13272],"disallowed"],[[13273,13273],"mapped",[112,112,109]],[[13274,13274],"mapped",[112,114]],[[13275,13275],"mapped",[115,114]],[[13276,13276],"mapped",[115,118]],[[13277,13277],"mapped",[119,98]],[[13278,13278],"mapped",[118,8725,109]],[[13279,13279],"mapped",[97,8725,109]],[[13280,13280],"mapped",[49,26085]],[[13281,13281],"mapped",[50,26085]],[[13282,13282],"mapped",[51,26085]],[[13283,13283],"mapped",[52,26085]],[[13284,13284],"mapped",[53,26085]],[[13285,13285],"mapped",[54,26085]],[[13286,13286],"mapped",[55,26085]],[[13287,13287],"mapped",[56,26085]],[[13288,13288],"mapped",[57,26085]],[[13289,13289],"mapped",[49,48,26085]],[[13290,13290],"mapped",[49,49,26085]],[[13291,13291],"mapped",[49,50,26085]],[[13292,13292],"mapped",[49,51,26085]],[[13293,13293],"mapped",[49,52,26085]],[[13294,13294],"mapped",[49,53,26085]],[[13295,13295],"mapped",[49,54,26085]],[[13296,13296],"mapped",[49,55,26085]],[[13297,13297],"mapped",[49,56,26085]],[[13298,13298],"mapped",[49,57,26085]],[[13299,13299],"mapped",[50,48,26085]],[[13300,13300],"mapped",[50,49,26085]],[[13301,13301],"mapped",[50,50,26085]],[[13302,13302],"mapped",[50,51,26085]],[[13303,13303],"mapped",[50,52,26085]],[[13304,13304],"mapped",[50,53,26085]],[[13305,13305],"mapped",[50,54,26085]],[[13306,13306],"mapped",[50,55,26085]],[[13307,13307],"mapped",[50,56,26085]],[[13308,13308],"mapped",[50,57,26085]],[[13309,13309],"mapped",[51,48,26085]],[[13310,13310],"mapped",[51,49,26085]],[[13311,13311],"mapped",[103,97,108]],[[13312,19893],"valid"],[[19894,19903],"disallowed"],[[19904,19967],"valid",[],"NV8"],[[19968,40869],"valid"],[[40870,40891],"valid"],[[40892,40899],"valid"],[[40900,40907],"valid"],[[40908,40908],"valid"],[[40909,40917],"valid"],[[40918,40959],"disallowed"],[[40960,42124],"valid"],[[42125,42127],"disallowed"],[[42128,42145],"valid",[],"NV8"],[[42146,42147],"valid",[],"NV8"],[[42148,42163],"valid",[],"NV8"],[[42164,42164],"valid",[],"NV8"],[[42165,42176],"valid",[],"NV8"],[[42177,42177],"valid",[],"NV8"],[[42178,42180],"valid",[],"NV8"],[[42181,42181],"valid",[],"NV8"],[[42182,42182],"valid",[],"NV8"],[[42183,42191],"disallowed"],[[42192,42237],"valid"],[[42238,42239],"valid",[],"NV8"],[[42240,42508],"valid"],[[42509,42511],"valid",[],"NV8"],[[42512,42539],"valid"],[[42540,42559],"disallowed"],[[42560,42560],"mapped",[42561]],[[42561,42561],"valid"],[[42562,42562],"mapped",[42563]],[[42563,42563],"valid"],[[42564,42564],"mapped",[42565]],[[42565,42565],"valid"],[[42566,42566],"mapped",[42567]],[[42567,42567],"valid"],[[42568,42568],"mapped",[42569]],[[42569,42569],"valid"],[[42570,42570],"mapped",[42571]],[[42571,42571],"valid"],[[42572,42572],"mapped",[42573]],[[42573,42573],"valid"],[[42574,42574],"mapped",[42575]],[[42575,42575],"valid"],[[42576,42576],"mapped",[42577]],[[42577,42577],"valid"],[[42578,42578],"mapped",[42579]],[[42579,42579],"valid"],[[42580,42580],"mapped",[42581]],[[42581,42581],"valid"],[[42582,42582],"mapped",[42583]],[[42583,42583],"valid"],[[42584,42584],"mapped",[42585]],[[42585,42585],"valid"],[[42586,42586],"mapped",[42587]],[[42587,42587],"valid"],[[42588,42588],"mapped",[42589]],[[42589,42589],"valid"],[[42590,42590],"mapped",[42591]],[[42591,42591],"valid"],[[42592,42592],"mapped",[42593]],[[42593,42593],"valid"],[[42594,42594],"mapped",[42595]],[[42595,42595],"valid"],[[42596,42596],"mapped",[42597]],[[42597,42597],"valid"],[[42598,42598],"mapped",[42599]],[[42599,42599],"valid"],[[42600,42600],"mapped",[42601]],[[42601,42601],"valid"],[[42602,42602],"mapped",[42603]],[[42603,42603],"valid"],[[42604,42604],"mapped",[42605]],[[42605,42607],"valid"],[[42608,42611],"valid",[],"NV8"],[[42612,42619],"valid"],[[42620,42621],"valid"],[[42622,42622],"valid",[],"NV8"],[[42623,42623],"valid"],[[42624,42624],"mapped",[42625]],[[42625,42625],"valid"],[[42626,42626],"mapped",[42627]],[[42627,42627],"valid"],[[42628,42628],"mapped",[42629]],[[42629,42629],"valid"],[[42630,42630],"mapped",[42631]],[[42631,42631],"valid"],[[42632,42632],"mapped",[42633]],[[42633,42633],"valid"],[[42634,42634],"mapped",[42635]],[[42635,42635],"valid"],[[42636,42636],"mapped",[42637]],[[42637,42637],"valid"],[[42638,42638],"mapped",[42639]],[[42639,42639],"valid"],[[42640,42640],"mapped",[42641]],[[42641,42641],"valid"],[[42642,42642],"mapped",[42643]],[[42643,42643],"valid"],[[42644,42644],"mapped",[42645]],[[42645,42645],"valid"],[[42646,42646],"mapped",[42647]],[[42647,42647],"valid"],[[42648,42648],"mapped",[42649]],[[42649,42649],"valid"],[[42650,42650],"mapped",[42651]],[[42651,42651],"valid"],[[42652,42652],"mapped",[1098]],[[42653,42653],"mapped",[1100]],[[42654,42654],"valid"],[[42655,42655],"valid"],[[42656,42725],"valid"],[[42726,42735],"valid",[],"NV8"],[[42736,42737],"valid"],[[42738,42743],"valid",[],"NV8"],[[42744,42751],"disallowed"],[[42752,42774],"valid",[],"NV8"],[[42775,42778],"valid"],[[42779,42783],"valid"],[[42784,42785],"valid",[],"NV8"],[[42786,42786],"mapped",[42787]],[[42787,42787],"valid"],[[42788,42788],"mapped",[42789]],[[42789,42789],"valid"],[[42790,42790],"mapped",[42791]],[[42791,42791],"valid"],[[42792,42792],"mapped",[42793]],[[42793,42793],"valid"],[[42794,42794],"mapped",[42795]],[[42795,42795],"valid"],[[42796,42796],"mapped",[42797]],[[42797,42797],"valid"],[[42798,42798],"mapped",[42799]],[[42799,42801],"valid"],[[42802,42802],"mapped",[42803]],[[42803,42803],"valid"],[[42804,42804],"mapped",[42805]],[[42805,42805],"valid"],[[42806,42806],"mapped",[42807]],[[42807,42807],"valid"],[[42808,42808],"mapped",[42809]],[[42809,42809],"valid"],[[42810,42810],"mapped",[42811]],[[42811,42811],"valid"],[[42812,42812],"mapped",[42813]],[[42813,42813],"valid"],[[42814,42814],"mapped",[42815]],[[42815,42815],"valid"],[[42816,42816],"mapped",[42817]],[[42817,42817],"valid"],[[42818,42818],"mapped",[42819]],[[42819,42819],"valid"],[[42820,42820],"mapped",[42821]],[[42821,42821],"valid"],[[42822,42822],"mapped",[42823]],[[42823,42823],"valid"],[[42824,42824],"mapped",[42825]],[[42825,42825],"valid"],[[42826,42826],"mapped",[42827]],[[42827,42827],"valid"],[[42828,42828],"mapped",[42829]],[[42829,42829],"valid"],[[42830,42830],"mapped",[42831]],[[42831,42831],"valid"],[[42832,42832],"mapped",[42833]],[[42833,42833],"valid"],[[42834,42834],"mapped",[42835]],[[42835,42835],"valid"],[[42836,42836],"mapped",[42837]],[[42837,42837],"valid"],[[42838,42838],"mapped",[42839]],[[42839,42839],"valid"],[[42840,42840],"mapped",[42841]],[[42841,42841],"valid"],[[42842,42842],"mapped",[42843]],[[42843,42843],"valid"],[[42844,42844],"mapped",[42845]],[[42845,42845],"valid"],[[42846,42846],"mapped",[42847]],[[42847,42847],"valid"],[[42848,42848],"mapped",[42849]],[[42849,42849],"valid"],[[42850,42850],"mapped",[42851]],[[42851,42851],"valid"],[[42852,42852],"mapped",[42853]],[[42853,42853],"valid"],[[42854,42854],"mapped",[42855]],[[42855,42855],"valid"],[[42856,42856],"mapped",[42857]],[[42857,42857],"valid"],[[42858,42858],"mapped",[42859]],[[42859,42859],"valid"],[[42860,42860],"mapped",[42861]],[[42861,42861],"valid"],[[42862,42862],"mapped",[42863]],[[42863,42863],"valid"],[[42864,42864],"mapped",[42863]],[[42865,42872],"valid"],[[42873,42873],"mapped",[42874]],[[42874,42874],"valid"],[[42875,42875],"mapped",[42876]],[[42876,42876],"valid"],[[42877,42877],"mapped",[7545]],[[42878,42878],"mapped",[42879]],[[42879,42879],"valid"],[[42880,42880],"mapped",[42881]],[[42881,42881],"valid"],[[42882,42882],"mapped",[42883]],[[42883,42883],"valid"],[[42884,42884],"mapped",[42885]],[[42885,42885],"valid"],[[42886,42886],"mapped",[42887]],[[42887,42888],"valid"],[[42889,42890],"valid",[],"NV8"],[[42891,42891],"mapped",[42892]],[[42892,42892],"valid"],[[42893,42893],"mapped",[613]],[[42894,42894],"valid"],[[42895,42895],"valid"],[[42896,42896],"mapped",[42897]],[[42897,42897],"valid"],[[42898,42898],"mapped",[42899]],[[42899,42899],"valid"],[[42900,42901],"valid"],[[42902,42902],"mapped",[42903]],[[42903,42903],"valid"],[[42904,42904],"mapped",[42905]],[[42905,42905],"valid"],[[42906,42906],"mapped",[42907]],[[42907,42907],"valid"],[[42908,42908],"mapped",[42909]],[[42909,42909],"valid"],[[42910,42910],"mapped",[42911]],[[42911,42911],"valid"],[[42912,42912],"mapped",[42913]],[[42913,42913],"valid"],[[42914,42914],"mapped",[42915]],[[42915,42915],"valid"],[[42916,42916],"mapped",[42917]],[[42917,42917],"valid"],[[42918,42918],"mapped",[42919]],[[42919,42919],"valid"],[[42920,42920],"mapped",[42921]],[[42921,42921],"valid"],[[42922,42922],"mapped",[614]],[[42923,42923],"mapped",[604]],[[42924,42924],"mapped",[609]],[[42925,42925],"mapped",[620]],[[42926,42927],"disallowed"],[[42928,42928],"mapped",[670]],[[42929,42929],"mapped",[647]],[[42930,42930],"mapped",[669]],[[42931,42931],"mapped",[43859]],[[42932,42932],"mapped",[42933]],[[42933,42933],"valid"],[[42934,42934],"mapped",[42935]],[[42935,42935],"valid"],[[42936,42998],"disallowed"],[[42999,42999],"valid"],[[43000,43000],"mapped",[295]],[[43001,43001],"mapped",[339]],[[43002,43002],"valid"],[[43003,43007],"valid"],[[43008,43047],"valid"],[[43048,43051],"valid",[],"NV8"],[[43052,43055],"disallowed"],[[43056,43065],"valid",[],"NV8"],[[43066,43071],"disallowed"],[[43072,43123],"valid"],[[43124,43127],"valid",[],"NV8"],[[43128,43135],"disallowed"],[[43136,43204],"valid"],[[43205,43213],"disallowed"],[[43214,43215],"valid",[],"NV8"],[[43216,43225],"valid"],[[43226,43231],"disallowed"],[[43232,43255],"valid"],[[43256,43258],"valid",[],"NV8"],[[43259,43259],"valid"],[[43260,43260],"valid",[],"NV8"],[[43261,43261],"valid"],[[43262,43263],"disallowed"],[[43264,43309],"valid"],[[43310,43311],"valid",[],"NV8"],[[43312,43347],"valid"],[[43348,43358],"disallowed"],[[43359,43359],"valid",[],"NV8"],[[43360,43388],"valid",[],"NV8"],[[43389,43391],"disallowed"],[[43392,43456],"valid"],[[43457,43469],"valid",[],"NV8"],[[43470,43470],"disallowed"],[[43471,43481],"valid"],[[43482,43485],"disallowed"],[[43486,43487],"valid",[],"NV8"],[[43488,43518],"valid"],[[43519,43519],"disallowed"],[[43520,43574],"valid"],[[43575,43583],"disallowed"],[[43584,43597],"valid"],[[43598,43599],"disallowed"],[[43600,43609],"valid"],[[43610,43611],"disallowed"],[[43612,43615],"valid",[],"NV8"],[[43616,43638],"valid"],[[43639,43641],"valid",[],"NV8"],[[43642,43643],"valid"],[[43644,43647],"valid"],[[43648,43714],"valid"],[[43715,43738],"disallowed"],[[43739,43741],"valid"],[[43742,43743],"valid",[],"NV8"],[[43744,43759],"valid"],[[43760,43761],"valid",[],"NV8"],[[43762,43766],"valid"],[[43767,43776],"disallowed"],[[43777,43782],"valid"],[[43783,43784],"disallowed"],[[43785,43790],"valid"],[[43791,43792],"disallowed"],[[43793,43798],"valid"],[[43799,43807],"disallowed"],[[43808,43814],"valid"],[[43815,43815],"disallowed"],[[43816,43822],"valid"],[[43823,43823],"disallowed"],[[43824,43866],"valid"],[[43867,43867],"valid",[],"NV8"],[[43868,43868],"mapped",[42791]],[[43869,43869],"mapped",[43831]],[[43870,43870],"mapped",[619]],[[43871,43871],"mapped",[43858]],[[43872,43875],"valid"],[[43876,43877],"valid"],[[43878,43887],"disallowed"],[[43888,43888],"mapped",[5024]],[[43889,43889],"mapped",[5025]],[[43890,43890],"mapped",[5026]],[[43891,43891],"mapped",[5027]],[[43892,43892],"mapped",[5028]],[[43893,43893],"mapped",[5029]],[[43894,43894],"mapped",[5030]],[[43895,43895],"mapped",[5031]],[[43896,43896],"mapped",[5032]],[[43897,43897],"mapped",[5033]],[[43898,43898],"mapped",[5034]],[[43899,43899],"mapped",[5035]],[[43900,43900],"mapped",[5036]],[[43901,43901],"mapped",[5037]],[[43902,43902],"mapped",[5038]],[[43903,43903],"mapped",[5039]],[[43904,43904],"mapped",[5040]],[[43905,43905],"mapped",[5041]],[[43906,43906],"mapped",[5042]],[[43907,43907],"mapped",[5043]],[[43908,43908],"mapped",[5044]],[[43909,43909],"mapped",[5045]],[[43910,43910],"mapped",[5046]],[[43911,43911],"mapped",[5047]],[[43912,43912],"mapped",[5048]],[[43913,43913],"mapped",[5049]],[[43914,43914],"mapped",[5050]],[[43915,43915],"mapped",[5051]],[[43916,43916],"mapped",[5052]],[[43917,43917],"mapped",[5053]],[[43918,43918],"mapped",[5054]],[[43919,43919],"mapped",[5055]],[[43920,43920],"mapped",[5056]],[[43921,43921],"mapped",[5057]],[[43922,43922],"mapped",[5058]],[[43923,43923],"mapped",[5059]],[[43924,43924],"mapped",[5060]],[[43925,43925],"mapped",[5061]],[[43926,43926],"mapped",[5062]],[[43927,43927],"mapped",[5063]],[[43928,43928],"mapped",[5064]],[[43929,43929],"mapped",[5065]],[[43930,43930],"mapped",[5066]],[[43931,43931],"mapped",[5067]],[[43932,43932],"mapped",[5068]],[[43933,43933],"mapped",[5069]],[[43934,43934],"mapped",[5070]],[[43935,43935],"mapped",[5071]],[[43936,43936],"mapped",[5072]],[[43937,43937],"mapped",[5073]],[[43938,43938],"mapped",[5074]],[[43939,43939],"mapped",[5075]],[[43940,43940],"mapped",[5076]],[[43941,43941],"mapped",[5077]],[[43942,43942],"mapped",[5078]],[[43943,43943],"mapped",[5079]],[[43944,43944],"mapped",[5080]],[[43945,43945],"mapped",[5081]],[[43946,43946],"mapped",[5082]],[[43947,43947],"mapped",[5083]],[[43948,43948],"mapped",[5084]],[[43949,43949],"mapped",[5085]],[[43950,43950],"mapped",[5086]],[[43951,43951],"mapped",[5087]],[[43952,43952],"mapped",[5088]],[[43953,43953],"mapped",[5089]],[[43954,43954],"mapped",[5090]],[[43955,43955],"mapped",[5091]],[[43956,43956],"mapped",[5092]],[[43957,43957],"mapped",[5093]],[[43958,43958],"mapped",[5094]],[[43959,43959],"mapped",[5095]],[[43960,43960],"mapped",[5096]],[[43961,43961],"mapped",[5097]],[[43962,43962],"mapped",[5098]],[[43963,43963],"mapped",[5099]],[[43964,43964],"mapped",[5100]],[[43965,43965],"mapped",[5101]],[[43966,43966],"mapped",[5102]],[[43967,43967],"mapped",[5103]],[[43968,44010],"valid"],[[44011,44011],"valid",[],"NV8"],[[44012,44013],"valid"],[[44014,44015],"disallowed"],[[44016,44025],"valid"],[[44026,44031],"disallowed"],[[44032,55203],"valid"],[[55204,55215],"disallowed"],[[55216,55238],"valid",[],"NV8"],[[55239,55242],"disallowed"],[[55243,55291],"valid",[],"NV8"],[[55292,55295],"disallowed"],[[55296,57343],"disallowed"],[[57344,63743],"disallowed"],[[63744,63744],"mapped",[35912]],[[63745,63745],"mapped",[26356]],[[63746,63746],"mapped",[36554]],[[63747,63747],"mapped",[36040]],[[63748,63748],"mapped",[28369]],[[63749,63749],"mapped",[20018]],[[63750,63750],"mapped",[21477]],[[63751,63752],"mapped",[40860]],[[63753,63753],"mapped",[22865]],[[63754,63754],"mapped",[37329]],[[63755,63755],"mapped",[21895]],[[63756,63756],"mapped",[22856]],[[63757,63757],"mapped",[25078]],[[63758,63758],"mapped",[30313]],[[63759,63759],"mapped",[32645]],[[63760,63760],"mapped",[34367]],[[63761,63761],"mapped",[34746]],[[63762,63762],"mapped",[35064]],[[63763,63763],"mapped",[37007]],[[63764,63764],"mapped",[27138]],[[63765,63765],"mapped",[27931]],[[63766,63766],"mapped",[28889]],[[63767,63767],"mapped",[29662]],[[63768,63768],"mapped",[33853]],[[63769,63769],"mapped",[37226]],[[63770,63770],"mapped",[39409]],[[63771,63771],"mapped",[20098]],[[63772,63772],"mapped",[21365]],[[63773,63773],"mapped",[27396]],[[63774,63774],"mapped",[29211]],[[63775,63775],"mapped",[34349]],[[63776,63776],"mapped",[40478]],[[63777,63777],"mapped",[23888]],[[63778,63778],"mapped",[28651]],[[63779,63779],"mapped",[34253]],[[63780,63780],"mapped",[35172]],[[63781,63781],"mapped",[25289]],[[63782,63782],"mapped",[33240]],[[63783,63783],"mapped",[34847]],[[63784,63784],"mapped",[24266]],[[63785,63785],"mapped",[26391]],[[63786,63786],"mapped",[28010]],[[63787,63787],"mapped",[29436]],[[63788,63788],"mapped",[37070]],[[63789,63789],"mapped",[20358]],[[63790,63790],"mapped",[20919]],[[63791,63791],"mapped",[21214]],[[63792,63792],"mapped",[25796]],[[63793,63793],"mapped",[27347]],[[63794,63794],"mapped",[29200]],[[63795,63795],"mapped",[30439]],[[63796,63796],"mapped",[32769]],[[63797,63797],"mapped",[34310]],[[63798,63798],"mapped",[34396]],[[63799,63799],"mapped",[36335]],[[63800,63800],"mapped",[38706]],[[63801,63801],"mapped",[39791]],[[63802,63802],"mapped",[40442]],[[63803,63803],"mapped",[30860]],[[63804,63804],"mapped",[31103]],[[63805,63805],"mapped",[32160]],[[63806,63806],"mapped",[33737]],[[63807,63807],"mapped",[37636]],[[63808,63808],"mapped",[40575]],[[63809,63809],"mapped",[35542]],[[63810,63810],"mapped",[22751]],[[63811,63811],"mapped",[24324]],[[63812,63812],"mapped",[31840]],[[63813,63813],"mapped",[32894]],[[63814,63814],"mapped",[29282]],[[63815,63815],"mapped",[30922]],[[63816,63816],"mapped",[36034]],[[63817,63817],"mapped",[38647]],[[63818,63818],"mapped",[22744]],[[63819,63819],"mapped",[23650]],[[63820,63820],"mapped",[27155]],[[63821,63821],"mapped",[28122]],[[63822,63822],"mapped",[28431]],[[63823,63823],"mapped",[32047]],[[63824,63824],"mapped",[32311]],[[63825,63825],"mapped",[38475]],[[63826,63826],"mapped",[21202]],[[63827,63827],"mapped",[32907]],[[63828,63828],"mapped",[20956]],[[63829,63829],"mapped",[20940]],[[63830,63830],"mapped",[31260]],[[63831,63831],"mapped",[32190]],[[63832,63832],"mapped",[33777]],[[63833,63833],"mapped",[38517]],[[63834,63834],"mapped",[35712]],[[63835,63835],"mapped",[25295]],[[63836,63836],"mapped",[27138]],[[63837,63837],"mapped",[35582]],[[63838,63838],"mapped",[20025]],[[63839,63839],"mapped",[23527]],[[63840,63840],"mapped",[24594]],[[63841,63841],"mapped",[29575]],[[63842,63842],"mapped",[30064]],[[63843,63843],"mapped",[21271]],[[63844,63844],"mapped",[30971]],[[63845,63845],"mapped",[20415]],[[63846,63846],"mapped",[24489]],[[63847,63847],"mapped",[19981]],[[63848,63848],"mapped",[27852]],[[63849,63849],"mapped",[25976]],[[63850,63850],"mapped",[32034]],[[63851,63851],"mapped",[21443]],[[63852,63852],"mapped",[22622]],[[63853,63853],"mapped",[30465]],[[63854,63854],"mapped",[33865]],[[63855,63855],"mapped",[35498]],[[63856,63856],"mapped",[27578]],[[63857,63857],"mapped",[36784]],[[63858,63858],"mapped",[27784]],[[63859,63859],"mapped",[25342]],[[63860,63860],"mapped",[33509]],[[63861,63861],"mapped",[25504]],[[63862,63862],"mapped",[30053]],[[63863,63863],"mapped",[20142]],[[63864,63864],"mapped",[20841]],[[63865,63865],"mapped",[20937]],[[63866,63866],"mapped",[26753]],[[63867,63867],"mapped",[31975]],[[63868,63868],"mapped",[33391]],[[63869,63869],"mapped",[35538]],[[63870,63870],"mapped",[37327]],[[63871,63871],"mapped",[21237]],[[63872,63872],"mapped",[21570]],[[63873,63873],"mapped",[22899]],[[63874,63874],"mapped",[24300]],[[63875,63875],"mapped",[26053]],[[63876,63876],"mapped",[28670]],[[63877,63877],"mapped",[31018]],[[63878,63878],"mapped",[38317]],[[63879,63879],"mapped",[39530]],[[63880,63880],"mapped",[40599]],[[63881,63881],"mapped",[40654]],[[63882,63882],"mapped",[21147]],[[63883,63883],"mapped",[26310]],[[63884,63884],"mapped",[27511]],[[63885,63885],"mapped",[36706]],[[63886,63886],"mapped",[24180]],[[63887,63887],"mapped",[24976]],[[63888,63888],"mapped",[25088]],[[63889,63889],"mapped",[25754]],[[63890,63890],"mapped",[28451]],[[63891,63891],"mapped",[29001]],[[63892,63892],"mapped",[29833]],[[63893,63893],"mapped",[31178]],[[63894,63894],"mapped",[32244]],[[63895,63895],"mapped",[32879]],[[63896,63896],"mapped",[36646]],[[63897,63897],"mapped",[34030]],[[63898,63898],"mapped",[36899]],[[63899,63899],"mapped",[37706]],[[63900,63900],"mapped",[21015]],[[63901,63901],"mapped",[21155]],[[63902,63902],"mapped",[21693]],[[63903,63903],"mapped",[28872]],[[63904,63904],"mapped",[35010]],[[63905,63905],"mapped",[35498]],[[63906,63906],"mapped",[24265]],[[63907,63907],"mapped",[24565]],[[63908,63908],"mapped",[25467]],[[63909,63909],"mapped",[27566]],[[63910,63910],"mapped",[31806]],[[63911,63911],"mapped",[29557]],[[63912,63912],"mapped",[20196]],[[63913,63913],"mapped",[22265]],[[63914,63914],"mapped",[23527]],[[63915,63915],"mapped",[23994]],[[63916,63916],"mapped",[24604]],[[63917,63917],"mapped",[29618]],[[63918,63918],"mapped",[29801]],[[63919,63919],"mapped",[32666]],[[63920,63920],"mapped",[32838]],[[63921,63921],"mapped",[37428]],[[63922,63922],"mapped",[38646]],[[63923,63923],"mapped",[38728]],[[63924,63924],"mapped",[38936]],[[63925,63925],"mapped",[20363]],[[63926,63926],"mapped",[31150]],[[63927,63927],"mapped",[37300]],[[63928,63928],"mapped",[38584]],[[63929,63929],"mapped",[24801]],[[63930,63930],"mapped",[20102]],[[63931,63931],"mapped",[20698]],[[63932,63932],"mapped",[23534]],[[63933,63933],"mapped",[23615]],[[63934,63934],"mapped",[26009]],[[63935,63935],"mapped",[27138]],[[63936,63936],"mapped",[29134]],[[63937,63937],"mapped",[30274]],[[63938,63938],"mapped",[34044]],[[63939,63939],"mapped",[36988]],[[63940,63940],"mapped",[40845]],[[63941,63941],"mapped",[26248]],[[63942,63942],"mapped",[38446]],[[63943,63943],"mapped",[21129]],[[63944,63944],"mapped",[26491]],[[63945,63945],"mapped",[26611]],[[63946,63946],"mapped",[27969]],[[63947,63947],"mapped",[28316]],[[63948,63948],"mapped",[29705]],[[63949,63949],"mapped",[30041]],[[63950,63950],"mapped",[30827]],[[63951,63951],"mapped",[32016]],[[63952,63952],"mapped",[39006]],[[63953,63953],"mapped",[20845]],[[63954,63954],"mapped",[25134]],[[63955,63955],"mapped",[38520]],[[63956,63956],"mapped",[20523]],[[63957,63957],"mapped",[23833]],[[63958,63958],"mapped",[28138]],[[63959,63959],"mapped",[36650]],[[63960,63960],"mapped",[24459]],[[63961,63961],"mapped",[24900]],[[63962,63962],"mapped",[26647]],[[63963,63963],"mapped",[29575]],[[63964,63964],"mapped",[38534]],[[63965,63965],"mapped",[21033]],[[63966,63966],"mapped",[21519]],[[63967,63967],"mapped",[23653]],[[63968,63968],"mapped",[26131]],[[63969,63969],"mapped",[26446]],[[63970,63970],"mapped",[26792]],[[63971,63971],"mapped",[27877]],[[63972,63972],"mapped",[29702]],[[63973,63973],"mapped",[30178]],[[63974,63974],"mapped",[32633]],[[63975,63975],"mapped",[35023]],[[63976,63976],"mapped",[35041]],[[63977,63977],"mapped",[37324]],[[63978,63978],"mapped",[38626]],[[63979,63979],"mapped",[21311]],[[63980,63980],"mapped",[28346]],[[63981,63981],"mapped",[21533]],[[63982,63982],"mapped",[29136]],[[63983,63983],"mapped",[29848]],[[63984,63984],"mapped",[34298]],[[63985,63985],"mapped",[38563]],[[63986,63986],"mapped",[40023]],[[63987,63987],"mapped",[40607]],[[63988,63988],"mapped",[26519]],[[63989,63989],"mapped",[28107]],[[63990,63990],"mapped",[33256]],[[63991,63991],"mapped",[31435]],[[63992,63992],"mapped",[31520]],[[63993,63993],"mapped",[31890]],[[63994,63994],"mapped",[29376]],[[63995,63995],"mapped",[28825]],[[63996,63996],"mapped",[35672]],[[63997,63997],"mapped",[20160]],[[63998,63998],"mapped",[33590]],[[63999,63999],"mapped",[21050]],[[64000,64000],"mapped",[20999]],[[64001,64001],"mapped",[24230]],[[64002,64002],"mapped",[25299]],[[64003,64003],"mapped",[31958]],[[64004,64004],"mapped",[23429]],[[64005,64005],"mapped",[27934]],[[64006,64006],"mapped",[26292]],[[64007,64007],"mapped",[36667]],[[64008,64008],"mapped",[34892]],[[64009,64009],"mapped",[38477]],[[64010,64010],"mapped",[35211]],[[64011,64011],"mapped",[24275]],[[64012,64012],"mapped",[20800]],[[64013,64013],"mapped",[21952]],[[64014,64015],"valid"],[[64016,64016],"mapped",[22618]],[[64017,64017],"valid"],[[64018,64018],"mapped",[26228]],[[64019,64020],"valid"],[[64021,64021],"mapped",[20958]],[[64022,64022],"mapped",[29482]],[[64023,64023],"mapped",[30410]],[[64024,64024],"mapped",[31036]],[[64025,64025],"mapped",[31070]],[[64026,64026],"mapped",[31077]],[[64027,64027],"mapped",[31119]],[[64028,64028],"mapped",[38742]],[[64029,64029],"mapped",[31934]],[[64030,64030],"mapped",[32701]],[[64031,64031],"valid"],[[64032,64032],"mapped",[34322]],[[64033,64033],"valid"],[[64034,64034],"mapped",[35576]],[[64035,64036],"valid"],[[64037,64037],"mapped",[36920]],[[64038,64038],"mapped",[37117]],[[64039,64041],"valid"],[[64042,64042],"mapped",[39151]],[[64043,64043],"mapped",[39164]],[[64044,64044],"mapped",[39208]],[[64045,64045],"mapped",[40372]],[[64046,64046],"mapped",[37086]],[[64047,64047],"mapped",[38583]],[[64048,64048],"mapped",[20398]],[[64049,64049],"mapped",[20711]],[[64050,64050],"mapped",[20813]],[[64051,64051],"mapped",[21193]],[[64052,64052],"mapped",[21220]],[[64053,64053],"mapped",[21329]],[[64054,64054],"mapped",[21917]],[[64055,64055],"mapped",[22022]],[[64056,64056],"mapped",[22120]],[[64057,64057],"mapped",[22592]],[[64058,64058],"mapped",[22696]],[[64059,64059],"mapped",[23652]],[[64060,64060],"mapped",[23662]],[[64061,64061],"mapped",[24724]],[[64062,64062],"mapped",[24936]],[[64063,64063],"mapped",[24974]],[[64064,64064],"mapped",[25074]],[[64065,64065],"mapped",[25935]],[[64066,64066],"mapped",[26082]],[[64067,64067],"mapped",[26257]],[[64068,64068],"mapped",[26757]],[[64069,64069],"mapped",[28023]],[[64070,64070],"mapped",[28186]],[[64071,64071],"mapped",[28450]],[[64072,64072],"mapped",[29038]],[[64073,64073],"mapped",[29227]],[[64074,64074],"mapped",[29730]],[[64075,64075],"mapped",[30865]],[[64076,64076],"mapped",[31038]],[[64077,64077],"mapped",[31049]],[[64078,64078],"mapped",[31048]],[[64079,64079],"mapped",[31056]],[[64080,64080],"mapped",[31062]],[[64081,64081],"mapped",[31069]],[[64082,64082],"mapped",[31117]],[[64083,64083],"mapped",[31118]],[[64084,64084],"mapped",[31296]],[[64085,64085],"mapped",[31361]],[[64086,64086],"mapped",[31680]],[[64087,64087],"mapped",[32244]],[[64088,64088],"mapped",[32265]],[[64089,64089],"mapped",[32321]],[[64090,64090],"mapped",[32626]],[[64091,64091],"mapped",[32773]],[[64092,64092],"mapped",[33261]],[[64093,64094],"mapped",[33401]],[[64095,64095],"mapped",[33879]],[[64096,64096],"mapped",[35088]],[[64097,64097],"mapped",[35222]],[[64098,64098],"mapped",[35585]],[[64099,64099],"mapped",[35641]],[[64100,64100],"mapped",[36051]],[[64101,64101],"mapped",[36104]],[[64102,64102],"mapped",[36790]],[[64103,64103],"mapped",[36920]],[[64104,64104],"mapped",[38627]],[[64105,64105],"mapped",[38911]],[[64106,64106],"mapped",[38971]],[[64107,64107],"mapped",[24693]],[[64108,64108],"mapped",[148206]],[[64109,64109],"mapped",[33304]],[[64110,64111],"disallowed"],[[64112,64112],"mapped",[20006]],[[64113,64113],"mapped",[20917]],[[64114,64114],"mapped",[20840]],[[64115,64115],"mapped",[20352]],[[64116,64116],"mapped",[20805]],[[64117,64117],"mapped",[20864]],[[64118,64118],"mapped",[21191]],[[64119,64119],"mapped",[21242]],[[64120,64120],"mapped",[21917]],[[64121,64121],"mapped",[21845]],[[64122,64122],"mapped",[21913]],[[64123,64123],"mapped",[21986]],[[64124,64124],"mapped",[22618]],[[64125,64125],"mapped",[22707]],[[64126,64126],"mapped",[22852]],[[64127,64127],"mapped",[22868]],[[64128,64128],"mapped",[23138]],[[64129,64129],"mapped",[23336]],[[64130,64130],"mapped",[24274]],[[64131,64131],"mapped",[24281]],[[64132,64132],"mapped",[24425]],[[64133,64133],"mapped",[24493]],[[64134,64134],"mapped",[24792]],[[64135,64135],"mapped",[24910]],[[64136,64136],"mapped",[24840]],[[64137,64137],"mapped",[24974]],[[64138,64138],"mapped",[24928]],[[64139,64139],"mapped",[25074]],[[64140,64140],"mapped",[25140]],[[64141,64141],"mapped",[25540]],[[64142,64142],"mapped",[25628]],[[64143,64143],"mapped",[25682]],[[64144,64144],"mapped",[25942]],[[64145,64145],"mapped",[26228]],[[64146,64146],"mapped",[26391]],[[64147,64147],"mapped",[26395]],[[64148,64148],"mapped",[26454]],[[64149,64149],"mapped",[27513]],[[64150,64150],"mapped",[27578]],[[64151,64151],"mapped",[27969]],[[64152,64152],"mapped",[28379]],[[64153,64153],"mapped",[28363]],[[64154,64154],"mapped",[28450]],[[64155,64155],"mapped",[28702]],[[64156,64156],"mapped",[29038]],[[64157,64157],"mapped",[30631]],[[64158,64158],"mapped",[29237]],[[64159,64159],"mapped",[29359]],[[64160,64160],"mapped",[29482]],[[64161,64161],"mapped",[29809]],[[64162,64162],"mapped",[29958]],[[64163,64163],"mapped",[30011]],[[64164,64164],"mapped",[30237]],[[64165,64165],"mapped",[30239]],[[64166,64166],"mapped",[30410]],[[64167,64167],"mapped",[30427]],[[64168,64168],"mapped",[30452]],[[64169,64169],"mapped",[30538]],[[64170,64170],"mapped",[30528]],[[64171,64171],"mapped",[30924]],[[64172,64172],"mapped",[31409]],[[64173,64173],"mapped",[31680]],[[64174,64174],"mapped",[31867]],[[64175,64175],"mapped",[32091]],[[64176,64176],"mapped",[32244]],[[64177,64177],"mapped",[32574]],[[64178,64178],"mapped",[32773]],[[64179,64179],"mapped",[33618]],[[64180,64180],"mapped",[33775]],[[64181,64181],"mapped",[34681]],[[64182,64182],"mapped",[35137]],[[64183,64183],"mapped",[35206]],[[64184,64184],"mapped",[35222]],[[64185,64185],"mapped",[35519]],[[64186,64186],"mapped",[35576]],[[64187,64187],"mapped",[35531]],[[64188,64188],"mapped",[35585]],[[64189,64189],"mapped",[35582]],[[64190,64190],"mapped",[35565]],[[64191,64191],"mapped",[35641]],[[64192,64192],"mapped",[35722]],[[64193,64193],"mapped",[36104]],[[64194,64194],"mapped",[36664]],[[64195,64195],"mapped",[36978]],[[64196,64196],"mapped",[37273]],[[64197,64197],"mapped",[37494]],[[64198,64198],"mapped",[38524]],[[64199,64199],"mapped",[38627]],[[64200,64200],"mapped",[38742]],[[64201,64201],"mapped",[38875]],[[64202,64202],"mapped",[38911]],[[64203,64203],"mapped",[38923]],[[64204,64204],"mapped",[38971]],[[64205,64205],"mapped",[39698]],[[64206,64206],"mapped",[40860]],[[64207,64207],"mapped",[141386]],[[64208,64208],"mapped",[141380]],[[64209,64209],"mapped",[144341]],[[64210,64210],"mapped",[15261]],[[64211,64211],"mapped",[16408]],[[64212,64212],"mapped",[16441]],[[64213,64213],"mapped",[152137]],[[64214,64214],"mapped",[154832]],[[64215,64215],"mapped",[163539]],[[64216,64216],"mapped",[40771]],[[64217,64217],"mapped",[40846]],[[64218,64255],"disallowed"],[[64256,64256],"mapped",[102,102]],[[64257,64257],"mapped",[102,105]],[[64258,64258],"mapped",[102,108]],[[64259,64259],"mapped",[102,102,105]],[[64260,64260],"mapped",[102,102,108]],[[64261,64262],"mapped",[115,116]],[[64263,64274],"disallowed"],[[64275,64275],"mapped",[1396,1398]],[[64276,64276],"mapped",[1396,1381]],[[64277,64277],"mapped",[1396,1387]],[[64278,64278],"mapped",[1406,1398]],[[64279,64279],"mapped",[1396,1389]],[[64280,64284],"disallowed"],[[64285,64285],"mapped",[1497,1460]],[[64286,64286],"valid"],[[64287,64287],"mapped",[1522,1463]],[[64288,64288],"mapped",[1506]],[[64289,64289],"mapped",[1488]],[[64290,64290],"mapped",[1491]],[[64291,64291],"mapped",[1492]],[[64292,64292],"mapped",[1499]],[[64293,64293],"mapped",[1500]],[[64294,64294],"mapped",[1501]],[[64295,64295],"mapped",[1512]],[[64296,64296],"mapped",[1514]],[[64297,64297],"disallowed_STD3_mapped",[43]],[[64298,64298],"mapped",[1513,1473]],[[64299,64299],"mapped",[1513,1474]],[[64300,64300],"mapped",[1513,1468,1473]],[[64301,64301],"mapped",[1513,1468,1474]],[[64302,64302],"mapped",[1488,1463]],[[64303,64303],"mapped",[1488,1464]],[[64304,64304],"mapped",[1488,1468]],[[64305,64305],"mapped",[1489,1468]],[[64306,64306],"mapped",[1490,1468]],[[64307,64307],"mapped",[1491,1468]],[[64308,64308],"mapped",[1492,1468]],[[64309,64309],"mapped",[1493,1468]],[[64310,64310],"mapped",[1494,1468]],[[64311,64311],"disallowed"],[[64312,64312],"mapped",[1496,1468]],[[64313,64313],"mapped",[1497,1468]],[[64314,64314],"mapped",[1498,1468]],[[64315,64315],"mapped",[1499,1468]],[[64316,64316],"mapped",[1500,1468]],[[64317,64317],"disallowed"],[[64318,64318],"mapped",[1502,1468]],[[64319,64319],"disallowed"],[[64320,64320],"mapped",[1504,1468]],[[64321,64321],"mapped",[1505,1468]],[[64322,64322],"disallowed"],[[64323,64323],"mapped",[1507,1468]],[[64324,64324],"mapped",[1508,1468]],[[64325,64325],"disallowed"],[[64326,64326],"mapped",[1510,1468]],[[64327,64327],"mapped",[1511,1468]],[[64328,64328],"mapped",[1512,1468]],[[64329,64329],"mapped",[1513,1468]],[[64330,64330],"mapped",[1514,1468]],[[64331,64331],"mapped",[1493,1465]],[[64332,64332],"mapped",[1489,1471]],[[64333,64333],"mapped",[1499,1471]],[[64334,64334],"mapped",[1508,1471]],[[64335,64335],"mapped",[1488,1500]],[[64336,64337],"mapped",[1649]],[[64338,64341],"mapped",[1659]],[[64342,64345],"mapped",[1662]],[[64346,64349],"mapped",[1664]],[[64350,64353],"mapped",[1658]],[[64354,64357],"mapped",[1663]],[[64358,64361],"mapped",[1657]],[[64362,64365],"mapped",[1700]],[[64366,64369],"mapped",[1702]],[[64370,64373],"mapped",[1668]],[[64374,64377],"mapped",[1667]],[[64378,64381],"mapped",[1670]],[[64382,64385],"mapped",[1671]],[[64386,64387],"mapped",[1677]],[[64388,64389],"mapped",[1676]],[[64390,64391],"mapped",[1678]],[[64392,64393],"mapped",[1672]],[[64394,64395],"mapped",[1688]],[[64396,64397],"mapped",[1681]],[[64398,64401],"mapped",[1705]],[[64402,64405],"mapped",[1711]],[[64406,64409],"mapped",[1715]],[[64410,64413],"mapped",[1713]],[[64414,64415],"mapped",[1722]],[[64416,64419],"mapped",[1723]],[[64420,64421],"mapped",[1728]],[[64422,64425],"mapped",[1729]],[[64426,64429],"mapped",[1726]],[[64430,64431],"mapped",[1746]],[[64432,64433],"mapped",[1747]],[[64434,64449],"valid",[],"NV8"],[[64450,64466],"disallowed"],[[64467,64470],"mapped",[1709]],[[64471,64472],"mapped",[1735]],[[64473,64474],"mapped",[1734]],[[64475,64476],"mapped",[1736]],[[64477,64477],"mapped",[1735,1652]],[[64478,64479],"mapped",[1739]],[[64480,64481],"mapped",[1733]],[[64482,64483],"mapped",[1737]],[[64484,64487],"mapped",[1744]],[[64488,64489],"mapped",[1609]],[[64490,64491],"mapped",[1574,1575]],[[64492,64493],"mapped",[1574,1749]],[[64494,64495],"mapped",[1574,1608]],[[64496,64497],"mapped",[1574,1735]],[[64498,64499],"mapped",[1574,1734]],[[64500,64501],"mapped",[1574,1736]],[[64502,64504],"mapped",[1574,1744]],[[64505,64507],"mapped",[1574,1609]],[[64508,64511],"mapped",[1740]],[[64512,64512],"mapped",[1574,1580]],[[64513,64513],"mapped",[1574,1581]],[[64514,64514],"mapped",[1574,1605]],[[64515,64515],"mapped",[1574,1609]],[[64516,64516],"mapped",[1574,1610]],[[64517,64517],"mapped",[1576,1580]],[[64518,64518],"mapped",[1576,1581]],[[64519,64519],"mapped",[1576,1582]],[[64520,64520],"mapped",[1576,1605]],[[64521,64521],"mapped",[1576,1609]],[[64522,64522],"mapped",[1576,1610]],[[64523,64523],"mapped",[1578,1580]],[[64524,64524],"mapped",[1578,1581]],[[64525,64525],"mapped",[1578,1582]],[[64526,64526],"mapped",[1578,1605]],[[64527,64527],"mapped",[1578,1609]],[[64528,64528],"mapped",[1578,1610]],[[64529,64529],"mapped",[1579,1580]],[[64530,64530],"mapped",[1579,1605]],[[64531,64531],"mapped",[1579,1609]],[[64532,64532],"mapped",[1579,1610]],[[64533,64533],"mapped",[1580,1581]],[[64534,64534],"mapped",[1580,1605]],[[64535,64535],"mapped",[1581,1580]],[[64536,64536],"mapped",[1581,1605]],[[64537,64537],"mapped",[1582,1580]],[[64538,64538],"mapped",[1582,1581]],[[64539,64539],"mapped",[1582,1605]],[[64540,64540],"mapped",[1587,1580]],[[64541,64541],"mapped",[1587,1581]],[[64542,64542],"mapped",[1587,1582]],[[64543,64543],"mapped",[1587,1605]],[[64544,64544],"mapped",[1589,1581]],[[64545,64545],"mapped",[1589,1605]],[[64546,64546],"mapped",[1590,1580]],[[64547,64547],"mapped",[1590,1581]],[[64548,64548],"mapped",[1590,1582]],[[64549,64549],"mapped",[1590,1605]],[[64550,64550],"mapped",[1591,1581]],[[64551,64551],"mapped",[1591,1605]],[[64552,64552],"mapped",[1592,1605]],[[64553,64553],"mapped",[1593,1580]],[[64554,64554],"mapped",[1593,1605]],[[64555,64555],"mapped",[1594,1580]],[[64556,64556],"mapped",[1594,1605]],[[64557,64557],"mapped",[1601,1580]],[[64558,64558],"mapped",[1601,1581]],[[64559,64559],"mapped",[1601,1582]],[[64560,64560],"mapped",[1601,1605]],[[64561,64561],"mapped",[1601,1609]],[[64562,64562],"mapped",[1601,1610]],[[64563,64563],"mapped",[1602,1581]],[[64564,64564],"mapped",[1602,1605]],[[64565,64565],"mapped",[1602,1609]],[[64566,64566],"mapped",[1602,1610]],[[64567,64567],"mapped",[1603,1575]],[[64568,64568],"mapped",[1603,1580]],[[64569,64569],"mapped",[1603,1581]],[[64570,64570],"mapped",[1603,1582]],[[64571,64571],"mapped",[1603,1604]],[[64572,64572],"mapped",[1603,1605]],[[64573,64573],"mapped",[1603,1609]],[[64574,64574],"mapped",[1603,1610]],[[64575,64575],"mapped",[1604,1580]],[[64576,64576],"mapped",[1604,1581]],[[64577,64577],"mapped",[1604,1582]],[[64578,64578],"mapped",[1604,1605]],[[64579,64579],"mapped",[1604,1609]],[[64580,64580],"mapped",[1604,1610]],[[64581,64581],"mapped",[1605,1580]],[[64582,64582],"mapped",[1605,1581]],[[64583,64583],"mapped",[1605,1582]],[[64584,64584],"mapped",[1605,1605]],[[64585,64585],"mapped",[1605,1609]],[[64586,64586],"mapped",[1605,1610]],[[64587,64587],"mapped",[1606,1580]],[[64588,64588],"mapped",[1606,1581]],[[64589,64589],"mapped",[1606,1582]],[[64590,64590],"mapped",[1606,1605]],[[64591,64591],"mapped",[1606,1609]],[[64592,64592],"mapped",[1606,1610]],[[64593,64593],"mapped",[1607,1580]],[[64594,64594],"mapped",[1607,1605]],[[64595,64595],"mapped",[1607,1609]],[[64596,64596],"mapped",[1607,1610]],[[64597,64597],"mapped",[1610,1580]],[[64598,64598],"mapped",[1610,1581]],[[64599,64599],"mapped",[1610,1582]],[[64600,64600],"mapped",[1610,1605]],[[64601,64601],"mapped",[1610,1609]],[[64602,64602],"mapped",[1610,1610]],[[64603,64603],"mapped",[1584,1648]],[[64604,64604],"mapped",[1585,1648]],[[64605,64605],"mapped",[1609,1648]],[[64606,64606],"disallowed_STD3_mapped",[32,1612,1617]],[[64607,64607],"disallowed_STD3_mapped",[32,1613,1617]],[[64608,64608],"disallowed_STD3_mapped",[32,1614,1617]],[[64609,64609],"disallowed_STD3_mapped",[32,1615,1617]],[[64610,64610],"disallowed_STD3_mapped",[32,1616,1617]],[[64611,64611],"disallowed_STD3_mapped",[32,1617,1648]],[[64612,64612],"mapped",[1574,1585]],[[64613,64613],"mapped",[1574,1586]],[[64614,64614],"mapped",[1574,1605]],[[64615,64615],"mapped",[1574,1606]],[[64616,64616],"mapped",[1574,1609]],[[64617,64617],"mapped",[1574,1610]],[[64618,64618],"mapped",[1576,1585]],[[64619,64619],"mapped",[1576,1586]],[[64620,64620],"mapped",[1576,1605]],[[64621,64621],"mapped",[1576,1606]],[[64622,64622],"mapped",[1576,1609]],[[64623,64623],"mapped",[1576,1610]],[[64624,64624],"mapped",[1578,1585]],[[64625,64625],"mapped",[1578,1586]],[[64626,64626],"mapped",[1578,1605]],[[64627,64627],"mapped",[1578,1606]],[[64628,64628],"mapped",[1578,1609]],[[64629,64629],"mapped",[1578,1610]],[[64630,64630],"mapped",[1579,1585]],[[64631,64631],"mapped",[1579,1586]],[[64632,64632],"mapped",[1579,1605]],[[64633,64633],"mapped",[1579,1606]],[[64634,64634],"mapped",[1579,1609]],[[64635,64635],"mapped",[1579,1610]],[[64636,64636],"mapped",[1601,1609]],[[64637,64637],"mapped",[1601,1610]],[[64638,64638],"mapped",[1602,1609]],[[64639,64639],"mapped",[1602,1610]],[[64640,64640],"mapped",[1603,1575]],[[64641,64641],"mapped",[1603,1604]],[[64642,64642],"mapped",[1603,1605]],[[64643,64643],"mapped",[1603,1609]],[[64644,64644],"mapped",[1603,1610]],[[64645,64645],"mapped",[1604,1605]],[[64646,64646],"mapped",[1604,1609]],[[64647,64647],"mapped",[1604,1610]],[[64648,64648],"mapped",[1605,1575]],[[64649,64649],"mapped",[1605,1605]],[[64650,64650],"mapped",[1606,1585]],[[64651,64651],"mapped",[1606,1586]],[[64652,64652],"mapped",[1606,1605]],[[64653,64653],"mapped",[1606,1606]],[[64654,64654],"mapped",[1606,1609]],[[64655,64655],"mapped",[1606,1610]],[[64656,64656],"mapped",[1609,1648]],[[64657,64657],"mapped",[1610,1585]],[[64658,64658],"mapped",[1610,1586]],[[64659,64659],"mapped",[1610,1605]],[[64660,64660],"mapped",[1610,1606]],[[64661,64661],"mapped",[1610,1609]],[[64662,64662],"mapped",[1610,1610]],[[64663,64663],"mapped",[1574,1580]],[[64664,64664],"mapped",[1574,1581]],[[64665,64665],"mapped",[1574,1582]],[[64666,64666],"mapped",[1574,1605]],[[64667,64667],"mapped",[1574,1607]],[[64668,64668],"mapped",[1576,1580]],[[64669,64669],"mapped",[1576,1581]],[[64670,64670],"mapped",[1576,1582]],[[64671,64671],"mapped",[1576,1605]],[[64672,64672],"mapped",[1576,1607]],[[64673,64673],"mapped",[1578,1580]],[[64674,64674],"mapped",[1578,1581]],[[64675,64675],"mapped",[1578,1582]],[[64676,64676],"mapped",[1578,1605]],[[64677,64677],"mapped",[1578,1607]],[[64678,64678],"mapped",[1579,1605]],[[64679,64679],"mapped",[1580,1581]],[[64680,64680],"mapped",[1580,1605]],[[64681,64681],"mapped",[1581,1580]],[[64682,64682],"mapped",[1581,1605]],[[64683,64683],"mapped",[1582,1580]],[[64684,64684],"mapped",[1582,1605]],[[64685,64685],"mapped",[1587,1580]],[[64686,64686],"mapped",[1587,1581]],[[64687,64687],"mapped",[1587,1582]],[[64688,64688],"mapped",[1587,1605]],[[64689,64689],"mapped",[1589,1581]],[[64690,64690],"mapped",[1589,1582]],[[64691,64691],"mapped",[1589,1605]],[[64692,64692],"mapped",[1590,1580]],[[64693,64693],"mapped",[1590,1581]],[[64694,64694],"mapped",[1590,1582]],[[64695,64695],"mapped",[1590,1605]],[[64696,64696],"mapped",[1591,1581]],[[64697,64697],"mapped",[1592,1605]],[[64698,64698],"mapped",[1593,1580]],[[64699,64699],"mapped",[1593,1605]],[[64700,64700],"mapped",[1594,1580]],[[64701,64701],"mapped",[1594,1605]],[[64702,64702],"mapped",[1601,1580]],[[64703,64703],"mapped",[1601,1581]],[[64704,64704],"mapped",[1601,1582]],[[64705,64705],"mapped",[1601,1605]],[[64706,64706],"mapped",[1602,1581]],[[64707,64707],"mapped",[1602,1605]],[[64708,64708],"mapped",[1603,1580]],[[64709,64709],"mapped",[1603,1581]],[[64710,64710],"mapped",[1603,1582]],[[64711,64711],"mapped",[1603,1604]],[[64712,64712],"mapped",[1603,1605]],[[64713,64713],"mapped",[1604,1580]],[[64714,64714],"mapped",[1604,1581]],[[64715,64715],"mapped",[1604,1582]],[[64716,64716],"mapped",[1604,1605]],[[64717,64717],"mapped",[1604,1607]],[[64718,64718],"mapped",[1605,1580]],[[64719,64719],"mapped",[1605,1581]],[[64720,64720],"mapped",[1605,1582]],[[64721,64721],"mapped",[1605,1605]],[[64722,64722],"mapped",[1606,1580]],[[64723,64723],"mapped",[1606,1581]],[[64724,64724],"mapped",[1606,1582]],[[64725,64725],"mapped",[1606,1605]],[[64726,64726],"mapped",[1606,1607]],[[64727,64727],"mapped",[1607,1580]],[[64728,64728],"mapped",[1607,1605]],[[64729,64729],"mapped",[1607,1648]],[[64730,64730],"mapped",[1610,1580]],[[64731,64731],"mapped",[1610,1581]],[[64732,64732],"mapped",[1610,1582]],[[64733,64733],"mapped",[1610,1605]],[[64734,64734],"mapped",[1610,1607]],[[64735,64735],"mapped",[1574,1605]],[[64736,64736],"mapped",[1574,1607]],[[64737,64737],"mapped",[1576,1605]],[[64738,64738],"mapped",[1576,1607]],[[64739,64739],"mapped",[1578,1605]],[[64740,64740],"mapped",[1578,1607]],[[64741,64741],"mapped",[1579,1605]],[[64742,64742],"mapped",[1579,1607]],[[64743,64743],"mapped",[1587,1605]],[[64744,64744],"mapped",[1587,1607]],[[64745,64745],"mapped",[1588,1605]],[[64746,64746],"mapped",[1588,1607]],[[64747,64747],"mapped",[1603,1604]],[[64748,64748],"mapped",[1603,1605]],[[64749,64749],"mapped",[1604,1605]],[[64750,64750],"mapped",[1606,1605]],[[64751,64751],"mapped",[1606,1607]],[[64752,64752],"mapped",[1610,1605]],[[64753,64753],"mapped",[1610,1607]],[[64754,64754],"mapped",[1600,1614,1617]],[[64755,64755],"mapped",[1600,1615,1617]],[[64756,64756],"mapped",[1600,1616,1617]],[[64757,64757],"mapped",[1591,1609]],[[64758,64758],"mapped",[1591,1610]],[[64759,64759],"mapped",[1593,1609]],[[64760,64760],"mapped",[1593,1610]],[[64761,64761],"mapped",[1594,1609]],[[64762,64762],"mapped",[1594,1610]],[[64763,64763],"mapped",[1587,1609]],[[64764,64764],"mapped",[1587,1610]],[[64765,64765],"mapped",[1588,1609]],[[64766,64766],"mapped",[1588,1610]],[[64767,64767],"mapped",[1581,1609]],[[64768,64768],"mapped",[1581,1610]],[[64769,64769],"mapped",[1580,1609]],[[64770,64770],"mapped",[1580,1610]],[[64771,64771],"mapped",[1582,1609]],[[64772,64772],"mapped",[1582,1610]],[[64773,64773],"mapped",[1589,1609]],[[64774,64774],"mapped",[1589,1610]],[[64775,64775],"mapped",[1590,1609]],[[64776,64776],"mapped",[1590,1610]],[[64777,64777],"mapped",[1588,1580]],[[64778,64778],"mapped",[1588,1581]],[[64779,64779],"mapped",[1588,1582]],[[64780,64780],"mapped",[1588,1605]],[[64781,64781],"mapped",[1588,1585]],[[64782,64782],"mapped",[1587,1585]],[[64783,64783],"mapped",[1589,1585]],[[64784,64784],"mapped",[1590,1585]],[[64785,64785],"mapped",[1591,1609]],[[64786,64786],"mapped",[1591,1610]],[[64787,64787],"mapped",[1593,1609]],[[64788,64788],"mapped",[1593,1610]],[[64789,64789],"mapped",[1594,1609]],[[64790,64790],"mapped",[1594,1610]],[[64791,64791],"mapped",[1587,1609]],[[64792,64792],"mapped",[1587,1610]],[[64793,64793],"mapped",[1588,1609]],[[64794,64794],"mapped",[1588,1610]],[[64795,64795],"mapped",[1581,1609]],[[64796,64796],"mapped",[1581,1610]],[[64797,64797],"mapped",[1580,1609]],[[64798,64798],"mapped",[1580,1610]],[[64799,64799],"mapped",[1582,1609]],[[64800,64800],"mapped",[1582,1610]],[[64801,64801],"mapped",[1589,1609]],[[64802,64802],"mapped",[1589,1610]],[[64803,64803],"mapped",[1590,1609]],[[64804,64804],"mapped",[1590,1610]],[[64805,64805],"mapped",[1588,1580]],[[64806,64806],"mapped",[1588,1581]],[[64807,64807],"mapped",[1588,1582]],[[64808,64808],"mapped",[1588,1605]],[[64809,64809],"mapped",[1588,1585]],[[64810,64810],"mapped",[1587,1585]],[[64811,64811],"mapped",[1589,1585]],[[64812,64812],"mapped",[1590,1585]],[[64813,64813],"mapped",[1588,1580]],[[64814,64814],"mapped",[1588,1581]],[[64815,64815],"mapped",[1588,1582]],[[64816,64816],"mapped",[1588,1605]],[[64817,64817],"mapped",[1587,1607]],[[64818,64818],"mapped",[1588,1607]],[[64819,64819],"mapped",[1591,1605]],[[64820,64820],"mapped",[1587,1580]],[[64821,64821],"mapped",[1587,1581]],[[64822,64822],"mapped",[1587,1582]],[[64823,64823],"mapped",[1588,1580]],[[64824,64824],"mapped",[1588,1581]],[[64825,64825],"mapped",[1588,1582]],[[64826,64826],"mapped",[1591,1605]],[[64827,64827],"mapped",[1592,1605]],[[64828,64829],"mapped",[1575,1611]],[[64830,64831],"valid",[],"NV8"],[[64832,64847],"disallowed"],[[64848,64848],"mapped",[1578,1580,1605]],[[64849,64850],"mapped",[1578,1581,1580]],[[64851,64851],"mapped",[1578,1581,1605]],[[64852,64852],"mapped",[1578,1582,1605]],[[64853,64853],"mapped",[1578,1605,1580]],[[64854,64854],"mapped",[1578,1605,1581]],[[64855,64855],"mapped",[1578,1605,1582]],[[64856,64857],"mapped",[1580,1605,1581]],[[64858,64858],"mapped",[1581,1605,1610]],[[64859,64859],"mapped",[1581,1605,1609]],[[64860,64860],"mapped",[1587,1581,1580]],[[64861,64861],"mapped",[1587,1580,1581]],[[64862,64862],"mapped",[1587,1580,1609]],[[64863,64864],"mapped",[1587,1605,1581]],[[64865,64865],"mapped",[1587,1605,1580]],[[64866,64867],"mapped",[1587,1605,1605]],[[64868,64869],"mapped",[1589,1581,1581]],[[64870,64870],"mapped",[1589,1605,1605]],[[64871,64872],"mapped",[1588,1581,1605]],[[64873,64873],"mapped",[1588,1580,1610]],[[64874,64875],"mapped",[1588,1605,1582]],[[64876,64877],"mapped",[1588,1605,1605]],[[64878,64878],"mapped",[1590,1581,1609]],[[64879,64880],"mapped",[1590,1582,1605]],[[64881,64882],"mapped",[1591,1605,1581]],[[64883,64883],"mapped",[1591,1605,1605]],[[64884,64884],"mapped",[1591,1605,1610]],[[64885,64885],"mapped",[1593,1580,1605]],[[64886,64887],"mapped",[1593,1605,1605]],[[64888,64888],"mapped",[1593,1605,1609]],[[64889,64889],"mapped",[1594,1605,1605]],[[64890,64890],"mapped",[1594,1605,1610]],[[64891,64891],"mapped",[1594,1605,1609]],[[64892,64893],"mapped",[1601,1582,1605]],[[64894,64894],"mapped",[1602,1605,1581]],[[64895,64895],"mapped",[1602,1605,1605]],[[64896,64896],"mapped",[1604,1581,1605]],[[64897,64897],"mapped",[1604,1581,1610]],[[64898,64898],"mapped",[1604,1581,1609]],[[64899,64900],"mapped",[1604,1580,1580]],[[64901,64902],"mapped",[1604,1582,1605]],[[64903,64904],"mapped",[1604,1605,1581]],[[64905,64905],"mapped",[1605,1581,1580]],[[64906,64906],"mapped",[1605,1581,1605]],[[64907,64907],"mapped",[1605,1581,1610]],[[64908,64908],"mapped",[1605,1580,1581]],[[64909,64909],"mapped",[1605,1580,1605]],[[64910,64910],"mapped",[1605,1582,1580]],[[64911,64911],"mapped",[1605,1582,1605]],[[64912,64913],"disallowed"],[[64914,64914],"mapped",[1605,1580,1582]],[[64915,64915],"mapped",[1607,1605,1580]],[[64916,64916],"mapped",[1607,1605,1605]],[[64917,64917],"mapped",[1606,1581,1605]],[[64918,64918],"mapped",[1606,1581,1609]],[[64919,64920],"mapped",[1606,1580,1605]],[[64921,64921],"mapped",[1606,1580,1609]],[[64922,64922],"mapped",[1606,1605,1610]],[[64923,64923],"mapped",[1606,1605,1609]],[[64924,64925],"mapped",[1610,1605,1605]],[[64926,64926],"mapped",[1576,1582,1610]],[[64927,64927],"mapped",[1578,1580,1610]],[[64928,64928],"mapped",[1578,1580,1609]],[[64929,64929],"mapped",[1578,1582,1610]],[[64930,64930],"mapped",[1578,1582,1609]],[[64931,64931],"mapped",[1578,1605,1610]],[[64932,64932],"mapped",[1578,1605,1609]],[[64933,64933],"mapped",[1580,1605,1610]],[[64934,64934],"mapped",[1580,1581,1609]],[[64935,64935],"mapped",[1580,1605,1609]],[[64936,64936],"mapped",[1587,1582,1609]],[[64937,64937],"mapped",[1589,1581,1610]],[[64938,64938],"mapped",[1588,1581,1610]],[[64939,64939],"mapped",[1590,1581,1610]],[[64940,64940],"mapped",[1604,1580,1610]],[[64941,64941],"mapped",[1604,1605,1610]],[[64942,64942],"mapped",[1610,1581,1610]],[[64943,64943],"mapped",[1610,1580,1610]],[[64944,64944],"mapped",[1610,1605,1610]],[[64945,64945],"mapped",[1605,1605,1610]],[[64946,64946],"mapped",[1602,1605,1610]],[[64947,64947],"mapped",[1606,1581,1610]],[[64948,64948],"mapped",[1602,1605,1581]],[[64949,64949],"mapped",[1604,1581,1605]],[[64950,64950],"mapped",[1593,1605,1610]],[[64951,64951],"mapped",[1603,1605,1610]],[[64952,64952],"mapped",[1606,1580,1581]],[[64953,64953],"mapped",[1605,1582,1610]],[[64954,64954],"mapped",[1604,1580,1605]],[[64955,64955],"mapped",[1603,1605,1605]],[[64956,64956],"mapped",[1604,1580,1605]],[[64957,64957],"mapped",[1606,1580,1581]],[[64958,64958],"mapped",[1580,1581,1610]],[[64959,64959],"mapped",[1581,1580,1610]],[[64960,64960],"mapped",[1605,1580,1610]],[[64961,64961],"mapped",[1601,1605,1610]],[[64962,64962],"mapped",[1576,1581,1610]],[[64963,64963],"mapped",[1603,1605,1605]],[[64964,64964],"mapped",[1593,1580,1605]],[[64965,64965],"mapped",[1589,1605,1605]],[[64966,64966],"mapped",[1587,1582,1610]],[[64967,64967],"mapped",[1606,1580,1610]],[[64968,64975],"disallowed"],[[64976,65007],"disallowed"],[[65008,65008],"mapped",[1589,1604,1746]],[[65009,65009],"mapped",[1602,1604,1746]],[[65010,65010],"mapped",[1575,1604,1604,1607]],[[65011,65011],"mapped",[1575,1603,1576,1585]],[[65012,65012],"mapped",[1605,1581,1605,1583]],[[65013,65013],"mapped",[1589,1604,1593,1605]],[[65014,65014],"mapped",[1585,1587,1608,1604]],[[65015,65015],"mapped",[1593,1604,1610,1607]],[[65016,65016],"mapped",[1608,1587,1604,1605]],[[65017,65017],"mapped",[1589,1604,1609]],[[65018,65018],"disallowed_STD3_mapped",[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605]],[[65019,65019],"disallowed_STD3_mapped",[1580,1604,32,1580,1604,1575,1604,1607]],[[65020,65020],"mapped",[1585,1740,1575,1604]],[[65021,65021],"valid",[],"NV8"],[[65022,65023],"disallowed"],[[65024,65039],"ignored"],[[65040,65040],"disallowed_STD3_mapped",[44]],[[65041,65041],"mapped",[12289]],[[65042,65042],"disallowed"],[[65043,65043],"disallowed_STD3_mapped",[58]],[[65044,65044],"disallowed_STD3_mapped",[59]],[[65045,65045],"disallowed_STD3_mapped",[33]],[[65046,65046],"disallowed_STD3_mapped",[63]],[[65047,65047],"mapped",[12310]],[[65048,65048],"mapped",[12311]],[[65049,65049],"disallowed"],[[65050,65055],"disallowed"],[[65056,65059],"valid"],[[65060,65062],"valid"],[[65063,65069],"valid"],[[65070,65071],"valid"],[[65072,65072],"disallowed"],[[65073,65073],"mapped",[8212]],[[65074,65074],"mapped",[8211]],[[65075,65076],"disallowed_STD3_mapped",[95]],[[65077,65077],"disallowed_STD3_mapped",[40]],[[65078,65078],"disallowed_STD3_mapped",[41]],[[65079,65079],"disallowed_STD3_mapped",[123]],[[65080,65080],"disallowed_STD3_mapped",[125]],[[65081,65081],"mapped",[12308]],[[65082,65082],"mapped",[12309]],[[65083,65083],"mapped",[12304]],[[65084,65084],"mapped",[12305]],[[65085,65085],"mapped",[12298]],[[65086,65086],"mapped",[12299]],[[65087,65087],"mapped",[12296]],[[65088,65088],"mapped",[12297]],[[65089,65089],"mapped",[12300]],[[65090,65090],"mapped",[12301]],[[65091,65091],"mapped",[12302]],[[65092,65092],"mapped",[12303]],[[65093,65094],"valid",[],"NV8"],[[65095,65095],"disallowed_STD3_mapped",[91]],[[65096,65096],"disallowed_STD3_mapped",[93]],[[65097,65100],"disallowed_STD3_mapped",[32,773]],[[65101,65103],"disallowed_STD3_mapped",[95]],[[65104,65104],"disallowed_STD3_mapped",[44]],[[65105,65105],"mapped",[12289]],[[65106,65106],"disallowed"],[[65107,65107],"disallowed"],[[65108,65108],"disallowed_STD3_mapped",[59]],[[65109,65109],"disallowed_STD3_mapped",[58]],[[65110,65110],"disallowed_STD3_mapped",[63]],[[65111,65111],"disallowed_STD3_mapped",[33]],[[65112,65112],"mapped",[8212]],[[65113,65113],"disallowed_STD3_mapped",[40]],[[65114,65114],"disallowed_STD3_mapped",[41]],[[65115,65115],"disallowed_STD3_mapped",[123]],[[65116,65116],"disallowed_STD3_mapped",[125]],[[65117,65117],"mapped",[12308]],[[65118,65118],"mapped",[12309]],[[65119,65119],"disallowed_STD3_mapped",[35]],[[65120,65120],"disallowed_STD3_mapped",[38]],[[65121,65121],"disallowed_STD3_mapped",[42]],[[65122,65122],"disallowed_STD3_mapped",[43]],[[65123,65123],"mapped",[45]],[[65124,65124],"disallowed_STD3_mapped",[60]],[[65125,65125],"disallowed_STD3_mapped",[62]],[[65126,65126],"disallowed_STD3_mapped",[61]],[[65127,65127],"disallowed"],[[65128,65128],"disallowed_STD3_mapped",[92]],[[65129,65129],"disallowed_STD3_mapped",[36]],[[65130,65130],"disallowed_STD3_mapped",[37]],[[65131,65131],"disallowed_STD3_mapped",[64]],[[65132,65135],"disallowed"],[[65136,65136],"disallowed_STD3_mapped",[32,1611]],[[65137,65137],"mapped",[1600,1611]],[[65138,65138],"disallowed_STD3_mapped",[32,1612]],[[65139,65139],"valid"],[[65140,65140],"disallowed_STD3_mapped",[32,1613]],[[65141,65141],"disallowed"],[[65142,65142],"disallowed_STD3_mapped",[32,1614]],[[65143,65143],"mapped",[1600,1614]],[[65144,65144],"disallowed_STD3_mapped",[32,1615]],[[65145,65145],"mapped",[1600,1615]],[[65146,65146],"disallowed_STD3_mapped",[32,1616]],[[65147,65147],"mapped",[1600,1616]],[[65148,65148],"disallowed_STD3_mapped",[32,1617]],[[65149,65149],"mapped",[1600,1617]],[[65150,65150],"disallowed_STD3_mapped",[32,1618]],[[65151,65151],"mapped",[1600,1618]],[[65152,65152],"mapped",[1569]],[[65153,65154],"mapped",[1570]],[[65155,65156],"mapped",[1571]],[[65157,65158],"mapped",[1572]],[[65159,65160],"mapped",[1573]],[[65161,65164],"mapped",[1574]],[[65165,65166],"mapped",[1575]],[[65167,65170],"mapped",[1576]],[[65171,65172],"mapped",[1577]],[[65173,65176],"mapped",[1578]],[[65177,65180],"mapped",[1579]],[[65181,65184],"mapped",[1580]],[[65185,65188],"mapped",[1581]],[[65189,65192],"mapped",[1582]],[[65193,65194],"mapped",[1583]],[[65195,65196],"mapped",[1584]],[[65197,65198],"mapped",[1585]],[[65199,65200],"mapped",[1586]],[[65201,65204],"mapped",[1587]],[[65205,65208],"mapped",[1588]],[[65209,65212],"mapped",[1589]],[[65213,65216],"mapped",[1590]],[[65217,65220],"mapped",[1591]],[[65221,65224],"mapped",[1592]],[[65225,65228],"mapped",[1593]],[[65229,65232],"mapped",[1594]],[[65233,65236],"mapped",[1601]],[[65237,65240],"mapped",[1602]],[[65241,65244],"mapped",[1603]],[[65245,65248],"mapped",[1604]],[[65249,65252],"mapped",[1605]],[[65253,65256],"mapped",[1606]],[[65257,65260],"mapped",[1607]],[[65261,65262],"mapped",[1608]],[[65263,65264],"mapped",[1609]],[[65265,65268],"mapped",[1610]],[[65269,65270],"mapped",[1604,1570]],[[65271,65272],"mapped",[1604,1571]],[[65273,65274],"mapped",[1604,1573]],[[65275,65276],"mapped",[1604,1575]],[[65277,65278],"disallowed"],[[65279,65279],"ignored"],[[65280,65280],"disallowed"],[[65281,65281],"disallowed_STD3_mapped",[33]],[[65282,65282],"disallowed_STD3_mapped",[34]],[[65283,65283],"disallowed_STD3_mapped",[35]],[[65284,65284],"disallowed_STD3_mapped",[36]],[[65285,65285],"disallowed_STD3_mapped",[37]],[[65286,65286],"disallowed_STD3_mapped",[38]],[[65287,65287],"disallowed_STD3_mapped",[39]],[[65288,65288],"disallowed_STD3_mapped",[40]],[[65289,65289],"disallowed_STD3_mapped",[41]],[[65290,65290],"disallowed_STD3_mapped",[42]],[[65291,65291],"disallowed_STD3_mapped",[43]],[[65292,65292],"disallowed_STD3_mapped",[44]],[[65293,65293],"mapped",[45]],[[65294,65294],"mapped",[46]],[[65295,65295],"disallowed_STD3_mapped",[47]],[[65296,65296],"mapped",[48]],[[65297,65297],"mapped",[49]],[[65298,65298],"mapped",[50]],[[65299,65299],"mapped",[51]],[[65300,65300],"mapped",[52]],[[65301,65301],"mapped",[53]],[[65302,65302],"mapped",[54]],[[65303,65303],"mapped",[55]],[[65304,65304],"mapped",[56]],[[65305,65305],"mapped",[57]],[[65306,65306],"disallowed_STD3_mapped",[58]],[[65307,65307],"disallowed_STD3_mapped",[59]],[[65308,65308],"disallowed_STD3_mapped",[60]],[[65309,65309],"disallowed_STD3_mapped",[61]],[[65310,65310],"disallowed_STD3_mapped",[62]],[[65311,65311],"disallowed_STD3_mapped",[63]],[[65312,65312],"disallowed_STD3_mapped",[64]],[[65313,65313],"mapped",[97]],[[65314,65314],"mapped",[98]],[[65315,65315],"mapped",[99]],[[65316,65316],"mapped",[100]],[[65317,65317],"mapped",[101]],[[65318,65318],"mapped",[102]],[[65319,65319],"mapped",[103]],[[65320,65320],"mapped",[104]],[[65321,65321],"mapped",[105]],[[65322,65322],"mapped",[106]],[[65323,65323],"mapped",[107]],[[65324,65324],"mapped",[108]],[[65325,65325],"mapped",[109]],[[65326,65326],"mapped",[110]],[[65327,65327],"mapped",[111]],[[65328,65328],"mapped",[112]],[[65329,65329],"mapped",[113]],[[65330,65330],"mapped",[114]],[[65331,65331],"mapped",[115]],[[65332,65332],"mapped",[116]],[[65333,65333],"mapped",[117]],[[65334,65334],"mapped",[118]],[[65335,65335],"mapped",[119]],[[65336,65336],"mapped",[120]],[[65337,65337],"mapped",[121]],[[65338,65338],"mapped",[122]],[[65339,65339],"disallowed_STD3_mapped",[91]],[[65340,65340],"disallowed_STD3_mapped",[92]],[[65341,65341],"disallowed_STD3_mapped",[93]],[[65342,65342],"disallowed_STD3_mapped",[94]],[[65343,65343],"disallowed_STD3_mapped",[95]],[[65344,65344],"disallowed_STD3_mapped",[96]],[[65345,65345],"mapped",[97]],[[65346,65346],"mapped",[98]],[[65347,65347],"mapped",[99]],[[65348,65348],"mapped",[100]],[[65349,65349],"mapped",[101]],[[65350,65350],"mapped",[102]],[[65351,65351],"mapped",[103]],[[65352,65352],"mapped",[104]],[[65353,65353],"mapped",[105]],[[65354,65354],"mapped",[106]],[[65355,65355],"mapped",[107]],[[65356,65356],"mapped",[108]],[[65357,65357],"mapped",[109]],[[65358,65358],"mapped",[110]],[[65359,65359],"mapped",[111]],[[65360,65360],"mapped",[112]],[[65361,65361],"mapped",[113]],[[65362,65362],"mapped",[114]],[[65363,65363],"mapped",[115]],[[65364,65364],"mapped",[116]],[[65365,65365],"mapped",[117]],[[65366,65366],"mapped",[118]],[[65367,65367],"mapped",[119]],[[65368,65368],"mapped",[120]],[[65369,65369],"mapped",[121]],[[65370,65370],"mapped",[122]],[[65371,65371],"disallowed_STD3_mapped",[123]],[[65372,65372],"disallowed_STD3_mapped",[124]],[[65373,65373],"disallowed_STD3_mapped",[125]],[[65374,65374],"disallowed_STD3_mapped",[126]],[[65375,65375],"mapped",[10629]],[[65376,65376],"mapped",[10630]],[[65377,65377],"mapped",[46]],[[65378,65378],"mapped",[12300]],[[65379,65379],"mapped",[12301]],[[65380,65380],"mapped",[12289]],[[65381,65381],"mapped",[12539]],[[65382,65382],"mapped",[12530]],[[65383,65383],"mapped",[12449]],[[65384,65384],"mapped",[12451]],[[65385,65385],"mapped",[12453]],[[65386,65386],"mapped",[12455]],[[65387,65387],"mapped",[12457]],[[65388,65388],"mapped",[12515]],[[65389,65389],"mapped",[12517]],[[65390,65390],"mapped",[12519]],[[65391,65391],"mapped",[12483]],[[65392,65392],"mapped",[12540]],[[65393,65393],"mapped",[12450]],[[65394,65394],"mapped",[12452]],[[65395,65395],"mapped",[12454]],[[65396,65396],"mapped",[12456]],[[65397,65397],"mapped",[12458]],[[65398,65398],"mapped",[12459]],[[65399,65399],"mapped",[12461]],[[65400,65400],"mapped",[12463]],[[65401,65401],"mapped",[12465]],[[65402,65402],"mapped",[12467]],[[65403,65403],"mapped",[12469]],[[65404,65404],"mapped",[12471]],[[65405,65405],"mapped",[12473]],[[65406,65406],"mapped",[12475]],[[65407,65407],"mapped",[12477]],[[65408,65408],"mapped",[12479]],[[65409,65409],"mapped",[12481]],[[65410,65410],"mapped",[12484]],[[65411,65411],"mapped",[12486]],[[65412,65412],"mapped",[12488]],[[65413,65413],"mapped",[12490]],[[65414,65414],"mapped",[12491]],[[65415,65415],"mapped",[12492]],[[65416,65416],"mapped",[12493]],[[65417,65417],"mapped",[12494]],[[65418,65418],"mapped",[12495]],[[65419,65419],"mapped",[12498]],[[65420,65420],"mapped",[12501]],[[65421,65421],"mapped",[12504]],[[65422,65422],"mapped",[12507]],[[65423,65423],"mapped",[12510]],[[65424,65424],"mapped",[12511]],[[65425,65425],"mapped",[12512]],[[65426,65426],"mapped",[12513]],[[65427,65427],"mapped",[12514]],[[65428,65428],"mapped",[12516]],[[65429,65429],"mapped",[12518]],[[65430,65430],"mapped",[12520]],[[65431,65431],"mapped",[12521]],[[65432,65432],"mapped",[12522]],[[65433,65433],"mapped",[12523]],[[65434,65434],"mapped",[12524]],[[65435,65435],"mapped",[12525]],[[65436,65436],"mapped",[12527]],[[65437,65437],"mapped",[12531]],[[65438,65438],"mapped",[12441]],[[65439,65439],"mapped",[12442]],[[65440,65440],"disallowed"],[[65441,65441],"mapped",[4352]],[[65442,65442],"mapped",[4353]],[[65443,65443],"mapped",[4522]],[[65444,65444],"mapped",[4354]],[[65445,65445],"mapped",[4524]],[[65446,65446],"mapped",[4525]],[[65447,65447],"mapped",[4355]],[[65448,65448],"mapped",[4356]],[[65449,65449],"mapped",[4357]],[[65450,65450],"mapped",[4528]],[[65451,65451],"mapped",[4529]],[[65452,65452],"mapped",[4530]],[[65453,65453],"mapped",[4531]],[[65454,65454],"mapped",[4532]],[[65455,65455],"mapped",[4533]],[[65456,65456],"mapped",[4378]],[[65457,65457],"mapped",[4358]],[[65458,65458],"mapped",[4359]],[[65459,65459],"mapped",[4360]],[[65460,65460],"mapped",[4385]],[[65461,65461],"mapped",[4361]],[[65462,65462],"mapped",[4362]],[[65463,65463],"mapped",[4363]],[[65464,65464],"mapped",[4364]],[[65465,65465],"mapped",[4365]],[[65466,65466],"mapped",[4366]],[[65467,65467],"mapped",[4367]],[[65468,65468],"mapped",[4368]],[[65469,65469],"mapped",[4369]],[[65470,65470],"mapped",[4370]],[[65471,65473],"disallowed"],[[65474,65474],"mapped",[4449]],[[65475,65475],"mapped",[4450]],[[65476,65476],"mapped",[4451]],[[65477,65477],"mapped",[4452]],[[65478,65478],"mapped",[4453]],[[65479,65479],"mapped",[4454]],[[65480,65481],"disallowed"],[[65482,65482],"mapped",[4455]],[[65483,65483],"mapped",[4456]],[[65484,65484],"mapped",[4457]],[[65485,65485],"mapped",[4458]],[[65486,65486],"mapped",[4459]],[[65487,65487],"mapped",[4460]],[[65488,65489],"disallowed"],[[65490,65490],"mapped",[4461]],[[65491,65491],"mapped",[4462]],[[65492,65492],"mapped",[4463]],[[65493,65493],"mapped",[4464]],[[65494,65494],"mapped",[4465]],[[65495,65495],"mapped",[4466]],[[65496,65497],"disallowed"],[[65498,65498],"mapped",[4467]],[[65499,65499],"mapped",[4468]],[[65500,65500],"mapped",[4469]],[[65501,65503],"disallowed"],[[65504,65504],"mapped",[162]],[[65505,65505],"mapped",[163]],[[65506,65506],"mapped",[172]],[[65507,65507],"disallowed_STD3_mapped",[32,772]],[[65508,65508],"mapped",[166]],[[65509,65509],"mapped",[165]],[[65510,65510],"mapped",[8361]],[[65511,65511],"disallowed"],[[65512,65512],"mapped",[9474]],[[65513,65513],"mapped",[8592]],[[65514,65514],"mapped",[8593]],[[65515,65515],"mapped",[8594]],[[65516,65516],"mapped",[8595]],[[65517,65517],"mapped",[9632]],[[65518,65518],"mapped",[9675]],[[65519,65528],"disallowed"],[[65529,65531],"disallowed"],[[65532,65532],"disallowed"],[[65533,65533],"disallowed"],[[65534,65535],"disallowed"],[[65536,65547],"valid"],[[65548,65548],"disallowed"],[[65549,65574],"valid"],[[65575,65575],"disallowed"],[[65576,65594],"valid"],[[65595,65595],"disallowed"],[[65596,65597],"valid"],[[65598,65598],"disallowed"],[[65599,65613],"valid"],[[65614,65615],"disallowed"],[[65616,65629],"valid"],[[65630,65663],"disallowed"],[[65664,65786],"valid"],[[65787,65791],"disallowed"],[[65792,65794],"valid",[],"NV8"],[[65795,65798],"disallowed"],[[65799,65843],"valid",[],"NV8"],[[65844,65846],"disallowed"],[[65847,65855],"valid",[],"NV8"],[[65856,65930],"valid",[],"NV8"],[[65931,65932],"valid",[],"NV8"],[[65933,65935],"disallowed"],[[65936,65947],"valid",[],"NV8"],[[65948,65951],"disallowed"],[[65952,65952],"valid",[],"NV8"],[[65953,65999],"disallowed"],[[66000,66044],"valid",[],"NV8"],[[66045,66045],"valid"],[[66046,66175],"disallowed"],[[66176,66204],"valid"],[[66205,66207],"disallowed"],[[66208,66256],"valid"],[[66257,66271],"disallowed"],[[66272,66272],"valid"],[[66273,66299],"valid",[],"NV8"],[[66300,66303],"disallowed"],[[66304,66334],"valid"],[[66335,66335],"valid"],[[66336,66339],"valid",[],"NV8"],[[66340,66351],"disallowed"],[[66352,66368],"valid"],[[66369,66369],"valid",[],"NV8"],[[66370,66377],"valid"],[[66378,66378],"valid",[],"NV8"],[[66379,66383],"disallowed"],[[66384,66426],"valid"],[[66427,66431],"disallowed"],[[66432,66461],"valid"],[[66462,66462],"disallowed"],[[66463,66463],"valid",[],"NV8"],[[66464,66499],"valid"],[[66500,66503],"disallowed"],[[66504,66511],"valid"],[[66512,66517],"valid",[],"NV8"],[[66518,66559],"disallowed"],[[66560,66560],"mapped",[66600]],[[66561,66561],"mapped",[66601]],[[66562,66562],"mapped",[66602]],[[66563,66563],"mapped",[66603]],[[66564,66564],"mapped",[66604]],[[66565,66565],"mapped",[66605]],[[66566,66566],"mapped",[66606]],[[66567,66567],"mapped",[66607]],[[66568,66568],"mapped",[66608]],[[66569,66569],"mapped",[66609]],[[66570,66570],"mapped",[66610]],[[66571,66571],"mapped",[66611]],[[66572,66572],"mapped",[66612]],[[66573,66573],"mapped",[66613]],[[66574,66574],"mapped",[66614]],[[66575,66575],"mapped",[66615]],[[66576,66576],"mapped",[66616]],[[66577,66577],"mapped",[66617]],[[66578,66578],"mapped",[66618]],[[66579,66579],"mapped",[66619]],[[66580,66580],"mapped",[66620]],[[66581,66581],"mapped",[66621]],[[66582,66582],"mapped",[66622]],[[66583,66583],"mapped",[66623]],[[66584,66584],"mapped",[66624]],[[66585,66585],"mapped",[66625]],[[66586,66586],"mapped",[66626]],[[66587,66587],"mapped",[66627]],[[66588,66588],"mapped",[66628]],[[66589,66589],"mapped",[66629]],[[66590,66590],"mapped",[66630]],[[66591,66591],"mapped",[66631]],[[66592,66592],"mapped",[66632]],[[66593,66593],"mapped",[66633]],[[66594,66594],"mapped",[66634]],[[66595,66595],"mapped",[66635]],[[66596,66596],"mapped",[66636]],[[66597,66597],"mapped",[66637]],[[66598,66598],"mapped",[66638]],[[66599,66599],"mapped",[66639]],[[66600,66637],"valid"],[[66638,66717],"valid"],[[66718,66719],"disallowed"],[[66720,66729],"valid"],[[66730,66815],"disallowed"],[[66816,66855],"valid"],[[66856,66863],"disallowed"],[[66864,66915],"valid"],[[66916,66926],"disallowed"],[[66927,66927],"valid",[],"NV8"],[[66928,67071],"disallowed"],[[67072,67382],"valid"],[[67383,67391],"disallowed"],[[67392,67413],"valid"],[[67414,67423],"disallowed"],[[67424,67431],"valid"],[[67432,67583],"disallowed"],[[67584,67589],"valid"],[[67590,67591],"disallowed"],[[67592,67592],"valid"],[[67593,67593],"disallowed"],[[67594,67637],"valid"],[[67638,67638],"disallowed"],[[67639,67640],"valid"],[[67641,67643],"disallowed"],[[67644,67644],"valid"],[[67645,67646],"disallowed"],[[67647,67647],"valid"],[[67648,67669],"valid"],[[67670,67670],"disallowed"],[[67671,67679],"valid",[],"NV8"],[[67680,67702],"valid"],[[67703,67711],"valid",[],"NV8"],[[67712,67742],"valid"],[[67743,67750],"disallowed"],[[67751,67759],"valid",[],"NV8"],[[67760,67807],"disallowed"],[[67808,67826],"valid"],[[67827,67827],"disallowed"],[[67828,67829],"valid"],[[67830,67834],"disallowed"],[[67835,67839],"valid",[],"NV8"],[[67840,67861],"valid"],[[67862,67865],"valid",[],"NV8"],[[67866,67867],"valid",[],"NV8"],[[67868,67870],"disallowed"],[[67871,67871],"valid",[],"NV8"],[[67872,67897],"valid"],[[67898,67902],"disallowed"],[[67903,67903],"valid",[],"NV8"],[[67904,67967],"disallowed"],[[67968,68023],"valid"],[[68024,68027],"disallowed"],[[68028,68029],"valid",[],"NV8"],[[68030,68031],"valid"],[[68032,68047],"valid",[],"NV8"],[[68048,68049],"disallowed"],[[68050,68095],"valid",[],"NV8"],[[68096,68099],"valid"],[[68100,68100],"disallowed"],[[68101,68102],"valid"],[[68103,68107],"disallowed"],[[68108,68115],"valid"],[[68116,68116],"disallowed"],[[68117,68119],"valid"],[[68120,68120],"disallowed"],[[68121,68147],"valid"],[[68148,68151],"disallowed"],[[68152,68154],"valid"],[[68155,68158],"disallowed"],[[68159,68159],"valid"],[[68160,68167],"valid",[],"NV8"],[[68168,68175],"disallowed"],[[68176,68184],"valid",[],"NV8"],[[68185,68191],"disallowed"],[[68192,68220],"valid"],[[68221,68223],"valid",[],"NV8"],[[68224,68252],"valid"],[[68253,68255],"valid",[],"NV8"],[[68256,68287],"disallowed"],[[68288,68295],"valid"],[[68296,68296],"valid",[],"NV8"],[[68297,68326],"valid"],[[68327,68330],"disallowed"],[[68331,68342],"valid",[],"NV8"],[[68343,68351],"disallowed"],[[68352,68405],"valid"],[[68406,68408],"disallowed"],[[68409,68415],"valid",[],"NV8"],[[68416,68437],"valid"],[[68438,68439],"disallowed"],[[68440,68447],"valid",[],"NV8"],[[68448,68466],"valid"],[[68467,68471],"disallowed"],[[68472,68479],"valid",[],"NV8"],[[68480,68497],"valid"],[[68498,68504],"disallowed"],[[68505,68508],"valid",[],"NV8"],[[68509,68520],"disallowed"],[[68521,68527],"valid",[],"NV8"],[[68528,68607],"disallowed"],[[68608,68680],"valid"],[[68681,68735],"disallowed"],[[68736,68736],"mapped",[68800]],[[68737,68737],"mapped",[68801]],[[68738,68738],"mapped",[68802]],[[68739,68739],"mapped",[68803]],[[68740,68740],"mapped",[68804]],[[68741,68741],"mapped",[68805]],[[68742,68742],"mapped",[68806]],[[68743,68743],"mapped",[68807]],[[68744,68744],"mapped",[68808]],[[68745,68745],"mapped",[68809]],[[68746,68746],"mapped",[68810]],[[68747,68747],"mapped",[68811]],[[68748,68748],"mapped",[68812]],[[68749,68749],"mapped",[68813]],[[68750,68750],"mapped",[68814]],[[68751,68751],"mapped",[68815]],[[68752,68752],"mapped",[68816]],[[68753,68753],"mapped",[68817]],[[68754,68754],"mapped",[68818]],[[68755,68755],"mapped",[68819]],[[68756,68756],"mapped",[68820]],[[68757,68757],"mapped",[68821]],[[68758,68758],"mapped",[68822]],[[68759,68759],"mapped",[68823]],[[68760,68760],"mapped",[68824]],[[68761,68761],"mapped",[68825]],[[68762,68762],"mapped",[68826]],[[68763,68763],"mapped",[68827]],[[68764,68764],"mapped",[68828]],[[68765,68765],"mapped",[68829]],[[68766,68766],"mapped",[68830]],[[68767,68767],"mapped",[68831]],[[68768,68768],"mapped",[68832]],[[68769,68769],"mapped",[68833]],[[68770,68770],"mapped",[68834]],[[68771,68771],"mapped",[68835]],[[68772,68772],"mapped",[68836]],[[68773,68773],"mapped",[68837]],[[68774,68774],"mapped",[68838]],[[68775,68775],"mapped",[68839]],[[68776,68776],"mapped",[68840]],[[68777,68777],"mapped",[68841]],[[68778,68778],"mapped",[68842]],[[68779,68779],"mapped",[68843]],[[68780,68780],"mapped",[68844]],[[68781,68781],"mapped",[68845]],[[68782,68782],"mapped",[68846]],[[68783,68783],"mapped",[68847]],[[68784,68784],"mapped",[68848]],[[68785,68785],"mapped",[68849]],[[68786,68786],"mapped",[68850]],[[68787,68799],"disallowed"],[[68800,68850],"valid"],[[68851,68857],"disallowed"],[[68858,68863],"valid",[],"NV8"],[[68864,69215],"disallowed"],[[69216,69246],"valid",[],"NV8"],[[69247,69631],"disallowed"],[[69632,69702],"valid"],[[69703,69709],"valid",[],"NV8"],[[69710,69713],"disallowed"],[[69714,69733],"valid",[],"NV8"],[[69734,69743],"valid"],[[69744,69758],"disallowed"],[[69759,69759],"valid"],[[69760,69818],"valid"],[[69819,69820],"valid",[],"NV8"],[[69821,69821],"disallowed"],[[69822,69825],"valid",[],"NV8"],[[69826,69839],"disallowed"],[[69840,69864],"valid"],[[69865,69871],"disallowed"],[[69872,69881],"valid"],[[69882,69887],"disallowed"],[[69888,69940],"valid"],[[69941,69941],"disallowed"],[[69942,69951],"valid"],[[69952,69955],"valid",[],"NV8"],[[69956,69967],"disallowed"],[[69968,70003],"valid"],[[70004,70005],"valid",[],"NV8"],[[70006,70006],"valid"],[[70007,70015],"disallowed"],[[70016,70084],"valid"],[[70085,70088],"valid",[],"NV8"],[[70089,70089],"valid",[],"NV8"],[[70090,70092],"valid"],[[70093,70093],"valid",[],"NV8"],[[70094,70095],"disallowed"],[[70096,70105],"valid"],[[70106,70106],"valid"],[[70107,70107],"valid",[],"NV8"],[[70108,70108],"valid"],[[70109,70111],"valid",[],"NV8"],[[70112,70112],"disallowed"],[[70113,70132],"valid",[],"NV8"],[[70133,70143],"disallowed"],[[70144,70161],"valid"],[[70162,70162],"disallowed"],[[70163,70199],"valid"],[[70200,70205],"valid",[],"NV8"],[[70206,70271],"disallowed"],[[70272,70278],"valid"],[[70279,70279],"disallowed"],[[70280,70280],"valid"],[[70281,70281],"disallowed"],[[70282,70285],"valid"],[[70286,70286],"disallowed"],[[70287,70301],"valid"],[[70302,70302],"disallowed"],[[70303,70312],"valid"],[[70313,70313],"valid",[],"NV8"],[[70314,70319],"disallowed"],[[70320,70378],"valid"],[[70379,70383],"disallowed"],[[70384,70393],"valid"],[[70394,70399],"disallowed"],[[70400,70400],"valid"],[[70401,70403],"valid"],[[70404,70404],"disallowed"],[[70405,70412],"valid"],[[70413,70414],"disallowed"],[[70415,70416],"valid"],[[70417,70418],"disallowed"],[[70419,70440],"valid"],[[70441,70441],"disallowed"],[[70442,70448],"valid"],[[70449,70449],"disallowed"],[[70450,70451],"valid"],[[70452,70452],"disallowed"],[[70453,70457],"valid"],[[70458,70459],"disallowed"],[[70460,70468],"valid"],[[70469,70470],"disallowed"],[[70471,70472],"valid"],[[70473,70474],"disallowed"],[[70475,70477],"valid"],[[70478,70479],"disallowed"],[[70480,70480],"valid"],[[70481,70486],"disallowed"],[[70487,70487],"valid"],[[70488,70492],"disallowed"],[[70493,70499],"valid"],[[70500,70501],"disallowed"],[[70502,70508],"valid"],[[70509,70511],"disallowed"],[[70512,70516],"valid"],[[70517,70783],"disallowed"],[[70784,70853],"valid"],[[70854,70854],"valid",[],"NV8"],[[70855,70855],"valid"],[[70856,70863],"disallowed"],[[70864,70873],"valid"],[[70874,71039],"disallowed"],[[71040,71093],"valid"],[[71094,71095],"disallowed"],[[71096,71104],"valid"],[[71105,71113],"valid",[],"NV8"],[[71114,71127],"valid",[],"NV8"],[[71128,71133],"valid"],[[71134,71167],"disallowed"],[[71168,71232],"valid"],[[71233,71235],"valid",[],"NV8"],[[71236,71236],"valid"],[[71237,71247],"disallowed"],[[71248,71257],"valid"],[[71258,71295],"disallowed"],[[71296,71351],"valid"],[[71352,71359],"disallowed"],[[71360,71369],"valid"],[[71370,71423],"disallowed"],[[71424,71449],"valid"],[[71450,71452],"disallowed"],[[71453,71467],"valid"],[[71468,71471],"disallowed"],[[71472,71481],"valid"],[[71482,71487],"valid",[],"NV8"],[[71488,71839],"disallowed"],[[71840,71840],"mapped",[71872]],[[71841,71841],"mapped",[71873]],[[71842,71842],"mapped",[71874]],[[71843,71843],"mapped",[71875]],[[71844,71844],"mapped",[71876]],[[71845,71845],"mapped",[71877]],[[71846,71846],"mapped",[71878]],[[71847,71847],"mapped",[71879]],[[71848,71848],"mapped",[71880]],[[71849,71849],"mapped",[71881]],[[71850,71850],"mapped",[71882]],[[71851,71851],"mapped",[71883]],[[71852,71852],"mapped",[71884]],[[71853,71853],"mapped",[71885]],[[71854,71854],"mapped",[71886]],[[71855,71855],"mapped",[71887]],[[71856,71856],"mapped",[71888]],[[71857,71857],"mapped",[71889]],[[71858,71858],"mapped",[71890]],[[71859,71859],"mapped",[71891]],[[71860,71860],"mapped",[71892]],[[71861,71861],"mapped",[71893]],[[71862,71862],"mapped",[71894]],[[71863,71863],"mapped",[71895]],[[71864,71864],"mapped",[71896]],[[71865,71865],"mapped",[71897]],[[71866,71866],"mapped",[71898]],[[71867,71867],"mapped",[71899]],[[71868,71868],"mapped",[71900]],[[71869,71869],"mapped",[71901]],[[71870,71870],"mapped",[71902]],[[71871,71871],"mapped",[71903]],[[71872,71913],"valid"],[[71914,71922],"valid",[],"NV8"],[[71923,71934],"disallowed"],[[71935,71935],"valid"],[[71936,72383],"disallowed"],[[72384,72440],"valid"],[[72441,73727],"disallowed"],[[73728,74606],"valid"],[[74607,74648],"valid"],[[74649,74649],"valid"],[[74650,74751],"disallowed"],[[74752,74850],"valid",[],"NV8"],[[74851,74862],"valid",[],"NV8"],[[74863,74863],"disallowed"],[[74864,74867],"valid",[],"NV8"],[[74868,74868],"valid",[],"NV8"],[[74869,74879],"disallowed"],[[74880,75075],"valid"],[[75076,77823],"disallowed"],[[77824,78894],"valid"],[[78895,82943],"disallowed"],[[82944,83526],"valid"],[[83527,92159],"disallowed"],[[92160,92728],"valid"],[[92729,92735],"disallowed"],[[92736,92766],"valid"],[[92767,92767],"disallowed"],[[92768,92777],"valid"],[[92778,92781],"disallowed"],[[92782,92783],"valid",[],"NV8"],[[92784,92879],"disallowed"],[[92880,92909],"valid"],[[92910,92911],"disallowed"],[[92912,92916],"valid"],[[92917,92917],"valid",[],"NV8"],[[92918,92927],"disallowed"],[[92928,92982],"valid"],[[92983,92991],"valid",[],"NV8"],[[92992,92995],"valid"],[[92996,92997],"valid",[],"NV8"],[[92998,93007],"disallowed"],[[93008,93017],"valid"],[[93018,93018],"disallowed"],[[93019,93025],"valid",[],"NV8"],[[93026,93026],"disallowed"],[[93027,93047],"valid"],[[93048,93052],"disallowed"],[[93053,93071],"valid"],[[93072,93951],"disallowed"],[[93952,94020],"valid"],[[94021,94031],"disallowed"],[[94032,94078],"valid"],[[94079,94094],"disallowed"],[[94095,94111],"valid"],[[94112,110591],"disallowed"],[[110592,110593],"valid"],[[110594,113663],"disallowed"],[[113664,113770],"valid"],[[113771,113775],"disallowed"],[[113776,113788],"valid"],[[113789,113791],"disallowed"],[[113792,113800],"valid"],[[113801,113807],"disallowed"],[[113808,113817],"valid"],[[113818,113819],"disallowed"],[[113820,113820],"valid",[],"NV8"],[[113821,113822],"valid"],[[113823,113823],"valid",[],"NV8"],[[113824,113827],"ignored"],[[113828,118783],"disallowed"],[[118784,119029],"valid",[],"NV8"],[[119030,119039],"disallowed"],[[119040,119078],"valid",[],"NV8"],[[119079,119080],"disallowed"],[[119081,119081],"valid",[],"NV8"],[[119082,119133],"valid",[],"NV8"],[[119134,119134],"mapped",[119127,119141]],[[119135,119135],"mapped",[119128,119141]],[[119136,119136],"mapped",[119128,119141,119150]],[[119137,119137],"mapped",[119128,119141,119151]],[[119138,119138],"mapped",[119128,119141,119152]],[[119139,119139],"mapped",[119128,119141,119153]],[[119140,119140],"mapped",[119128,119141,119154]],[[119141,119154],"valid",[],"NV8"],[[119155,119162],"disallowed"],[[119163,119226],"valid",[],"NV8"],[[119227,119227],"mapped",[119225,119141]],[[119228,119228],"mapped",[119226,119141]],[[119229,119229],"mapped",[119225,119141,119150]],[[119230,119230],"mapped",[119226,119141,119150]],[[119231,119231],"mapped",[119225,119141,119151]],[[119232,119232],"mapped",[119226,119141,119151]],[[119233,119261],"valid",[],"NV8"],[[119262,119272],"valid",[],"NV8"],[[119273,119295],"disallowed"],[[119296,119365],"valid",[],"NV8"],[[119366,119551],"disallowed"],[[119552,119638],"valid",[],"NV8"],[[119639,119647],"disallowed"],[[119648,119665],"valid",[],"NV8"],[[119666,119807],"disallowed"],[[119808,119808],"mapped",[97]],[[119809,119809],"mapped",[98]],[[119810,119810],"mapped",[99]],[[119811,119811],"mapped",[100]],[[119812,119812],"mapped",[101]],[[119813,119813],"mapped",[102]],[[119814,119814],"mapped",[103]],[[119815,119815],"mapped",[104]],[[119816,119816],"mapped",[105]],[[119817,119817],"mapped",[106]],[[119818,119818],"mapped",[107]],[[119819,119819],"mapped",[108]],[[119820,119820],"mapped",[109]],[[119821,119821],"mapped",[110]],[[119822,119822],"mapped",[111]],[[119823,119823],"mapped",[112]],[[119824,119824],"mapped",[113]],[[119825,119825],"mapped",[114]],[[119826,119826],"mapped",[115]],[[119827,119827],"mapped",[116]],[[119828,119828],"mapped",[117]],[[119829,119829],"mapped",[118]],[[119830,119830],"mapped",[119]],[[119831,119831],"mapped",[120]],[[119832,119832],"mapped",[121]],[[119833,119833],"mapped",[122]],[[119834,119834],"mapped",[97]],[[119835,119835],"mapped",[98]],[[119836,119836],"mapped",[99]],[[119837,119837],"mapped",[100]],[[119838,119838],"mapped",[101]],[[119839,119839],"mapped",[102]],[[119840,119840],"mapped",[103]],[[119841,119841],"mapped",[104]],[[119842,119842],"mapped",[105]],[[119843,119843],"mapped",[106]],[[119844,119844],"mapped",[107]],[[119845,119845],"mapped",[108]],[[119846,119846],"mapped",[109]],[[119847,119847],"mapped",[110]],[[119848,119848],"mapped",[111]],[[119849,119849],"mapped",[112]],[[119850,119850],"mapped",[113]],[[119851,119851],"mapped",[114]],[[119852,119852],"mapped",[115]],[[119853,119853],"mapped",[116]],[[119854,119854],"mapped",[117]],[[119855,119855],"mapped",[118]],[[119856,119856],"mapped",[119]],[[119857,119857],"mapped",[120]],[[119858,119858],"mapped",[121]],[[119859,119859],"mapped",[122]],[[119860,119860],"mapped",[97]],[[119861,119861],"mapped",[98]],[[119862,119862],"mapped",[99]],[[119863,119863],"mapped",[100]],[[119864,119864],"mapped",[101]],[[119865,119865],"mapped",[102]],[[119866,119866],"mapped",[103]],[[119867,119867],"mapped",[104]],[[119868,119868],"mapped",[105]],[[119869,119869],"mapped",[106]],[[119870,119870],"mapped",[107]],[[119871,119871],"mapped",[108]],[[119872,119872],"mapped",[109]],[[119873,119873],"mapped",[110]],[[119874,119874],"mapped",[111]],[[119875,119875],"mapped",[112]],[[119876,119876],"mapped",[113]],[[119877,119877],"mapped",[114]],[[119878,119878],"mapped",[115]],[[119879,119879],"mapped",[116]],[[119880,119880],"mapped",[117]],[[119881,119881],"mapped",[118]],[[119882,119882],"mapped",[119]],[[119883,119883],"mapped",[120]],[[119884,119884],"mapped",[121]],[[119885,119885],"mapped",[122]],[[119886,119886],"mapped",[97]],[[119887,119887],"mapped",[98]],[[119888,119888],"mapped",[99]],[[119889,119889],"mapped",[100]],[[119890,119890],"mapped",[101]],[[119891,119891],"mapped",[102]],[[119892,119892],"mapped",[103]],[[119893,119893],"disallowed"],[[119894,119894],"mapped",[105]],[[119895,119895],"mapped",[106]],[[119896,119896],"mapped",[107]],[[119897,119897],"mapped",[108]],[[119898,119898],"mapped",[109]],[[119899,119899],"mapped",[110]],[[119900,119900],"mapped",[111]],[[119901,119901],"mapped",[112]],[[119902,119902],"mapped",[113]],[[119903,119903],"mapped",[114]],[[119904,119904],"mapped",[115]],[[119905,119905],"mapped",[116]],[[119906,119906],"mapped",[117]],[[119907,119907],"mapped",[118]],[[119908,119908],"mapped",[119]],[[119909,119909],"mapped",[120]],[[119910,119910],"mapped",[121]],[[119911,119911],"mapped",[122]],[[119912,119912],"mapped",[97]],[[119913,119913],"mapped",[98]],[[119914,119914],"mapped",[99]],[[119915,119915],"mapped",[100]],[[119916,119916],"mapped",[101]],[[119917,119917],"mapped",[102]],[[119918,119918],"mapped",[103]],[[119919,119919],"mapped",[104]],[[119920,119920],"mapped",[105]],[[119921,119921],"mapped",[106]],[[119922,119922],"mapped",[107]],[[119923,119923],"mapped",[108]],[[119924,119924],"mapped",[109]],[[119925,119925],"mapped",[110]],[[119926,119926],"mapped",[111]],[[119927,119927],"mapped",[112]],[[119928,119928],"mapped",[113]],[[119929,119929],"mapped",[114]],[[119930,119930],"mapped",[115]],[[119931,119931],"mapped",[116]],[[119932,119932],"mapped",[117]],[[119933,119933],"mapped",[118]],[[119934,119934],"mapped",[119]],[[119935,119935],"mapped",[120]],[[119936,119936],"mapped",[121]],[[119937,119937],"mapped",[122]],[[119938,119938],"mapped",[97]],[[119939,119939],"mapped",[98]],[[119940,119940],"mapped",[99]],[[119941,119941],"mapped",[100]],[[119942,119942],"mapped",[101]],[[119943,119943],"mapped",[102]],[[119944,119944],"mapped",[103]],[[119945,119945],"mapped",[104]],[[119946,119946],"mapped",[105]],[[119947,119947],"mapped",[106]],[[119948,119948],"mapped",[107]],[[119949,119949],"mapped",[108]],[[119950,119950],"mapped",[109]],[[119951,119951],"mapped",[110]],[[119952,119952],"mapped",[111]],[[119953,119953],"mapped",[112]],[[119954,119954],"mapped",[113]],[[119955,119955],"mapped",[114]],[[119956,119956],"mapped",[115]],[[119957,119957],"mapped",[116]],[[119958,119958],"mapped",[117]],[[119959,119959],"mapped",[118]],[[119960,119960],"mapped",[119]],[[119961,119961],"mapped",[120]],[[119962,119962],"mapped",[121]],[[119963,119963],"mapped",[122]],[[119964,119964],"mapped",[97]],[[119965,119965],"disallowed"],[[119966,119966],"mapped",[99]],[[119967,119967],"mapped",[100]],[[119968,119969],"disallowed"],[[119970,119970],"mapped",[103]],[[119971,119972],"disallowed"],[[119973,119973],"mapped",[106]],[[119974,119974],"mapped",[107]],[[119975,119976],"disallowed"],[[119977,119977],"mapped",[110]],[[119978,119978],"mapped",[111]],[[119979,119979],"mapped",[112]],[[119980,119980],"mapped",[113]],[[119981,119981],"disallowed"],[[119982,119982],"mapped",[115]],[[119983,119983],"mapped",[116]],[[119984,119984],"mapped",[117]],[[119985,119985],"mapped",[118]],[[119986,119986],"mapped",[119]],[[119987,119987],"mapped",[120]],[[119988,119988],"mapped",[121]],[[119989,119989],"mapped",[122]],[[119990,119990],"mapped",[97]],[[119991,119991],"mapped",[98]],[[119992,119992],"mapped",[99]],[[119993,119993],"mapped",[100]],[[119994,119994],"disallowed"],[[119995,119995],"mapped",[102]],[[119996,119996],"disallowed"],[[119997,119997],"mapped",[104]],[[119998,119998],"mapped",[105]],[[119999,119999],"mapped",[106]],[[120000,120000],"mapped",[107]],[[120001,120001],"mapped",[108]],[[120002,120002],"mapped",[109]],[[120003,120003],"mapped",[110]],[[120004,120004],"disallowed"],[[120005,120005],"mapped",[112]],[[120006,120006],"mapped",[113]],[[120007,120007],"mapped",[114]],[[120008,120008],"mapped",[115]],[[120009,120009],"mapped",[116]],[[120010,120010],"mapped",[117]],[[120011,120011],"mapped",[118]],[[120012,120012],"mapped",[119]],[[120013,120013],"mapped",[120]],[[120014,120014],"mapped",[121]],[[120015,120015],"mapped",[122]],[[120016,120016],"mapped",[97]],[[120017,120017],"mapped",[98]],[[120018,120018],"mapped",[99]],[[120019,120019],"mapped",[100]],[[120020,120020],"mapped",[101]],[[120021,120021],"mapped",[102]],[[120022,120022],"mapped",[103]],[[120023,120023],"mapped",[104]],[[120024,120024],"mapped",[105]],[[120025,120025],"mapped",[106]],[[120026,120026],"mapped",[107]],[[120027,120027],"mapped",[108]],[[120028,120028],"mapped",[109]],[[120029,120029],"mapped",[110]],[[120030,120030],"mapped",[111]],[[120031,120031],"mapped",[112]],[[120032,120032],"mapped",[113]],[[120033,120033],"mapped",[114]],[[120034,120034],"mapped",[115]],[[120035,120035],"mapped",[116]],[[120036,120036],"mapped",[117]],[[120037,120037],"mapped",[118]],[[120038,120038],"mapped",[119]],[[120039,120039],"mapped",[120]],[[120040,120040],"mapped",[121]],[[120041,120041],"mapped",[122]],[[120042,120042],"mapped",[97]],[[120043,120043],"mapped",[98]],[[120044,120044],"mapped",[99]],[[120045,120045],"mapped",[100]],[[120046,120046],"mapped",[101]],[[120047,120047],"mapped",[102]],[[120048,120048],"mapped",[103]],[[120049,120049],"mapped",[104]],[[120050,120050],"mapped",[105]],[[120051,120051],"mapped",[106]],[[120052,120052],"mapped",[107]],[[120053,120053],"mapped",[108]],[[120054,120054],"mapped",[109]],[[120055,120055],"mapped",[110]],[[120056,120056],"mapped",[111]],[[120057,120057],"mapped",[112]],[[120058,120058],"mapped",[113]],[[120059,120059],"mapped",[114]],[[120060,120060],"mapped",[115]],[[120061,120061],"mapped",[116]],[[120062,120062],"mapped",[117]],[[120063,120063],"mapped",[118]],[[120064,120064],"mapped",[119]],[[120065,120065],"mapped",[120]],[[120066,120066],"mapped",[121]],[[120067,120067],"mapped",[122]],[[120068,120068],"mapped",[97]],[[120069,120069],"mapped",[98]],[[120070,120070],"disallowed"],[[120071,120071],"mapped",[100]],[[120072,120072],"mapped",[101]],[[120073,120073],"mapped",[102]],[[120074,120074],"mapped",[103]],[[120075,120076],"disallowed"],[[120077,120077],"mapped",[106]],[[120078,120078],"mapped",[107]],[[120079,120079],"mapped",[108]],[[120080,120080],"mapped",[109]],[[120081,120081],"mapped",[110]],[[120082,120082],"mapped",[111]],[[120083,120083],"mapped",[112]],[[120084,120084],"mapped",[113]],[[120085,120085],"disallowed"],[[120086,120086],"mapped",[115]],[[120087,120087],"mapped",[116]],[[120088,120088],"mapped",[117]],[[120089,120089],"mapped",[118]],[[120090,120090],"mapped",[119]],[[120091,120091],"mapped",[120]],[[120092,120092],"mapped",[121]],[[120093,120093],"disallowed"],[[120094,120094],"mapped",[97]],[[120095,120095],"mapped",[98]],[[120096,120096],"mapped",[99]],[[120097,120097],"mapped",[100]],[[120098,120098],"mapped",[101]],[[120099,120099],"mapped",[102]],[[120100,120100],"mapped",[103]],[[120101,120101],"mapped",[104]],[[120102,120102],"mapped",[105]],[[120103,120103],"mapped",[106]],[[120104,120104],"mapped",[107]],[[120105,120105],"mapped",[108]],[[120106,120106],"mapped",[109]],[[120107,120107],"mapped",[110]],[[120108,120108],"mapped",[111]],[[120109,120109],"mapped",[112]],[[120110,120110],"mapped",[113]],[[120111,120111],"mapped",[114]],[[120112,120112],"mapped",[115]],[[120113,120113],"mapped",[116]],[[120114,120114],"mapped",[117]],[[120115,120115],"mapped",[118]],[[120116,120116],"mapped",[119]],[[120117,120117],"mapped",[120]],[[120118,120118],"mapped",[121]],[[120119,120119],"mapped",[122]],[[120120,120120],"mapped",[97]],[[120121,120121],"mapped",[98]],[[120122,120122],"disallowed"],[[120123,120123],"mapped",[100]],[[120124,120124],"mapped",[101]],[[120125,120125],"mapped",[102]],[[120126,120126],"mapped",[103]],[[120127,120127],"disallowed"],[[120128,120128],"mapped",[105]],[[120129,120129],"mapped",[106]],[[120130,120130],"mapped",[107]],[[120131,120131],"mapped",[108]],[[120132,120132],"mapped",[109]],[[120133,120133],"disallowed"],[[120134,120134],"mapped",[111]],[[120135,120137],"disallowed"],[[120138,120138],"mapped",[115]],[[120139,120139],"mapped",[116]],[[120140,120140],"mapped",[117]],[[120141,120141],"mapped",[118]],[[120142,120142],"mapped",[119]],[[120143,120143],"mapped",[120]],[[120144,120144],"mapped",[121]],[[120145,120145],"disallowed"],[[120146,120146],"mapped",[97]],[[120147,120147],"mapped",[98]],[[120148,120148],"mapped",[99]],[[120149,120149],"mapped",[100]],[[120150,120150],"mapped",[101]],[[120151,120151],"mapped",[102]],[[120152,120152],"mapped",[103]],[[120153,120153],"mapped",[104]],[[120154,120154],"mapped",[105]],[[120155,120155],"mapped",[106]],[[120156,120156],"mapped",[107]],[[120157,120157],"mapped",[108]],[[120158,120158],"mapped",[109]],[[120159,120159],"mapped",[110]],[[120160,120160],"mapped",[111]],[[120161,120161],"mapped",[112]],[[120162,120162],"mapped",[113]],[[120163,120163],"mapped",[114]],[[120164,120164],"mapped",[115]],[[120165,120165],"mapped",[116]],[[120166,120166],"mapped",[117]],[[120167,120167],"mapped",[118]],[[120168,120168],"mapped",[119]],[[120169,120169],"mapped",[120]],[[120170,120170],"mapped",[121]],[[120171,120171],"mapped",[122]],[[120172,120172],"mapped",[97]],[[120173,120173],"mapped",[98]],[[120174,120174],"mapped",[99]],[[120175,120175],"mapped",[100]],[[120176,120176],"mapped",[101]],[[120177,120177],"mapped",[102]],[[120178,120178],"mapped",[103]],[[120179,120179],"mapped",[104]],[[120180,120180],"mapped",[105]],[[120181,120181],"mapped",[106]],[[120182,120182],"mapped",[107]],[[120183,120183],"mapped",[108]],[[120184,120184],"mapped",[109]],[[120185,120185],"mapped",[110]],[[120186,120186],"mapped",[111]],[[120187,120187],"mapped",[112]],[[120188,120188],"mapped",[113]],[[120189,120189],"mapped",[114]],[[120190,120190],"mapped",[115]],[[120191,120191],"mapped",[116]],[[120192,120192],"mapped",[117]],[[120193,120193],"mapped",[118]],[[120194,120194],"mapped",[119]],[[120195,120195],"mapped",[120]],[[120196,120196],"mapped",[121]],[[120197,120197],"mapped",[122]],[[120198,120198],"mapped",[97]],[[120199,120199],"mapped",[98]],[[120200,120200],"mapped",[99]],[[120201,120201],"mapped",[100]],[[120202,120202],"mapped",[101]],[[120203,120203],"mapped",[102]],[[120204,120204],"mapped",[103]],[[120205,120205],"mapped",[104]],[[120206,120206],"mapped",[105]],[[120207,120207],"mapped",[106]],[[120208,120208],"mapped",[107]],[[120209,120209],"mapped",[108]],[[120210,120210],"mapped",[109]],[[120211,120211],"mapped",[110]],[[120212,120212],"mapped",[111]],[[120213,120213],"mapped",[112]],[[120214,120214],"mapped",[113]],[[120215,120215],"mapped",[114]],[[120216,120216],"mapped",[115]],[[120217,120217],"mapped",[116]],[[120218,120218],"mapped",[117]],[[120219,120219],"mapped",[118]],[[120220,120220],"mapped",[119]],[[120221,120221],"mapped",[120]],[[120222,120222],"mapped",[121]],[[120223,120223],"mapped",[122]],[[120224,120224],"mapped",[97]],[[120225,120225],"mapped",[98]],[[120226,120226],"mapped",[99]],[[120227,120227],"mapped",[100]],[[120228,120228],"mapped",[101]],[[120229,120229],"mapped",[102]],[[120230,120230],"mapped",[103]],[[120231,120231],"mapped",[104]],[[120232,120232],"mapped",[105]],[[120233,120233],"mapped",[106]],[[120234,120234],"mapped",[107]],[[120235,120235],"mapped",[108]],[[120236,120236],"mapped",[109]],[[120237,120237],"mapped",[110]],[[120238,120238],"mapped",[111]],[[120239,120239],"mapped",[112]],[[120240,120240],"mapped",[113]],[[120241,120241],"mapped",[114]],[[120242,120242],"mapped",[115]],[[120243,120243],"mapped",[116]],[[120244,120244],"mapped",[117]],[[120245,120245],"mapped",[118]],[[120246,120246],"mapped",[119]],[[120247,120247],"mapped",[120]],[[120248,120248],"mapped",[121]],[[120249,120249],"mapped",[122]],[[120250,120250],"mapped",[97]],[[120251,120251],"mapped",[98]],[[120252,120252],"mapped",[99]],[[120253,120253],"mapped",[100]],[[120254,120254],"mapped",[101]],[[120255,120255],"mapped",[102]],[[120256,120256],"mapped",[103]],[[120257,120257],"mapped",[104]],[[120258,120258],"mapped",[105]],[[120259,120259],"mapped",[106]],[[120260,120260],"mapped",[107]],[[120261,120261],"mapped",[108]],[[120262,120262],"mapped",[109]],[[120263,120263],"mapped",[110]],[[120264,120264],"mapped",[111]],[[120265,120265],"mapped",[112]],[[120266,120266],"mapped",[113]],[[120267,120267],"mapped",[114]],[[120268,120268],"mapped",[115]],[[120269,120269],"mapped",[116]],[[120270,120270],"mapped",[117]],[[120271,120271],"mapped",[118]],[[120272,120272],"mapped",[119]],[[120273,120273],"mapped",[120]],[[120274,120274],"mapped",[121]],[[120275,120275],"mapped",[122]],[[120276,120276],"mapped",[97]],[[120277,120277],"mapped",[98]],[[120278,120278],"mapped",[99]],[[120279,120279],"mapped",[100]],[[120280,120280],"mapped",[101]],[[120281,120281],"mapped",[102]],[[120282,120282],"mapped",[103]],[[120283,120283],"mapped",[104]],[[120284,120284],"mapped",[105]],[[120285,120285],"mapped",[106]],[[120286,120286],"mapped",[107]],[[120287,120287],"mapped",[108]],[[120288,120288],"mapped",[109]],[[120289,120289],"mapped",[110]],[[120290,120290],"mapped",[111]],[[120291,120291],"mapped",[112]],[[120292,120292],"mapped",[113]],[[120293,120293],"mapped",[114]],[[120294,120294],"mapped",[115]],[[120295,120295],"mapped",[116]],[[120296,120296],"mapped",[117]],[[120297,120297],"mapped",[118]],[[120298,120298],"mapped",[119]],[[120299,120299],"mapped",[120]],[[120300,120300],"mapped",[121]],[[120301,120301],"mapped",[122]],[[120302,120302],"mapped",[97]],[[120303,120303],"mapped",[98]],[[120304,120304],"mapped",[99]],[[120305,120305],"mapped",[100]],[[120306,120306],"mapped",[101]],[[120307,120307],"mapped",[102]],[[120308,120308],"mapped",[103]],[[120309,120309],"mapped",[104]],[[120310,120310],"mapped",[105]],[[120311,120311],"mapped",[106]],[[120312,120312],"mapped",[107]],[[120313,120313],"mapped",[108]],[[120314,120314],"mapped",[109]],[[120315,120315],"mapped",[110]],[[120316,120316],"mapped",[111]],[[120317,120317],"mapped",[112]],[[120318,120318],"mapped",[113]],[[120319,120319],"mapped",[114]],[[120320,120320],"mapped",[115]],[[120321,120321],"mapped",[116]],[[120322,120322],"mapped",[117]],[[120323,120323],"mapped",[118]],[[120324,120324],"mapped",[119]],[[120325,120325],"mapped",[120]],[[120326,120326],"mapped",[121]],[[120327,120327],"mapped",[122]],[[120328,120328],"mapped",[97]],[[120329,120329],"mapped",[98]],[[120330,120330],"mapped",[99]],[[120331,120331],"mapped",[100]],[[120332,120332],"mapped",[101]],[[120333,120333],"mapped",[102]],[[120334,120334],"mapped",[103]],[[120335,120335],"mapped",[104]],[[120336,120336],"mapped",[105]],[[120337,120337],"mapped",[106]],[[120338,120338],"mapped",[107]],[[120339,120339],"mapped",[108]],[[120340,120340],"mapped",[109]],[[120341,120341],"mapped",[110]],[[120342,120342],"mapped",[111]],[[120343,120343],"mapped",[112]],[[120344,120344],"mapped",[113]],[[120345,120345],"mapped",[114]],[[120346,120346],"mapped",[115]],[[120347,120347],"mapped",[116]],[[120348,120348],"mapped",[117]],[[120349,120349],"mapped",[118]],[[120350,120350],"mapped",[119]],[[120351,120351],"mapped",[120]],[[120352,120352],"mapped",[121]],[[120353,120353],"mapped",[122]],[[120354,120354],"mapped",[97]],[[120355,120355],"mapped",[98]],[[120356,120356],"mapped",[99]],[[120357,120357],"mapped",[100]],[[120358,120358],"mapped",[101]],[[120359,120359],"mapped",[102]],[[120360,120360],"mapped",[103]],[[120361,120361],"mapped",[104]],[[120362,120362],"mapped",[105]],[[120363,120363],"mapped",[106]],[[120364,120364],"mapped",[107]],[[120365,120365],"mapped",[108]],[[120366,120366],"mapped",[109]],[[120367,120367],"mapped",[110]],[[120368,120368],"mapped",[111]],[[120369,120369],"mapped",[112]],[[120370,120370],"mapped",[113]],[[120371,120371],"mapped",[114]],[[120372,120372],"mapped",[115]],[[120373,120373],"mapped",[116]],[[120374,120374],"mapped",[117]],[[120375,120375],"mapped",[118]],[[120376,120376],"mapped",[119]],[[120377,120377],"mapped",[120]],[[120378,120378],"mapped",[121]],[[120379,120379],"mapped",[122]],[[120380,120380],"mapped",[97]],[[120381,120381],"mapped",[98]],[[120382,120382],"mapped",[99]],[[120383,120383],"mapped",[100]],[[120384,120384],"mapped",[101]],[[120385,120385],"mapped",[102]],[[120386,120386],"mapped",[103]],[[120387,120387],"mapped",[104]],[[120388,120388],"mapped",[105]],[[120389,120389],"mapped",[106]],[[120390,120390],"mapped",[107]],[[120391,120391],"mapped",[108]],[[120392,120392],"mapped",[109]],[[120393,120393],"mapped",[110]],[[120394,120394],"mapped",[111]],[[120395,120395],"mapped",[112]],[[120396,120396],"mapped",[113]],[[120397,120397],"mapped",[114]],[[120398,120398],"mapped",[115]],[[120399,120399],"mapped",[116]],[[120400,120400],"mapped",[117]],[[120401,120401],"mapped",[118]],[[120402,120402],"mapped",[119]],[[120403,120403],"mapped",[120]],[[120404,120404],"mapped",[121]],[[120405,120405],"mapped",[122]],[[120406,120406],"mapped",[97]],[[120407,120407],"mapped",[98]],[[120408,120408],"mapped",[99]],[[120409,120409],"mapped",[100]],[[120410,120410],"mapped",[101]],[[120411,120411],"mapped",[102]],[[120412,120412],"mapped",[103]],[[120413,120413],"mapped",[104]],[[120414,120414],"mapped",[105]],[[120415,120415],"mapped",[106]],[[120416,120416],"mapped",[107]],[[120417,120417],"mapped",[108]],[[120418,120418],"mapped",[109]],[[120419,120419],"mapped",[110]],[[120420,120420],"mapped",[111]],[[120421,120421],"mapped",[112]],[[120422,120422],"mapped",[113]],[[120423,120423],"mapped",[114]],[[120424,120424],"mapped",[115]],[[120425,120425],"mapped",[116]],[[120426,120426],"mapped",[117]],[[120427,120427],"mapped",[118]],[[120428,120428],"mapped",[119]],[[120429,120429],"mapped",[120]],[[120430,120430],"mapped",[121]],[[120431,120431],"mapped",[122]],[[120432,120432],"mapped",[97]],[[120433,120433],"mapped",[98]],[[120434,120434],"mapped",[99]],[[120435,120435],"mapped",[100]],[[120436,120436],"mapped",[101]],[[120437,120437],"mapped",[102]],[[120438,120438],"mapped",[103]],[[120439,120439],"mapped",[104]],[[120440,120440],"mapped",[105]],[[120441,120441],"mapped",[106]],[[120442,120442],"mapped",[107]],[[120443,120443],"mapped",[108]],[[120444,120444],"mapped",[109]],[[120445,120445],"mapped",[110]],[[120446,120446],"mapped",[111]],[[120447,120447],"mapped",[112]],[[120448,120448],"mapped",[113]],[[120449,120449],"mapped",[114]],[[120450,120450],"mapped",[115]],[[120451,120451],"mapped",[116]],[[120452,120452],"mapped",[117]],[[120453,120453],"mapped",[118]],[[120454,120454],"mapped",[119]],[[120455,120455],"mapped",[120]],[[120456,120456],"mapped",[121]],[[120457,120457],"mapped",[122]],[[120458,120458],"mapped",[97]],[[120459,120459],"mapped",[98]],[[120460,120460],"mapped",[99]],[[120461,120461],"mapped",[100]],[[120462,120462],"mapped",[101]],[[120463,120463],"mapped",[102]],[[120464,120464],"mapped",[103]],[[120465,120465],"mapped",[104]],[[120466,120466],"mapped",[105]],[[120467,120467],"mapped",[106]],[[120468,120468],"mapped",[107]],[[120469,120469],"mapped",[108]],[[120470,120470],"mapped",[109]],[[120471,120471],"mapped",[110]],[[120472,120472],"mapped",[111]],[[120473,120473],"mapped",[112]],[[120474,120474],"mapped",[113]],[[120475,120475],"mapped",[114]],[[120476,120476],"mapped",[115]],[[120477,120477],"mapped",[116]],[[120478,120478],"mapped",[117]],[[120479,120479],"mapped",[118]],[[120480,120480],"mapped",[119]],[[120481,120481],"mapped",[120]],[[120482,120482],"mapped",[121]],[[120483,120483],"mapped",[122]],[[120484,120484],"mapped",[305]],[[120485,120485],"mapped",[567]],[[120486,120487],"disallowed"],[[120488,120488],"mapped",[945]],[[120489,120489],"mapped",[946]],[[120490,120490],"mapped",[947]],[[120491,120491],"mapped",[948]],[[120492,120492],"mapped",[949]],[[120493,120493],"mapped",[950]],[[120494,120494],"mapped",[951]],[[120495,120495],"mapped",[952]],[[120496,120496],"mapped",[953]],[[120497,120497],"mapped",[954]],[[120498,120498],"mapped",[955]],[[120499,120499],"mapped",[956]],[[120500,120500],"mapped",[957]],[[120501,120501],"mapped",[958]],[[120502,120502],"mapped",[959]],[[120503,120503],"mapped",[960]],[[120504,120504],"mapped",[961]],[[120505,120505],"mapped",[952]],[[120506,120506],"mapped",[963]],[[120507,120507],"mapped",[964]],[[120508,120508],"mapped",[965]],[[120509,120509],"mapped",[966]],[[120510,120510],"mapped",[967]],[[120511,120511],"mapped",[968]],[[120512,120512],"mapped",[969]],[[120513,120513],"mapped",[8711]],[[120514,120514],"mapped",[945]],[[120515,120515],"mapped",[946]],[[120516,120516],"mapped",[947]],[[120517,120517],"mapped",[948]],[[120518,120518],"mapped",[949]],[[120519,120519],"mapped",[950]],[[120520,120520],"mapped",[951]],[[120521,120521],"mapped",[952]],[[120522,120522],"mapped",[953]],[[120523,120523],"mapped",[954]],[[120524,120524],"mapped",[955]],[[120525,120525],"mapped",[956]],[[120526,120526],"mapped",[957]],[[120527,120527],"mapped",[958]],[[120528,120528],"mapped",[959]],[[120529,120529],"mapped",[960]],[[120530,120530],"mapped",[961]],[[120531,120532],"mapped",[963]],[[120533,120533],"mapped",[964]],[[120534,120534],"mapped",[965]],[[120535,120535],"mapped",[966]],[[120536,120536],"mapped",[967]],[[120537,120537],"mapped",[968]],[[120538,120538],"mapped",[969]],[[120539,120539],"mapped",[8706]],[[120540,120540],"mapped",[949]],[[120541,120541],"mapped",[952]],[[120542,120542],"mapped",[954]],[[120543,120543],"mapped",[966]],[[120544,120544],"mapped",[961]],[[120545,120545],"mapped",[960]],[[120546,120546],"mapped",[945]],[[120547,120547],"mapped",[946]],[[120548,120548],"mapped",[947]],[[120549,120549],"mapped",[948]],[[120550,120550],"mapped",[949]],[[120551,120551],"mapped",[950]],[[120552,120552],"mapped",[951]],[[120553,120553],"mapped",[952]],[[120554,120554],"mapped",[953]],[[120555,120555],"mapped",[954]],[[120556,120556],"mapped",[955]],[[120557,120557],"mapped",[956]],[[120558,120558],"mapped",[957]],[[120559,120559],"mapped",[958]],[[120560,120560],"mapped",[959]],[[120561,120561],"mapped",[960]],[[120562,120562],"mapped",[961]],[[120563,120563],"mapped",[952]],[[120564,120564],"mapped",[963]],[[120565,120565],"mapped",[964]],[[120566,120566],"mapped",[965]],[[120567,120567],"mapped",[966]],[[120568,120568],"mapped",[967]],[[120569,120569],"mapped",[968]],[[120570,120570],"mapped",[969]],[[120571,120571],"mapped",[8711]],[[120572,120572],"mapped",[945]],[[120573,120573],"mapped",[946]],[[120574,120574],"mapped",[947]],[[120575,120575],"mapped",[948]],[[120576,120576],"mapped",[949]],[[120577,120577],"mapped",[950]],[[120578,120578],"mapped",[951]],[[120579,120579],"mapped",[952]],[[120580,120580],"mapped",[953]],[[120581,120581],"mapped",[954]],[[120582,120582],"mapped",[955]],[[120583,120583],"mapped",[956]],[[120584,120584],"mapped",[957]],[[120585,120585],"mapped",[958]],[[120586,120586],"mapped",[959]],[[120587,120587],"mapped",[960]],[[120588,120588],"mapped",[961]],[[120589,120590],"mapped",[963]],[[120591,120591],"mapped",[964]],[[120592,120592],"mapped",[965]],[[120593,120593],"mapped",[966]],[[120594,120594],"mapped",[967]],[[120595,120595],"mapped",[968]],[[120596,120596],"mapped",[969]],[[120597,120597],"mapped",[8706]],[[120598,120598],"mapped",[949]],[[120599,120599],"mapped",[952]],[[120600,120600],"mapped",[954]],[[120601,120601],"mapped",[966]],[[120602,120602],"mapped",[961]],[[120603,120603],"mapped",[960]],[[120604,120604],"mapped",[945]],[[120605,120605],"mapped",[946]],[[120606,120606],"mapped",[947]],[[120607,120607],"mapped",[948]],[[120608,120608],"mapped",[949]],[[120609,120609],"mapped",[950]],[[120610,120610],"mapped",[951]],[[120611,120611],"mapped",[952]],[[120612,120612],"mapped",[953]],[[120613,120613],"mapped",[954]],[[120614,120614],"mapped",[955]],[[120615,120615],"mapped",[956]],[[120616,120616],"mapped",[957]],[[120617,120617],"mapped",[958]],[[120618,120618],"mapped",[959]],[[120619,120619],"mapped",[960]],[[120620,120620],"mapped",[961]],[[120621,120621],"mapped",[952]],[[120622,120622],"mapped",[963]],[[120623,120623],"mapped",[964]],[[120624,120624],"mapped",[965]],[[120625,120625],"mapped",[966]],[[120626,120626],"mapped",[967]],[[120627,120627],"mapped",[968]],[[120628,120628],"mapped",[969]],[[120629,120629],"mapped",[8711]],[[120630,120630],"mapped",[945]],[[120631,120631],"mapped",[946]],[[120632,120632],"mapped",[947]],[[120633,120633],"mapped",[948]],[[120634,120634],"mapped",[949]],[[120635,120635],"mapped",[950]],[[120636,120636],"mapped",[951]],[[120637,120637],"mapped",[952]],[[120638,120638],"mapped",[953]],[[120639,120639],"mapped",[954]],[[120640,120640],"mapped",[955]],[[120641,120641],"mapped",[956]],[[120642,120642],"mapped",[957]],[[120643,120643],"mapped",[958]],[[120644,120644],"mapped",[959]],[[120645,120645],"mapped",[960]],[[120646,120646],"mapped",[961]],[[120647,120648],"mapped",[963]],[[120649,120649],"mapped",[964]],[[120650,120650],"mapped",[965]],[[120651,120651],"mapped",[966]],[[120652,120652],"mapped",[967]],[[120653,120653],"mapped",[968]],[[120654,120654],"mapped",[969]],[[120655,120655],"mapped",[8706]],[[120656,120656],"mapped",[949]],[[120657,120657],"mapped",[952]],[[120658,120658],"mapped",[954]],[[120659,120659],"mapped",[966]],[[120660,120660],"mapped",[961]],[[120661,120661],"mapped",[960]],[[120662,120662],"mapped",[945]],[[120663,120663],"mapped",[946]],[[120664,120664],"mapped",[947]],[[120665,120665],"mapped",[948]],[[120666,120666],"mapped",[949]],[[120667,120667],"mapped",[950]],[[120668,120668],"mapped",[951]],[[120669,120669],"mapped",[952]],[[120670,120670],"mapped",[953]],[[120671,120671],"mapped",[954]],[[120672,120672],"mapped",[955]],[[120673,120673],"mapped",[956]],[[120674,120674],"mapped",[957]],[[120675,120675],"mapped",[958]],[[120676,120676],"mapped",[959]],[[120677,120677],"mapped",[960]],[[120678,120678],"mapped",[961]],[[120679,120679],"mapped",[952]],[[120680,120680],"mapped",[963]],[[120681,120681],"mapped",[964]],[[120682,120682],"mapped",[965]],[[120683,120683],"mapped",[966]],[[120684,120684],"mapped",[967]],[[120685,120685],"mapped",[968]],[[120686,120686],"mapped",[969]],[[120687,120687],"mapped",[8711]],[[120688,120688],"mapped",[945]],[[120689,120689],"mapped",[946]],[[120690,120690],"mapped",[947]],[[120691,120691],"mapped",[948]],[[120692,120692],"mapped",[949]],[[120693,120693],"mapped",[950]],[[120694,120694],"mapped",[951]],[[120695,120695],"mapped",[952]],[[120696,120696],"mapped",[953]],[[120697,120697],"mapped",[954]],[[120698,120698],"mapped",[955]],[[120699,120699],"mapped",[956]],[[120700,120700],"mapped",[957]],[[120701,120701],"mapped",[958]],[[120702,120702],"mapped",[959]],[[120703,120703],"mapped",[960]],[[120704,120704],"mapped",[961]],[[120705,120706],"mapped",[963]],[[120707,120707],"mapped",[964]],[[120708,120708],"mapped",[965]],[[120709,120709],"mapped",[966]],[[120710,120710],"mapped",[967]],[[120711,120711],"mapped",[968]],[[120712,120712],"mapped",[969]],[[120713,120713],"mapped",[8706]],[[120714,120714],"mapped",[949]],[[120715,120715],"mapped",[952]],[[120716,120716],"mapped",[954]],[[120717,120717],"mapped",[966]],[[120718,120718],"mapped",[961]],[[120719,120719],"mapped",[960]],[[120720,120720],"mapped",[945]],[[120721,120721],"mapped",[946]],[[120722,120722],"mapped",[947]],[[120723,120723],"mapped",[948]],[[120724,120724],"mapped",[949]],[[120725,120725],"mapped",[950]],[[120726,120726],"mapped",[951]],[[120727,120727],"mapped",[952]],[[120728,120728],"mapped",[953]],[[120729,120729],"mapped",[954]],[[120730,120730],"mapped",[955]],[[120731,120731],"mapped",[956]],[[120732,120732],"mapped",[957]],[[120733,120733],"mapped",[958]],[[120734,120734],"mapped",[959]],[[120735,120735],"mapped",[960]],[[120736,120736],"mapped",[961]],[[120737,120737],"mapped",[952]],[[120738,120738],"mapped",[963]],[[120739,120739],"mapped",[964]],[[120740,120740],"mapped",[965]],[[120741,120741],"mapped",[966]],[[120742,120742],"mapped",[967]],[[120743,120743],"mapped",[968]],[[120744,120744],"mapped",[969]],[[120745,120745],"mapped",[8711]],[[120746,120746],"mapped",[945]],[[120747,120747],"mapped",[946]],[[120748,120748],"mapped",[947]],[[120749,120749],"mapped",[948]],[[120750,120750],"mapped",[949]],[[120751,120751],"mapped",[950]],[[120752,120752],"mapped",[951]],[[120753,120753],"mapped",[952]],[[120754,120754],"mapped",[953]],[[120755,120755],"mapped",[954]],[[120756,120756],"mapped",[955]],[[120757,120757],"mapped",[956]],[[120758,120758],"mapped",[957]],[[120759,120759],"mapped",[958]],[[120760,120760],"mapped",[959]],[[120761,120761],"mapped",[960]],[[120762,120762],"mapped",[961]],[[120763,120764],"mapped",[963]],[[120765,120765],"mapped",[964]],[[120766,120766],"mapped",[965]],[[120767,120767],"mapped",[966]],[[120768,120768],"mapped",[967]],[[120769,120769],"mapped",[968]],[[120770,120770],"mapped",[969]],[[120771,120771],"mapped",[8706]],[[120772,120772],"mapped",[949]],[[120773,120773],"mapped",[952]],[[120774,120774],"mapped",[954]],[[120775,120775],"mapped",[966]],[[120776,120776],"mapped",[961]],[[120777,120777],"mapped",[960]],[[120778,120779],"mapped",[989]],[[120780,120781],"disallowed"],[[120782,120782],"mapped",[48]],[[120783,120783],"mapped",[49]],[[120784,120784],"mapped",[50]],[[120785,120785],"mapped",[51]],[[120786,120786],"mapped",[52]],[[120787,120787],"mapped",[53]],[[120788,120788],"mapped",[54]],[[120789,120789],"mapped",[55]],[[120790,120790],"mapped",[56]],[[120791,120791],"mapped",[57]],[[120792,120792],"mapped",[48]],[[120793,120793],"mapped",[49]],[[120794,120794],"mapped",[50]],[[120795,120795],"mapped",[51]],[[120796,120796],"mapped",[52]],[[120797,120797],"mapped",[53]],[[120798,120798],"mapped",[54]],[[120799,120799],"mapped",[55]],[[120800,120800],"mapped",[56]],[[120801,120801],"mapped",[57]],[[120802,120802],"mapped",[48]],[[120803,120803],"mapped",[49]],[[120804,120804],"mapped",[50]],[[120805,120805],"mapped",[51]],[[120806,120806],"mapped",[52]],[[120807,120807],"mapped",[53]],[[120808,120808],"mapped",[54]],[[120809,120809],"mapped",[55]],[[120810,120810],"mapped",[56]],[[120811,120811],"mapped",[57]],[[120812,120812],"mapped",[48]],[[120813,120813],"mapped",[49]],[[120814,120814],"mapped",[50]],[[120815,120815],"mapped",[51]],[[120816,120816],"mapped",[52]],[[120817,120817],"mapped",[53]],[[120818,120818],"mapped",[54]],[[120819,120819],"mapped",[55]],[[120820,120820],"mapped",[56]],[[120821,120821],"mapped",[57]],[[120822,120822],"mapped",[48]],[[120823,120823],"mapped",[49]],[[120824,120824],"mapped",[50]],[[120825,120825],"mapped",[51]],[[120826,120826],"mapped",[52]],[[120827,120827],"mapped",[53]],[[120828,120828],"mapped",[54]],[[120829,120829],"mapped",[55]],[[120830,120830],"mapped",[56]],[[120831,120831],"mapped",[57]],[[120832,121343],"valid",[],"NV8"],[[121344,121398],"valid"],[[121399,121402],"valid",[],"NV8"],[[121403,121452],"valid"],[[121453,121460],"valid",[],"NV8"],[[121461,121461],"valid"],[[121462,121475],"valid",[],"NV8"],[[121476,121476],"valid"],[[121477,121483],"valid",[],"NV8"],[[121484,121498],"disallowed"],[[121499,121503],"valid"],[[121504,121504],"disallowed"],[[121505,121519],"valid"],[[121520,124927],"disallowed"],[[124928,125124],"valid"],[[125125,125126],"disallowed"],[[125127,125135],"valid",[],"NV8"],[[125136,125142],"valid"],[[125143,126463],"disallowed"],[[126464,126464],"mapped",[1575]],[[126465,126465],"mapped",[1576]],[[126466,126466],"mapped",[1580]],[[126467,126467],"mapped",[1583]],[[126468,126468],"disallowed"],[[126469,126469],"mapped",[1608]],[[126470,126470],"mapped",[1586]],[[126471,126471],"mapped",[1581]],[[126472,126472],"mapped",[1591]],[[126473,126473],"mapped",[1610]],[[126474,126474],"mapped",[1603]],[[126475,126475],"mapped",[1604]],[[126476,126476],"mapped",[1605]],[[126477,126477],"mapped",[1606]],[[126478,126478],"mapped",[1587]],[[126479,126479],"mapped",[1593]],[[126480,126480],"mapped",[1601]],[[126481,126481],"mapped",[1589]],[[126482,126482],"mapped",[1602]],[[126483,126483],"mapped",[1585]],[[126484,126484],"mapped",[1588]],[[126485,126485],"mapped",[1578]],[[126486,126486],"mapped",[1579]],[[126487,126487],"mapped",[1582]],[[126488,126488],"mapped",[1584]],[[126489,126489],"mapped",[1590]],[[126490,126490],"mapped",[1592]],[[126491,126491],"mapped",[1594]],[[126492,126492],"mapped",[1646]],[[126493,126493],"mapped",[1722]],[[126494,126494],"mapped",[1697]],[[126495,126495],"mapped",[1647]],[[126496,126496],"disallowed"],[[126497,126497],"mapped",[1576]],[[126498,126498],"mapped",[1580]],[[126499,126499],"disallowed"],[[126500,126500],"mapped",[1607]],[[126501,126502],"disallowed"],[[126503,126503],"mapped",[1581]],[[126504,126504],"disallowed"],[[126505,126505],"mapped",[1610]],[[126506,126506],"mapped",[1603]],[[126507,126507],"mapped",[1604]],[[126508,126508],"mapped",[1605]],[[126509,126509],"mapped",[1606]],[[126510,126510],"mapped",[1587]],[[126511,126511],"mapped",[1593]],[[126512,126512],"mapped",[1601]],[[126513,126513],"mapped",[1589]],[[126514,126514],"mapped",[1602]],[[126515,126515],"disallowed"],[[126516,126516],"mapped",[1588]],[[126517,126517],"mapped",[1578]],[[126518,126518],"mapped",[1579]],[[126519,126519],"mapped",[1582]],[[126520,126520],"disallowed"],[[126521,126521],"mapped",[1590]],[[126522,126522],"disallowed"],[[126523,126523],"mapped",[1594]],[[126524,126529],"disallowed"],[[126530,126530],"mapped",[1580]],[[126531,126534],"disallowed"],[[126535,126535],"mapped",[1581]],[[126536,126536],"disallowed"],[[126537,126537],"mapped",[1610]],[[126538,126538],"disallowed"],[[126539,126539],"mapped",[1604]],[[126540,126540],"disallowed"],[[126541,126541],"mapped",[1606]],[[126542,126542],"mapped",[1587]],[[126543,126543],"mapped",[1593]],[[126544,126544],"disallowed"],[[126545,126545],"mapped",[1589]],[[126546,126546],"mapped",[1602]],[[126547,126547],"disallowed"],[[126548,126548],"mapped",[1588]],[[126549,126550],"disallowed"],[[126551,126551],"mapped",[1582]],[[126552,126552],"disallowed"],[[126553,126553],"mapped",[1590]],[[126554,126554],"disallowed"],[[126555,126555],"mapped",[1594]],[[126556,126556],"disallowed"],[[126557,126557],"mapped",[1722]],[[126558,126558],"disallowed"],[[126559,126559],"mapped",[1647]],[[126560,126560],"disallowed"],[[126561,126561],"mapped",[1576]],[[126562,126562],"mapped",[1580]],[[126563,126563],"disallowed"],[[126564,126564],"mapped",[1607]],[[126565,126566],"disallowed"],[[126567,126567],"mapped",[1581]],[[126568,126568],"mapped",[1591]],[[126569,126569],"mapped",[1610]],[[126570,126570],"mapped",[1603]],[[126571,126571],"disallowed"],[[126572,126572],"mapped",[1605]],[[126573,126573],"mapped",[1606]],[[126574,126574],"mapped",[1587]],[[126575,126575],"mapped",[1593]],[[126576,126576],"mapped",[1601]],[[126577,126577],"mapped",[1589]],[[126578,126578],"mapped",[1602]],[[126579,126579],"disallowed"],[[126580,126580],"mapped",[1588]],[[126581,126581],"mapped",[1578]],[[126582,126582],"mapped",[1579]],[[126583,126583],"mapped",[1582]],[[126584,126584],"disallowed"],[[126585,126585],"mapped",[1590]],[[126586,126586],"mapped",[1592]],[[126587,126587],"mapped",[1594]],[[126588,126588],"mapped",[1646]],[[126589,126589],"disallowed"],[[126590,126590],"mapped",[1697]],[[126591,126591],"disallowed"],[[126592,126592],"mapped",[1575]],[[126593,126593],"mapped",[1576]],[[126594,126594],"mapped",[1580]],[[126595,126595],"mapped",[1583]],[[126596,126596],"mapped",[1607]],[[126597,126597],"mapped",[1608]],[[126598,126598],"mapped",[1586]],[[126599,126599],"mapped",[1581]],[[126600,126600],"mapped",[1591]],[[126601,126601],"mapped",[1610]],[[126602,126602],"disallowed"],[[126603,126603],"mapped",[1604]],[[126604,126604],"mapped",[1605]],[[126605,126605],"mapped",[1606]],[[126606,126606],"mapped",[1587]],[[126607,126607],"mapped",[1593]],[[126608,126608],"mapped",[1601]],[[126609,126609],"mapped",[1589]],[[126610,126610],"mapped",[1602]],[[126611,126611],"mapped",[1585]],[[126612,126612],"mapped",[1588]],[[126613,126613],"mapped",[1578]],[[126614,126614],"mapped",[1579]],[[126615,126615],"mapped",[1582]],[[126616,126616],"mapped",[1584]],[[126617,126617],"mapped",[1590]],[[126618,126618],"mapped",[1592]],[[126619,126619],"mapped",[1594]],[[126620,126624],"disallowed"],[[126625,126625],"mapped",[1576]],[[126626,126626],"mapped",[1580]],[[126627,126627],"mapped",[1583]],[[126628,126628],"disallowed"],[[126629,126629],"mapped",[1608]],[[126630,126630],"mapped",[1586]],[[126631,126631],"mapped",[1581]],[[126632,126632],"mapped",[1591]],[[126633,126633],"mapped",[1610]],[[126634,126634],"disallowed"],[[126635,126635],"mapped",[1604]],[[126636,126636],"mapped",[1605]],[[126637,126637],"mapped",[1606]],[[126638,126638],"mapped",[1587]],[[126639,126639],"mapped",[1593]],[[126640,126640],"mapped",[1601]],[[126641,126641],"mapped",[1589]],[[126642,126642],"mapped",[1602]],[[126643,126643],"mapped",[1585]],[[126644,126644],"mapped",[1588]],[[126645,126645],"mapped",[1578]],[[126646,126646],"mapped",[1579]],[[126647,126647],"mapped",[1582]],[[126648,126648],"mapped",[1584]],[[126649,126649],"mapped",[1590]],[[126650,126650],"mapped",[1592]],[[126651,126651],"mapped",[1594]],[[126652,126703],"disallowed"],[[126704,126705],"valid",[],"NV8"],[[126706,126975],"disallowed"],[[126976,127019],"valid",[],"NV8"],[[127020,127023],"disallowed"],[[127024,127123],"valid",[],"NV8"],[[127124,127135],"disallowed"],[[127136,127150],"valid",[],"NV8"],[[127151,127152],"disallowed"],[[127153,127166],"valid",[],"NV8"],[[127167,127167],"valid",[],"NV8"],[[127168,127168],"disallowed"],[[127169,127183],"valid",[],"NV8"],[[127184,127184],"disallowed"],[[127185,127199],"valid",[],"NV8"],[[127200,127221],"valid",[],"NV8"],[[127222,127231],"disallowed"],[[127232,127232],"disallowed"],[[127233,127233],"disallowed_STD3_mapped",[48,44]],[[127234,127234],"disallowed_STD3_mapped",[49,44]],[[127235,127235],"disallowed_STD3_mapped",[50,44]],[[127236,127236],"disallowed_STD3_mapped",[51,44]],[[127237,127237],"disallowed_STD3_mapped",[52,44]],[[127238,127238],"disallowed_STD3_mapped",[53,44]],[[127239,127239],"disallowed_STD3_mapped",[54,44]],[[127240,127240],"disallowed_STD3_mapped",[55,44]],[[127241,127241],"disallowed_STD3_mapped",[56,44]],[[127242,127242],"disallowed_STD3_mapped",[57,44]],[[127243,127244],"valid",[],"NV8"],[[127245,127247],"disallowed"],[[127248,127248],"disallowed_STD3_mapped",[40,97,41]],[[127249,127249],"disallowed_STD3_mapped",[40,98,41]],[[127250,127250],"disallowed_STD3_mapped",[40,99,41]],[[127251,127251],"disallowed_STD3_mapped",[40,100,41]],[[127252,127252],"disallowed_STD3_mapped",[40,101,41]],[[127253,127253],"disallowed_STD3_mapped",[40,102,41]],[[127254,127254],"disallowed_STD3_mapped",[40,103,41]],[[127255,127255],"disallowed_STD3_mapped",[40,104,41]],[[127256,127256],"disallowed_STD3_mapped",[40,105,41]],[[127257,127257],"disallowed_STD3_mapped",[40,106,41]],[[127258,127258],"disallowed_STD3_mapped",[40,107,41]],[[127259,127259],"disallowed_STD3_mapped",[40,108,41]],[[127260,127260],"disallowed_STD3_mapped",[40,109,41]],[[127261,127261],"disallowed_STD3_mapped",[40,110,41]],[[127262,127262],"disallowed_STD3_mapped",[40,111,41]],[[127263,127263],"disallowed_STD3_mapped",[40,112,41]],[[127264,127264],"disallowed_STD3_mapped",[40,113,41]],[[127265,127265],"disallowed_STD3_mapped",[40,114,41]],[[127266,127266],"disallowed_STD3_mapped",[40,115,41]],[[127267,127267],"disallowed_STD3_mapped",[40,116,41]],[[127268,127268],"disallowed_STD3_mapped",[40,117,41]],[[127269,127269],"disallowed_STD3_mapped",[40,118,41]],[[127270,127270],"disallowed_STD3_mapped",[40,119,41]],[[127271,127271],"disallowed_STD3_mapped",[40,120,41]],[[127272,127272],"disallowed_STD3_mapped",[40,121,41]],[[127273,127273],"disallowed_STD3_mapped",[40,122,41]],[[127274,127274],"mapped",[12308,115,12309]],[[127275,127275],"mapped",[99]],[[127276,127276],"mapped",[114]],[[127277,127277],"mapped",[99,100]],[[127278,127278],"mapped",[119,122]],[[127279,127279],"disallowed"],[[127280,127280],"mapped",[97]],[[127281,127281],"mapped",[98]],[[127282,127282],"mapped",[99]],[[127283,127283],"mapped",[100]],[[127284,127284],"mapped",[101]],[[127285,127285],"mapped",[102]],[[127286,127286],"mapped",[103]],[[127287,127287],"mapped",[104]],[[127288,127288],"mapped",[105]],[[127289,127289],"mapped",[106]],[[127290,127290],"mapped",[107]],[[127291,127291],"mapped",[108]],[[127292,127292],"mapped",[109]],[[127293,127293],"mapped",[110]],[[127294,127294],"mapped",[111]],[[127295,127295],"mapped",[112]],[[127296,127296],"mapped",[113]],[[127297,127297],"mapped",[114]],[[127298,127298],"mapped",[115]],[[127299,127299],"mapped",[116]],[[127300,127300],"mapped",[117]],[[127301,127301],"mapped",[118]],[[127302,127302],"mapped",[119]],[[127303,127303],"mapped",[120]],[[127304,127304],"mapped",[121]],[[127305,127305],"mapped",[122]],[[127306,127306],"mapped",[104,118]],[[127307,127307],"mapped",[109,118]],[[127308,127308],"mapped",[115,100]],[[127309,127309],"mapped",[115,115]],[[127310,127310],"mapped",[112,112,118]],[[127311,127311],"mapped",[119,99]],[[127312,127318],"valid",[],"NV8"],[[127319,127319],"valid",[],"NV8"],[[127320,127326],"valid",[],"NV8"],[[127327,127327],"valid",[],"NV8"],[[127328,127337],"valid",[],"NV8"],[[127338,127338],"mapped",[109,99]],[[127339,127339],"mapped",[109,100]],[[127340,127343],"disallowed"],[[127344,127352],"valid",[],"NV8"],[[127353,127353],"valid",[],"NV8"],[[127354,127354],"valid",[],"NV8"],[[127355,127356],"valid",[],"NV8"],[[127357,127358],"valid",[],"NV8"],[[127359,127359],"valid",[],"NV8"],[[127360,127369],"valid",[],"NV8"],[[127370,127373],"valid",[],"NV8"],[[127374,127375],"valid",[],"NV8"],[[127376,127376],"mapped",[100,106]],[[127377,127386],"valid",[],"NV8"],[[127387,127461],"disallowed"],[[127462,127487],"valid",[],"NV8"],[[127488,127488],"mapped",[12411,12363]],[[127489,127489],"mapped",[12467,12467]],[[127490,127490],"mapped",[12469]],[[127491,127503],"disallowed"],[[127504,127504],"mapped",[25163]],[[127505,127505],"mapped",[23383]],[[127506,127506],"mapped",[21452]],[[127507,127507],"mapped",[12487]],[[127508,127508],"mapped",[20108]],[[127509,127509],"mapped",[22810]],[[127510,127510],"mapped",[35299]],[[127511,127511],"mapped",[22825]],[[127512,127512],"mapped",[20132]],[[127513,127513],"mapped",[26144]],[[127514,127514],"mapped",[28961]],[[127515,127515],"mapped",[26009]],[[127516,127516],"mapped",[21069]],[[127517,127517],"mapped",[24460]],[[127518,127518],"mapped",[20877]],[[127519,127519],"mapped",[26032]],[[127520,127520],"mapped",[21021]],[[127521,127521],"mapped",[32066]],[[127522,127522],"mapped",[29983]],[[127523,127523],"mapped",[36009]],[[127524,127524],"mapped",[22768]],[[127525,127525],"mapped",[21561]],[[127526,127526],"mapped",[28436]],[[127527,127527],"mapped",[25237]],[[127528,127528],"mapped",[25429]],[[127529,127529],"mapped",[19968]],[[127530,127530],"mapped",[19977]],[[127531,127531],"mapped",[36938]],[[127532,127532],"mapped",[24038]],[[127533,127533],"mapped",[20013]],[[127534,127534],"mapped",[21491]],[[127535,127535],"mapped",[25351]],[[127536,127536],"mapped",[36208]],[[127537,127537],"mapped",[25171]],[[127538,127538],"mapped",[31105]],[[127539,127539],"mapped",[31354]],[[127540,127540],"mapped",[21512]],[[127541,127541],"mapped",[28288]],[[127542,127542],"mapped",[26377]],[[127543,127543],"mapped",[26376]],[[127544,127544],"mapped",[30003]],[[127545,127545],"mapped",[21106]],[[127546,127546],"mapped",[21942]],[[127547,127551],"disallowed"],[[127552,127552],"mapped",[12308,26412,12309]],[[127553,127553],"mapped",[12308,19977,12309]],[[127554,127554],"mapped",[12308,20108,12309]],[[127555,127555],"mapped",[12308,23433,12309]],[[127556,127556],"mapped",[12308,28857,12309]],[[127557,127557],"mapped",[12308,25171,12309]],[[127558,127558],"mapped",[12308,30423,12309]],[[127559,127559],"mapped",[12308,21213,12309]],[[127560,127560],"mapped",[12308,25943,12309]],[[127561,127567],"disallowed"],[[127568,127568],"mapped",[24471]],[[127569,127569],"mapped",[21487]],[[127570,127743],"disallowed"],[[127744,127776],"valid",[],"NV8"],[[127777,127788],"valid",[],"NV8"],[[127789,127791],"valid",[],"NV8"],[[127792,127797],"valid",[],"NV8"],[[127798,127798],"valid",[],"NV8"],[[127799,127868],"valid",[],"NV8"],[[127869,127869],"valid",[],"NV8"],[[127870,127871],"valid",[],"NV8"],[[127872,127891],"valid",[],"NV8"],[[127892,127903],"valid",[],"NV8"],[[127904,127940],"valid",[],"NV8"],[[127941,127941],"valid",[],"NV8"],[[127942,127946],"valid",[],"NV8"],[[127947,127950],"valid",[],"NV8"],[[127951,127955],"valid",[],"NV8"],[[127956,127967],"valid",[],"NV8"],[[127968,127984],"valid",[],"NV8"],[[127985,127991],"valid",[],"NV8"],[[127992,127999],"valid",[],"NV8"],[[128000,128062],"valid",[],"NV8"],[[128063,128063],"valid",[],"NV8"],[[128064,128064],"valid",[],"NV8"],[[128065,128065],"valid",[],"NV8"],[[128066,128247],"valid",[],"NV8"],[[128248,128248],"valid",[],"NV8"],[[128249,128252],"valid",[],"NV8"],[[128253,128254],"valid",[],"NV8"],[[128255,128255],"valid",[],"NV8"],[[128256,128317],"valid",[],"NV8"],[[128318,128319],"valid",[],"NV8"],[[128320,128323],"valid",[],"NV8"],[[128324,128330],"valid",[],"NV8"],[[128331,128335],"valid",[],"NV8"],[[128336,128359],"valid",[],"NV8"],[[128360,128377],"valid",[],"NV8"],[[128378,128378],"disallowed"],[[128379,128419],"valid",[],"NV8"],[[128420,128420],"disallowed"],[[128421,128506],"valid",[],"NV8"],[[128507,128511],"valid",[],"NV8"],[[128512,128512],"valid",[],"NV8"],[[128513,128528],"valid",[],"NV8"],[[128529,128529],"valid",[],"NV8"],[[128530,128532],"valid",[],"NV8"],[[128533,128533],"valid",[],"NV8"],[[128534,128534],"valid",[],"NV8"],[[128535,128535],"valid",[],"NV8"],[[128536,128536],"valid",[],"NV8"],[[128537,128537],"valid",[],"NV8"],[[128538,128538],"valid",[],"NV8"],[[128539,128539],"valid",[],"NV8"],[[128540,128542],"valid",[],"NV8"],[[128543,128543],"valid",[],"NV8"],[[128544,128549],"valid",[],"NV8"],[[128550,128551],"valid",[],"NV8"],[[128552,128555],"valid",[],"NV8"],[[128556,128556],"valid",[],"NV8"],[[128557,128557],"valid",[],"NV8"],[[128558,128559],"valid",[],"NV8"],[[128560,128563],"valid",[],"NV8"],[[128564,128564],"valid",[],"NV8"],[[128565,128576],"valid",[],"NV8"],[[128577,128578],"valid",[],"NV8"],[[128579,128580],"valid",[],"NV8"],[[128581,128591],"valid",[],"NV8"],[[128592,128639],"valid",[],"NV8"],[[128640,128709],"valid",[],"NV8"],[[128710,128719],"valid",[],"NV8"],[[128720,128720],"valid",[],"NV8"],[[128721,128735],"disallowed"],[[128736,128748],"valid",[],"NV8"],[[128749,128751],"disallowed"],[[128752,128755],"valid",[],"NV8"],[[128756,128767],"disallowed"],[[128768,128883],"valid",[],"NV8"],[[128884,128895],"disallowed"],[[128896,128980],"valid",[],"NV8"],[[128981,129023],"disallowed"],[[129024,129035],"valid",[],"NV8"],[[129036,129039],"disallowed"],[[129040,129095],"valid",[],"NV8"],[[129096,129103],"disallowed"],[[129104,129113],"valid",[],"NV8"],[[129114,129119],"disallowed"],[[129120,129159],"valid",[],"NV8"],[[129160,129167],"disallowed"],[[129168,129197],"valid",[],"NV8"],[[129198,129295],"disallowed"],[[129296,129304],"valid",[],"NV8"],[[129305,129407],"disallowed"],[[129408,129412],"valid",[],"NV8"],[[129413,129471],"disallowed"],[[129472,129472],"valid",[],"NV8"],[[129473,131069],"disallowed"],[[131070,131071],"disallowed"],[[131072,173782],"valid"],[[173783,173823],"disallowed"],[[173824,177972],"valid"],[[177973,177983],"disallowed"],[[177984,178205],"valid"],[[178206,178207],"disallowed"],[[178208,183969],"valid"],[[183970,194559],"disallowed"],[[194560,194560],"mapped",[20029]],[[194561,194561],"mapped",[20024]],[[194562,194562],"mapped",[20033]],[[194563,194563],"mapped",[131362]],[[194564,194564],"mapped",[20320]],[[194565,194565],"mapped",[20398]],[[194566,194566],"mapped",[20411]],[[194567,194567],"mapped",[20482]],[[194568,194568],"mapped",[20602]],[[194569,194569],"mapped",[20633]],[[194570,194570],"mapped",[20711]],[[194571,194571],"mapped",[20687]],[[194572,194572],"mapped",[13470]],[[194573,194573],"mapped",[132666]],[[194574,194574],"mapped",[20813]],[[194575,194575],"mapped",[20820]],[[194576,194576],"mapped",[20836]],[[194577,194577],"mapped",[20855]],[[194578,194578],"mapped",[132380]],[[194579,194579],"mapped",[13497]],[[194580,194580],"mapped",[20839]],[[194581,194581],"mapped",[20877]],[[194582,194582],"mapped",[132427]],[[194583,194583],"mapped",[20887]],[[194584,194584],"mapped",[20900]],[[194585,194585],"mapped",[20172]],[[194586,194586],"mapped",[20908]],[[194587,194587],"mapped",[20917]],[[194588,194588],"mapped",[168415]],[[194589,194589],"mapped",[20981]],[[194590,194590],"mapped",[20995]],[[194591,194591],"mapped",[13535]],[[194592,194592],"mapped",[21051]],[[194593,194593],"mapped",[21062]],[[194594,194594],"mapped",[21106]],[[194595,194595],"mapped",[21111]],[[194596,194596],"mapped",[13589]],[[194597,194597],"mapped",[21191]],[[194598,194598],"mapped",[21193]],[[194599,194599],"mapped",[21220]],[[194600,194600],"mapped",[21242]],[[194601,194601],"mapped",[21253]],[[194602,194602],"mapped",[21254]],[[194603,194603],"mapped",[21271]],[[194604,194604],"mapped",[21321]],[[194605,194605],"mapped",[21329]],[[194606,194606],"mapped",[21338]],[[194607,194607],"mapped",[21363]],[[194608,194608],"mapped",[21373]],[[194609,194611],"mapped",[21375]],[[194612,194612],"mapped",[133676]],[[194613,194613],"mapped",[28784]],[[194614,194614],"mapped",[21450]],[[194615,194615],"mapped",[21471]],[[194616,194616],"mapped",[133987]],[[194617,194617],"mapped",[21483]],[[194618,194618],"mapped",[21489]],[[194619,194619],"mapped",[21510]],[[194620,194620],"mapped",[21662]],[[194621,194621],"mapped",[21560]],[[194622,194622],"mapped",[21576]],[[194623,194623],"mapped",[21608]],[[194624,194624],"mapped",[21666]],[[194625,194625],"mapped",[21750]],[[194626,194626],"mapped",[21776]],[[194627,194627],"mapped",[21843]],[[194628,194628],"mapped",[21859]],[[194629,194630],"mapped",[21892]],[[194631,194631],"mapped",[21913]],[[194632,194632],"mapped",[21931]],[[194633,194633],"mapped",[21939]],[[194634,194634],"mapped",[21954]],[[194635,194635],"mapped",[22294]],[[194636,194636],"mapped",[22022]],[[194637,194637],"mapped",[22295]],[[194638,194638],"mapped",[22097]],[[194639,194639],"mapped",[22132]],[[194640,194640],"mapped",[20999]],[[194641,194641],"mapped",[22766]],[[194642,194642],"mapped",[22478]],[[194643,194643],"mapped",[22516]],[[194644,194644],"mapped",[22541]],[[194645,194645],"mapped",[22411]],[[194646,194646],"mapped",[22578]],[[194647,194647],"mapped",[22577]],[[194648,194648],"mapped",[22700]],[[194649,194649],"mapped",[136420]],[[194650,194650],"mapped",[22770]],[[194651,194651],"mapped",[22775]],[[194652,194652],"mapped",[22790]],[[194653,194653],"mapped",[22810]],[[194654,194654],"mapped",[22818]],[[194655,194655],"mapped",[22882]],[[194656,194656],"mapped",[136872]],[[194657,194657],"mapped",[136938]],[[194658,194658],"mapped",[23020]],[[194659,194659],"mapped",[23067]],[[194660,194660],"mapped",[23079]],[[194661,194661],"mapped",[23000]],[[194662,194662],"mapped",[23142]],[[194663,194663],"mapped",[14062]],[[194664,194664],"disallowed"],[[194665,194665],"mapped",[23304]],[[194666,194667],"mapped",[23358]],[[194668,194668],"mapped",[137672]],[[194669,194669],"mapped",[23491]],[[194670,194670],"mapped",[23512]],[[194671,194671],"mapped",[23527]],[[194672,194672],"mapped",[23539]],[[194673,194673],"mapped",[138008]],[[194674,194674],"mapped",[23551]],[[194675,194675],"mapped",[23558]],[[194676,194676],"disallowed"],[[194677,194677],"mapped",[23586]],[[194678,194678],"mapped",[14209]],[[194679,194679],"mapped",[23648]],[[194680,194680],"mapped",[23662]],[[194681,194681],"mapped",[23744]],[[194682,194682],"mapped",[23693]],[[194683,194683],"mapped",[138724]],[[194684,194684],"mapped",[23875]],[[194685,194685],"mapped",[138726]],[[194686,194686],"mapped",[23918]],[[194687,194687],"mapped",[23915]],[[194688,194688],"mapped",[23932]],[[194689,194689],"mapped",[24033]],[[194690,194690],"mapped",[24034]],[[194691,194691],"mapped",[14383]],[[194692,194692],"mapped",[24061]],[[194693,194693],"mapped",[24104]],[[194694,194694],"mapped",[24125]],[[194695,194695],"mapped",[24169]],[[194696,194696],"mapped",[14434]],[[194697,194697],"mapped",[139651]],[[194698,194698],"mapped",[14460]],[[194699,194699],"mapped",[24240]],[[194700,194700],"mapped",[24243]],[[194701,194701],"mapped",[24246]],[[194702,194702],"mapped",[24266]],[[194703,194703],"mapped",[172946]],[[194704,194704],"mapped",[24318]],[[194705,194706],"mapped",[140081]],[[194707,194707],"mapped",[33281]],[[194708,194709],"mapped",[24354]],[[194710,194710],"mapped",[14535]],[[194711,194711],"mapped",[144056]],[[194712,194712],"mapped",[156122]],[[194713,194713],"mapped",[24418]],[[194714,194714],"mapped",[24427]],[[194715,194715],"mapped",[14563]],[[194716,194716],"mapped",[24474]],[[194717,194717],"mapped",[24525]],[[194718,194718],"mapped",[24535]],[[194719,194719],"mapped",[24569]],[[194720,194720],"mapped",[24705]],[[194721,194721],"mapped",[14650]],[[194722,194722],"mapped",[14620]],[[194723,194723],"mapped",[24724]],[[194724,194724],"mapped",[141012]],[[194725,194725],"mapped",[24775]],[[194726,194726],"mapped",[24904]],[[194727,194727],"mapped",[24908]],[[194728,194728],"mapped",[24910]],[[194729,194729],"mapped",[24908]],[[194730,194730],"mapped",[24954]],[[194731,194731],"mapped",[24974]],[[194732,194732],"mapped",[25010]],[[194733,194733],"mapped",[24996]],[[194734,194734],"mapped",[25007]],[[194735,194735],"mapped",[25054]],[[194736,194736],"mapped",[25074]],[[194737,194737],"mapped",[25078]],[[194738,194738],"mapped",[25104]],[[194739,194739],"mapped",[25115]],[[194740,194740],"mapped",[25181]],[[194741,194741],"mapped",[25265]],[[194742,194742],"mapped",[25300]],[[194743,194743],"mapped",[25424]],[[194744,194744],"mapped",[142092]],[[194745,194745],"mapped",[25405]],[[194746,194746],"mapped",[25340]],[[194747,194747],"mapped",[25448]],[[194748,194748],"mapped",[25475]],[[194749,194749],"mapped",[25572]],[[194750,194750],"mapped",[142321]],[[194751,194751],"mapped",[25634]],[[194752,194752],"mapped",[25541]],[[194753,194753],"mapped",[25513]],[[194754,194754],"mapped",[14894]],[[194755,194755],"mapped",[25705]],[[194756,194756],"mapped",[25726]],[[194757,194757],"mapped",[25757]],[[194758,194758],"mapped",[25719]],[[194759,194759],"mapped",[14956]],[[194760,194760],"mapped",[25935]],[[194761,194761],"mapped",[25964]],[[194762,194762],"mapped",[143370]],[[194763,194763],"mapped",[26083]],[[194764,194764],"mapped",[26360]],[[194765,194765],"mapped",[26185]],[[194766,194766],"mapped",[15129]],[[194767,194767],"mapped",[26257]],[[194768,194768],"mapped",[15112]],[[194769,194769],"mapped",[15076]],[[194770,194770],"mapped",[20882]],[[194771,194771],"mapped",[20885]],[[194772,194772],"mapped",[26368]],[[194773,194773],"mapped",[26268]],[[194774,194774],"mapped",[32941]],[[194775,194775],"mapped",[17369]],[[194776,194776],"mapped",[26391]],[[194777,194777],"mapped",[26395]],[[194778,194778],"mapped",[26401]],[[194779,194779],"mapped",[26462]],[[194780,194780],"mapped",[26451]],[[194781,194781],"mapped",[144323]],[[194782,194782],"mapped",[15177]],[[194783,194783],"mapped",[26618]],[[194784,194784],"mapped",[26501]],[[194785,194785],"mapped",[26706]],[[194786,194786],"mapped",[26757]],[[194787,194787],"mapped",[144493]],[[194788,194788],"mapped",[26766]],[[194789,194789],"mapped",[26655]],[[194790,194790],"mapped",[26900]],[[194791,194791],"mapped",[15261]],[[194792,194792],"mapped",[26946]],[[194793,194793],"mapped",[27043]],[[194794,194794],"mapped",[27114]],[[194795,194795],"mapped",[27304]],[[194796,194796],"mapped",[145059]],[[194797,194797],"mapped",[27355]],[[194798,194798],"mapped",[15384]],[[194799,194799],"mapped",[27425]],[[194800,194800],"mapped",[145575]],[[194801,194801],"mapped",[27476]],[[194802,194802],"mapped",[15438]],[[194803,194803],"mapped",[27506]],[[194804,194804],"mapped",[27551]],[[194805,194805],"mapped",[27578]],[[194806,194806],"mapped",[27579]],[[194807,194807],"mapped",[146061]],[[194808,194808],"mapped",[138507]],[[194809,194809],"mapped",[146170]],[[194810,194810],"mapped",[27726]],[[194811,194811],"mapped",[146620]],[[194812,194812],"mapped",[27839]],[[194813,194813],"mapped",[27853]],[[194814,194814],"mapped",[27751]],[[194815,194815],"mapped",[27926]],[[194816,194816],"mapped",[27966]],[[194817,194817],"mapped",[28023]],[[194818,194818],"mapped",[27969]],[[194819,194819],"mapped",[28009]],[[194820,194820],"mapped",[28024]],[[194821,194821],"mapped",[28037]],[[194822,194822],"mapped",[146718]],[[194823,194823],"mapped",[27956]],[[194824,194824],"mapped",[28207]],[[194825,194825],"mapped",[28270]],[[194826,194826],"mapped",[15667]],[[194827,194827],"mapped",[28363]],[[194828,194828],"mapped",[28359]],[[194829,194829],"mapped",[147153]],[[194830,194830],"mapped",[28153]],[[194831,194831],"mapped",[28526]],[[194832,194832],"mapped",[147294]],[[194833,194833],"mapped",[147342]],[[194834,194834],"mapped",[28614]],[[194835,194835],"mapped",[28729]],[[194836,194836],"mapped",[28702]],[[194837,194837],"mapped",[28699]],[[194838,194838],"mapped",[15766]],[[194839,194839],"mapped",[28746]],[[194840,194840],"mapped",[28797]],[[194841,194841],"mapped",[28791]],[[194842,194842],"mapped",[28845]],[[194843,194843],"mapped",[132389]],[[194844,194844],"mapped",[28997]],[[194845,194845],"mapped",[148067]],[[194846,194846],"mapped",[29084]],[[194847,194847],"disallowed"],[[194848,194848],"mapped",[29224]],[[194849,194849],"mapped",[29237]],[[194850,194850],"mapped",[29264]],[[194851,194851],"mapped",[149000]],[[194852,194852],"mapped",[29312]],[[194853,194853],"mapped",[29333]],[[194854,194854],"mapped",[149301]],[[194855,194855],"mapped",[149524]],[[194856,194856],"mapped",[29562]],[[194857,194857],"mapped",[29579]],[[194858,194858],"mapped",[16044]],[[194859,194859],"mapped",[29605]],[[194860,194861],"mapped",[16056]],[[194862,194862],"mapped",[29767]],[[194863,194863],"mapped",[29788]],[[194864,194864],"mapped",[29809]],[[194865,194865],"mapped",[29829]],[[194866,194866],"mapped",[29898]],[[194867,194867],"mapped",[16155]],[[194868,194868],"mapped",[29988]],[[194869,194869],"mapped",[150582]],[[194870,194870],"mapped",[30014]],[[194871,194871],"mapped",[150674]],[[194872,194872],"mapped",[30064]],[[194873,194873],"mapped",[139679]],[[194874,194874],"mapped",[30224]],[[194875,194875],"mapped",[151457]],[[194876,194876],"mapped",[151480]],[[194877,194877],"mapped",[151620]],[[194878,194878],"mapped",[16380]],[[194879,194879],"mapped",[16392]],[[194880,194880],"mapped",[30452]],[[194881,194881],"mapped",[151795]],[[194882,194882],"mapped",[151794]],[[194883,194883],"mapped",[151833]],[[194884,194884],"mapped",[151859]],[[194885,194885],"mapped",[30494]],[[194886,194887],"mapped",[30495]],[[194888,194888],"mapped",[30538]],[[194889,194889],"mapped",[16441]],[[194890,194890],"mapped",[30603]],[[194891,194891],"mapped",[16454]],[[194892,194892],"mapped",[16534]],[[194893,194893],"mapped",[152605]],[[194894,194894],"mapped",[30798]],[[194895,194895],"mapped",[30860]],[[194896,194896],"mapped",[30924]],[[194897,194897],"mapped",[16611]],[[194898,194898],"mapped",[153126]],[[194899,194899],"mapped",[31062]],[[194900,194900],"mapped",[153242]],[[194901,194901],"mapped",[153285]],[[194902,194902],"mapped",[31119]],[[194903,194903],"mapped",[31211]],[[194904,194904],"mapped",[16687]],[[194905,194905],"mapped",[31296]],[[194906,194906],"mapped",[31306]],[[194907,194907],"mapped",[31311]],[[194908,194908],"mapped",[153980]],[[194909,194910],"mapped",[154279]],[[194911,194911],"disallowed"],[[194912,194912],"mapped",[16898]],[[194913,194913],"mapped",[154539]],[[194914,194914],"mapped",[31686]],[[194915,194915],"mapped",[31689]],[[194916,194916],"mapped",[16935]],[[194917,194917],"mapped",[154752]],[[194918,194918],"mapped",[31954]],[[194919,194919],"mapped",[17056]],[[194920,194920],"mapped",[31976]],[[194921,194921],"mapped",[31971]],[[194922,194922],"mapped",[32000]],[[194923,194923],"mapped",[155526]],[[194924,194924],"mapped",[32099]],[[194925,194925],"mapped",[17153]],[[194926,194926],"mapped",[32199]],[[194927,194927],"mapped",[32258]],[[194928,194928],"mapped",[32325]],[[194929,194929],"mapped",[17204]],[[194930,194930],"mapped",[156200]],[[194931,194931],"mapped",[156231]],[[194932,194932],"mapped",[17241]],[[194933,194933],"mapped",[156377]],[[194934,194934],"mapped",[32634]],[[194935,194935],"mapped",[156478]],[[194936,194936],"mapped",[32661]],[[194937,194937],"mapped",[32762]],[[194938,194938],"mapped",[32773]],[[194939,194939],"mapped",[156890]],[[194940,194940],"mapped",[156963]],[[194941,194941],"mapped",[32864]],[[194942,194942],"mapped",[157096]],[[194943,194943],"mapped",[32880]],[[194944,194944],"mapped",[144223]],[[194945,194945],"mapped",[17365]],[[194946,194946],"mapped",[32946]],[[194947,194947],"mapped",[33027]],[[194948,194948],"mapped",[17419]],[[194949,194949],"mapped",[33086]],[[194950,194950],"mapped",[23221]],[[194951,194951],"mapped",[157607]],[[194952,194952],"mapped",[157621]],[[194953,194953],"mapped",[144275]],[[194954,194954],"mapped",[144284]],[[194955,194955],"mapped",[33281]],[[194956,194956],"mapped",[33284]],[[194957,194957],"mapped",[36766]],[[194958,194958],"mapped",[17515]],[[194959,194959],"mapped",[33425]],[[194960,194960],"mapped",[33419]],[[194961,194961],"mapped",[33437]],[[194962,194962],"mapped",[21171]],[[194963,194963],"mapped",[33457]],[[194964,194964],"mapped",[33459]],[[194965,194965],"mapped",[33469]],[[194966,194966],"mapped",[33510]],[[194967,194967],"mapped",[158524]],[[194968,194968],"mapped",[33509]],[[194969,194969],"mapped",[33565]],[[194970,194970],"mapped",[33635]],[[194971,194971],"mapped",[33709]],[[194972,194972],"mapped",[33571]],[[194973,194973],"mapped",[33725]],[[194974,194974],"mapped",[33767]],[[194975,194975],"mapped",[33879]],[[194976,194976],"mapped",[33619]],[[194977,194977],"mapped",[33738]],[[194978,194978],"mapped",[33740]],[[194979,194979],"mapped",[33756]],[[194980,194980],"mapped",[158774]],[[194981,194981],"mapped",[159083]],[[194982,194982],"mapped",[158933]],[[194983,194983],"mapped",[17707]],[[194984,194984],"mapped",[34033]],[[194985,194985],"mapped",[34035]],[[194986,194986],"mapped",[34070]],[[194987,194987],"mapped",[160714]],[[194988,194988],"mapped",[34148]],[[194989,194989],"mapped",[159532]],[[194990,194990],"mapped",[17757]],[[194991,194991],"mapped",[17761]],[[194992,194992],"mapped",[159665]],[[194993,194993],"mapped",[159954]],[[194994,194994],"mapped",[17771]],[[194995,194995],"mapped",[34384]],[[194996,194996],"mapped",[34396]],[[194997,194997],"mapped",[34407]],[[194998,194998],"mapped",[34409]],[[194999,194999],"mapped",[34473]],[[195000,195000],"mapped",[34440]],[[195001,195001],"mapped",[34574]],[[195002,195002],"mapped",[34530]],[[195003,195003],"mapped",[34681]],[[195004,195004],"mapped",[34600]],[[195005,195005],"mapped",[34667]],[[195006,195006],"mapped",[34694]],[[195007,195007],"disallowed"],[[195008,195008],"mapped",[34785]],[[195009,195009],"mapped",[34817]],[[195010,195010],"mapped",[17913]],[[195011,195011],"mapped",[34912]],[[195012,195012],"mapped",[34915]],[[195013,195013],"mapped",[161383]],[[195014,195014],"mapped",[35031]],[[195015,195015],"mapped",[35038]],[[195016,195016],"mapped",[17973]],[[195017,195017],"mapped",[35066]],[[195018,195018],"mapped",[13499]],[[195019,195019],"mapped",[161966]],[[195020,195020],"mapped",[162150]],[[195021,195021],"mapped",[18110]],[[195022,195022],"mapped",[18119]],[[195023,195023],"mapped",[35488]],[[195024,195024],"mapped",[35565]],[[195025,195025],"mapped",[35722]],[[195026,195026],"mapped",[35925]],[[195027,195027],"mapped",[162984]],[[195028,195028],"mapped",[36011]],[[195029,195029],"mapped",[36033]],[[195030,195030],"mapped",[36123]],[[195031,195031],"mapped",[36215]],[[195032,195032],"mapped",[163631]],[[195033,195033],"mapped",[133124]],[[195034,195034],"mapped",[36299]],[[195035,195035],"mapped",[36284]],[[195036,195036],"mapped",[36336]],[[195037,195037],"mapped",[133342]],[[195038,195038],"mapped",[36564]],[[195039,195039],"mapped",[36664]],[[195040,195040],"mapped",[165330]],[[195041,195041],"mapped",[165357]],[[195042,195042],"mapped",[37012]],[[195043,195043],"mapped",[37105]],[[195044,195044],"mapped",[37137]],[[195045,195045],"mapped",[165678]],[[195046,195046],"mapped",[37147]],[[195047,195047],"mapped",[37432]],[[195048,195048],"mapped",[37591]],[[195049,195049],"mapped",[37592]],[[195050,195050],"mapped",[37500]],[[195051,195051],"mapped",[37881]],[[195052,195052],"mapped",[37909]],[[195053,195053],"mapped",[166906]],[[195054,195054],"mapped",[38283]],[[195055,195055],"mapped",[18837]],[[195056,195056],"mapped",[38327]],[[195057,195057],"mapped",[167287]],[[195058,195058],"mapped",[18918]],[[195059,195059],"mapped",[38595]],[[195060,195060],"mapped",[23986]],[[195061,195061],"mapped",[38691]],[[195062,195062],"mapped",[168261]],[[195063,195063],"mapped",[168474]],[[195064,195064],"mapped",[19054]],[[195065,195065],"mapped",[19062]],[[195066,195066],"mapped",[38880]],[[195067,195067],"mapped",[168970]],[[195068,195068],"mapped",[19122]],[[195069,195069],"mapped",[169110]],[[195070,195071],"mapped",[38923]],[[195072,195072],"mapped",[38953]],[[195073,195073],"mapped",[169398]],[[195074,195074],"mapped",[39138]],[[195075,195075],"mapped",[19251]],[[195076,195076],"mapped",[39209]],[[195077,195077],"mapped",[39335]],[[195078,195078],"mapped",[39362]],[[195079,195079],"mapped",[39422]],[[195080,195080],"mapped",[19406]],[[195081,195081],"mapped",[170800]],[[195082,195082],"mapped",[39698]],[[195083,195083],"mapped",[40000]],[[195084,195084],"mapped",[40189]],[[195085,195085],"mapped",[19662]],[[195086,195086],"mapped",[19693]],[[195087,195087],"mapped",[40295]],[[195088,195088],"mapped",[172238]],[[195089,195089],"mapped",[19704]],[[195090,195090],"mapped",[172293]],[[195091,195091],"mapped",[172558]],[[195092,195092],"mapped",[172689]],[[195093,195093],"mapped",[40635]],[[195094,195094],"mapped",[19798]],[[195095,195095],"mapped",[40697]],[[195096,195096],"mapped",[40702]],[[195097,195097],"mapped",[40709]],[[195098,195098],"mapped",[40719]],[[195099,195099],"mapped",[40726]],[[195100,195100],"mapped",[40763]],[[195101,195101],"mapped",[173568]],[[195102,196605],"disallowed"],[[196606,196607],"disallowed"],[[196608,262141],"disallowed"],[[262142,262143],"disallowed"],[[262144,327677],"disallowed"],[[327678,327679],"disallowed"],[[327680,393213],"disallowed"],[[393214,393215],"disallowed"],[[393216,458749],"disallowed"],[[458750,458751],"disallowed"],[[458752,524285],"disallowed"],[[524286,524287],"disallowed"],[[524288,589821],"disallowed"],[[589822,589823],"disallowed"],[[589824,655357],"disallowed"],[[655358,655359],"disallowed"],[[655360,720893],"disallowed"],[[720894,720895],"disallowed"],[[720896,786429],"disallowed"],[[786430,786431],"disallowed"],[[786432,851965],"disallowed"],[[851966,851967],"disallowed"],[[851968,917501],"disallowed"],[[917502,917503],"disallowed"],[[917504,917504],"disallowed"],[[917505,917505],"disallowed"],[[917506,917535],"disallowed"],[[917536,917631],"disallowed"],[[917632,917759],"disallowed"],[[917760,917999],"ignored"],[[918000,983037],"disallowed"],[[983038,983039],"disallowed"],[[983040,1048573],"disallowed"],[[1048574,1048575],"disallowed"],[[1048576,1114109],"disallowed"],[[1114110,1114111],"disallowed"]]');
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        id: moduleId,
        loaded: false,
        exports: {}
    };
    __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.loaded = true;
    return module.exports;
}
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ("u" > typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
(()=>{
    __webpack_require__.nmd = (module)=>{
        module.paths = [];
        if (!module.children) module.children = [];
        return module;
    };
})();
var __webpack_exports__ = {};
(()=>{
    "use strict";
    var core = __webpack_require__("../../../node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/core.js");
    var cache = __webpack_require__("../../../node_modules/.pnpm/@actions+cache@3.2.4/node_modules/@actions/cache/lib/cache.js");
    var express = __webpack_require__("../../../node_modules/.pnpm/express@5.2.1/node_modules/express/index.js");
    var express_default = /*#__PURE__*/ __webpack_require__.n(express);
    var external_path_ = __webpack_require__("path");
    var external_fs_ = __webpack_require__("fs");
    const asyncHandler = (fn)=>(req, res, next)=>Promise.resolve(fn(req, res, next)).catch((err)=>next(err));
    const rootDirectory = process.env.GITHUB_WORKSPACE;
    const cacheDirectory = ".turbo/cache";
    const absoluteCacheDirectory = external_path_.resolve(rootDirectory, cacheDirectory);
    const portFileName = "__turbo_port.txt";
    async function startServer() {
        const app = express_default()();
        const serverToken = (0, core.getInput)("server-token", {
            required: true,
            trimWhitespace: true
        });
        app.all("*", (req, res, next)=>{
            console.info(`Got a ${req.method} request`, req.path);
            const { authorization = "" } = req.headers;
            const [type = "", token = ""] = authorization.split(" ");
            if ("Bearer" !== type || token !== serverToken) return res.status(401).send("Unauthorized");
            next();
        });
        app.get("/v8/artifacts/:artifactId", asyncHandler(async (req, res)=>{
            const { artifactId } = req.params;
            const filename = artifactId + ".gz";
            const cacheKey = await cache.restoreCache([
                `${cacheDirectory}/${filename}`
            ], artifactId, void 0, {
                timeoutInMs: 5000
            });
            if (cacheKey) console.log(`Artifact ${artifactId} downloaded successfully to ${cacheDirectory}/${filename}.`);
            else {
                console.log(`Artifact ${artifactId} not found.`);
                return res.status(404).send("Not found");
            }
            external_fs_.createReadStream(external_path_.join(absoluteCacheDirectory, filename)).pipe(res).on("error", (err)=>{
                console.error(err);
                res.end(err);
            });
        }));
        app.put("/v8/artifacts/:artifactId", asyncHandler(async (req, res)=>{
            const artifactId = req.params.artifactId;
            const filename = `${artifactId}.gz`;
            const writeStream = external_fs_.createWriteStream(external_path_.join(cacheDirectory, filename));
            try {
                await new Promise((resolve, reject)=>{
                    req.pipe(writeStream);
                    req.on("end", resolve);
                    writeStream.on("error", reject);
                });
            } catch (err) {
                console.error(err);
                return res.status(500).send("Error while writing artifact to disk.");
            }
            await cache.saveCache([
                `${cacheDirectory}/${filename}`
            ], artifactId);
            res.end();
        }));
        app.post("/v8/artifacts/events", (req, res)=>{
            res.status(200).send();
        });
        const server = app.disable("etag").listen(0);
        server.once("listening", ()=>{
            const port = "" + server.address().port;
            console.log(`Cache dir: ${cacheDirectory}`);
            console.log(`Local Turbo server is listening at http://127.0.0.1:${port}`);
            external_fs_.writeFileSync(external_path_.resolve(absoluteCacheDirectory, portFileName), port);
        });
    }
    startServer().catch((error)=>{
        console.error(error);
        process.exit(1);
    });
})();
for(var __rspack_i in __webpack_exports__)exports[__rspack_i] = __webpack_exports__[__rspack_i];
Object.defineProperty(exports, '__esModule', {
    value: true
});

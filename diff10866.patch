diff --git a/.changeset/pink-grapes-rule.md b/.changeset/pink-grapes-rule.md
new file mode 100644
index 00000000000..cc11be452da
--- /dev/null
+++ b/.changeset/pink-grapes-rule.md
@@ -0,0 +1,16 @@
+---
+"@ledgerhq/cryptoassets": minor
+"@ledgerhq/types-live": minor
+"@ledgerhq/coin-hedera": minor
+"@ledgerhq/errors": minor
+"ledger-live-desktop": minor
+"live-mobile": minor
+"@ledgerhq/live-common": minor
+"@ledgerhq/live-env": minor
+---
+
+added Hedera tokens to CAL
+added send/receive support to Hedera in LLD & LLM
+added support for HTS token association flow to LLD & LLM
+added support for "Associate token" transaction type to Hedera
+added test fixtures to coin-hedera
diff --git a/apps/ledger-live-desktop/src/config/urls.ts b/apps/ledger-live-desktop/src/config/urls.ts
index 5c67e8bd0ed..86ac2571d07 100644
--- a/apps/ledger-live-desktop/src/config/urls.ts
+++ b/apps/ledger-live-desktop/src/config/urls.ts
@@ -163,6 +163,8 @@ export const urls = {
   },
   hedera: {
     supportArticleLink: "https://support.ledger.com/article/4494505217565-zd",
+    tokenAssociation:
+      "https://support.ledger.com/article/How-to-manage-Hedera-tokens-with-Ledger-Live",
   },
   celo: {
     ledgerByFigmentTC:
diff --git a/apps/ledger-live-desktop/src/renderer/components/OperationsList/AddressCell.tsx b/apps/ledger-live-desktop/src/renderer/components/OperationsList/AddressCell.tsx
index 6b7fee9cd2d..eea91ce8591 100644
--- a/apps/ledger-live-desktop/src/renderer/components/OperationsList/AddressCell.tsx
+++ b/apps/ledger-live-desktop/src/renderer/components/OperationsList/AddressCell.tsx
@@ -1,7 +1,9 @@
 import React, { PureComponent } from "react";
 import styled from "styled-components";
-import { Operation } from "@ledgerhq/types-live";
+import type { Operation } from "@ledgerhq/types-live";
+import type { Currency } from "@ledgerhq/types-cryptoassets";
 import Box from "~/renderer/components/Box";
+import { getLLDCoinFamily } from "~/renderer/families";
 
 export const splitAddress = (value: string): { left: string; right: string } => {
   let left, right;
@@ -82,6 +84,7 @@ export const Cell = styled(Box).attrs<{
 `;
 type Props = {
   operation: Operation;
+  currency: Currency;
 };
 const showSender = (o: Operation) => o.senders[0];
 const showRecipient = (o: Operation) => o.recipients[0];
@@ -96,7 +99,17 @@ const perOperationType = {
 };
 class AddressCell extends PureComponent<Props> {
   render() {
-    const { operation } = this.props;
+    const { currency, operation } = this.props;
+
+    const cryptoCurrency = "family" in currency && currency.family ? currency : null;
+    const specific = cryptoCurrency ? getLLDCoinFamily(cryptoCurrency.family) : null;
+    const addressCell = specific?.operationDetails?.addressCell;
+    const AddressElement = addressCell ? addressCell[operation.type] : null;
+
+    if (AddressElement && !!cryptoCurrency) {
+      return <AddressElement operation={operation} currency={cryptoCurrency} />;
+    }
+
     const lense =
       perOperationType[operation.type as keyof typeof perOperationType] || perOperationType._;
     const value = lense(operation);
diff --git a/apps/ledger-live-desktop/src/renderer/components/OperationsList/ConfirmationCheck.tsx b/apps/ledger-live-desktop/src/renderer/components/OperationsList/ConfirmationCheck.tsx
index 7557c63eb77..6b09519c3e2 100644
--- a/apps/ledger-live-desktop/src/renderer/components/OperationsList/ConfirmationCheck.tsx
+++ b/apps/ledger-live-desktop/src/renderer/components/OperationsList/ConfirmationCheck.tsx
@@ -123,6 +123,7 @@ const iconsComponent = {
   WITHDRAW_UNSTAKED: IconCoins,
   UNKNOWN: IconCheck,
   BURN: IconTrash,
+  ASSOCIATE_TOKEN: IconPlus,
 };
 class ConfirmationCheck extends PureComponent<{
   marketColor: string;
diff --git a/apps/ledger-live-desktop/src/renderer/components/OperationsList/Operation.tsx b/apps/ledger-live-desktop/src/renderer/components/OperationsList/Operation.tsx
index 79cf5176108..8a919bdd3f7 100644
--- a/apps/ledger-live-desktop/src/renderer/components/OperationsList/Operation.tsx
+++ b/apps/ledger-live-desktop/src/renderer/components/OperationsList/Operation.tsx
@@ -91,7 +91,7 @@ function OperationComponent({
         t={t}
       />
       {withAccount && <AccountCell accountName={accountName} currency={currency} />}
-      {withAddress ? <AddressCell operation={operation} /> : <Box flex="1" />}
+      {withAddress ? <AddressCell operation={operation} currency={currency} /> : <Box flex="1" />}
       <AmountCell operation={operation} currency={currency} unit={unit} isConfirmed={isConfirmed} />
     </OperationRow>
   );
diff --git a/apps/ledger-live-desktop/src/renderer/drawers/OperationDetails/index.tsx b/apps/ledger-live-desktop/src/renderer/drawers/OperationDetails/index.tsx
index c0122406e59..16cceb86d22 100644
--- a/apps/ledger-live-desktop/src/renderer/drawers/OperationDetails/index.tsx
+++ b/apps/ledger-live-desktop/src/renderer/drawers/OperationDetails/index.tsx
@@ -188,7 +188,10 @@ const OperationD = (props: Props) => {
     ? getTransactionExplorer(getDefaultExplorerView(mainAccount.currency), operation)
     : getDefaultTransactionExplorer(getDefaultExplorerView(mainAccount.currency), operation.hash);
 
+  const OpDetailsPostAccountSection =
+    specific?.operationDetails?.OperationDetailsPostAccountSection;
   const OpDetailsExtra = specific?.operationDetails?.OperationDetailsExtra || OperationDetailsExtra;
+  const OpDetailsPostAlert = specific?.operationDetails?.OperationDetailsPostAlert;
   const { hasFailed } = operation;
   const subOperations: Operation[] = useMemo(
     () => operation.subOperations || [],
@@ -640,6 +643,13 @@ const OperationD = (props: Props) => {
           </Box>
         </OpDetailsData>
       </OpDetailsSection>
+      {OpDetailsPostAccountSection && (
+        <OpDetailsPostAccountSection
+          operation={operation}
+          type={type}
+          account={account as Account}
+        />
+      )}
       {isNftOperation ? <NFTOperationDetails operation={operation} /> : null}
       <OpDetailsSection>
         <OpDetailsTitle>{t("operationDetails.date")}</OpDetailsTitle>
@@ -691,6 +701,9 @@ const OperationD = (props: Props) => {
         <OpDetailsExtra operation={operation} type={type} account={account as Account} />
       )}
       <B />
+      {OpDetailsPostAlert && (
+        <OpDetailsPostAlert operation={operation} type={type} account={account as Account} />
+      )}
     </Box>
   );
 };
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/OperationDetails.tsx b/apps/ledger-live-desktop/src/renderer/families/hedera/OperationDetails.tsx
new file mode 100644
index 00000000000..8aac3007fa1
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/OperationDetails.tsx
@@ -0,0 +1,127 @@
+import React from "react";
+import { Trans, useTranslation } from "react-i18next";
+import type { OperationType } from "@ledgerhq/types-live";
+import { findTokenByAddressInCurrency } from "@ledgerhq/cryptoassets";
+import { isValidExtra } from "@ledgerhq/live-common/families/hedera/logic";
+import type { HederaAccount, HederaOperation } from "@ledgerhq/live-common/families/hedera/types";
+import { Link } from "@ledgerhq/react-ui";
+import { urls } from "~/config/urls";
+import { useDispatch } from "react-redux";
+import { openModal } from "~/renderer/actions/modals";
+import type {
+  AddressCellProps,
+  OperationDetailsExtraProps,
+  OperationDetailsPostAccountSectionProps,
+} from "~/renderer/families/types";
+import Alert from "~/renderer/components/Alert";
+import { Cell } from "~/renderer/components/OperationsList/AddressCell";
+import Box from "~/renderer/components/Box";
+import {
+  OpDetailsData,
+  OpDetailsSection,
+  OpDetailsTitle,
+  TextEllipsis,
+} from "~/renderer/drawers/OperationDetails/styledComponents";
+
+const OperationDetailsPostAccountSection = ({
+  operation,
+}: OperationDetailsPostAccountSectionProps<HederaAccount, HederaOperation>) => {
+  const { t } = useTranslation();
+
+  if (operation.type !== "ASSOCIATE_TOKEN") {
+    return null;
+  }
+
+  const token = operation.extra.associatedTokenId
+    ? findTokenByAddressInCurrency(operation.extra.associatedTokenId, "hedera")
+    : null;
+
+  if (!token) {
+    return null;
+  }
+
+  return (
+    <OpDetailsSection>
+      <OpDetailsTitle>{t("hedera.operationDetails.postAccountSection")}</OpDetailsTitle>
+      <OpDetailsData>
+        <TextEllipsis>
+          {token.contractAddress} ({token.name})
+        </TextEllipsis>
+      </OpDetailsData>
+    </OpDetailsSection>
+  );
+};
+
+const OperationDetailsPostAlert = ({
+  account,
+  operation,
+}: OperationDetailsExtraProps<HederaAccount, HederaOperation>) => {
+  const dispatch = useDispatch();
+
+  if (operation.type !== "ASSOCIATE_TOKEN") {
+    return null;
+  }
+
+  const extra = isValidExtra(operation.extra) ? operation.extra : null;
+  const associatedTokenId = extra?.associatedTokenId;
+  const token = associatedTokenId
+    ? findTokenByAddressInCurrency(associatedTokenId, "hedera")
+    : null;
+
+  if (!token) {
+    return null;
+  }
+
+  const openReceiveModal = () => {
+    const tokenAccount = account.subAccounts?.find(
+      a => a.token.contractAddress === token.contractAddress,
+    );
+
+    dispatch(
+      openModal(
+        "MODAL_RECEIVE",
+        tokenAccount ? { account: tokenAccount, parentAccount: account } : { account },
+      ),
+    );
+  };
+
+  return (
+    <Alert
+      type="primary"
+      learnMoreUrl={urls.hedera.tokenAssociation}
+      learnMoreLabel={<Trans i18nKey="hedera.operationDetails.postAlert.learnMore" />}
+    >
+      <Trans i18nKey="hedera.operationDetails.postAlert.text">
+        <Link onClick={openReceiveModal} color="inherit" textProps={{ fontWeight: "medium" }} />
+      </Trans>
+    </Alert>
+  );
+};
+
+const AddressCell = ({ operation }: AddressCellProps<HederaOperation>) => {
+  const token = operation.extra.associatedTokenId
+    ? findTokenByAddressInCurrency(operation.extra.associatedTokenId, "hedera")
+    : null;
+
+  if (!token) {
+    return null;
+  }
+
+  return (
+    <Cell>
+      <Box color="palette.text.shade80" ff="Inter" fontSize={3}>
+        {token.contractAddress} ({token.name})
+      </Box>
+    </Cell>
+  );
+};
+
+const addressCell = {
+  ASSOCIATE_TOKEN: AddressCell,
+} satisfies Partial<Record<OperationType, unknown>>;
+
+export default {
+  OperationDetailsPostAccountSection,
+  OperationDetailsPostAlert,
+  addressCell,
+};
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/Body.tsx b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/Body.tsx
new file mode 100644
index 00000000000..8f0bce34295
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/Body.tsx
@@ -0,0 +1,390 @@
+import React, { useState, useCallback, useEffect } from "react";
+import { compose } from "redux";
+import { connect, useDispatch } from "react-redux";
+import { Trans, withTranslation } from "react-i18next";
+import { createStructuredSelector } from "reselect";
+import invariant from "invariant";
+import { SyncSkipUnderPriority } from "@ledgerhq/live-common/bridge/react/index";
+import useBridgeTransaction from "@ledgerhq/live-common/bridge/useBridgeTransaction";
+import { getAccountBridge } from "@ledgerhq/live-common/bridge/index";
+import type { Transaction, TransactionStatus } from "@ledgerhq/live-common/families/hedera/types";
+import { isTokenAssociationRequired } from "@ledgerhq/live-common/families/hedera/logic";
+import { UserRefusedOnDevice } from "@ledgerhq/errors";
+import type { Account, Operation, TokenAccount } from "@ledgerhq/types-live";
+import type { TokenCurrency } from "@ledgerhq/types-cryptoassets";
+import { getAccountCurrency } from "@ledgerhq/live-common/account/helpers";
+import Track from "~/renderer/analytics/Track";
+import { getCurrentDevice } from "~/renderer/reducers/devices";
+import { accountsSelector } from "~/renderer/reducers/accounts";
+import { closeModal } from "~/renderer/actions/modals";
+import Stepper, { Step } from "~/renderer/components/Stepper";
+import StepConnectDevice, {
+  StepConnectDeviceFooter,
+} from "~/renderer/modals/Receive/steps/StepConnectDevice";
+import StepWarning, { StepWarningFooter } from "~/renderer/modals/Receive/steps/StepWarning";
+import StepReceiveFunds from "~/renderer/modals/Receive/steps/StepReceiveFunds";
+import type { StepId as DefaultStepId } from "~/renderer/modals/Receive/Body";
+import StepReceiveStakingFlow, {
+  StepReceiveStakingFooter,
+} from "~/renderer/modals/Receive/steps/StepReceiveStakingFlow";
+import { updateAccountWithUpdater } from "~/renderer/actions/accounts";
+import { addPendingOperation } from "@ledgerhq/coin-framework/account/pending";
+import logger from "~/renderer/logger";
+import StepAccount from "~/renderer/modals/Receive/steps/StepAccount";
+import type {
+  Data as DefaultData,
+  StepProps as DefaultStepProps,
+  OwnProps as DefaultOwnProps,
+  StateProps as DefaultStateProps,
+} from "~/renderer/modals/Receive/Body";
+import StepAssociationConfirmation, {
+  StepAssociationConfirmationFooter,
+} from "./steps/StepAssociationConfirmation";
+import { StepAccountFooter } from "./steps/StepAccountFooter";
+import StepAssociationDevice from "./steps/StepAssociationDevice";
+
+type CustomStepId = "associationDevice" | "associationConfirmation";
+
+export type StepId = DefaultStepId | CustomStepId;
+
+export type Data = DefaultData;
+
+type OwnProps = Omit<DefaultOwnProps, "stepId" | "onChangeStepId"> & {
+  stepId: StepId;
+  onChangeStepId: (a: StepId) => void;
+};
+
+type StateProps = DefaultStateProps;
+
+type Props = OwnProps & StateProps;
+
+export type StepProps = DefaultStepProps & {
+  isAssociationFlow: boolean;
+  transaction: Transaction | undefined | null;
+  optimisticOperation: Operation | undefined;
+  error: Error | undefined;
+  status: TransactionStatus;
+  signed: boolean;
+  bridgePending: boolean;
+  setSigned: (a: boolean) => void;
+  onChangeTransaction: (a: Transaction) => void;
+  onUpdateTransaction: (a: (a: Transaction) => Transaction) => void;
+  onTransactionError: (a: Error) => void;
+  onOperationBroadcasted: (a: Operation) => void;
+};
+
+type St = Step<StepId, StepProps>;
+
+const createSteps = (isAssociationFlow: boolean): Array<St> => [
+  {
+    id: "warning",
+    excludeFromBreadcrumb: true,
+    component: StepWarning,
+    footer: StepWarningFooter,
+  },
+  {
+    id: "account",
+    label: <Trans i18nKey="receive.steps.chooseAccount.title" />,
+    component: StepAccount,
+    noScroll: true,
+    footer: StepAccountFooter,
+  },
+  {
+    id: "device",
+    label: <Trans i18nKey="receive.steps.connectDevice.title" />,
+    excludeFromBreadcrumb: isAssociationFlow,
+    component: StepConnectDevice,
+    footer: StepConnectDeviceFooter,
+    onBack: ({ transitionTo }: StepProps) => transitionTo("account"),
+  },
+  {
+    id: "receive",
+    label: <Trans i18nKey="receive.steps.receiveFunds.title" />,
+    excludeFromBreadcrumb: isAssociationFlow,
+    component: StepReceiveFunds,
+  },
+  {
+    id: "associationDevice",
+    label: <Trans i18nKey="receive.steps.connectDevice.title" />,
+    excludeFromBreadcrumb: !isAssociationFlow,
+    component: StepAssociationDevice,
+    onBack: ({ transitionTo }: StepProps) => transitionTo("account"),
+  },
+  {
+    id: "associationConfirmation",
+    label: (
+      <Trans i18nKey="hedera.receiveWithAssociation.steps.associationConfirmation.breadcrumbTitle" />
+    ),
+    excludeFromBreadcrumb: !isAssociationFlow,
+    component: StepAssociationConfirmation,
+    footer: StepAssociationConfirmationFooter,
+  },
+  {
+    id: "stakingFlow",
+    excludeFromBreadcrumb: true,
+    component: StepReceiveStakingFlow,
+    footer: StepReceiveStakingFooter,
+  },
+];
+
+const mapStateToProps = createStructuredSelector({
+  device: getCurrentDevice,
+  accounts: accountsSelector,
+});
+
+const mapDispatchToProps = {
+  closeModal,
+};
+
+const Body = ({
+  t,
+  stepId,
+  device,
+  accounts,
+  closeModal,
+  onChangeStepId,
+  isAddressVerified,
+  verifyAddressError,
+  onChangeAddressVerified,
+  params,
+}: Props) => {
+  const [optimisticOperation, setOptimisticOperation] = useState<Operation | null>(null);
+  const [transactionError, setTransactionError] = useState<Error | null>(null);
+  const [signed, setSigned] = useState(false);
+  const [account, setAccount] = useState(() => (params && params.account) || accounts[0]);
+  const [parentAccount, setParentAccount] = useState(() => params && params.parentAccount);
+  const [disabledSteps, setDisabledSteps] = useState<number[]>([]);
+  const [token, setToken] = useState<TokenCurrency | null>(null);
+  const [hideBreadcrumb, setHideBreadcrumb] = useState<boolean | undefined>(false);
+  const [title, setTitle] = useState("");
+  const dispatch = useDispatch();
+
+  const receiveTokenMode = !!params.receiveTokenMode;
+  const isAssociationFlow = receiveTokenMode ? isTokenAssociationRequired(account, token) : false;
+  const [steps, setSteps] = useState(() => createSteps(isAssociationFlow));
+
+  const currency = getAccountCurrency(account);
+  const currencyName = currency ? currency.name : undefined;
+
+  const {
+    transaction,
+    status,
+    bridgeError,
+    bridgePending,
+    updateTransaction,
+    setAccount: updateTransactionAccount,
+  } = useBridgeTransaction(() => {
+    invariant(account, "hedera: account is required");
+
+    const bridge = getAccountBridge(account, parentAccount);
+    const transaction = bridge.createTransaction(account);
+
+    return {
+      account,
+      parentAccount,
+      transaction,
+    };
+  });
+
+  const getTransactionProperties = useCallback(
+    (token: TokenCurrency | undefined | null): Transaction["properties"] | null => {
+      if (!token) {
+        return null;
+      }
+
+      return {
+        name: "tokenAssociate",
+        token,
+      };
+    },
+    [],
+  );
+
+  const handleChangeAccount = useCallback(
+    (account: Account | TokenAccount, parentAccount?: Account | null) => {
+      setAccount(account);
+      setParentAccount(parentAccount);
+
+      const transactionProperties = getTransactionProperties(token);
+      updateTransactionAccount(account, parentAccount);
+      updateTransaction(prev => ({ ...prev, properties: transactionProperties }));
+    },
+    [
+      token,
+      updateTransaction,
+      updateTransactionAccount,
+      getTransactionProperties,
+      setParentAccount,
+      setAccount,
+    ],
+  );
+
+  const handleChangeToken = useCallback(
+    (token?: TokenCurrency | null) => {
+      setToken(token ?? null);
+
+      const transactionProperties = getTransactionProperties(token);
+      updateTransaction(prev => ({ ...prev, properties: transactionProperties }));
+    },
+    [getTransactionProperties, updateTransaction],
+  );
+
+  const handleCloseModal = useCallback(() => {
+    closeModal("MODAL_HEDERA_RECEIVE_WITH_ASSOCIATION");
+  }, [closeModal]);
+
+  const handleStepChange = useCallback(
+    (e: Step<StepId, StepProps>) => onChangeStepId(e.id),
+    [onChangeStepId],
+  );
+
+  const handleResetSkip = useCallback(() => {
+    setDisabledSteps([]);
+  }, [setDisabledSteps]);
+
+  const handleRetry = useCallback(() => {
+    onChangeAddressVerified(null, null);
+    setTransactionError(null);
+    onChangeStepId("account");
+  }, [onChangeStepId, onChangeAddressVerified]);
+
+  const handleSkipConfirm = useCallback(() => {
+    const connectStepIndex = steps.findIndex(
+      step => step.id === "device" || step.id === "associationDevice",
+    );
+    if (connectStepIndex > -1) {
+      onChangeAddressVerified(false, null);
+      setDisabledSteps([connectStepIndex]);
+    }
+    onChangeStepId("receive");
+  }, [onChangeAddressVerified, setDisabledSteps, steps, onChangeStepId]);
+
+  const handleTransactionError = useCallback((error: Error) => {
+    if (!(error instanceof UserRefusedOnDevice)) {
+      logger.critical(error);
+    }
+    setTransactionError(error);
+  }, []);
+
+  const handleOperationBroadcasted = useCallback(
+    (optimisticOperation: Operation) => {
+      if (!account) return;
+      dispatch(
+        updateAccountWithUpdater(account.id, account =>
+          addPendingOperation(account, optimisticOperation),
+        ),
+      );
+      setOptimisticOperation(optimisticOperation);
+      setTransactionError(null);
+    },
+    [account, dispatch],
+  );
+
+  useEffect(() => {
+    const stepId =
+      params && params.startWithWarning ? "warning" : params.receiveTokenMode ? "account" : null;
+    if (stepId) onChangeStepId(stepId);
+  }, [onChangeStepId, params]);
+
+  useEffect(() => {
+    if (!account) {
+      if (params && params.account) {
+        handleChangeAccount(params.account, params?.parentAccount);
+      } else {
+        handleChangeAccount(accounts[0]);
+      }
+    }
+  }, [accounts, account, params, handleChangeAccount]);
+
+  useEffect(() => {
+    const currentStep = steps.find(step => step.id === stepId);
+
+    if (stepId !== "associationDevice") {
+      setHideBreadcrumb(currentStep?.excludeFromBreadcrumb);
+    }
+
+    switch (stepId) {
+      case "warning":
+        setTitle(t("common.information"));
+        break;
+      case "associationDevice":
+        setTitle(t("hedera.receiveWithAssociation.steps.associationConfirmation.title"));
+        break;
+      case "stakingFlow":
+        setTitle(
+          t("receive.steps.staking.title", {
+            currencyName: currency.name,
+          }),
+        );
+        break;
+      default:
+        setTitle(t("receive.title"));
+    }
+  }, [steps, stepId, t, currency.name]);
+
+  useEffect(() => {
+    const updatedSteps = createSteps(isAssociationFlow);
+    setSteps(updatedSteps);
+  }, [isAssociationFlow]);
+
+  const error = transactionError || bridgeError;
+  const errorSteps = [];
+  if (transactionError) {
+    errorSteps.push(2);
+  } else if (bridgeError) {
+    errorSteps.push(0);
+  }
+
+  const stepperProps = {
+    title,
+    device,
+    account,
+    parentAccount,
+    eventType: params.eventType,
+    stepId,
+    steps,
+    error,
+    errorSteps,
+    disabledSteps,
+    receiveTokenMode,
+    receiveNFTMode: !!params.receiveNFTMode,
+    receiveOrdinalMode: !!params.receiveOrdinalMode,
+    hideBreadcrumb,
+    token,
+    isAddressVerified,
+    verifyAddressError,
+    isAssociationFlow,
+    optimisticOperation,
+    transaction,
+    status,
+    bridgePending,
+    signed,
+    setSigned,
+    onOperationBroadcasted: handleOperationBroadcasted,
+    onUpdateTransaction: updateTransaction,
+    onTransactionError: handleTransactionError,
+    closeModal: handleCloseModal,
+    onRetry: handleRetry,
+    onSkipConfirm: handleSkipConfirm,
+    onResetSkip: handleResetSkip,
+    onChangeAccount: handleChangeAccount,
+    onChangeToken: handleChangeToken,
+    onChangeAddressVerified,
+    onStepChange: handleStepChange,
+    onClose: handleCloseModal,
+    currencyName,
+    isFromPostOnboardingEntryPoint: !!params.isFromPostOnboardingEntryPoint,
+  };
+
+  return (
+    <Stepper {...stepperProps}>
+      <SyncSkipUnderPriority priority={100} />
+      <Track onUnmount event="CloseModalReceiveWithAssociation" />
+    </Stepper>
+  );
+};
+const C = compose(
+  connect(mapStateToProps, mapDispatchToProps),
+  withTranslation(),
+)(Body) as React.ComponentType<OwnProps>;
+export default C;
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/index.tsx b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/index.tsx
new file mode 100644
index 00000000000..715e4e39237
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/index.tsx
@@ -0,0 +1,110 @@
+import React, { useState, useCallback, useEffect } from "react";
+import logger from "~/renderer/logger";
+import Modal from "~/renderer/components/Modal";
+import { useDispatch, useSelector } from "react-redux";
+import { accountsSelector } from "~/renderer/reducers/accounts";
+import { openModal, closeModal } from "~/renderer/actions/modals";
+import { useTrackReceiveFlow } from "~/renderer/analytics/hooks/useTrackReceiveFlow";
+import { trackingEnabledSelector } from "~/renderer/reducers/settings";
+import { getCurrentDevice } from "~/renderer/reducers/devices";
+import { HOOKS_TRACKING_LOCATIONS } from "~/renderer/analytics/hooks/variables";
+import type { StepId } from "./Body";
+import Body from "./Body";
+
+type State = {
+  stepId: StepId;
+  isAddressVerified: boolean | undefined | null;
+  verifyAddressError: Error | undefined | null;
+};
+
+const INITIAL_STATE = {
+  stepId: "account" as StepId,
+  isAddressVerified: null,
+  verifyAddressError: null,
+};
+
+const ReceiveWithAssociationModal = () => {
+  const [state, setState] = useState<State>(INITIAL_STATE);
+  const device = useSelector(getCurrentDevice);
+  const dispatch = useDispatch();
+  // Making sure at least one account exists, if not, redirecting to the add account modal
+  const accounts = useSelector(accountsSelector);
+
+  const { stepId, isAddressVerified, verifyAddressError } = state;
+
+  useTrackReceiveFlow({
+    location: HOOKS_TRACKING_LOCATIONS.receiveModal,
+    device,
+    verifyAddressError,
+    isTrackingEnabled: useSelector(trackingEnabledSelector),
+  });
+
+  const setStepId = useCallback((newStepId: State["stepId"]) => {
+    setState(prevState => ({ ...prevState, stepId: newStepId }));
+  }, []);
+
+  const setIsAddressVerified = (newIsAddressVerified: State["isAddressVerified"]) => {
+    setState(prevState => ({ ...prevState, isAddressVerified: newIsAddressVerified }));
+  };
+
+  const setVerifyAddressError = (newVerifyAddressError: State["verifyAddressError"]) => {
+    setState(prevState => ({ ...prevState, verifyAddressError: newVerifyAddressError }));
+  };
+
+  const handleReset = () => {
+    setStepId(INITIAL_STATE.stepId);
+    setIsAddressVerified(INITIAL_STATE.isAddressVerified);
+    setVerifyAddressError(INITIAL_STATE.verifyAddressError);
+  };
+
+  const handleChangeAddressVerified = (isAddressVerified?: boolean | null, err?: Error | null) => {
+    if (err && err.name !== "UserRefusedAddress") {
+      logger.critical(err);
+    }
+    setIsAddressVerified(isAddressVerified);
+    setVerifyAddressError(err);
+  };
+
+  const hasAccounts = !!accounts.length;
+
+  const openAddAccounts = useCallback(() => {
+    dispatch(closeModal("MODAL_HEDERA_RECEIVE_WITH_ASSOCIATION"));
+    dispatch(
+      openModal("MODAL_ADD_ACCOUNTS", {
+        currency: null,
+      }),
+    );
+  }, [dispatch]);
+
+  useEffect(() => {
+    if (!hasAccounts) {
+      openAddAccounts();
+    }
+  }, [hasAccounts, openAddAccounts]);
+
+  if (!hasAccounts) return null;
+
+  const isModalLocked = stepId === "receive" && isAddressVerified === null;
+
+  return (
+    <Modal
+      name="MODAL_HEDERA_RECEIVE_WITH_ASSOCIATION"
+      centered
+      onHide={handleReset}
+      preventBackdropClick={isModalLocked}
+      render={({ data, onClose }) => (
+        <Body
+          onClose={onClose}
+          stepId={stepId}
+          isAddressVerified={isAddressVerified}
+          verifyAddressError={verifyAddressError}
+          onChangeAddressVerified={handleChangeAddressVerified}
+          onChangeStepId={setStepId}
+          params={data || {}}
+        />
+      )}
+    />
+  );
+};
+
+export default ReceiveWithAssociationModal;
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/steps/StepAccountFooter.tsx b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/steps/StepAccountFooter.tsx
new file mode 100644
index 00000000000..eb4fc8f6b8a
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/steps/StepAccountFooter.tsx
@@ -0,0 +1,36 @@
+import React from "react";
+import { Trans } from "react-i18next";
+import { getReceiveFlowError } from "@ledgerhq/live-common/account/index";
+
+import Button from "~/renderer/components/Button";
+import type { StepId, StepProps } from "../Body";
+
+export function StepAccountFooter({
+  transitionTo,
+  isAssociationFlow,
+  receiveTokenMode,
+  token,
+  account,
+  parentAccount,
+  status,
+}: StepProps) {
+  const error = account ? getReceiveFlowError(account, parentAccount) : null;
+  const isMissingToken = receiveTokenMode && !token;
+  const isTransactionError = Object.keys(status.errors).length > 0;
+
+  const redirectToDeviceStep = () => {
+    const deviceStepId: StepId = isAssociationFlow ? "associationDevice" : "device";
+    transitionTo(deviceStepId);
+  };
+
+  return (
+    <Button
+      primary
+      data-testid="modal-continue-button"
+      disabled={!account || isMissingToken || !!error || isTransactionError}
+      onClick={redirectToDeviceStep}
+    >
+      <Trans i18nKey="common.continue" />
+    </Button>
+  );
+}
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/steps/StepAssociationConfirmation.tsx b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/steps/StepAssociationConfirmation.tsx
new file mode 100644
index 00000000000..1b0418f3dbe
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/steps/StepAssociationConfirmation.tsx
@@ -0,0 +1,129 @@
+import React from "react";
+import { Trans } from "react-i18next";
+import styled from "styled-components";
+import { SyncOneAccountOnMount } from "@ledgerhq/live-common/bridge/react/index";
+import Box from "~/renderer/components/Box";
+import BroadcastErrorDisclaimer from "~/renderer/components/BroadcastErrorDisclaimer";
+import Button from "~/renderer/components/Button";
+import ErrorDisplay from "~/renderer/components/ErrorDisplay";
+import RetryButton from "~/renderer/components/RetryButton";
+import SuccessDisplay from "~/renderer/components/SuccessDisplay";
+import TrackPage from "~/renderer/analytics/TrackPage";
+import { setDrawer } from "~/renderer/drawers/Provider";
+import { OperationDetails } from "~/renderer/drawers/OperationDetails";
+import type { StepProps } from "../Body";
+
+const Container = styled(Box).attrs<{
+  shouldSpace?: boolean;
+}>(() => ({
+  alignItems: "center",
+  grow: true,
+  color: "palette.text.shade100",
+}))<{
+  shouldSpace?: boolean;
+}>`
+  justify-content: ${p => (p.shouldSpace ? "space-between" : "center")};
+`;
+
+function StepAssociationConfirmation({
+  transaction,
+  optimisticOperation,
+  error,
+  signed,
+}: StepProps) {
+  if (optimisticOperation) {
+    const tokenName = transaction?.properties?.token.name ?? "token";
+
+    return (
+      <Container>
+        <TrackPage
+          category="Hedera Token Association Flow"
+          name="Step Confirmed"
+          flow="tokenAssociation"
+        />
+        <SyncOneAccountOnMount priority={10} accountId={optimisticOperation.accountId} />
+        <SuccessDisplay
+          title={
+            <Trans i18nKey="hedera.receiveWithAssociation.steps.associationConfirmation.success.title" />
+          }
+          description={
+            <Trans
+              i18nKey="hedera.receiveWithAssociation.steps.associationConfirmation.success.description"
+              values={{ tokenName }}
+            />
+          }
+        />
+      </Container>
+    );
+  }
+
+  if (error) {
+    return (
+      <Container shouldSpace={signed}>
+        <TrackPage
+          category="Hedera Token Association Flow"
+          name="Step Confirmation Error"
+          flow="tokenAssociation"
+        />
+        {signed ? (
+          <BroadcastErrorDisclaimer
+            title={
+              <Trans i18nKey="hedera.receiveWithAssociation.steps.associationConfirmation.broadcastError" />
+            }
+          />
+        ) : null}
+        <ErrorDisplay error={error} withExportLogs />
+      </Container>
+    );
+  }
+
+  return null;
+}
+
+export function StepAssociationConfirmationFooter({
+  account,
+  parentAccount,
+  optimisticOperation,
+  error,
+  onRetry,
+  closeModal,
+  onClose,
+}: StepProps) {
+  const concernedOperation = optimisticOperation
+    ? optimisticOperation.subOperations && optimisticOperation.subOperations.length > 0
+      ? optimisticOperation.subOperations[0]
+      : optimisticOperation
+    : null;
+
+  return (
+    <Box horizontal alignItems="right">
+      <Button data-testid="modal-close-button" ml={2} onClick={onClose}>
+        <Trans i18nKey="common.close" />
+      </Button>
+      {concernedOperation ? (
+        <Button
+          ml={2}
+          id={"hedera-token-association-confirmation-opc-button"}
+          event="Hedera Token Association Flow View OpD Clicked"
+          onClick={() => {
+            closeModal();
+            if (account && concernedOperation) {
+              setDrawer(OperationDetails, {
+                operationId: concernedOperation.id,
+                accountId: account.id,
+                parentId: (parentAccount && parentAccount.id) || undefined,
+              });
+            }
+          }}
+          primary
+        >
+          <Trans i18nKey="hedera.receiveWithAssociation.steps.associationConfirmation.success.cta" />
+        </Button>
+      ) : error ? (
+        <RetryButton primary ml={2} onClick={onRetry} />
+      ) : null}
+    </Box>
+  );
+}
+
+export default StepAssociationConfirmation;
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/steps/StepAssociationDevice.tsx b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/steps/StepAssociationDevice.tsx
new file mode 100644
index 00000000000..83bfa15c36a
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/ReceiveWithAssociationModal/steps/StepAssociationDevice.tsx
@@ -0,0 +1,98 @@
+import React, { useMemo } from "react";
+import { Trans } from "react-i18next";
+import { useSelector } from "react-redux";
+import { useBroadcast } from "@ledgerhq/live-common/hooks/useBroadcast";
+import type { Device } from "@ledgerhq/live-common/hw/actions/types";
+import type { SignedOperation } from "@ledgerhq/types-live";
+import DeviceAction from "~/renderer/components/DeviceAction";
+import { HOOKS_TRACKING_LOCATIONS } from "~/renderer/analytics/hooks/variables";
+import StepProgress from "~/renderer/components/StepProgress";
+import { DeviceBlocker } from "~/renderer/components/DeviceAction/DeviceBlocker";
+import { useTransactionAction } from "~/renderer/hooks/useConnectAppAction";
+import { mevProtectionSelector } from "~/renderer/reducers/settings";
+import type { StepProps } from "../Body";
+
+const Result = (
+  props:
+    | {
+        signedOperation: SignedOperation | undefined | null;
+        device: Device;
+      }
+    | {
+        transactionSignError: Error;
+      },
+) => {
+  if (!("signedOperation" in props)) return null;
+  return (
+    <StepProgress>
+      <DeviceBlocker />
+      <Trans i18nKey="hedera.receiveWithAssociation.steps.associationConfirmation.pending.title" />
+    </StepProgress>
+  );
+};
+
+export default function StepAssociationDevice(props: StepProps) {
+  const {
+    token,
+    account,
+    transaction,
+    status,
+    parentAccount,
+    transitionTo,
+    setSigned,
+    onOperationBroadcasted,
+    onTransactionError,
+  } = props;
+  const mevProtected = useSelector(mevProtectionSelector);
+  const action = useTransactionAction();
+  const broadcastConfig = useMemo(() => ({ mevProtected }), [mevProtected]);
+  const broadcast = useBroadcast({ account, parentAccount, broadcastConfig });
+
+  const tokenCurrency = (account && account.type === "TokenAccount" && account.token) || token;
+
+  const request = useMemo(
+    () => ({
+      tokenCurrency,
+      parentAccount,
+      account,
+      transaction,
+      status,
+    }),
+    [tokenCurrency, parentAccount, account, transaction, status],
+  );
+
+  if (!transaction || !account) {
+    return null;
+  }
+
+  return (
+    <DeviceAction
+      action={action}
+      // @ts-expect-error This type is not compatible with the one expected by the action
+      request={request}
+      Result={Result}
+      onResult={result => {
+        if ("signedOperation" in result) {
+          const { signedOperation } = result;
+          setSigned(true);
+          broadcast(signedOperation).then(
+            operation => {
+              onOperationBroadcasted(operation);
+              transitionTo("associationConfirmation");
+            },
+            error => {
+              onTransactionError(error);
+              transitionTo("associationConfirmation");
+            },
+          );
+        } else if ("transactionSignError" in result) {
+          const { transactionSignError } = result;
+          onTransactionError(transactionSignError);
+          transitionTo("associationConfirmation");
+        }
+      }}
+      analyticsPropertyFlow="tokenAssociation"
+      location={HOOKS_TRACKING_LOCATIONS.receiveModal}
+    />
+  );
+}
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/StepReceiveAccountCustomAlert.tsx b/apps/ledger-live-desktop/src/renderer/families/hedera/StepReceiveAccountCustomAlert.tsx
new file mode 100644
index 00000000000..1f1e6338da1
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/StepReceiveAccountCustomAlert.tsx
@@ -0,0 +1,115 @@
+import React from "react";
+import { Trans } from "react-i18next";
+import { useDispatch } from "react-redux";
+import styled from "styled-components";
+import type { AccountLike } from "@ledgerhq/types-live";
+import {
+  isTokenAssociationRequired,
+  isAutoTokenAssociationEnabled,
+} from "@ledgerhq/live-common/families/hedera/logic";
+import { isTokenAccount } from "@ledgerhq/coin-framework/account/helpers";
+import { Link } from "@ledgerhq/react-ui";
+import { urls } from "~/config/urls";
+import { openModal } from "~/renderer/actions/modals";
+import Alert from "~/renderer/components/Alert";
+import Box from "~/renderer/components/Box";
+import Text from "~/renderer/components/Text";
+import type { StepProps as ReceiveStepProps } from "~/renderer/modals/Receive/Body";
+import TranslatedError from "~/renderer/components/TranslatedError";
+import type { StepProps as ReceiveWithAssociationStepProps } from "./ReceiveWithAssociationModal/Body";
+
+type Props = (ReceiveStepProps | ReceiveWithAssociationStepProps) & {
+  account: AccountLike;
+};
+
+const Container = styled.div`
+  margin-top: 16px;
+`;
+
+const ErrorBox = styled(Box)`
+  margin-bottom: 16px;
+  color: ${p => p.theme.colors.pearl};
+`;
+
+const AssociationPrerequisiteAlert = ({ account, closeModal }: Props) => {
+  const dispatch = useDispatch();
+
+  const triggerAssociate = () => {
+    closeModal();
+    dispatch(
+      openModal("MODAL_HEDERA_RECEIVE_WITH_ASSOCIATION", { account, receiveTokenMode: true }),
+    );
+  };
+
+  return (
+    <Container>
+      <Alert
+        type="primary"
+        learnMoreUrl={urls.hedera.tokenAssociation}
+        learnMoreLabel={
+          <Trans i18nKey="hedera.receive.warnings.associationPrerequisite.learnMore" />
+        }
+      >
+        <Trans i18nKey="hedera.receive.warnings.associationPrerequisite.text">
+          <Link onClick={triggerAssociate} color="inherit" textProps={{ fontWeight: "medium" }} />
+        </Trans>
+      </Alert>
+    </Container>
+  );
+};
+
+const AssociationInsufficientFundsError = (props: Props) => {
+  const isReceiveWithAssociationModal = "transaction" in props;
+
+  if (!isReceiveWithAssociationModal) {
+    return null;
+  }
+
+  const { insufficientAssociateBalance } = props.status.errors;
+
+  if (!insufficientAssociateBalance) {
+    return null;
+  }
+
+  return (
+    <ErrorBox>
+      <Text fontSize={12} fontWeight="medium">
+        <TranslatedError error={insufficientAssociateBalance} field="description" noLink />
+      </Text>
+    </ErrorBox>
+  );
+};
+
+const AssociationRequiredAlert = () => {
+  return (
+    <Alert
+      type="warning"
+      learnMoreUrl={urls.hedera.tokenAssociation}
+      learnMoreLabel={<Trans i18nKey="hedera.receive.warnings.associationRequired.learnMore" />}
+    >
+      <Trans i18nKey="hedera.receive.warnings.associationRequired.text" />
+    </Alert>
+  );
+};
+
+const StepReceiveAccountCustomAlert = (props: Props) => {
+  const { account, token, receiveTokenMode } = props;
+  const isAssociationFlow = receiveTokenMode ? isTokenAssociationRequired(account, token) : false;
+
+  if (!receiveTokenMode && !isTokenAccount(account) && !isAutoTokenAssociationEnabled(account)) {
+    return <AssociationPrerequisiteAlert {...props} />;
+  }
+
+  if (token && isAssociationFlow) {
+    return (
+      <Container>
+        <AssociationInsufficientFundsError {...props} />
+        <AssociationRequiredAlert />
+      </Container>
+    );
+  }
+
+  return null;
+};
+
+export default StepReceiveAccountCustomAlert;
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/StepRecipientCustomAlert.tsx b/apps/ledger-live-desktop/src/renderer/families/hedera/StepRecipientCustomAlert.tsx
new file mode 100644
index 00000000000..4aa96f24169
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/StepRecipientCustomAlert.tsx
@@ -0,0 +1,56 @@
+import React from "react";
+import { Trans } from "react-i18next";
+import type { TransactionStatus } from "@ledgerhq/live-common/generated/types";
+import { urls } from "~/config/urls";
+import Alert from "~/renderer/components/Alert";
+import TranslatedError from "~/renderer/components/TranslatedError";
+
+interface AlertProps {
+  error: Error;
+}
+
+const MissingAssociationAlert = ({ error }: AlertProps) => {
+  return (
+    <Alert
+      type="warning"
+      mt={4}
+      learnMoreUrl={urls.hedera.tokenAssociation}
+      learnMoreLabel={<Trans i18nKey="hedera.send.warnings.missingAssociation.learnMore" />}
+    >
+      <TranslatedError error={error} field="description" />
+    </Alert>
+  );
+};
+
+const UnverifiedAssociationAlert = ({ error }: AlertProps) => {
+  return (
+    <Alert
+      type="warning"
+      mt={4}
+      learnMoreUrl={urls.hedera.tokenAssociation}
+      learnMoreLabel={<Trans i18nKey="hedera.send.warnings.unverifiedAssociation.learnMore" />}
+    >
+      <TranslatedError error={error} field="description" />
+    </Alert>
+  );
+};
+
+interface Props {
+  status: TransactionStatus;
+}
+
+const StepRecipientCustomAlert = ({ status }: Props) => {
+  const { missingAssociation, unverifiedAssociation } = status.warnings;
+
+  if (missingAssociation) {
+    return <MissingAssociationAlert error={missingAssociation} />;
+  }
+
+  if (unverifiedAssociation) {
+    return <UnverifiedAssociationAlert error={unverifiedAssociation} />;
+  }
+
+  return null;
+};
+
+export default StepRecipientCustomAlert;
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/TokenList.tsx b/apps/ledger-live-desktop/src/renderer/families/hedera/TokenList.tsx
new file mode 100644
index 00000000000..90b24b6a2ee
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/TokenList.tsx
@@ -0,0 +1,31 @@
+import React from "react";
+import { useTranslation } from "react-i18next";
+import { useDispatch } from "react-redux";
+import type { Account } from "@ledgerhq/types-live";
+import { openModal } from "~/renderer/actions/modals";
+import Box from "~/renderer/components/Box";
+import IconPlus from "~/renderer/icons/Plus";
+import Button from "~/renderer/components/Button";
+
+const ReceiveButton = ({ account }: { account: Account }) => {
+  const { t } = useTranslation();
+  const dispatch = useDispatch();
+  const onReceiveClick = () => {
+    dispatch(
+      openModal("MODAL_HEDERA_RECEIVE_WITH_ASSOCIATION", { account, receiveTokenMode: true }),
+    );
+  };
+
+  return (
+    <Button small primary onClick={onReceiveClick}>
+      <Box horizontal flow={1} alignItems="center">
+        <IconPlus size={12} />
+        <Box>{t("tokensList.cta")}</Box>
+      </Box>
+    </Button>
+  );
+};
+
+export default {
+  ReceiveButton,
+};
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/index.ts b/apps/ledger-live-desktop/src/renderer/families/hedera/index.ts
index e297c7ca9d8..f2f529fb596 100644
--- a/apps/ledger-live-desktop/src/renderer/families/hedera/index.ts
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/index.ts
@@ -1,16 +1,28 @@
-import { getTransactionExplorer } from "@ledgerhq/live-common/families/hedera/logic";
+import {
+  getTransactionExplorer,
+  sendRecipientCanNext,
+} from "@ledgerhq/live-common/families/hedera/logic";
 import AccountSubHeader from "./AccountSubHeader";
 import NoAssociatedAccounts from "./NoAssociatedAccounts";
 import sendRecipientFields from "./SendRecipientFields";
+import StepReceiveAccountCustomAlert from "./StepReceiveAccountCustomAlert";
+import StepRecipientCustomAlert from "./StepRecipientCustomAlert";
 import StepReceiveFunds from "./StepReceiveFunds";
 import { HederaFamily } from "./types";
+import tokenList from "./TokenList";
+import operationDetails from "./OperationDetails";
 
 const family: HederaFamily = {
-  AccountSubHeader,
   sendRecipientFields,
+  tokenList,
+  operationDetails,
+  AccountSubHeader,
+  StepReceiveAccountCustomAlert,
   StepReceiveFunds,
+  StepRecipientCustomAlert,
   NoAssociatedAccounts,
   getTransactionExplorer,
+  sendRecipientCanNext,
 };
 
 export default family;
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/modals.ts b/apps/ledger-live-desktop/src/renderer/families/hedera/modals.ts
new file mode 100644
index 00000000000..cb05428e151
--- /dev/null
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/modals.ts
@@ -0,0 +1,13 @@
+import type { MakeModalsType } from "~/renderer/modals/types";
+import { Data as ReceiveModalProps } from "./ReceiveWithAssociationModal/Body";
+import MODAL_HEDERA_RECEIVE_WITH_ASSOCIATION from "./ReceiveWithAssociationModal";
+
+export type ModalsData = {
+  MODAL_HEDERA_RECEIVE_WITH_ASSOCIATION: ReceiveModalProps;
+};
+
+const modals: MakeModalsType<ModalsData> = {
+  MODAL_HEDERA_RECEIVE_WITH_ASSOCIATION,
+};
+
+export default modals;
diff --git a/apps/ledger-live-desktop/src/renderer/families/hedera/types.ts b/apps/ledger-live-desktop/src/renderer/families/hedera/types.ts
index d94767b5c09..d7420c5b538 100644
--- a/apps/ledger-live-desktop/src/renderer/families/hedera/types.ts
+++ b/apps/ledger-live-desktop/src/renderer/families/hedera/types.ts
@@ -1,9 +1,18 @@
-import { Transaction, TransactionStatus } from "@ledgerhq/live-common/families/hedera/types";
+import type {
+  HederaAccount,
+  HederaOperation,
+  Transaction,
+  TransactionStatus,
+} from "@ledgerhq/live-common/families/hedera/types";
+import type { Account } from "@ledgerhq/types-live";
+import type { LLDCoinFamily } from "../types";
 
-import { Account, Operation } from "@ledgerhq/types-live";
-import { LLDCoinFamily } from "../types";
-
-export type HederaFamily = LLDCoinFamily<Account, Transaction, TransactionStatus, Operation>;
+export type HederaFamily = LLDCoinFamily<
+  HederaAccount,
+  Transaction,
+  TransactionStatus,
+  HederaOperation
+>;
 
 export type SendAmountProps = {
   account: Account;
diff --git a/apps/ledger-live-desktop/src/renderer/families/types.ts b/apps/ledger-live-desktop/src/renderer/families/types.ts
index 667772028ef..6e723b72feb 100644
--- a/apps/ledger-live-desktop/src/renderer/families/types.ts
+++ b/apps/ledger-live-desktop/src/renderer/families/types.ts
@@ -20,12 +20,18 @@ import {
   TokenAccount,
   TransactionCommon,
   MessageProperties,
+  AccountLike,
 } from "@ledgerhq/types-live";
 // FIXME: ideally we need to have <A,T,TS> parametric version of StepProps
 import { StepProps as SendStepProps } from "../modals/Send/types";
 import { StepProps as ReceiveStepProps } from "../modals/Receive/Body";
 import { StepProps as AddAccountsStepProps } from "../modals/AddAccounts";
 
+export type AddressCellProps<O extends Operation> = {
+  operation: O;
+  currency: CryptoCurrency;
+};
+
 export type AmountCellExtraProps<O extends Operation> = {
   operation: O;
   unit: Unit;
@@ -56,6 +62,12 @@ export type AmountTooltipProps<O extends Operation> = {
   amount: BigNumber;
 };
 
+export type OperationDetailsPostAccountSectionProps<A extends Account, O extends Operation> = {
+  operation: O;
+  account: A;
+  type: OperationType;
+};
+
 export type OperationDetailsExtraProps<A extends Account, O extends Operation> = {
   operation: O;
   account: A;
@@ -83,6 +95,11 @@ export type LLDCoinFamily<
   O extends Operation,
 > = {
   operationDetails?: {
+    /**
+     * Replace address cell
+     */
+    addressCell?: Partial<Record<OperationType, React.ComponentType<AddressCellProps<O>>>>;
+
     /**
      * Cell amount before the amount cell in operation row
      */
@@ -115,10 +132,22 @@ export type LLDCoinFamily<
      */
     getURLFeesInfo?: (_: { op: O; currencyId: string }) => string | null | undefined;
 
+    /**
+     * Add custom component after the Account section in operation details drawer
+     */
+    OperationDetailsPostAccountSection?: React.ComponentType<
+      OperationDetailsPostAccountSectionProps<A, O>
+    >;
+
     /**
      * Add extra info
      */
     OperationDetailsExtra?: React.ComponentType<OperationDetailsExtraProps<A, O>>;
+
+    /**
+     * Add custom component at the end in operation details drawer
+     */
+    OperationDetailsPostAlert?: React.ComponentType<OperationDetailsExtraProps<A, O>>;
   };
 
   accountActions?: {
@@ -241,6 +270,11 @@ export type LLDCoinFamily<
     fields?: string[];
   };
 
+  /**
+   * Allow to disable "Continue" button on Recipient step in Send modal
+   */
+  sendRecipientCanNext?: (status: TS) => boolean;
+
   /**
    *  One time modal that is trigger only one time on a account that never send
    */
@@ -279,6 +313,11 @@ export type LLDCoinFamily<
     }>;
   };
 
+  /**
+   * Allow to add component below the token select on Account step in Receive modal
+   */
+  StepReceiveAccountCustomAlert?: React.ComponentType<ReceiveStepProps & { account: AccountLike }>;
+
   /**
    * Change Receive funds with this component (example: Hedera)
    */
@@ -294,6 +333,11 @@ export type LLDCoinFamily<
    */
   StepSummaryNetworkFeesRow?: React.ComponentType<SummaryNetworkFeesRowProps>;
 
+  /**
+   * Allow to add specific component in Send modal below the recipient address
+   */
+  StepRecipientCustomAlert?: React.ComponentType<{ status: TS }>;
+
   /**
    * Allow to add specific component in Send modal at the end of Summary Step
    */
diff --git a/apps/ledger-live-desktop/src/renderer/modals/Receive/Body.tsx b/apps/ledger-live-desktop/src/renderer/modals/Receive/Body.tsx
index 290f48234df..723b0132ecb 100644
--- a/apps/ledger-live-desktop/src/renderer/modals/Receive/Body.tsx
+++ b/apps/ledger-live-desktop/src/renderer/modals/Receive/Body.tsx
@@ -33,7 +33,7 @@ export type Data = {
   isFromPostOnboardingEntryPoint?: boolean;
 };
 
-type OwnProps = {
+export type OwnProps = {
   stepId: StepId;
   onClose?: () => void | undefined;
   onChangeStepId: (a: StepId) => void;
@@ -42,7 +42,7 @@ type OwnProps = {
   onChangeAddressVerified: (isAddressVerified?: boolean | null, err?: Error | null) => void;
   params: Data;
 };
-type StateProps = {
+export type StateProps = {
   t: TFunction;
   accounts: Account[];
   device: Device | undefined | null;
diff --git a/apps/ledger-live-desktop/src/renderer/modals/Receive/steps/StepAccount.tsx b/apps/ledger-live-desktop/src/renderer/modals/Receive/steps/StepAccount.tsx
index ab661b81cb3..6ddfc8b150e 100644
--- a/apps/ledger-live-desktop/src/renderer/modals/Receive/steps/StepAccount.tsx
+++ b/apps/ledger-live-desktop/src/renderer/modals/Receive/steps/StepAccount.tsx
@@ -11,6 +11,7 @@ import {
   listTokensForCryptoCurrency,
   listTokenTypesForCryptoCurrency,
 } from "@ledgerhq/live-common/currencies/index";
+import { supportLinkByTokenType } from "~/config/urls";
 import TrackPage from "~/renderer/analytics/TrackPage";
 import Box from "~/renderer/components/Box";
 import Label from "~/renderer/components/Label";
@@ -20,8 +21,8 @@ import SelectCurrency from "~/renderer/components/SelectCurrency";
 import CurrencyDownStatusAlert from "~/renderer/components/CurrencyDownStatusAlert";
 import ErrorBanner from "~/renderer/components/ErrorBanner";
 import Alert from "~/renderer/components/Alert";
+import { getLLDCoinFamily } from "~/renderer/families";
 import { StepProps } from "../Body";
-import { supportLinkByTokenType } from "~/config/urls";
 
 type OnChangeAccount = (account?: AccountLike | null, tokenAccount?: Account | null) => void;
 const AccountSelection = ({
@@ -86,15 +87,16 @@ const TokenSelection = ({
     </>
   );
 };
-export default function StepAccount({
-  token,
-  account,
-  parentAccount,
-  receiveTokenMode,
-  onChangeAccount,
-  onChangeToken,
-  eventType,
-}: StepProps) {
+export default function StepAccount(props: StepProps) {
+  const {
+    token,
+    account,
+    parentAccount,
+    receiveTokenMode,
+    onChangeAccount,
+    onChangeToken,
+    eventType,
+  } = props;
   const mainAccount = account ? getMainAccount(account, parentAccount) : null;
   const error = account ? getReceiveFlowError(account, parentAccount) : null;
   const tokenTypes = mainAccount ? listTokenTypesForCryptoCurrency(mainAccount.currency) : [];
@@ -105,6 +107,9 @@ export default function StepAccount({
       ? mainAccount.currency.name
       : tokenTypes.map(tt => tt.toUpperCase()).join("/");
   const url = supportLinkByTokenType[tokenTypes[0] as keyof typeof supportLinkByTokenType];
+  const specific = mainAccount ? getLLDCoinFamily(mainAccount.currency.family) : null;
+  const StepReceiveAccountCustomAlert = specific?.StepReceiveAccountCustomAlert;
+
   return (
     <Box flow={1}>
       <TrackPage category={`Receive Flow${eventType ? ` (${eventType})` : ""}`} name="Step 1" />
@@ -149,6 +154,9 @@ export default function StepAccount({
           </Alert>
         </div>
       ) : null}
+      {!!account && !!StepReceiveAccountCustomAlert && (
+        <StepReceiveAccountCustomAlert {...props} account={account} />
+      )}
     </Box>
   );
 }
diff --git a/apps/ledger-live-desktop/src/renderer/modals/Send/fields/RecipientFieldBase.tsx b/apps/ledger-live-desktop/src/renderer/modals/Send/fields/RecipientFieldBase.tsx
index b9a913a162b..27f4c7e4e42 100644
--- a/apps/ledger-live-desktop/src/renderer/modals/Send/fields/RecipientFieldBase.tsx
+++ b/apps/ledger-live-desktop/src/renderer/modals/Send/fields/RecipientFieldBase.tsx
@@ -6,6 +6,7 @@ import { TFunction } from "i18next";
 import Box from "~/renderer/components/Box";
 import Label from "~/renderer/components/Label";
 import RecipientAddress, { OnChangeExtra } from "~/renderer/components/RecipientAddress";
+import { getLLDCoinFamily } from "~/renderer/families";
 
 type Props = {
   account: Account;
@@ -35,6 +36,9 @@ const RecipientFieldBase = ({
   const { recipient: recipientError } = status.errors;
   const { recipient: recipientWarning } = status.warnings;
 
+  const specific = getLLDCoinFamily(account.currency.family);
+  const StepRecipientCustomAlert = specific?.StepRecipientCustomAlert;
+
   return (
     <Box flow={1}>
       <Label>
@@ -52,6 +56,7 @@ const RecipientFieldBase = ({
         id={"send-recipient-input"}
         data-testid="send-recipient-input"
       />
+      {StepRecipientCustomAlert && <StepRecipientCustomAlert status={status} />}
     </Box>
   );
 };
diff --git a/apps/ledger-live-desktop/src/renderer/modals/Send/steps/StepRecipient.tsx b/apps/ledger-live-desktop/src/renderer/modals/Send/steps/StepRecipient.tsx
index 26f9515edad..e04122bc8d3 100644
--- a/apps/ledger-live-desktop/src/renderer/modals/Send/steps/StepRecipient.tsx
+++ b/apps/ledger-live-desktop/src/renderer/modals/Send/steps/StepRecipient.tsx
@@ -37,6 +37,7 @@ import {
 import Alert from "~/renderer/components/Alert";
 import { openURL } from "~/renderer/linking";
 import { urls } from "~/config/urls";
+import { getLLDCoinFamily } from "~/renderer/families";
 
 const openSplTokenExtensionsArticle = () => openURL(urls.solana.splTokenExtensions);
 
@@ -171,7 +172,9 @@ export const StepRecipientFooter = ({
     mainAccount ? getFields(mainAccount, lldMemoTag?.enabled) : [],
   );
   const hasFieldError = Object.keys(errors).some(name => fields.includes(name));
-  const canNext = !bridgePending && !hasFieldError && !isTerminated;
+  const specific = mainAccount ? getLLDCoinFamily(mainAccount.currency.family) : null;
+  const customValidationSuccess = specific?.sendRecipientCanNext?.(status) ?? true;
+  const canNext = !bridgePending && !hasFieldError && !isTerminated && customValidationSuccess;
   const isMemoTagBoxVisibile = useSelector(memoTagBoxVisibilitySelector);
   const alwaysShowMemoTagInfo = useSelector(alwaysShowMemoTagInfoSelector);
 
diff --git a/apps/ledger-live-desktop/static/i18n/en/app.json b/apps/ledger-live-desktop/static/i18n/en/app.json
index cba2251792e..a74fef093a9 100644
--- a/apps/ledger-live-desktop/static/i18n/en/app.json
+++ b/apps/ledger-live-desktop/static/i18n/en/app.json
@@ -202,7 +202,8 @@
       "UNSTAKE": "Unstaked",
       "WITHDRAW_UNSTAKED": "Withdrawn",
       "SENDING": "Sending",
-      "BURN": "Burned"
+      "BURN": "Burned",
+      "ASSOCIATE_TOKEN": "Associate token"
     },
     "edit": {
       "title": "Speed up or Cancel",
@@ -6482,6 +6483,18 @@
     "HederaAddAccountError": {
       "title": "Your account has not been added. Please try again."
     },
+    "HederaInsufficientFundsForAssociation": {
+      "title": "Insufficient balance",
+      "description": "Not enough HBAR to pay for the token association. At least ${{requiredWorthInUSD}} worth of HBAR is required."
+    },
+    "HederaRecipientTokenAssociationRequired": {
+      "title": "Token association required",
+      "description": "The token you’re trying to send is not associated with the destination account. It needs to be associated by the recipient account to be received."
+    },
+    "HederaRecipientTokenAssociationUnverified": {
+      "title": "Unable to verify token association",
+      "description": "We couldn’t confirm if the destination account can receive this token. The address might be invalid, or there could be a network or service problem."
+    },
     "ImageIncorrectFileTypeError": {
       "title": "Image loading from file failed.",
       "description": "Please try again with an image."
@@ -6651,10 +6664,54 @@
     "currentAddress": {
       "messageIfVirtual": "Your {{name}} address cannot be confirmed on your Ledger device. Use at your own risk."
     },
+    "receive": {
+      "warnings": {
+        "associationPrerequisite": {
+          "text": "In order to receive HTS tokens, your account needs to be associated. If you did not already associate your account with the HTS token that you want to receive, <0>click here</0> to start the token association flow.",
+          "learnMore": "Learn more"
+        },
+        "associationRequired": {
+          "text": "By clicking Continue you will associate the selected token to your Hedera account.",
+          "learnMore": "Learn more"
+        }
+      }
+    },
+    "receiveWithAssociation": {
+      "steps": {
+        "associationConfirmation": {
+          "breadcrumbTitle": "Associate",
+          "title": "Associate Token",
+          "pending": {
+            "title": "Broadcasting transaction..."
+          },
+          "success": {
+            "title": "Transaction sent",
+            "description": "You will be able to receive this token once the Associate Token transaction has been confirmed",
+            "cta": "View details"
+          },
+          "broadcastError": "Your transaction may have failed. Please wait a moment then check the transaction history before trying again."
+        }
+      }
+    },
     "send": {
       "memo": {
         "label": "Memo (optional)",
         "characterCount": "{{memoLength}} / {{memoMaxLength}}"
+      },
+      "warnings": {
+        "missingAssociation": {
+          "learnMore": "Learn more"
+        },
+        "unverifiedAssociation": {
+          "learnMore": "Learn more"
+        }
+      }
+    },
+    "operationDetails": {
+      "postAccountSection": "Associated token",
+      "postAlert": {
+        "text": "Once this transaction has been confirmed you will be able to receive your token. <0>Click here</0> to start the receive flow.",
+        "learnMore": "Learn more"
       }
     }
   },
diff --git a/apps/ledger-live-mobile/scripts/sync-families-dispatch.mjs b/apps/ledger-live-mobile/scripts/sync-families-dispatch.mjs
index e55c50194fb..7f68ddd4ec2 100644
--- a/apps/ledger-live-mobile/scripts/sync-families-dispatch.mjs
+++ b/apps/ledger-live-mobile/scripts/sync-families-dispatch.mjs
@@ -29,10 +29,12 @@ const targets = [
   "AccountSubHeader",
   "SendRowsCustom",
   "SendRowsFee",
+  "SendSelectRecipient",
   "AccountBalanceSummaryFooter",
   "SubAccountList",
   "Confirmation",
   "ReceiveConfirmationPostAlert",
+  "ReceiveConfirmationTokenAlert",
   "ConnectDevice",
   "NoAssociatedAccounts",
   "EditOperationPanel",
diff --git a/apps/ledger-live-mobile/src/components/RootNavigator/types/BaseNavigator.ts b/apps/ledger-live-mobile/src/components/RootNavigator/types/BaseNavigator.ts
index c1772cd6a38..4e97fe433f1 100644
--- a/apps/ledger-live-mobile/src/components/RootNavigator/types/BaseNavigator.ts
+++ b/apps/ledger-live-mobile/src/components/RootNavigator/types/BaseNavigator.ts
@@ -45,6 +45,7 @@ import type { SolanaDelegationFlowParamList } from "../../../families/solana/Del
 import type { StellarAddAssetFlowParamList } from "../../../families/stellar/AddAssetFlow/types";
 import type { TezosDelegationFlowParamList } from "../../../families/tezos/DelegationFlow/types";
 import type { TronVoteFlowParamList } from "../../../families/tron/VoteFlow/types";
+import type { HederaAssociateTokenFlowParamList } from "../../../families/hedera/AssociateTokenFlow/types";
 import type { AccountSettingsNavigatorParamList } from "./AccountSettingsNavigator";
 import type { AccountsNavigatorParamList } from "./AccountsNavigator";
 import type { AddAccountsNavigatorParamList } from "./AddAccountsNavigator";
@@ -298,6 +299,9 @@ export type BaseNavigatorStackParamList = {
   // Tron
   [NavigatorName.TronVoteFlow]: NavigatorScreenParams<TronVoteFlowParamList>;
 
+  // Hedera
+  [NavigatorName.HederaAssociateTokenFlow]: NavigatorScreenParams<HederaAssociateTokenFlowParamList>;
+
   [NavigatorName.ExploreTab]: NavigatorScreenParams<ExploreTabNavigatorStackParamList>;
 
   [ScreenName.DeviceConnect]: {
diff --git a/apps/ledger-live-mobile/src/const/navigation.ts b/apps/ledger-live-mobile/src/const/navigation.ts
index 66552fb668b..2a4ca355e45 100644
--- a/apps/ledger-live-mobile/src/const/navigation.ts
+++ b/apps/ledger-live-mobile/src/const/navigation.ts
@@ -476,6 +476,12 @@ export enum ScreenName {
   CasperEditTransferId = "CasperEditTransferId",
   // hedera
   HederaEditMemo = "HederaEditMemo",
+  HederaAssociateTokenSelectToken = "HederaAssociateTokenSelectToken",
+  HederaAssociateTokenSummary = "HederaAssociateTokenSummary",
+  HederaAssociateTokenSelectDevice = "HederaAssociateTokenSelectDevice",
+  HederaAssociateTokenConnectDevice = "HederaAssociateTokenConnectDevice",
+  HederaAssociateTokenValidationError = "HederaAssociateTokenValidationError",
+  HederaAssociateTokenValidationSuccess = "HederaAssociateTokenValidationSuccess",
   // near
   NearStakingValidator = "NearStakingValidator",
   NearStakingValidatorSelect = "NearStakingValidatorSelect",
@@ -643,6 +649,8 @@ export enum NavigatorName {
   NearStakingFlow = "NearStakingFlow",
   NearUnstakingFlow = "NearUnstakingFlow",
   NearWithdrawingFlow = "NearWithdrawingFlow",
+  // Hedera
+  HederaAssociateTokenFlow = "HederaAssociateTokenFlow",
 
   // Tab
   Main = "Main",
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/01-SelectToken.tsx b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/01-SelectToken.tsx
new file mode 100644
index 00000000000..762e4d0938a
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/01-SelectToken.tsx
@@ -0,0 +1,113 @@
+import React, { useCallback, useMemo } from "react";
+import { FlatList } from "react-native";
+import { useSelector } from "react-redux";
+import { Trans, useTranslation } from "react-i18next";
+import { Flex, Text } from "@ledgerhq/native-ui";
+import type { CryptoOrTokenCurrency } from "@ledgerhq/types-cryptoassets";
+import { getEnv } from "@ledgerhq/live-env";
+import { listTokens } from "@ledgerhq/live-common/currencies/index";
+import { getMainAccount } from "@ledgerhq/coin-framework/account/helpers";
+import invariant from "invariant";
+
+import { TrackScreen, track } from "~/analytics";
+import BigCurrencyRow from "~/components/BigCurrencyRow";
+import FilteredSearchBar from "~/components/FilteredSearchBar";
+import SafeAreaView from "~/components/SafeAreaView";
+import type { BaseComposite, StackNavigatorProps } from "~/components/RootNavigator/types/helpers";
+import { NavigatorName, ScreenName } from "~/const";
+import type { HederaAssociateTokenFlowParamList } from "~/families/hedera/AssociateTokenFlow/types";
+import { accountScreenSelector } from "~/reducers/accounts";
+
+type Props = BaseComposite<
+  StackNavigatorProps<HederaAssociateTokenFlowParamList, ScreenName.HederaAssociateTokenSelectToken>
+>;
+
+const SEARCH_KEYS = getEnv("CRYPTO_ASSET_SEARCH_KEYS");
+
+const keyExtractor = (currency: CryptoOrTokenCurrency) => currency.id;
+
+const renderEmptyList = () => (
+  <Flex px={6}>
+    <Text textAlign="center">
+      <Trans i18nKey="common.noCryptoFound" />
+    </Text>
+  </Flex>
+);
+
+export default function SelectToken({ navigation, route }: Props) {
+  const { t } = useTranslation();
+  const { account, parentAccount } = useSelector(accountScreenSelector(route));
+  const list = useMemo(() => listTokens().filter(t => t.parentCurrency.id === "hedera"), []);
+
+  const mainAccount = account ? getMainAccount(account, parentAccount) : null;
+
+  const onPressItem = useCallback(
+    (currency: CryptoOrTokenCurrency) => {
+      if (currency.type !== "TokenCurrency") return;
+      invariant(mainAccount, "hedera: mainAccount is missing");
+
+      const subAccount = (mainAccount?.subAccounts ?? []).find(acc => acc.token.id === currency.id);
+      const isAlreadyAssociated = !!subAccount;
+
+      track("asset_clicked", {
+        currency: currency.parentCurrency,
+        asset: currency.name,
+        page: ScreenName.HederaAssociateTokenSelectToken,
+        isAlreadyAssociated,
+      });
+
+      if (isAlreadyAssociated) {
+        navigation.navigate(NavigatorName.ReceiveFunds, {
+          screen: ScreenName.ReceiveConfirmation,
+          params: {
+            currency,
+            accountId: subAccount.id,
+            parentId: subAccount.parentId,
+          },
+        });
+      } else {
+        navigation.navigate(ScreenName.HederaAssociateTokenSummary, {
+          accountId: mainAccount.id,
+          tokenAddress: currency.contractAddress,
+        });
+      }
+    },
+    [mainAccount, navigation],
+  );
+
+  const renderList = useCallback(
+    (items: CryptoOrTokenCurrency[]) => (
+      <FlatList
+        data={items}
+        renderItem={({ item }) => (
+          <BigCurrencyRow currency={item} onPress={onPressItem} subTitle={item.ticker} />
+        )}
+        keyExtractor={keyExtractor}
+        showsVerticalScrollIndicator={false}
+        keyboardDismissMode="on-drag"
+      />
+    ),
+    [onPressItem],
+  );
+
+  return (
+    <SafeAreaView edges={["left", "right"]} isFlex>
+      <TrackScreen category="AssociateTokenFlow" name="SelectToken" currency="hedera" />
+      <Text variant="h4" fontWeight="semiBold" mx={6}>
+        {t("hedera.associate.selectToken.title")}
+      </Text>
+      {list.length > 0 ? (
+        <Flex flex={1} ml={6} mr={6} mt={3}>
+          <FilteredSearchBar
+            keys={SEARCH_KEYS}
+            list={list}
+            renderList={renderList}
+            renderEmptySearch={renderEmptyList}
+          />
+        </Flex>
+      ) : (
+        renderEmptyList()
+      )}
+    </SafeAreaView>
+  );
+}
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/02-Summary.tsx b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/02-Summary.tsx
new file mode 100644
index 00000000000..b744243e4b2
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/02-Summary.tsx
@@ -0,0 +1,143 @@
+import React, { useCallback } from "react";
+import { useSelector } from "react-redux";
+import { Trans } from "react-i18next";
+import { getAccountBridge } from "@ledgerhq/live-common/bridge/index";
+import useBridgeTransaction from "@ledgerhq/live-common/bridge/useBridgeTransaction";
+import { Transaction } from "@ledgerhq/live-common/families/hedera/types";
+import { View, SafeAreaView, StyleSheet } from "react-native";
+import { findTokenByAddress } from "@ledgerhq/live-common/currencies/index";
+import { getMainAccount } from "@ledgerhq/coin-framework/account/helpers";
+import { useTheme } from "@react-navigation/native";
+import invariant from "invariant";
+
+import SummaryToSection from "./SummaryToSection";
+import SummaryFromSection from "./SummaryFromSection";
+import type { HederaAssociateTokenFlowParamList } from "./types";
+import { TrackScreen } from "~/analytics";
+import { ScreenName } from "~/const";
+import Button from "~/components/Button";
+import LText from "~/components/LText";
+import type { BaseComposite, StackNavigatorProps } from "~/components/RootNavigator/types/helpers";
+import NavigationScrollView from "~/components/NavigationScrollView";
+import TranslatedError from "~/components/TranslatedError";
+import Alert from "~/components/Alert";
+import AssociationInsufficientFundsError from "~/families/hedera/AssociateTokenFlow/AssociationInsufficientFundsError";
+import { accountScreenSelector } from "~/reducers/accounts";
+import { urls } from "~/utils/urls";
+
+type Props = BaseComposite<
+  StackNavigatorProps<HederaAssociateTokenFlowParamList, ScreenName.HederaAssociateTokenSummary>
+>;
+
+export default function Summary({ navigation, route }: Props) {
+  const { colors } = useTheme();
+  const { account, parentAccount } = useSelector(accountScreenSelector(route));
+
+  const { tokenAddress } = route.params;
+  const token = findTokenByAddress(tokenAddress);
+
+  invariant(account, "hedera: account is required");
+  invariant(token, `hedera: token with address ${tokenAddress} is not available`);
+
+  const { transaction, status, bridgeError, bridgePending } = useBridgeTransaction(() => {
+    const bridge = getAccountBridge(account, parentAccount);
+    const transaction = bridge.createTransaction(account);
+    const updatedTransaction = bridge.updateTransaction(transaction, {
+      properties: {
+        name: "tokenAssociate",
+        token,
+      } satisfies Transaction["properties"],
+    });
+
+    return {
+      account,
+      parentAccount,
+      transaction: updatedTransaction,
+    };
+  });
+
+  const navigateToNext = useCallback(() => {
+    navigation.navigate(ScreenName.HederaAssociateTokenSelectDevice, {
+      ...route.params,
+      transaction,
+    });
+  }, [navigation, transaction, route]);
+
+  const mainAccount = getMainAccount(account, parentAccount);
+  const transactionError = status.errors.transaction;
+  const error = status.errors[Object.keys(status.errors)[0]];
+
+  return (
+    <SafeAreaView style={styles.root}>
+      <TrackScreen category="AssociateTokenFlow" name="Summary" currency="hedera" />
+      <NavigationScrollView style={styles.body}>
+        <SummaryFromSection token={token} />
+        <View
+          style={[
+            styles.verticalConnector,
+            {
+              borderColor: colors.lightFog,
+            },
+          ]}
+        />
+        <SummaryToSection account={mainAccount} />
+        <AssociationInsufficientFundsError status={status} />
+      </NavigationScrollView>
+      <LText style={styles.error} color="alert">
+        <TranslatedError error={transactionError} />
+      </LText>
+      <View style={styles.footer}>
+        <Alert
+          type="warning"
+          learnMoreUrl={urls.hedera.tokenAssociation}
+          learnMoreKey="hedera.associate.summary.warning.learnMore"
+        >
+          <Trans i18nKey="hedera.associate.summary.warning.text" />
+        </Alert>
+        <Button
+          event="HederaAssociateTokenSummaryContinue"
+          type="primary"
+          title={<Trans i18nKey="common.continue" />}
+          containerStyle={styles.continueButton}
+          onPress={navigateToNext}
+          disabled={bridgePending || !!bridgeError || !!error}
+          pending={bridgePending}
+        />
+      </View>
+    </SafeAreaView>
+  );
+}
+
+const styles = StyleSheet.create({
+  root: {
+    flex: 1,
+    flexDirection: "column",
+  },
+  body: {
+    flex: 1,
+    paddingHorizontal: 16,
+    paddingVertical: 16,
+    backgroundColor: "transparent",
+  },
+  footer: {
+    gap: 32,
+    flexDirection: "column",
+    alignItems: "center",
+    paddingHorizontal: 16,
+    paddingBottom: 24,
+  },
+  continueButton: {
+    alignSelf: "stretch",
+  },
+  error: {
+    fontSize: 12,
+    marginBottom: 5,
+  },
+  verticalConnector: {
+    position: "absolute",
+    borderLeftWidth: 2,
+    height: 20,
+    top: -12,
+    left: 16,
+  },
+});
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/04-ValidationError.tsx b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/04-ValidationError.tsx
new file mode 100644
index 00000000000..a6747f36d21
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/04-ValidationError.tsx
@@ -0,0 +1,49 @@
+import React, { useCallback } from "react";
+import { StyleSheet } from "react-native";
+import { SafeAreaView } from "react-native-safe-area-context";
+import { useTheme } from "@react-navigation/native";
+
+import type { HederaAssociateTokenFlowParamList } from "./types";
+import { TrackScreen } from "~/analytics";
+import ValidateError from "~/components/ValidateError";
+import type {
+  BaseComposite,
+  StackNavigatorNavigation,
+  StackNavigatorProps,
+} from "~/components/RootNavigator/types/helpers";
+import type { BaseNavigatorStackParamList } from "~/components/RootNavigator/types/BaseNavigator";
+import { ScreenName } from "~/const";
+
+type Props = BaseComposite<
+  StackNavigatorProps<
+    HederaAssociateTokenFlowParamList,
+    ScreenName.HederaAssociateTokenValidationError
+  >
+>;
+
+export default function ValidationError({ navigation, route }: Props) {
+  const { colors } = useTheme();
+
+  const error = route.params.error;
+
+  const onClose = useCallback(() => {
+    navigation.getParent<StackNavigatorNavigation<BaseNavigatorStackParamList>>().pop();
+  }, [navigation]);
+
+  const retry = useCallback(() => {
+    navigation.goBack();
+  }, [navigation]);
+
+  return (
+    <SafeAreaView style={[styles.root, { backgroundColor: colors.background }]}>
+      <TrackScreen category="AssociateTokenFlow" name="ValidationError" currency="hedera" />
+      <ValidateError error={error} onRetry={retry} onClose={onClose} />
+    </SafeAreaView>
+  );
+}
+
+const styles = StyleSheet.create({
+  root: {
+    flex: 1,
+  },
+});
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/04-ValidationSuccess.tsx b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/04-ValidationSuccess.tsx
new file mode 100644
index 00000000000..d3f272bd651
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/04-ValidationSuccess.tsx
@@ -0,0 +1,62 @@
+import React, { useCallback } from "react";
+import { View, StyleSheet } from "react-native";
+import { useSelector } from "react-redux";
+import { Trans } from "react-i18next";
+import { useTheme } from "@react-navigation/native";
+
+import type { HederaAssociateTokenFlowParamList } from "./types";
+import { TrackScreen } from "~/analytics";
+import { ScreenName } from "~/const";
+import PreventNativeBack from "~/components/PreventNativeBack";
+import ValidateSuccess from "~/components/ValidateSuccess";
+import type {
+  BaseComposite,
+  StackNavigatorNavigation,
+  StackNavigatorProps,
+} from "~/components/RootNavigator/types/helpers";
+import type { BaseNavigatorStackParamList } from "~/components/RootNavigator/types/BaseNavigator";
+import { accountScreenSelector } from "~/reducers/accounts";
+
+type Props = BaseComposite<
+  StackNavigatorProps<
+    HederaAssociateTokenFlowParamList,
+    ScreenName.HederaAssociateTokenValidationSuccess
+  >
+>;
+
+export default function ValidationSuccess({ navigation, route }: Props) {
+  const { colors } = useTheme();
+  const { account } = useSelector(accountScreenSelector(route));
+
+  const onClose = useCallback(() => {
+    navigation.getParent<StackNavigatorNavigation<BaseNavigatorStackParamList>>().pop();
+  }, [navigation]);
+
+  const goToOperationDetails = useCallback(() => {
+    const result = route.params?.result;
+    if (!account || !result) return;
+
+    navigation.navigate(ScreenName.OperationDetails, {
+      accountId: account.id,
+      operation: result,
+    });
+  }, [account, route.params, navigation]);
+
+  return (
+    <View style={[styles.root, { backgroundColor: colors.background }]}>
+      <TrackScreen category="AssociateTokenFlow" name="ValidationSuccess" currency="hedera" />
+      <PreventNativeBack />
+      <ValidateSuccess
+        onClose={onClose}
+        onViewDetails={goToOperationDetails}
+        title={<Trans i18nKey="hedera.associate.validationSuccess.title" />}
+        description={<Trans i18nKey="hedera.associate.validationSuccess.text" />}
+      />
+    </View>
+  );
+}
+const styles = StyleSheet.create({
+  root: {
+    flex: 1,
+  },
+});
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/AssociationInsufficientFundsError.tsx b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/AssociationInsufficientFundsError.tsx
new file mode 100644
index 00000000000..2be6cfa2d62
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/AssociationInsufficientFundsError.tsx
@@ -0,0 +1,24 @@
+import React from "react";
+import type { TransactionStatus } from "@ledgerhq/live-common/generated/types";
+import { Text } from "@ledgerhq/native-ui";
+import { useTheme } from "styled-components/native";
+import TranslatedError from "~/components/TranslatedError";
+
+interface Props {
+  status: TransactionStatus;
+}
+
+export default function AssociationInsufficientFundsError(props: Props) {
+  const { colors } = useTheme();
+  const { insufficientAssociateBalance } = props.status.errors;
+
+  if (!insufficientAssociateBalance) {
+    return null;
+  }
+
+  return (
+    <Text fontSize={12} fontWeight="medium" color={colors.error.c60}>
+      <TranslatedError error={insufficientAssociateBalance} field="description" />
+    </Text>
+  );
+}
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/SummaryFromSection.tsx b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/SummaryFromSection.tsx
new file mode 100644
index 00000000000..c4c65514cce
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/SummaryFromSection.tsx
@@ -0,0 +1,58 @@
+import React, { memo } from "react";
+import { View, StyleSheet } from "react-native";
+import { useTranslation } from "react-i18next";
+import { useTheme } from "styled-components/native";
+import Wallet from "@ledgerhq/icons-ui/native/Wallet";
+import type { TokenCurrency } from "@ledgerhq/types-cryptoassets";
+
+import SummaryRowCustom from "./SummaryRowCustom";
+import Circle from "~/components/Circle";
+import LText from "~/components/LText";
+import CurrencyIcon from "~/components/CurrencyIcon";
+
+interface Props {
+  token: TokenCurrency;
+}
+
+function SummaryFromSection({ token }: Props) {
+  const { colors } = useTheme();
+  const { t } = useTranslation();
+
+  return (
+    <SummaryRowCustom
+      label={t("hedera.associate.summary.from")}
+      iconLeft={
+        <Circle bg={colors.palette.opacityDefault.c05} size={34}>
+          <Wallet size="S" color={colors.palette.primary.c80} />
+        </Circle>
+      }
+      data={
+        <View style={styles.container}>
+          <View style={styles.currencyIcon}>
+            <CurrencyIcon size={16} forceIconScale={2} currency={token} circle />
+          </View>
+          <LText numberOfLines={1} style={styles.text}>
+            {token.name}
+          </LText>
+        </View>
+      }
+    />
+  );
+}
+
+const styles = StyleSheet.create({
+  container: {
+    flexDirection: "row",
+    gap: 4,
+  },
+  text: {
+    fontSize: 14,
+    textAlign: "right",
+  },
+  currencyIcon: {
+    alignItems: "center",
+    justifyContent: "center",
+  },
+});
+
+export default memo<Props>(SummaryFromSection);
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/SummaryRowCustom.tsx b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/SummaryRowCustom.tsx
new file mode 100644
index 00000000000..fd2e727de4c
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/SummaryRowCustom.tsx
@@ -0,0 +1,43 @@
+import React from "react";
+import { StyleSheet, View } from "react-native";
+
+import LText from "~/components/LText/index";
+
+interface Props {
+  label: string;
+  data: React.ReactNode;
+  iconLeft: React.ReactElement;
+}
+
+const SummaryRowCustom = ({ label, data, iconLeft }: Props) => {
+  return (
+    <View style={styles.root}>
+      <View style={styles.iconLeft}>{iconLeft}</View>
+      <View style={styles.right}>
+        <LText style={styles.labelStyle} color="grey">
+          {label}
+        </LText>
+        {data}
+      </View>
+    </View>
+  );
+};
+
+const styles = StyleSheet.create({
+  root: {
+    flexDirection: "row",
+    paddingVertical: 16,
+  },
+  labelStyle: {
+    fontSize: 16,
+  },
+  iconLeft: {
+    paddingRight: 16,
+  },
+  right: {
+    flex: 1,
+    gap: 2,
+  },
+});
+
+export default SummaryRowCustom;
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/SummaryToSection.tsx b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/SummaryToSection.tsx
new file mode 100644
index 00000000000..fa4c8b7df63
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/SummaryToSection.tsx
@@ -0,0 +1,50 @@
+import React, { memo } from "react";
+import { StyleSheet } from "react-native";
+import { useTranslation } from "react-i18next";
+import { useTheme } from "styled-components/native";
+import QrCode from "@ledgerhq/icons-ui/native/QrCode";
+import type { Account } from "@ledgerhq/types-live";
+
+import SummaryRowCustom from "./SummaryRowCustom";
+import Circle from "~/components/Circle";
+import LText from "~/components/LText";
+import { useAccountName } from "~/reducers/wallet";
+
+interface Props {
+  account: Account;
+}
+
+function SummaryToSection({ account }: Props) {
+  const { colors } = useTheme();
+  const { t } = useTranslation();
+  const name = useAccountName(account);
+
+  return (
+    <SummaryRowCustom
+      label={t("hedera.associate.summary.to")}
+      iconLeft={
+        <Circle bg={colors.palette.opacityDefault.c05} size={34}>
+          <QrCode size="S" color={colors.palette.primary.c80} />
+        </Circle>
+      }
+      data={
+        <>
+          <LText numberOfLines={1} style={styles.addressRowText}>
+            {name}
+          </LText>
+          <LText numberOfLines={1} style={styles.addressRowText} color="neutral.c70">
+            {account.freshAddress}
+          </LText>
+        </>
+      }
+    />
+  );
+}
+
+const styles = StyleSheet.create({
+  addressRowText: {
+    fontSize: 14,
+  },
+});
+
+export default memo<Props>(SummaryToSection);
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/index.tsx b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/index.tsx
new file mode 100644
index 00000000000..788beb70e7c
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/index.tsx
@@ -0,0 +1,91 @@
+import React, { useMemo } from "react";
+import { Platform } from "react-native";
+import { useTranslation } from "react-i18next";
+import { createStackNavigator } from "@react-navigation/stack";
+import { useTheme } from "@react-navigation/native";
+
+import SelectToken from "./01-SelectToken";
+import Summary from "./02-Summary";
+import ValidationError from "./04-ValidationError";
+import ValidationSuccess from "./04-ValidationSuccess";
+import type { HederaAssociateTokenFlowParamList } from "./types";
+import { NavigationHeaderBackButton } from "~/components/NavigationHeaderBackButton";
+import { NavigationHeaderCloseButtonAdvanced } from "~/components/NavigationHeaderCloseButton";
+import { ScreenName } from "~/const";
+import { getStackNavigatorConfig } from "~/navigation/navigatorConfig";
+import SelectDevice from "~/screens/SelectDevice";
+import ConnectDevice from "~/screens/ConnectDevice";
+
+function AssociateTokenFlow() {
+  const { t } = useTranslation();
+  const { colors } = useTheme();
+  const stackNavigationConfig = useMemo(() => getStackNavigatorConfig(colors, true), [colors]);
+
+  return (
+    <Stack.Navigator
+      screenOptions={{
+        ...stackNavigationConfig,
+        gestureEnabled: Platform.OS === "ios",
+      }}
+    >
+      <Stack.Screen
+        name={ScreenName.HederaAssociateTokenSelectToken}
+        component={SelectToken}
+        options={{
+          headerLeft: () => <NavigationHeaderBackButton />,
+          headerTitle: "",
+          headerRight: () => <NavigationHeaderCloseButtonAdvanced />,
+        }}
+      />
+      <Stack.Screen
+        name={ScreenName.HederaAssociateTokenSummary}
+        component={Summary}
+        options={{
+          headerLeft: () => <NavigationHeaderBackButton />,
+          headerTitle: t("hedera.associate.summary.title"),
+          headerRight: () => <NavigationHeaderCloseButtonAdvanced />,
+        }}
+      />
+      <Stack.Screen
+        name={ScreenName.HederaAssociateTokenSelectDevice}
+        component={SelectDevice}
+        options={{
+          headerTitle: t("hedera.associate.selectDevice.title"),
+        }}
+      />
+      <Stack.Screen
+        name={ScreenName.HederaAssociateTokenConnectDevice}
+        component={ConnectDevice}
+        options={{
+          headerLeft: undefined,
+          gestureEnabled: false,
+          headerTitle: t("hedera.associate.connectDevice.title"),
+        }}
+      />
+      <Stack.Screen
+        name={ScreenName.HederaAssociateTokenValidationError}
+        component={ValidationError}
+        options={{
+          headerShown: false,
+          gestureEnabled: false,
+        }}
+      />
+      <Stack.Screen
+        name={ScreenName.HederaAssociateTokenValidationSuccess}
+        component={ValidationSuccess}
+        options={{
+          headerShown: false,
+          gestureEnabled: false,
+        }}
+      />
+    </Stack.Navigator>
+  );
+}
+
+const options = {
+  headerShown: false,
+};
+
+export { AssociateTokenFlow as component, options };
+
+const Stack = createStackNavigator<HederaAssociateTokenFlowParamList>();
diff --git a/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/types.ts b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/types.ts
new file mode 100644
index 00000000000..5602f42b9ea
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/AssociateTokenFlow/types.ts
@@ -0,0 +1,46 @@
+import type { Transaction, TransactionStatus } from "@ledgerhq/live-common/families/hedera/types";
+import type { Operation } from "@ledgerhq/types-live";
+import type { Device } from "@ledgerhq/live-common/hw/actions/types";
+
+import { ScreenName } from "~/const";
+
+export type HederaAssociateTokenFlowParamList = {
+  [ScreenName.HederaAssociateTokenSelectToken]: {
+    accountId: string;
+  };
+  [ScreenName.HederaAssociateTokenSummary]: {
+    accountId: string;
+    tokenAddress: string;
+  };
+  [ScreenName.HederaAssociateTokenSelectDevice]: {
+    accountId: string;
+    parentId?: string;
+    transaction?: Transaction;
+    status?: TransactionStatus;
+  };
+  [ScreenName.HederaAssociateTokenConnectDevice]: {
+    device: Device;
+    accountId: string;
+    parentId?: string;
+    transaction: Transaction;
+    status: TransactionStatus;
+    appName?: string;
+    selectDeviceLink?: boolean;
+    onSuccess?: (payload: unknown) => void;
+    onError?: (error: Error) => void;
+    analyticsPropertyFlow?: string;
+    forceSelectDevice?: boolean;
+  };
+  [ScreenName.HederaAssociateTokenValidationError]: {
+    accountId: string;
+    deviceId: string;
+    transaction: Transaction;
+    error: Error;
+  };
+  [ScreenName.HederaAssociateTokenValidationSuccess]: {
+    accountId: string;
+    deviceId: string;
+    transaction: Transaction;
+    result: Operation;
+  };
+};
diff --git a/apps/ledger-live-mobile/src/families/hedera/Confirmation.tsx b/apps/ledger-live-mobile/src/families/hedera/Confirmation.tsx
index 2bff086b25b..93e906f8f48 100644
--- a/apps/ledger-live-mobile/src/families/hedera/Confirmation.tsx
+++ b/apps/ledger-live-mobile/src/families/hedera/Confirmation.tsx
@@ -35,6 +35,7 @@ import type {
   StackNavigatorProps,
 } from "~/components/RootNavigator/types/helpers";
 import { useMaybeAccountName } from "~/reducers/wallet";
+import ReceiveConfirmationTokenAlert from "./ReceiveConfirmationTokenAlert";
 
 type ScreenProps = CompositeScreenProps<
   StackNavigatorProps<ReceiveFundsStackParamList, ScreenName.ReceiveConfirmation>,
@@ -109,6 +110,7 @@ export default function ReceiveConfirmation({ navigation, route }: Props) {
   const address = mainAccount.freshAddress;
   const currency = getAccountCurrency(account);
   const name = mainAccountName;
+
   return (
     <SafeAreaView
       style={[
@@ -131,12 +133,7 @@ export default function ReceiveConfirmation({ navigation, route }: Props) {
           <SkipLock />
         </>
       )}
-      <NavigationScrollView
-        style={{
-          flex: 1,
-        }}
-        contentContainerStyle={styles.root}
-      >
+      <NavigationScrollView style={styles.root}>
         <View style={styles.container}>
           <Touchable event="QRZoom" onPress={onZoom}>
             {width < 350 ? (
@@ -200,16 +197,16 @@ export default function ReceiveConfirmation({ navigation, route }: Props) {
         </View>
         <View style={styles.bottomContainer}>
           {/* warning message for unverified address */}
-          {
-            <Alert type="security">
-              <Trans
-                i18nKey="hedera.currentAddress.messageIfVirtual"
-                values={{
-                  name,
-                }}
-              />
-            </Alert>
-          }
+          <Alert type="security">
+            <Trans
+              i18nKey="hedera.currentAddress.messageIfVirtual"
+              values={{
+                name,
+              }}
+            />
+          </Alert>
+          {/* message about token association */}
+          <ReceiveConfirmationTokenAlert account={account} mainAccount={mainAccount} />
         </View>
       </NavigationScrollView>
       <ReactNativeModal
@@ -259,6 +256,7 @@ export default function ReceiveConfirmation({ navigation, route }: Props) {
 const styles = StyleSheet.create({
   root: {
     flex: 1,
+    paddingBottom: 16,
   },
   container: {
     paddingHorizontal: 16,
@@ -267,9 +265,9 @@ const styles = StyleSheet.create({
     justifyContent: "center",
   },
   bottomContainer: {
+    gap: 16,
     paddingHorizontal: 16,
-    paddingBottom: 8,
-    paddingTop: 32,
+    paddingVertical: 32,
   },
   qrWrapper: {
     borderWidth: 1,
@@ -368,6 +366,9 @@ const styles = StyleSheet.create({
     right: 10,
     top: 10,
   },
+  textUnderline: {
+    textDecorationLine: "underline",
+  },
   learnmore: {
     paddingLeft: 8,
     paddingTop: 4,
diff --git a/apps/ledger-live-mobile/src/families/hedera/ReceiveConfirmationTokenAlert.tsx b/apps/ledger-live-mobile/src/families/hedera/ReceiveConfirmationTokenAlert.tsx
new file mode 100644
index 00000000000..5cd5db0a206
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/ReceiveConfirmationTokenAlert.tsx
@@ -0,0 +1,79 @@
+import React from "react";
+import { Trans } from "react-i18next";
+import { StyleSheet } from "react-native";
+import { useNavigation } from "@react-navigation/native";
+import type { Account, AccountLike } from "@ledgerhq/types-live";
+import { Text } from "@ledgerhq/native-ui";
+import { isTokenAccount, getAccountCurrency } from "@ledgerhq/live-common/account/index";
+import {
+  isAutoTokenAssociationEnabled,
+  isTokenAssociationRequired,
+} from "@ledgerhq/live-common/families/hedera/logic";
+import { TokenCurrency } from "@ledgerhq/types-cryptoassets";
+import { track } from "~/analytics";
+import Alert from "~/components/Alert";
+import { NavigatorName, ScreenName } from "~/const";
+import { urls } from "~/utils/urls";
+
+interface Props {
+  account: AccountLike;
+  mainAccount: Account;
+  token?: TokenCurrency;
+}
+
+function shouldShowTokenAssociationAlert({ account, mainAccount, token }: Props) {
+  const isNotTokenAccount = !isTokenAccount(account);
+  const isAutoAssociationDisabled = !isAutoTokenAssociationEnabled(mainAccount);
+  const isNotAssociated = token ? isTokenAssociationRequired(account, token) : true;
+
+  return isNotTokenAccount && isAutoAssociationDisabled && isNotAssociated;
+}
+
+export default function ReceiveConfirmationTokenAlert(props: Props) {
+  const { account } = props;
+  const navigation = useNavigation();
+  const currency = getAccountCurrency(account);
+  const showTokenAssociationAlert = shouldShowTokenAssociationAlert(props);
+
+  function onAssociationClickHere() {
+    track("button_clicked", {
+      currency,
+      button: "Click here to start the token association flow",
+      page: ScreenName.ReceiveConfirmation,
+    });
+
+    navigation.navigate(NavigatorName.HederaAssociateTokenFlow, {
+      screen: ScreenName.HederaAssociateTokenSelectToken,
+      params: {
+        accountId: account.id,
+      },
+    });
+  }
+
+  if (!showTokenAssociationAlert) {
+    return null;
+  }
+
+  return (
+    <Alert
+      type="primary"
+      learnMoreUrl={urls.hedera.tokenAssociation}
+      learnMoreKey="hedera.receive.warnings.associationPrerequisite.learnMore"
+    >
+      <Trans i18nKey="hedera.receive.warnings.associationPrerequisite.text">
+        <Text
+          onPress={onAssociationClickHere}
+          style={styles.textUnderline}
+          variant="bodyLineHeight"
+          fontWeight="semiBold"
+        />
+      </Trans>
+    </Alert>
+  );
+}
+
+const styles = StyleSheet.create({
+  textUnderline: {
+    textDecorationLine: "underline",
+  },
+});
diff --git a/apps/ledger-live-mobile/src/families/hedera/SendSelectRecipient.tsx b/apps/ledger-live-mobile/src/families/hedera/SendSelectRecipient.tsx
new file mode 100644
index 00000000000..e59a4e477bc
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/SendSelectRecipient.tsx
@@ -0,0 +1,54 @@
+import React from "react";
+import { sendRecipientCanNext } from "@ledgerhq/live-common/families/hedera/logic";
+import type { TransactionStatus } from "@ledgerhq/live-common/generated/types";
+import { urls } from "~/utils/urls";
+import Alert from "~/components/Alert";
+import TranslatedError from "~/components/TranslatedError";
+
+interface AlertProps {
+  error: Error;
+}
+
+const MissingAssociationAlert = ({ error }: AlertProps) => {
+  return (
+    <Alert
+      type="warning"
+      learnMoreUrl={urls.hedera.tokenAssociation}
+      learnMoreKey="hedera.send.warnings.missingAssociation.learnMore"
+    >
+      <TranslatedError error={error} field="description" />
+    </Alert>
+  );
+};
+
+const UnverifiedAssociationAlert = ({ error }: AlertProps) => {
+  return (
+    <Alert
+      type="warning"
+      learnMoreUrl={urls.hedera.tokenAssociation}
+      learnMoreKey="hedera.send.warnings.unverifiedAssociation.learnMore"
+    >
+      <TranslatedError error={error} field="description" />
+    </Alert>
+  );
+};
+
+interface Props {
+  status: TransactionStatus;
+}
+
+const StepRecipientCustomAlert = ({ status }: Props) => {
+  const { missingAssociation, unverifiedAssociation } = status.warnings;
+
+  if (missingAssociation) {
+    return <MissingAssociationAlert error={missingAssociation} />;
+  }
+
+  if (unverifiedAssociation) {
+    return <UnverifiedAssociationAlert error={unverifiedAssociation} />;
+  }
+
+  return null;
+};
+
+export default { sendRecipientCanNext, StepRecipientCustomAlert };
diff --git a/apps/ledger-live-mobile/src/families/hedera/index.ts b/apps/ledger-live-mobile/src/families/hedera/index.ts
index b2e76fa9373..a9aa33eff7b 100644
--- a/apps/ledger-live-mobile/src/families/hedera/index.ts
+++ b/apps/ledger-live-mobile/src/families/hedera/index.ts
@@ -1,3 +1,4 @@
 import * as HederaEditMemo from "./EditMemo";
+import * as HederaAssociateTokenFlow from "./AssociateTokenFlow";
 
-export { HederaEditMemo };
+export { HederaEditMemo, HederaAssociateTokenFlow };
diff --git a/apps/ledger-live-mobile/src/families/hedera/operationDetails.ts b/apps/ledger-live-mobile/src/families/hedera/operationDetails.ts
deleted file mode 100644
index 962c348a6e0..00000000000
--- a/apps/ledger-live-mobile/src/families/hedera/operationDetails.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-import { getTransactionExplorer } from "@ledgerhq/live-common/families/hedera/logic";
-
-export default { getTransactionExplorer };
diff --git a/apps/ledger-live-mobile/src/families/hedera/operationDetails.tsx b/apps/ledger-live-mobile/src/families/hedera/operationDetails.tsx
new file mode 100644
index 00000000000..42d8a615e22
--- /dev/null
+++ b/apps/ledger-live-mobile/src/families/hedera/operationDetails.tsx
@@ -0,0 +1,112 @@
+import React from "react";
+import { StyleSheet } from "react-native";
+import { Trans, useTranslation } from "react-i18next";
+import { useNavigation } from "@react-navigation/native";
+import { findTokenByAddress } from "@ledgerhq/live-common/currencies/index";
+import { getTransactionExplorer, isValidExtra } from "@ledgerhq/live-common/families/hedera/logic";
+import type { HederaAccount, HederaOperation } from "@ledgerhq/live-common/families/hedera/types";
+import type { OperationType } from "@ledgerhq/types-live";
+import { Text } from "@ledgerhq/native-ui";
+import Alert from "~/components/Alert";
+import { NavigatorName, ScreenName } from "~/const";
+import Section from "~/screens/OperationDetails/Section";
+import { urls } from "~/utils/urls";
+
+interface OperationDetailsPostAccountSectionProps {
+  operation: HederaOperation;
+  type: OperationType;
+  account: HederaAccount;
+}
+
+function OperationDetailsPostAccountSection({
+  operation,
+}: OperationDetailsPostAccountSectionProps) {
+  const { t } = useTranslation();
+
+  if (operation.type !== "ASSOCIATE_TOKEN") {
+    return null;
+  }
+
+  const token = operation.extra.associatedTokenId
+    ? findTokenByAddress(operation.extra.associatedTokenId)
+    : null;
+
+  if (!token) {
+    return null;
+  }
+
+  return (
+    <Section
+      title={t("hedera.operationDetails.postAccountSection")}
+      value={`${token.contractAddress} (${token.name})`}
+    />
+  );
+}
+
+interface OperationDetailsExtraProps {
+  operation: HederaOperation;
+  account: HederaAccount;
+  type: OperationType;
+}
+
+function OperationDetailsPostAlert({ account, operation }: OperationDetailsExtraProps) {
+  const navigation = useNavigation();
+
+  if (operation.type !== "ASSOCIATE_TOKEN") {
+    return null;
+  }
+
+  const extra = isValidExtra(operation.extra) ? operation.extra : null;
+  const associatedTokenId = extra?.associatedTokenId;
+  const token = associatedTokenId ? findTokenByAddress(associatedTokenId) : null;
+
+  if (!token) {
+    return null;
+  }
+
+  const goToReceive = () => {
+    const subAccount = account.subAccounts?.find(
+      a => a.token.contractAddress === token.contractAddress,
+    );
+
+    if (!subAccount) return;
+
+    navigation.navigate(NavigatorName.ReceiveFunds, {
+      screen: ScreenName.ReceiveConfirmation,
+      params: {
+        currency: subAccount.token,
+        accountId: subAccount.id,
+        parentId: subAccount.parentId,
+      },
+    });
+  };
+
+  return (
+    <Alert
+      type="primary"
+      learnMoreUrl={urls.hedera.tokenAssociation}
+      learnMoreKey="hedera.operationDetails.postAlert.learnMore"
+    >
+      <Trans i18nKey="hedera.operationDetails.postAlert.text">
+        <Text
+          onPress={goToReceive}
+          style={styles.textUnderline}
+          variant="bodyLineHeight"
+          fontWeight="semiBold"
+        />
+      </Trans>
+    </Alert>
+  );
+}
+
+const styles = StyleSheet.create({
+  textUnderline: {
+    textDecorationLine: "underline",
+  },
+});
+
+export default {
+  OperationDetailsPostAccountSection,
+  OperationDetailsPostAlert,
+  getTransactionExplorer,
+};
diff --git a/apps/ledger-live-mobile/src/icons/OperationStatusIcon/index.tsx b/apps/ledger-live-mobile/src/icons/OperationStatusIcon/index.tsx
index 01eee4ddd3f..009cf75d6aa 100644
--- a/apps/ledger-live-mobile/src/icons/OperationStatusIcon/index.tsx
+++ b/apps/ledger-live-mobile/src/icons/OperationStatusIcon/index.tsx
@@ -46,6 +46,7 @@ const iconsComponent = {
   STAKE: IconsLegacy.HandshakeMedium,
   UNSTAKE: IconsLegacy.UndelegateMedium,
   WITHDRAW_UNSTAKED: IconsLegacy.CoinsMedium,
+  ASSOCIATE_TOKEN: IconsLegacy.PlusMedium,
 };
 
 const OperationStatusIcon = ({
diff --git a/apps/ledger-live-mobile/src/locales/en/common.json b/apps/ledger-live-mobile/src/locales/en/common.json
index eadabd9f568..47a8ea7f001 100644
--- a/apps/ledger-live-mobile/src/locales/en/common.json
+++ b/apps/ledger-live-mobile/src/locales/en/common.json
@@ -953,6 +953,18 @@
     "HederaAddAccountError": {
       "title": "Your account has not been added. Please try again."
     },
+    "HederaInsufficientFundsForAssociation": {
+      "title": "Insufficient balance",
+      "description": "Not enough HBAR to pay for the token association. At least ${{requiredWorthInUSD}} worth of HBAR is required."
+    },
+    "HederaRecipientTokenAssociationRequired": {
+      "title": "Token association required",
+      "description": "The token you’re trying to send is not associated with the destination account. It needs to be associated by the recipient account to be received."
+    },
+    "HederaRecipientTokenAssociationUnverified": {
+      "title": "Unable to verify token association",
+      "description": "We couldn’t confirm if the destination account can receive this token. The address might be invalid, or there could be a network or service problem."
+    },
     "NearNewAccountWarning": {
       "title": "The recipient account is not created yet. The protocol requires a {{formattedNewAccountStorageCost}} transfer to create it."
     },
@@ -2602,7 +2614,8 @@
       "WITHDRAW": "Withdrawn",
       "STAKE": "Staked",
       "UNSTAKE": "Unstaked",
-      "WITHDRAW_UNSTAKED": "Withdrawn"
+      "WITHDRAW_UNSTAKED": "Withdrawn",
+      "ASSOCIATE_TOKEN": "Associate token"
     }
   },
   "operationDetails": {
@@ -6811,6 +6824,55 @@
     },
     "currentAddress": {
       "messageIfVirtual": "Your {{name}} address cannot be confirmed on your Ledger device. Use at your own risk."
+    },
+    "receive": {
+      "warnings": {
+        "associationPrerequisite": {
+          "text": "In order to receive HTS tokens, your account needs to be associated. If you did not already associate your account with the HTS token that you want to receive, <0>click here</0> to start the token association flow.",
+          "learnMore": "Learn more"
+        }
+      }
+    },
+    "associate": {
+      "selectToken": {
+        "title": "Choose a token you want to receive"
+      },
+      "summary": {
+        "title": "Associate token",
+        "from": "Token",
+        "to": "To",
+        "warning": {
+          "text": "By clicking Continue you will associate the selected token to your Hedera account.",
+          "learnMore": "Learn more"
+        }
+      },
+      "selectDevice": {
+        "title": "Associate token"
+      },
+      "connectDevice": {
+        "title": "Associate token"
+      },
+      "validationSuccess": {
+        "title": "Transaction sent",
+        "text": "You will be able to receive this token once the Associate Token transaction has been confirmed"
+      }
+    },
+    "send": {
+      "warnings": {
+        "missingAssociation": {
+          "learnMore": "Learn more"
+        },
+        "unverifiedAssociation": {
+          "learnMore": "Learn more"
+        }
+      }
+    },
+    "operationDetails": {
+      "postAccountSection": "Associated token",
+      "postAlert": {
+        "text": "Once this transaction has been confirmed you will be able to receive your token. <0>Click here</0> to start the receive flow.",
+        "learnMore": "Learn more"
+      }
     }
   },
   "asset": {
diff --git a/apps/ledger-live-mobile/src/screens/ConnectDevice.tsx b/apps/ledger-live-mobile/src/screens/ConnectDevice.tsx
index a4860b65070..c35cc1397f9 100644
--- a/apps/ledger-live-mobile/src/screens/ConnectDevice.tsx
+++ b/apps/ledger-live-mobile/src/screens/ConnectDevice.tsx
@@ -46,6 +46,7 @@ import type { MultiversXWithdrawFlowParamList } from "~/families/multiversx/comp
 import type { NearStakingFlowParamList } from "~/families/near/StakingFlow/types";
 import type { NearUnstakingFlowParamList } from "~/families/near/UnstakingFlow/types";
 import type { NearWithdrawingFlowParamList } from "~/families/near/WithdrawingFlow/types";
+import type { HederaAssociateTokenFlowParamList } from "~/families/hedera/AssociateTokenFlow/types";
 import { SolanaDelegationFlowParamList } from "~/families/solana/DelegationFlow/types";
 import { StellarAddAssetFlowParamList } from "~/families/stellar/AddAssetFlow/types";
 import { TezosDelegationFlowParamList } from "~/families/tezos/DelegationFlow/types";
@@ -107,7 +108,11 @@ type Props =
   | StackNavigatorProps<SolanaDelegationFlowParamList, ScreenName.DelegationConnectDevice>
   | StackNavigatorProps<StellarAddAssetFlowParamList, ScreenName.StellarAddAssetConnectDevice>
   | StackNavigatorProps<TezosDelegationFlowParamList, ScreenName.DelegationConnectDevice>
-  | StackNavigatorProps<TronVoteFlowParamList, ScreenName.VoteConnectDevice>;
+  | StackNavigatorProps<TronVoteFlowParamList, ScreenName.VoteConnectDevice>
+  | StackNavigatorProps<
+      HederaAssociateTokenFlowParamList,
+      ScreenName.HederaAssociateTokenConnectDevice
+    >;
 
 export const navigateToSelectDevice = (navigation: Props["navigation"], route: Props["route"]) =>
   // Assumes that it will always navigate to a "SelectDevice"
diff --git a/apps/ledger-live-mobile/src/screens/OperationDetails/Content.tsx b/apps/ledger-live-mobile/src/screens/OperationDetails/Content.tsx
index ea659819e13..8bd91278bb5 100644
--- a/apps/ledger-live-mobile/src/screens/OperationDetails/Content.tsx
+++ b/apps/ledger-live-mobile/src/screens/OperationDetails/Content.tsx
@@ -152,10 +152,28 @@ export default function Content({
       specificOperationDetails as { getURLFeesInfo: (o: Operation, c: string) => string }
     )?.getURLFeesInfo(operation, mainAccount.currency.id);
 
-  const Extra =
+  const PostAccountSection =
+    specificOperationDetails &&
+    "OperationDetailsPostAccountSection" in specificOperationDetails &&
+    specificOperationDetails.OperationDetailsPostAccountSection &&
+    (specificOperationDetails.OperationDetailsPostAccountSection as React.ComponentType<{
+      type: typeof type;
+      account: AccountLike;
+      operation: Operation;
+    }>);
+
+  const PostAlert =
     specificOperationDetails &&
-    (specificOperationDetails as { OperationDetailsExtra: React.ComponentType })
-      .OperationDetailsExtra
+    "OperationDetailsPostAlert" in specificOperationDetails &&
+    specificOperationDetails.OperationDetailsPostAlert &&
+    (specificOperationDetails.OperationDetailsPostAlert as React.ComponentType<{
+      type: typeof type;
+      account: AccountLike;
+      operation: Operation;
+    }>);
+
+  const Extra =
+    specificOperationDetails && "OperationDetailsExtra" in specificOperationDetails
       ? (
           specificOperationDetails as {
             OperationDetailsExtra: React.ComponentType<{
@@ -343,6 +361,10 @@ export default function Content({
         />
       ) : null}
 
+      {PostAccountSection && (
+        <PostAccountSection operation={operation} type={type} account={account} />
+      )}
+
       {isNftOperation ? (
         <>
           <Section title={t("operationDetails.tokenName")}>
@@ -449,6 +471,12 @@ export default function Content({
 
       <Extra operation={operation} type={type} account={account} />
 
+      {PostAlert && (
+        <View style={sectionStyles.wrapper}>
+          <PostAlert operation={operation} type={type} account={account} />
+        </View>
+      )}
+
       <Modal isOpened={isModalOpened} onClose={onModalClose} currency={currency} />
     </>
   );
diff --git a/apps/ledger-live-mobile/src/screens/ReceiveFunds/03-Confirmation.tsx b/apps/ledger-live-mobile/src/screens/ReceiveFunds/03-Confirmation.tsx
index f1af739394b..ebf6a0f8961 100644
--- a/apps/ledger-live-mobile/src/screens/ReceiveFunds/03-Confirmation.tsx
+++ b/apps/ledger-live-mobile/src/screens/ReceiveFunds/03-Confirmation.tsx
@@ -29,6 +29,7 @@ import { ScreenName } from "~/const";
 import { track, TrackScreen } from "~/analytics";
 import byFamily from "../../generated/Confirmation";
 import byFamilyPostAlert from "../../generated/ReceiveConfirmationPostAlert";
+import byFamilyTokenAlert from "../../generated/ReceiveConfirmationTokenAlert";
 import { ReceiveFundsStackParamList } from "~/components/RootNavigator/types/ReceiveFundsNavigator";
 import { BaseComposite, StackNavigatorProps } from "~/components/RootNavigator/types/helpers";
 import styled, { BaseStyledProps } from "@ledgerhq/native-ui/components/styled";
@@ -282,12 +283,25 @@ function ReceiveConfirmationInner({ navigation, route, account, parentAccount }:
         : null;
   }
 
+  let CustomConfirmationTokenAlert;
+  if (
+    currency.type === "TokenCurrency" &&
+    Object.keys(byFamilyTokenAlert).includes(currency.parentCurrency.family)
+  ) {
+    CustomConfirmationTokenAlert =
+      byFamilyTokenAlert[currency.parentCurrency.family as keyof typeof byFamilyTokenAlert];
+  }
+
   const isAnAccount = account.type === "Account";
   const isUTXOCompliantCurrency = isAnAccount && isUTXOCompliant(account.currency.family);
 
   return (
     <Flex flex={1}>
-      <NavigationScrollView testID="receive-screen-scrollView" style={{ flex: 1 }}>
+      <NavigationScrollView
+        testID="receive-screen-scrollView"
+        style={{ flex: 1 }}
+        contentContainerStyle={{ paddingBottom: 80 }}
+      >
         <TrackScreen
           category="Deposit"
           name="Receive Account Qr Code"
@@ -411,6 +425,13 @@ function ReceiveConfirmationInner({ navigation, route, account, parentAccount }:
             </Text>
           </Flex>
           {CustomConfirmationAlert && <CustomConfirmationAlert mainAccount={mainAccount} />}
+          {CustomConfirmationTokenAlert && currency.type === "TokenCurrency" && (
+            <CustomConfirmationTokenAlert
+              account={account}
+              mainAccount={mainAccount}
+              token={currency}
+            />
+          )}
         </Flex>
       </NavigationScrollView>
       {displayBanner && (
diff --git a/apps/ledger-live-mobile/src/screens/SendFunds/02-SelectRecipient.tsx b/apps/ledger-live-mobile/src/screens/SendFunds/02-SelectRecipient.tsx
index 5334580ec4b..5e0e541fa7b 100644
--- a/apps/ledger-live-mobile/src/screens/SendFunds/02-SelectRecipient.tsx
+++ b/apps/ledger-live-mobile/src/screens/SendFunds/02-SelectRecipient.tsx
@@ -42,6 +42,7 @@ import { useMemoTagInput } from "LLM/features/MemoTag/hooks/useMemoTagInput";
 import { hasMemoDisclaimer } from "LLM/features/MemoTag/utils/hasMemoTag";
 import DomainServiceRecipientRow from "./DomainServiceRecipientRow";
 import RecipientRow from "./RecipientRow";
+import perFamilySendSelectRecipient from "../../generated/SendSelectRecipient";
 import {
   getTokenExtensions,
   hasProblematicExtension,
@@ -239,7 +240,18 @@ export default function SendSelectRecipient({ route }: Props) {
       !isConfirmedOperation(op, mainAccount, currencySettings.confirmationsNb),
   );
 
+  const specific =
+    perFamilySendSelectRecipient[
+      mainAccount.currency.family as keyof typeof perFamilySendSelectRecipient
+    ];
+  const CustomRecipientAlert =
+    specific && "StepRecipientCustomAlert" in specific ? specific.StepRecipientCustomAlert : null;
+  const customSendRecipientCanNext =
+    specific && "sendRecipientCanNext" in specific ? specific.sendRecipientCanNext : null;
+
+  const customValidationSuccess = customSendRecipientCanNext?.(status) ?? true;
   const isContinueDisabled =
+    !customValidationSuccess ||
     debouncedBridgePending ||
     !!status.errors.recipient ||
     memoTag?.isDebouncePending ||
@@ -339,6 +351,12 @@ export default function SendSelectRecipient({ route }: Props) {
               />
             )}
 
+            {CustomRecipientAlert && (
+              <View style={styles.customRecipientAlertContainer}>
+                <CustomRecipientAlert status={status} />
+              </View>
+            )}
+
             {memoTag?.Input && (
               <View style={styles.memoTagInputContainer}>
                 <memoTag.Input
@@ -424,7 +442,12 @@ const styles = StyleSheet.create({
     paddingBottom: 24,
     backgroundColor: "transparent",
   },
-  memoTagInputContainer: { marginTop: 32 },
+  customRecipientAlertContainer: {
+    marginTop: 8,
+  },
+  memoTagInputContainer: {
+    marginTop: 32,
+  },
   infoBox: {
     marginTop: 24,
     paddingBottom: 24,
diff --git a/apps/ledger-live-mobile/src/utils/urls.tsx b/apps/ledger-live-mobile/src/utils/urls.tsx
index 3dbcb65bfaa..73fd9ddb79e 100644
--- a/apps/ledger-live-mobile/src/utils/urls.tsx
+++ b/apps/ledger-live-mobile/src/utils/urls.tsx
@@ -197,6 +197,8 @@ export const urls = {
   hedera: {
     supportArticleLink:
       "https://launchbadge.com/blog/using-a-ledger-nano-to-create-your-hedera-account",
+    tokenAssociation:
+      "https://support.ledger.com/article/How-to-manage-Hedera-tokens-with-Ledger-Live",
   },
   nft: {
     supportDisableIos: "https://support.ledger.com/article/7572912170653-zd",
diff --git a/libs/coin-modules/coin-hedera/src/api/mirror.test.ts b/libs/coin-modules/coin-hedera/src/api/mirror.test.ts
index ef0baf4f869..f677efdbcfa 100644
--- a/libs/coin-modules/coin-hedera/src/api/mirror.test.ts
+++ b/libs/coin-modules/coin-hedera/src/api/mirror.test.ts
@@ -1,5 +1,5 @@
 import network from "@ledgerhq/live-network/network";
-import { getAccountTransactions } from "./mirror";
+import { getAccount, getAccountTokens, getAccountTransactions } from "./mirror";
 
 jest.mock("@ledgerhq/live-network/network");
 const mockedNetwork = jest.mocked(network);
@@ -26,10 +26,10 @@ describe("getAccountTransactions", () => {
 
     await getAccountTransactions("0.0.1234", null);
 
-    const calledUrl = mockedNetwork.mock.calls[0][0].url;
-    expect(calledUrl).toContain("account.id=0.0.1234");
-    expect(calledUrl).toContain("limit=100");
-    expect(calledUrl).toContain("order=desc");
+    const requestUrl = mockedNetwork.mock.calls[0][0].url;
+    expect(requestUrl).toContain("account.id=0.0.1234");
+    expect(requestUrl).toContain("limit=100");
+    expect(requestUrl).toContain("order=desc");
   });
 
   test("should keep fetching if links.next is present", async () => {
@@ -72,3 +72,77 @@ describe("getAccountTransactions", () => {
     expect(mockedNetwork).toHaveBeenCalledTimes(5);
   });
 });
+
+describe("getAccount", () => {
+  beforeEach(() => {
+    jest.clearAllMocks();
+  });
+
+  it("should call the correct endpoint and return account data", async () => {
+    mockedNetwork.mockResolvedValueOnce(
+      makeMockResponse({
+        account: "0.0.1234",
+        max_automatic_token_associations: 0,
+        balance: {
+          balance: 1000,
+          timestamp: "1749047764.000113442",
+          tokens: [],
+        },
+      }),
+    );
+
+    const result = await getAccount("0.0.1234");
+    const requestUrl = mockedNetwork.mock.calls[0][0].url;
+
+    expect(result.account).toEqual("0.0.1234");
+    expect(requestUrl).toContain("/api/v1/accounts/0.0.1234");
+    expect(mockedNetwork).toHaveBeenCalledTimes(1);
+  });
+});
+
+describe("getAccountTokens", () => {
+  beforeEach(() => {
+    jest.clearAllMocks();
+  });
+
+  it("should return all tokens if only one page is needed", async () => {
+    mockedNetwork.mockResolvedValueOnce(
+      makeMockResponse({
+        tokens: [
+          { token_id: "0.0.1001", balance: 10 },
+          { token_id: "0.0.1002", balance: 20 },
+        ],
+        links: { next: null },
+      }),
+    );
+
+    const result = await getAccountTokens("0.0.1234");
+    const requestUrl = mockedNetwork.mock.calls[0][0].url;
+
+    expect(result.map(t => t.token_id)).toEqual(["0.0.1001", "0.0.1002"]);
+    expect(requestUrl).toContain("/api/v1/accounts/0.0.1234/tokens");
+    expect(requestUrl).toContain("limit=100");
+    expect(mockedNetwork).toHaveBeenCalledTimes(1);
+  });
+
+  it("should keep fetching if links.next is present and new tokens are returned", async () => {
+    mockedNetwork
+      .mockResolvedValueOnce(
+        makeMockResponse({
+          tokens: [{ token_id: "0.0.1001", balance: 10 }],
+          links: { next: "/next-1" },
+        }),
+      )
+      .mockResolvedValueOnce(
+        makeMockResponse({
+          tokens: [{ token_id: "0.0.1002", balance: 20 }],
+          links: { next: null },
+        }),
+      );
+
+    const result = await getAccountTokens("0.0.1234");
+
+    expect(result.map(t => t.token_id)).toEqual(["0.0.1001", "0.0.1002"]);
+    expect(mockedNetwork).toHaveBeenCalledTimes(2);
+  });
+});
diff --git a/libs/coin-modules/coin-hedera/src/api/network.ts b/libs/coin-modules/coin-hedera/src/api/network.ts
index 32ad12e0ad4..16012c9cb4b 100644
--- a/libs/coin-modules/coin-hedera/src/api/network.ts
+++ b/libs/coin-modules/coin-hedera/src/api/network.ts
@@ -1,4 +1,5 @@
 import BigNumber from "bignumber.js";
+import invariant from "invariant";
 import type { Transaction as HederaTransaction, TransactionResponse } from "@hashgraph/sdk";
 import {
   Client,
@@ -8,24 +9,27 @@ import {
   TransactionId,
   AccountBalanceQuery,
   HbarUnit,
+  TokenAssociateTransaction,
 } from "@hashgraph/sdk";
-import { Account } from "@ledgerhq/types-live";
+import type { Account, TokenAccount } from "@ledgerhq/types-live";
+import { findSubAccountById, isTokenAccount } from "@ledgerhq/coin-framework/account/helpers";
 import { HederaAddAccountError } from "../errors";
 import { Transaction } from "../types";
+import { isTokenAssociateTransaction } from "../logic";
 
 export function broadcastTransaction(transaction: HederaTransaction): Promise<TransactionResponse> {
   return transaction.execute(getClient());
 }
 
-export async function buildUnsignedTransaction({
+async function buildUnsignedCoinTransaction({
   account,
   transaction,
 }: {
   account: Account;
   transaction: Transaction;
 }): Promise<TransferTransaction> {
-  const hbarAmount = Hbar.fromTinybars(transaction.amount);
   const accountId = account.freshAddress;
+  const hbarAmount = Hbar.fromTinybars(transaction.amount);
 
   return new TransferTransaction()
     .setNodeAccountIds([new AccountId(3)])
@@ -36,6 +40,66 @@ export async function buildUnsignedTransaction({
     .freeze();
 }
 
+async function buildUnsignedTokenTransaction({
+  account,
+  tokenAccount,
+  transaction,
+}: {
+  account: Account;
+  tokenAccount: TokenAccount;
+  transaction: Transaction;
+}): Promise<TransferTransaction> {
+  const accountId = account.freshAddress;
+  const tokenId = tokenAccount.token.contractAddress;
+
+  return new TransferTransaction()
+    .setNodeAccountIds([new AccountId(3)])
+    .setTransactionId(TransactionId.generate(accountId))
+    .setTransactionMemo(transaction.memo ?? "")
+    .addTokenTransfer(tokenId, accountId, transaction.amount.negated().toNumber())
+    .addTokenTransfer(tokenId, transaction.recipient, transaction.amount.toNumber())
+    .freeze();
+}
+
+async function buildTokenAssociateTransaction({
+  account,
+  transaction,
+}: {
+  account: Account;
+  transaction: Transaction;
+}): Promise<TokenAssociateTransaction> {
+  invariant(isTokenAssociateTransaction(transaction), "invalid transaction properties");
+
+  const accountId = account.freshAddress;
+
+  return new TokenAssociateTransaction()
+    .setNodeAccountIds([new AccountId(3)])
+    .setTransactionId(TransactionId.generate(accountId))
+    .setTransactionMemo(transaction.memo ?? "")
+    .setAccountId(accountId)
+    .setTokenIds([transaction.properties.token.contractAddress])
+    .freeze();
+}
+
+export async function buildUnsignedTransaction({
+  account,
+  transaction,
+}: {
+  account: Account;
+  transaction: Transaction;
+}): Promise<TransferTransaction | TokenAssociateTransaction> {
+  const subAccount = findSubAccountById(account, transaction?.subAccountId || "");
+  const isTokenTransaction = isTokenAccount(subAccount);
+
+  if (isTokenAssociateTransaction(transaction)) {
+    return buildTokenAssociateTransaction({ account, transaction });
+  } else if (isTokenTransaction) {
+    return buildUnsignedTokenTransaction({ account, tokenAccount: subAccount, transaction });
+  } else {
+    return buildUnsignedCoinTransaction({ account, transaction });
+  }
+}
+
 export interface AccountBalance {
   balance: BigNumber;
 }
diff --git a/libs/coin-modules/coin-hedera/src/api/utils.ts b/libs/coin-modules/coin-hedera/src/api/utils.ts
index 551751da204..b93327bb919 100644
--- a/libs/coin-modules/coin-hedera/src/api/utils.ts
+++ b/libs/coin-modules/coin-hedera/src/api/utils.ts
@@ -107,11 +107,12 @@ export async function getOperationsForAccount(
       });
     } else if (transfers.length > 0) {
       const { type, value, senders, recipients } = parseTransfers(rawTx.transfers, address);
+      const operationType = rawTx.name === "TOKENASSOCIATE" ? "ASSOCIATE_TOKEN" : type;
 
       coinOperations.push({
-        id: encodeOperationId(ledgerAccountId, hash, type),
+        id: encodeOperationId(ledgerAccountId, hash, operationType),
         accountId: ledgerAccountId,
-        type,
+        type: operationType,
         value,
         recipients,
         senders,
diff --git a/libs/coin-modules/coin-hedera/src/bridge/buildOptimisticOperation.integration.test.ts b/libs/coin-modules/coin-hedera/src/bridge/buildOptimisticOperation.integration.test.ts
new file mode 100644
index 00000000000..f7e36f1288d
--- /dev/null
+++ b/libs/coin-modules/coin-hedera/src/bridge/buildOptimisticOperation.integration.test.ts
@@ -0,0 +1,87 @@
+import BigNumber from "bignumber.js";
+import { getMockedAccount, getMockedTokenAccount } from "../test/fixtures/account";
+import { getMockedTokenCurrency } from "../test/fixtures/currency";
+import { getMockedTransaction } from "../test/fixtures/transaction";
+import { buildOptimisticOperation } from "./buildOptimisticOperation";
+import { getEstimatedFees } from "./utils";
+
+describe("buildOptimisticOperation", () => {
+  let estimatedFees: Record<"crypto" | "associate", BigNumber>;
+
+  beforeAll(async () => {
+    const mockedAccount = getMockedAccount();
+    const [crypto, associate] = await Promise.all([
+      getEstimatedFees(mockedAccount, "CryptoTransfer"),
+      getEstimatedFees(mockedAccount, "TokenAssociate"),
+    ]);
+
+    estimatedFees = { crypto, associate };
+  });
+
+  test("builds optimistic operation for token association", async () => {
+    const mockedAccount = getMockedAccount();
+    const mockedToken = getMockedTokenCurrency();
+    const mockedTransaction = getMockedTransaction({
+      amount: new BigNumber(0),
+      recipient: "0.0.1234",
+      properties: {
+        name: "tokenAssociate",
+        token: mockedToken,
+      },
+    });
+
+    const op = await buildOptimisticOperation({
+      account: mockedAccount,
+      transaction: mockedTransaction,
+    });
+
+    expect(op.type).toBe("ASSOCIATE_TOKEN");
+    expect(op.extra).toEqual({ associatedTokenId: mockedToken.contractAddress });
+    expect(op.fee).toEqual(estimatedFees.associate);
+    expect(op.senders).toContain(mockedAccount.freshAddress.toString());
+    expect(op.recipients).toContain("0.0.1234");
+  });
+
+  test("builds optimistic operation for coin", async () => {
+    const mockedAccount = getMockedAccount();
+    const mockedTransaction = getMockedTransaction({
+      amount: new BigNumber(123),
+      recipient: "0.0.5678",
+    });
+
+    const op = await buildOptimisticOperation({
+      account: mockedAccount,
+      transaction: mockedTransaction,
+    });
+
+    expect(op.type).toBe("OUT");
+    expect(op.fee).toEqual(estimatedFees.crypto);
+    expect(op.value).toEqual(new BigNumber(123));
+    expect(op.senders).toContain(mockedAccount.freshAddress.toString());
+    expect(op.recipients).toContain("0.0.5678");
+  });
+
+  test("builds optimistic operation for token", async () => {
+    const mockedTokenCurrency = getMockedTokenCurrency();
+    const tokenAccount = getMockedTokenAccount(mockedTokenCurrency);
+    const parentAccount = getMockedAccount({ subAccounts: [tokenAccount] });
+    const mockedTransaction = getMockedTransaction({
+      subAccountId: tokenAccount.id,
+      amount: new BigNumber(123),
+      recipient: "0.0.9999",
+    });
+
+    const op = await buildOptimisticOperation({
+      account: parentAccount,
+      transaction: mockedTransaction,
+    });
+    const subOp = op.subOperations![0];
+
+    expect(op.type).toBe("FEES");
+    expect(op.subOperations).toHaveLength(1);
+    expect(subOp.type).toBe("OUT");
+    expect(subOp.value).toEqual(new BigNumber(123));
+    expect(subOp.accountId).toBe(tokenAccount.id);
+    expect(subOp.recipients).toContain("0.0.9999");
+  });
+});
diff --git a/libs/coin-modules/coin-hedera/src/bridge/buildOptimisticOperation.ts b/libs/coin-modules/coin-hedera/src/bridge/buildOptimisticOperation.ts
index 9a0da84ea8e..7544c56a9ec 100644
--- a/libs/coin-modules/coin-hedera/src/bridge/buildOptimisticOperation.ts
+++ b/libs/coin-modules/coin-hedera/src/bridge/buildOptimisticOperation.ts
@@ -1,9 +1,44 @@
 import BigNumber from "bignumber.js";
+import invariant from "invariant";
 import type { Account, Operation, OperationType, TokenAccount } from "@ledgerhq/types-live";
 import { encodeOperationId } from "@ledgerhq/coin-framework/operation";
 import { findSubAccountById, isTokenAccount } from "@ledgerhq/coin-framework/account/helpers";
-import type { Transaction } from "../types";
+import type { HederaOperationExtra, Transaction } from "../types";
 import { getEstimatedFees } from "./utils";
+import { isTokenAssociateTransaction } from "../logic";
+
+const buildOptimisticTokenAssociateOperation = async ({
+  account,
+  transaction,
+}: {
+  account: Account;
+  transaction: Transaction;
+}): Promise<Operation> => {
+  invariant(isTokenAssociateTransaction(transaction), "invalid transaction properties");
+
+  const estimatedFee = await getEstimatedFees(account, "TokenAssociate");
+  const value = transaction.amount;
+  const type: OperationType = "ASSOCIATE_TOKEN";
+
+  const operation: Operation = {
+    id: encodeOperationId(account.id, "", type),
+    hash: "",
+    type,
+    value,
+    fee: estimatedFee,
+    blockHash: null,
+    blockHeight: null,
+    senders: [account.freshAddress.toString()],
+    recipients: [transaction.recipient],
+    accountId: account.id,
+    date: new Date(),
+    extra: {
+      associatedTokenId: transaction.properties.token.contractAddress,
+    } satisfies HederaOperationExtra,
+  };
+
+  return operation;
+};
 
 const buildOptimisticCoinOperation = async ({
   account,
@@ -92,7 +127,9 @@ export const buildOptimisticOperation = async ({
   const subAccount = findSubAccountById(account, transaction.subAccountId || "");
   const isTokenTransaction = isTokenAccount(subAccount);
 
-  if (isTokenTransaction) {
+  if (isTokenAssociateTransaction(transaction)) {
+    return buildOptimisticTokenAssociateOperation({ account, transaction });
+  } else if (isTokenTransaction) {
     return buildOptimisticTokenOperation({ account, tokenAccount: subAccount, transaction });
   } else {
     return buildOptimisticCoinOperation({ account, transaction });
diff --git a/libs/coin-modules/coin-hedera/src/bridge/getTransactionStatus.test.ts b/libs/coin-modules/coin-hedera/src/bridge/getTransactionStatus.test.ts
new file mode 100644
index 00000000000..c17c277feba
--- /dev/null
+++ b/libs/coin-modules/coin-hedera/src/bridge/getTransactionStatus.test.ts
@@ -0,0 +1,199 @@
+import BigNumber from "bignumber.js";
+import {
+  InvalidAddress,
+  InvalidAddressBecauseDestinationIsAlsoSource,
+  AmountRequired,
+  NotEnoughBalance,
+  HederaInsufficientFundsForAssociation,
+  HederaRecipientTokenAssociationRequired,
+  HederaRecipientTokenAssociationUnverified,
+} from "@ledgerhq/errors";
+import { getMockedAccount, getMockedTokenAccount } from "../test/fixtures/account";
+import { getMockedTokenCurrency } from "../test/fixtures/currency";
+import { getMockedTransaction } from "../test/fixtures/transaction";
+import { getTransactionStatus } from "./getTransactionStatus";
+import * as utils from "./utils";
+
+describe("getTransactionStatus", () => {
+  const mockedEstimatedFee = new BigNumber(1);
+  const mockedUsdRate = new BigNumber(1);
+  const validRecipientAddress = "0.0.1234567";
+  const invalidRecipientAddress = "invalid_address";
+
+  beforeEach(() => {
+    jest.clearAllMocks();
+
+    jest.spyOn(utils, "getCurrencyToUSDRate").mockResolvedValueOnce(mockedUsdRate);
+    jest.spyOn(utils, "getEstimatedFees").mockResolvedValueOnce(mockedEstimatedFee);
+  });
+
+  test("coin transfer with valid recipient and sufficient balance completes successfully", async () => {
+    const mockedAccount = getMockedAccount({ balance: new BigNumber(1000) });
+    const mockedTransaction = getMockedTransaction({
+      recipient: validRecipientAddress,
+      amount: new BigNumber(100),
+    });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.errors).toEqual({});
+    expect(result.warnings).toEqual({});
+    expect(result.amount).toEqual(new BigNumber(100));
+    expect(result.totalSpent.isGreaterThan(100)).toBe(true);
+  });
+
+  test("token transfer with valid recipient and sufficient balance completes successfully", async () => {
+    jest.spyOn(utils, "checkAccountTokenAssociationStatus").mockResolvedValueOnce(true);
+
+    const tokenCurrency = getMockedTokenCurrency();
+    const tokenAccount = getMockedTokenAccount(tokenCurrency, { balance: new BigNumber(500) });
+    const account = getMockedAccount({ balance: new BigNumber(1000), subAccounts: [tokenAccount] });
+    const transaction = getMockedTransaction({
+      subAccountId: tokenAccount.id,
+      recipient: validRecipientAddress,
+      amount: new BigNumber(200),
+    });
+
+    const result = await getTransactionStatus(account, transaction);
+
+    expect(result.errors).toEqual({});
+    expect(result.warnings).toEqual({});
+    expect(result.amount).toEqual(new BigNumber(200));
+  });
+
+  test("token associate transaction with sufficient USD worth completes successfully", async () => {
+    const mockedTokenCurrency = getMockedTokenCurrency();
+    const mockedAccount = getMockedAccount();
+    const mockedTransaction = getMockedTransaction({
+      properties: {
+        name: "tokenAssociate",
+        token: mockedTokenCurrency,
+      },
+    });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.amount).toEqual(new BigNumber(0));
+    expect(result.errors).toEqual({});
+    expect(result.warnings).toEqual({});
+    expect(result.totalSpent).toEqual(mockedEstimatedFee);
+    expect(result.estimatedFees).toEqual(mockedEstimatedFee);
+  });
+
+  test("adds error for invalid recipient address", async () => {
+    const mockedAccount = getMockedAccount();
+    const mockedTransaction = getMockedTransaction({ recipient: invalidRecipientAddress });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.errors.recipient).toBeInstanceOf(InvalidAddress);
+  });
+
+  test("adds error for self transfers", async () => {
+    const mockedAccount = getMockedAccount();
+    const mockedTransaction = getMockedTransaction({
+      recipient: mockedAccount.freshAddress,
+    });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.errors.recipient).toBeInstanceOf(InvalidAddressBecauseDestinationIsAlsoSource);
+  });
+
+  test("adds error during coin transfer with insufficient balance", async () => {
+    const mockedAccount = getMockedAccount({ balance: new BigNumber(0) });
+    const mockedTransaction = getMockedTransaction({
+      amount: new BigNumber(100),
+      recipient: validRecipientAddress,
+    });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.errors.amount).toBeInstanceOf(NotEnoughBalance);
+  });
+
+  test("adds error if USD balance is too low for token association", async () => {
+    const mockedTokenCurrency = getMockedTokenCurrency();
+    const mockedAccount = getMockedAccount({ balance: new BigNumber(0) });
+    const mockedTransaction = getMockedTransaction({
+      properties: {
+        name: "tokenAssociate",
+        token: mockedTokenCurrency,
+      },
+    });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.errors.insufficientAssociateBalance).toBeInstanceOf(
+      HederaInsufficientFundsForAssociation,
+    );
+  });
+
+  test("adds warning during token transfer if recipient has no token associated", async () => {
+    jest.spyOn(utils, "checkAccountTokenAssociationStatus").mockResolvedValueOnce(false);
+
+    const mockedTokenCurrency = getMockedTokenCurrency();
+    const mockedTokenAccount = getMockedTokenAccount(mockedTokenCurrency);
+    const mockedAccount = getMockedAccount({ subAccounts: [mockedTokenAccount] });
+    const mockedTransaction = getMockedTransaction({
+      subAccountId: mockedTokenAccount.id,
+      recipient: validRecipientAddress,
+    });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.warnings.missingAssociation).toBeInstanceOf(
+      HederaRecipientTokenAssociationRequired,
+    );
+  });
+
+  test("adds warning if token association status can't be verified", async () => {
+    jest
+      .spyOn(utils, "checkAccountTokenAssociationStatus")
+      .mockRejectedValueOnce(new HederaRecipientTokenAssociationUnverified());
+
+    const mockedTokenCurrency = getMockedTokenCurrency();
+    const mockedTokenAccount = getMockedTokenAccount(mockedTokenCurrency);
+    const mockedAccount = getMockedAccount({ subAccounts: [mockedTokenAccount] });
+    const mockedTransaction = getMockedTransaction({
+      subAccountId: mockedTokenAccount.id,
+      recipient: validRecipientAddress,
+    });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.warnings.unverifiedAssociation).toBeInstanceOf(
+      HederaRecipientTokenAssociationUnverified,
+    );
+  });
+
+  test("adds error during token transfer with insufficient balance", async () => {
+    const mockedTokenCurrency = getMockedTokenCurrency();
+    const mockedTokenAccount = getMockedTokenAccount(mockedTokenCurrency, {
+      balance: new BigNumber(0),
+    });
+    const mockedAccount = getMockedAccount({ subAccounts: [mockedTokenAccount] });
+    const mockedTransaction = getMockedTransaction({
+      subAccountId: mockedTokenAccount.id,
+      recipient: validRecipientAddress,
+      amount: new BigNumber(100),
+    });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.errors.amount).toBeInstanceOf(NotEnoughBalance);
+  });
+
+  test("adds error if amount is zero and useAllAmount is false", async () => {
+    const mockedAccount = getMockedAccount();
+    const mockedTransaction = getMockedTransaction({
+      recipient: validRecipientAddress,
+      amount: new BigNumber(0),
+      useAllAmount: false,
+    });
+
+    const result = await getTransactionStatus(mockedAccount, mockedTransaction);
+
+    expect(result.errors.amount).toBeInstanceOf(AmountRequired);
+  });
+});
diff --git a/libs/coin-modules/coin-hedera/src/bridge/getTransactionStatus.ts b/libs/coin-modules/coin-hedera/src/bridge/getTransactionStatus.ts
index eaad481b672..5ef621c7067 100644
--- a/libs/coin-modules/coin-hedera/src/bridge/getTransactionStatus.ts
+++ b/libs/coin-modules/coin-hedera/src/bridge/getTransactionStatus.ts
@@ -1,15 +1,26 @@
+import BigNumber from "bignumber.js";
+import { AccountId } from "@hashgraph/sdk";
 import {
   AmountRequired,
   NotEnoughBalance,
   InvalidAddress,
   InvalidAddressBecauseDestinationIsAlsoSource,
   RecipientRequired,
+  HederaInsufficientFundsForAssociation,
+  HederaRecipientTokenAssociationRequired,
+  HederaRecipientTokenAssociationUnverified,
 } from "@ledgerhq/errors";
-import { AccountId } from "@hashgraph/sdk";
 import type { Account, AccountBridge } from "@ledgerhq/types-live";
-import { calculateAmount, getEstimatedFees } from "./utils";
-import type { HederaOperationType, Transaction, TransactionStatus } from "../types";
 import { findSubAccountById, isTokenAccount } from "@ledgerhq/coin-framework/account";
+import { getEnv } from "@ledgerhq/live-env";
+import { isTokenAssociateTransaction, isTokenAssociationRequired } from "../logic";
+import type { HederaOperationType, Transaction, TransactionStatus } from "../types";
+import {
+  calculateAmount,
+  checkAccountTokenAssociationStatus,
+  getCurrencyToUSDRate,
+  getEstimatedFees,
+} from "./utils";
 
 export const getTransactionStatus: AccountBridge<
   Transaction,
@@ -19,6 +30,34 @@ export const getTransactionStatus: AccountBridge<
   const errors: Record<string, Error> = {};
   const warnings: Record<string, Error> = {};
 
+  if (isTokenAssociateTransaction(transaction)) {
+    const [usdRate, estimatedFees] = await Promise.all([
+      getCurrencyToUSDRate(account.currency),
+      getEstimatedFees(account, "TokenAssociate"),
+    ]);
+
+    const amount = BigNumber(0);
+    const totalSpent = amount.plus(estimatedFees);
+    const hbarBalance = account.balance.dividedBy(10 ** account.currency.units[0].magnitude);
+    const currentWorthInUSD = usdRate ? hbarBalance.multipliedBy(usdRate) : new BigNumber(0);
+    const requiredWorthInUSD = getEnv("HEDERA_TOKEN_ASSOCIATION_MIN_USD");
+    const isAssociationFlow = isTokenAssociationRequired(account, transaction.properties.token);
+
+    if (isAssociationFlow && currentWorthInUSD.isLessThan(requiredWorthInUSD)) {
+      errors.insufficientAssociateBalance = new HederaInsufficientFundsForAssociation("", {
+        requiredWorthInUSD,
+      });
+    }
+
+    return {
+      amount,
+      errors,
+      estimatedFees,
+      totalSpent,
+      warnings,
+    };
+  }
+
   const subAccount = findSubAccountById(account, transaction?.subAccountId || "");
   const isTokenTransaction = isTokenAccount(subAccount);
   const operationType: HederaOperationType = isTokenTransaction
@@ -51,6 +90,21 @@ export const getTransactionStatus: AccountBridge<
   }
 
   if (isTokenTransaction) {
+    if (!errors.recipient) {
+      try {
+        const hasRecipientTokenAssociated = await checkAccountTokenAssociationStatus(
+          transaction.recipient,
+          subAccount.token.contractAddress,
+        );
+
+        if (!hasRecipientTokenAssociated) {
+          warnings.missingAssociation = new HederaRecipientTokenAssociationRequired();
+        }
+      } catch {
+        warnings.unverifiedAssociation = new HederaRecipientTokenAssociationUnverified();
+      }
+    }
+
     if (subAccount.balance.isLessThan(calculatedAmount.totalSpent)) {
       errors.amount = new NotEnoughBalance();
     }
diff --git a/libs/coin-modules/coin-hedera/src/bridge/index.ts b/libs/coin-modules/coin-hedera/src/bridge/index.ts
index 2a74c78ff0a..c31864885f9 100644
--- a/libs/coin-modules/coin-hedera/src/bridge/index.ts
+++ b/libs/coin-modules/coin-hedera/src/bridge/index.ts
@@ -4,19 +4,20 @@ import {
   makeSync,
   updateTransaction,
 } from "@ledgerhq/coin-framework/bridge/jsHelpers";
-import resolver from "../signer/index";
 import getAddressWrapper from "@ledgerhq/coin-framework/bridge/getAddressWrapper";
-import { SignerContext } from "@ledgerhq/coin-framework/signer";
-import type { Account, AccountBridge, CurrencyBridge } from "@ledgerhq/types-live";
-import type { Transaction, TransactionStatus, HederaSigner } from "../types";
-import { getTransactionStatus } from "./getTransactionStatus";
+import type { SignerContext } from "@ledgerhq/coin-framework/signer";
+import type { AccountBridge, CurrencyBridge } from "@ledgerhq/types-live";
+import { broadcast } from "./broadcast";
+import { createTransaction } from "./createTransaction";
 import { estimateMaxSpendable } from "./estimateMaxSpendable";
+import { getTransactionStatus } from "./getTransactionStatus";
 import { prepareTransaction } from "./prepareTransaction";
-import { createTransaction } from "./createTransaction";
-import { getAccountShape, buildIterateResult } from "./synchronisation";
-import { buildSignOperation } from "./signOperation";
-import { broadcast } from "./broadcast";
 import { receive } from "./receive";
+import { buildSignOperation } from "./signOperation";
+import { getAccountShape, buildIterateResult } from "./synchronisation";
+import { assignFromAccountRaw, assignToAccountRaw } from "./serialization";
+import resolver from "../signer/index";
+import type { Transaction, TransactionStatus, HederaSigner, HederaAccount } from "../types";
 
 function buildCurrencyBridge(signerContext: SignerContext<HederaSigner>): CurrencyBridge {
   const getAddress = resolver(signerContext);
@@ -38,7 +39,7 @@ const sync = makeSync({ getAccountShape });
 
 function buildAccountBridge(
   signerContext: SignerContext<HederaSigner>,
-): AccountBridge<Transaction, Account, TransactionStatus> {
+): AccountBridge<Transaction, HederaAccount, TransactionStatus> {
   const getAddress = resolver(signerContext);
 
   const signOperation = buildSignOperation(signerContext);
@@ -49,6 +50,8 @@ function buildAccountBridge(
     updateTransaction,
     getTransactionStatus,
     prepareTransaction,
+    assignToAccountRaw,
+    assignFromAccountRaw,
     sync,
     receive: receive(getAddressWrapper(getAddress)),
     signOperation,
diff --git a/libs/coin-modules/coin-hedera/src/bridge/js-estimateMaxSpendable.integration.test.ts b/libs/coin-modules/coin-hedera/src/bridge/js-estimateMaxSpendable.integration.test.ts
index c6747bf7854..70ce98565f8 100644
--- a/libs/coin-modules/coin-hedera/src/bridge/js-estimateMaxSpendable.integration.test.ts
+++ b/libs/coin-modules/coin-hedera/src/bridge/js-estimateMaxSpendable.integration.test.ts
@@ -1,63 +1,53 @@
 import BigNumber from "bignumber.js";
-import type { Account } from "@ledgerhq/types-live";
 import { createBridges } from ".";
 import { getEstimatedFees } from "./utils";
-
-// Balance is 1 Hbar
-const account: Account = {
-  type: "Account",
-  id: "",
-  seedIdentifier: "",
-  derivationMode: "",
-  index: 0,
-  freshAddress: "",
-  freshAddressPath: "",
-  used: false,
-  balance: new BigNumber(100000000),
-  spendableBalance: new BigNumber(0),
-  creationDate: new Date(),
-  blockHeight: 0,
-  currency: {
-    type: "CryptoCurrency",
-    id: "hedera",
-    managerAppName: "",
-    coinType: 0,
-    scheme: "",
-    color: "",
-    family: "",
-    explorerViews: [],
-    name: "",
-    ticker: "",
-    units: [],
-  },
-  operationsCount: 0,
-  operations: [],
-  pendingOperations: [],
-  lastSyncDate: new Date(),
-  balanceHistoryCache: {
-    HOUR: { latestDate: null, balances: [] },
-    DAY: { latestDate: null, balances: [] },
-    WEEK: { latestDate: null, balances: [] },
-  },
-  swapHistory: [],
-};
+import { getMockedAccount, getMockedTokenAccount } from "../test/fixtures/account";
+import { getMockedTokenCurrency } from "../test/fixtures/currency";
 
 describe("js-estimateMaxSpendable", () => {
   let bridge: ReturnType<typeof createBridges>;
-  let estimatedFees = new BigNumber("150200").multipliedBy(2); // 0.001502 ℏ (as of 2023-03-14)
+  let estimatedFees: Record<"crypto", BigNumber>;
 
   beforeAll(async () => {
     const signer = jest.fn();
     bridge = createBridges(signer);
-    estimatedFees = await getEstimatedFees(account, "CryptoTransfer");
+
+    const mockedAccount = getMockedAccount();
+    const crypto = await getEstimatedFees(mockedAccount, "CryptoTransfer");
+
+    estimatedFees = { crypto };
+  });
+
+  test("estimateMaxSpendable returns balance minus fee", async () => {
+    const mockedAccount = getMockedAccount();
+
+    const result = await bridge.accountBridge.estimateMaxSpendable({
+      account: mockedAccount,
+    });
+
+    expect(result).toEqual(mockedAccount.balance.minus(estimatedFees.crypto));
+  });
+
+  test("estimateMaxSpendable returns 0 if balance < estimated fees", async () => {
+    const mockedAccount = getMockedAccount({ balance: estimatedFees.crypto.minus(1) });
+
+    const result = await bridge.accountBridge.estimateMaxSpendable({
+      account: mockedAccount,
+    });
+
+    expect(result).toEqual(new BigNumber(0));
   });
 
-  test("estimateMaxSpendable", async () => {
+  test("estimateMaxSpendable returns token balance for token account", async () => {
+    const mockedTokenCurrency = getMockedTokenCurrency();
+    const mockedTokenAccount = getMockedTokenAccount(mockedTokenCurrency);
+    const mockedAccount = getMockedAccount({ subAccounts: [mockedTokenAccount] });
+
     const result = await bridge.accountBridge.estimateMaxSpendable({
-      account,
+      account: mockedTokenAccount,
+      parentAccount: mockedAccount,
     });
-    const data = account.balance.minus(estimatedFees);
 
-    expect(result).toEqual(data);
+    expect(result).toEqual(mockedTokenAccount.balance);
   });
 });
diff --git a/libs/coin-modules/coin-hedera/src/bridge/js-transaction.test.ts b/libs/coin-modules/coin-hedera/src/bridge/js-transaction.test.ts
index 996062f8568..9e0724fd86d 100644
--- a/libs/coin-modules/coin-hedera/src/bridge/js-transaction.test.ts
+++ b/libs/coin-modules/coin-hedera/src/bridge/js-transaction.test.ts
@@ -1,83 +1,42 @@
 import BigNumber from "bignumber.js";
-import type { Account } from "@ledgerhq/types-live";
 import { updateTransaction } from "@ledgerhq/coin-framework/bridge/jsHelpers";
-import type { Transaction } from "../types";
 import { createBridges } from ".";
-
-const account: Account = {
-  type: "Account",
-  id: "",
-  seedIdentifier: "",
-  derivationMode: "",
-  index: 0,
-  freshAddress: "",
-  freshAddressPath: "",
-  used: false,
-  balance: new BigNumber(200000),
-  spendableBalance: new BigNumber(0),
-  creationDate: new Date(),
-  blockHeight: 0,
-  currency: {
-    type: "CryptoCurrency",
-    id: "hedera",
-    managerAppName: "",
-    coinType: 0,
-    scheme: "",
-    color: "",
-    family: "",
-    explorerViews: [],
-    name: "",
-    ticker: "",
-    units: [],
-  },
-  operationsCount: 0,
-  operations: [],
-  pendingOperations: [],
-  lastSyncDate: new Date(),
-  balanceHistoryCache: {
-    HOUR: { latestDate: null, balances: [] },
-    DAY: { latestDate: null, balances: [] },
-    WEEK: { latestDate: null, balances: [] },
-  },
-  swapHistory: [],
-};
-
-const transaction: Transaction = {
-  family: "hedera",
-  amount: new BigNumber(0),
-  recipient: "",
-  useAllAmount: false,
-};
+import { getMockedAccount } from "../test/fixtures/account";
+import { getMockedTransaction } from "../test/fixtures/transaction";
+import type { Transaction } from "../types";
 
 describe("js-transaction", () => {
   let bridge: ReturnType<typeof createBridges>;
+  const mockedAccount = getMockedAccount();
+  const mockedTransaction = getMockedTransaction();
 
   beforeAll(() => {
     const signer = jest.fn();
     bridge = createBridges(signer);
   });
+
   test("createTransaction", () => {
-    const data = transaction;
-    const result = bridge.accountBridge.createTransaction(account);
+    const data = mockedTransaction;
+    const result = bridge.accountBridge.createTransaction(mockedAccount);
 
     expect(result).toEqual(data);
   });
 
   test("updateTransaction", () => {
-    const patch = {
+    const patch: Partial<Transaction> = {
       amount: new BigNumber(5),
       recipient: "0.0.3",
       useAllAmount: true,
     };
-    const data = { ...transaction, ...patch };
-    const result = updateTransaction(transaction, patch);
+    const data = { ...mockedTransaction, ...patch };
+    const result = updateTransaction(mockedTransaction, patch);
 
     expect(result).toEqual(data);
   });
 
   test("prepareTransaction", async () => {
-    const data = transaction;
-    const result = await bridge.accountBridge.prepareTransaction(account, transaction);
+    const data = mockedTransaction;
+    const result = await bridge.accountBridge.prepareTransaction(mockedAccount, mockedTransaction);
 
     expect(result).toEqual(data);
   });
diff --git a/libs/coin-modules/coin-hedera/src/bridge/serialization.test.ts b/libs/coin-modules/coin-hedera/src/bridge/serialization.test.ts
new file mode 100644
index 00000000000..0fa6ef53b48
--- /dev/null
+++ b/libs/coin-modules/coin-hedera/src/bridge/serialization.test.ts
@@ -0,0 +1,37 @@
+import {
+  getMockedAccount,
+  getMockedAccountRaw,
+  mockHederaResources,
+  mockHederaResourcesRaw,
+} from "../test/fixtures/account";
+import {
+  assignFromAccountRaw,
+  assignToAccountRaw,
+  fromHederaResourcesRaw,
+  toHederaResourcesRaw,
+} from "./serialization";
+
+const mockedAccount = getMockedAccount();
+const mockedAccountRaw = getMockedAccountRaw();
+
+describe("serialization", () => {
+  test("toHederaResourcesRaw should convert HederaResources to HederaResourcesRaw", () => {
+    const result = toHederaResourcesRaw(mockHederaResources);
+    expect(result).toEqual(mockHederaResourcesRaw);
+  });
+
+  test("fromHederaResourcesRaw should convert HederaResourcesRaw to HederaResources", () => {
+    const result = fromHederaResourcesRaw(mockHederaResourcesRaw);
+    expect(result).toEqual(mockHederaResources);
+  });
+
+  test("assignToAccountRaw should assign HederaResources to AccountRaw", () => {
+    assignToAccountRaw(mockedAccount, mockedAccountRaw);
+    expect(mockedAccountRaw.hederaResources).toBeDefined();
+  });
+
+  test("assignFromAccountRaw should assign HederaResourcesRaw to Account", () => {
+    assignFromAccountRaw(mockedAccountRaw, mockedAccount);
+    expect(mockedAccount.hederaResources).toBeDefined();
+  });
+});
diff --git a/libs/coin-modules/coin-hedera/src/bridge/serialization.ts b/libs/coin-modules/coin-hedera/src/bridge/serialization.ts
new file mode 100644
index 00000000000..21e6dc96805
--- /dev/null
+++ b/libs/coin-modules/coin-hedera/src/bridge/serialization.ts
@@ -0,0 +1,43 @@
+import type { AccountRaw, Account } from "@ledgerhq/types-live";
+import type {
+  HederaAccount,
+  HederaAccountRaw,
+  HederaResources,
+  HederaResourcesRaw,
+} from "../types";
+
+export function toHederaResourcesRaw(resources: HederaResources): HederaResourcesRaw {
+  const { maxAutomaticTokenAssociations, isAutoTokenAssociationEnabled } = resources;
+
+  return {
+    maxAutomaticTokenAssociations,
+    isAutoTokenAssociationEnabled,
+  };
+}
+
+export function fromHederaResourcesRaw(rawResources: HederaResourcesRaw): HederaResources {
+  const { maxAutomaticTokenAssociations, isAutoTokenAssociationEnabled } = rawResources;
+
+  return {
+    maxAutomaticTokenAssociations,
+    isAutoTokenAssociationEnabled,
+  };
+}
+
+export function assignToAccountRaw(account: Account, accountRaw: AccountRaw): void {
+  const hederaAccount = account as HederaAccount;
+  const hederaAccountRaw = accountRaw as HederaAccountRaw;
+
+  if (hederaAccount.hederaResources) {
+    hederaAccountRaw.hederaResources = toHederaResourcesRaw(hederaAccount.hederaResources);
+  }
+}
+
+export function assignFromAccountRaw(accountRaw: AccountRaw, account: Account) {
+  const hederaAccount = account as HederaAccount;
+  const hederaAccountRaw = accountRaw as HederaAccountRaw;
+
+  if (hederaAccountRaw.hederaResources) {
+    hederaAccount.hederaResources = fromHederaResourcesRaw(hederaAccountRaw.hederaResources);
+  }
+}
diff --git a/libs/coin-modules/coin-hedera/src/bridge/synchronisation.ts b/libs/coin-modules/coin-hedera/src/bridge/synchronisation.ts
index 058c7d1b0b0..5b9e0d586e9 100644
--- a/libs/coin-modules/coin-hedera/src/bridge/synchronisation.ts
+++ b/libs/coin-modules/coin-hedera/src/bridge/synchronisation.ts
@@ -2,19 +2,27 @@ import { BigNumber } from "bignumber.js";
 import invariant from "invariant";
 import type { Result } from "@ledgerhq/coin-framework/derivation";
 import { getDerivationScheme, runDerivationScheme } from "@ledgerhq/coin-framework/derivation";
-import type { Account } from "@ledgerhq/types-live";
 import type {
   GetAccountShape,
   IterateResultBuilder,
 } from "@ledgerhq/coin-framework/bridge/jsHelpers";
 import { mergeOps } from "@ledgerhq/coin-framework/bridge/jsHelpers";
 import { encodeAccountId } from "@ledgerhq/coin-framework/account";
-import { getAccount, getAccountsForPublicKey } from "../api/mirror";
+import { getAccount, getAccountsForPublicKey, getAccountTokens } from "../api/mirror";
+import {
+  getSubAccounts,
+  prepareOperations,
+  applyPendingExtras,
+  mergeSubAccounts,
+  getSyncHash,
+} from "./utils";
+import type { HederaAccount } from "../types";
 import { getOperationsForAccount } from "../api/utils";
 
-export const getAccountShape: GetAccountShape<Account> = async (
-  info: any,
-): Promise<Partial<Account>> => {
+export const getAccountShape: GetAccountShape<HederaAccount> = async (
+  info,
+  { blacklistedTokenIds },
+): Promise<Partial<HederaAccount>> => {
   const { currency, derivationMode, address, initialAccount } = info;
 
   invariant(address, "an hedera address is expected");
@@ -27,33 +35,64 @@ export const getAccountShape: GetAccountShape<Account> = async (
     derivationMode,
   });
 
-  // get current account balance
-  const mirrorAccount = await getAccount(address);
-  const accountBalance = new BigNumber(mirrorAccount.balance.balance);
+  // get current account balance and tokens
+  // tokens are fetched with separate requests to get "created_timestamp" for each token
+  // based on this, ASSOCIATE_TOKEN operations can be connected with tokens
+  const [mirrorAccount, mirrorTokens] = await Promise.all([
+    getAccount(address),
+    getAccountTokens(address),
+  ]);
+
+  // we should sync again when new tokens are added or blacklist changes
+  const syncHash = getSyncHash(currency, blacklistedTokenIds);
+  const shouldSyncFromScratch = !initialAccount || syncHash !== initialAccount?.syncHash;
 
-  // grab latest operation's consensus timestamp for incremental sync
   const oldOperations = initialAccount?.operations ?? [];
-  const latestOperationTimestamp = oldOperations[0]
-    ? new BigNumber(Math.floor(oldOperations[0].date.getTime() / 1000))
-    : null;
+  const pendingOperations = initialAccount?.pendingOperations ?? [];
 
-  // merge new operations w/ previously synced ones
-  const newOperations = await getOperationsForAccount(
+  // grab latest operation's consensus timestamp for incremental sync
+  const latestOperationTimestamp =
+    !shouldSyncFromScratch && oldOperations[0]
+      ? new BigNumber(Math.floor(oldOperations[0].date.getTime() / 1000))
+      : null;
+  const latestAccountOperations = await getOperationsForAccount(
     liveAccountId,
     address,
     latestOperationTimestamp ? latestOperationTimestamp.toString() : null,
   );
-  const operations = mergeOps(oldOperations, newOperations.coinOperations);
+
+  const newSubAccounts = await getSubAccounts(
+    liveAccountId,
+    latestAccountOperations.tokenOperations,
+    mirrorTokens,
+  );
+  const subAccounts = mergeSubAccounts(initialAccount, newSubAccounts);
+  const newOperations = prepareOperations(
+    latestAccountOperations.coinOperations,
+    latestAccountOperations.tokenOperations,
+    mirrorTokens,
+  );
+  const enrichedNewOperations = applyPendingExtras(newOperations, pendingOperations);
+  const operations = shouldSyncFromScratch
+    ? enrichedNewOperations
+    : mergeOps(oldOperations, enrichedNewOperations);
 
   return {
     id: liveAccountId,
     freshAddress: address,
-    balance: accountBalance,
-    spendableBalance: accountBalance,
+    syncHash,
+    lastSyncDate: new Date(),
+    balance: new BigNumber(mirrorAccount.balance.balance),
+    spendableBalance: new BigNumber(mirrorAccount.balance.balance),
     operations,
     // NOTE: there are no "blocks" in hedera
     // Set a value just so that operations are considered confirmed according to isConfirmedOperation
     blockHeight: 10,
+    subAccounts,
+    hederaResources: {
+      maxAutomaticTokenAssociations: mirrorAccount.max_automatic_token_associations,
+      isAutoTokenAssociationEnabled: mirrorAccount.max_automatic_token_associations === -1,
+    },
   };
 };
 
@@ -69,6 +108,7 @@ export const buildIterateResult: IterateResultBuilder = async ({ result: rootRes
     const freshAddressPath = runDerivationScheme(derivationScheme, currency, {
       account: index,
     });
+
     return addresses[index]
       ? ({
           address: addresses[index],
diff --git a/libs/coin-modules/coin-hedera/src/bridge/transaction.test.ts b/libs/coin-modules/coin-hedera/src/bridge/transaction.test.ts
index 64e8e76c14b..d8caa4e8f09 100644
--- a/libs/coin-modules/coin-hedera/src/bridge/transaction.test.ts
+++ b/libs/coin-modules/coin-hedera/src/bridge/transaction.test.ts
@@ -1,82 +1,37 @@
 import BigNumber from "bignumber.js";
-import type { Account } from "@ledgerhq/types-live";
-import type { Transaction, TransactionRaw } from "../types";
 import { formatTransaction, fromTransactionRaw, toTransactionRaw } from "../transaction";
-
-const account: Account = {
-  type: "Account",
-  id: "",
-  seedIdentifier: "",
-  derivationMode: "",
-  index: 0,
-  freshAddress: "",
-  freshAddressPath: "",
-  used: false,
-  balance: new BigNumber(200000),
-  spendableBalance: new BigNumber(0),
-  creationDate: new Date(),
-  blockHeight: 0,
-  currency: {
-    type: "CryptoCurrency",
-    id: "hedera",
-    managerAppName: "",
-    coinType: 0,
-    scheme: "",
-    color: "",
-    family: "",
-    explorerViews: [],
-    name: "",
-    ticker: "",
-    units: [
-      {
-        name: "",
-        code: "",
-        magnitude: 0,
-      },
-    ],
-  },
-  operationsCount: 0,
-  operations: [],
-  pendingOperations: [],
-  lastSyncDate: new Date(),
-  balanceHistoryCache: {
-    HOUR: { latestDate: null, balances: [] },
-    DAY: { latestDate: null, balances: [] },
-    WEEK: { latestDate: null, balances: [] },
-  },
-  swapHistory: [],
-};
-
-const transaction: Transaction = {
-  family: "hedera",
-  amount: new BigNumber(1),
-  recipient: "0.0.3",
-};
-
-const transactionRaw: TransactionRaw = {
-  family: "hedera",
-  amount: "1",
-  recipient: "0.0.3",
-};
+import { getMockedAccount } from "../test/fixtures/account";
+import { getMockedTransaction, getMockedTransactionRaw } from "../test/fixtures/transaction";
 
 describe("transaction", () => {
+  const mockedAccount = getMockedAccount();
+  const mockedTransaction = getMockedTransaction({
+    amount: new BigNumber(100000000),
+    recipient: "0.0.3",
+  });
+  const mockedTransactionRaw = getMockedTransactionRaw({
+    amount: "100000000",
+    recipient: "0.0.3",
+  });
+
   test("formatTransaction", () => {
-    const result = formatTransaction(transaction, account);
-    const string = `SEND 1\nTO 0.0.3`;
+    const result = formatTransaction(mockedTransaction, mockedAccount);
+    const nonBreakingSpace = String.fromCharCode(160);
+    const string = `SEND 1${nonBreakingSpace}HBAR\nTO 0.0.3`;
 
     expect(result).toEqual(string);
   });
 
   test("fromTransactionRaw", () => {
-    const result = fromTransactionRaw(transactionRaw);
-    const data = transaction;
+    const result = fromTransactionRaw(mockedTransactionRaw);
+    const data = mockedTransaction;
 
     expect(result).toEqual(data);
   });
 
   test("toTransactionRaw", () => {
-    const result = toTransactionRaw(transaction);
-    const data = transactionRaw;
+    const result = toTransactionRaw(mockedTransaction);
+    const data = mockedTransactionRaw;
 
     expect(result).toEqual(data);
   });
diff --git a/libs/coin-modules/coin-hedera/src/bridge/utils.integration.test.ts b/libs/coin-modules/coin-hedera/src/bridge/utils.integration.test.ts
index 1570b849c5a..ba2582526f9 100644
--- a/libs/coin-modules/coin-hedera/src/bridge/utils.integration.test.ts
+++ b/libs/coin-modules/coin-hedera/src/bridge/utils.integration.test.ts
@@ -1,94 +1,539 @@
-import type { Account } from "@ledgerhq/types-live";
 import BigNumber from "bignumber.js";
-import type { Transaction } from "../types";
-import { calculateAmount, getEstimatedFees } from "./utils";
-
-// Balance is 1 Hbar
-const account: Account = {
-  type: "Account",
-  id: "",
-  seedIdentifier: "",
-  derivationMode: "",
-  index: 0,
-  freshAddress: "",
-  freshAddressPath: "",
-  used: false,
-  balance: new BigNumber(100000000),
-  spendableBalance: new BigNumber(0),
-  creationDate: new Date(),
-  blockHeight: 0,
-  currency: {
-    type: "CryptoCurrency",
-    id: "hedera",
-    managerAppName: "",
-    coinType: 0,
-    scheme: "",
-    color: "",
-    family: "",
-    explorerViews: [],
-    name: "",
-    ticker: "",
-    units: [],
-  },
-  operationsCount: 0,
-  operations: [],
-  pendingOperations: [],
-  lastSyncDate: new Date(),
-  balanceHistoryCache: {
-    HOUR: { latestDate: null, balances: [] },
-    DAY: { latestDate: null, balances: [] },
-    WEEK: { latestDate: null, balances: [] },
-  },
-  swapHistory: [],
-};
-
-const transaction: Transaction = {
-  family: "hedera",
-  amount: new BigNumber(1),
-  recipient: "",
-  useAllAmount: false,
-};
+import cvsApi from "@ledgerhq/live-countervalues/api/index";
+import { encodeTokenAccountId } from "@ledgerhq/coin-framework/account";
+import { getMockedAccount, getMockedTokenAccount } from "../test/fixtures/account";
+import { getMockedTransaction } from "../test/fixtures/transaction";
+import {
+  applyPendingExtras,
+  calculateAmount,
+  checkAccountTokenAssociationStatus,
+  getCurrencyToUSDRate,
+  getEstimatedFees,
+  getSubAccounts,
+  getSyncHash,
+  mergeSubAccounts,
+  patchOperationWithExtra,
+  prepareOperations,
+} from "./utils";
+import {
+  getMockedCurrency,
+  getMockedTokenCurrency,
+  getTokenCurrencyFromCAL,
+} from "../test/fixtures/currency";
+import { getMockedOperation } from "../test/fixtures/operation";
+import { HederaOperationExtra } from "../types";
+import { getAccount } from "../api/mirror";
+import { isValidExtra } from "../logic";
+import { getMockedMirrorToken } from "../test/fixtures/mirror";
+
+jest.mock("../api/mirror");
+jest.mock("@ledgerhq/live-countervalues/api/index");
+
+const mockedFetchLatest = cvsApi.fetchLatest as jest.MockedFunction<typeof cvsApi.fetchLatest>;
+const mockedGetAccount = getAccount as jest.MockedFunction<typeof getAccount>;
 
 describe("utils", () => {
-  let estimatedFees = new BigNumber("150200").multipliedBy(2); // 0.001502 ℏ (as of 2023-03-14)
+  describe("calculateAmount", () => {
+    let estimatedFees: Record<"crypto" | "associate", BigNumber>;
+
+    beforeAll(async () => {
+      const mockedAccount = getMockedAccount();
+      const [crypto, associate] = await Promise.all([
+        getEstimatedFees(mockedAccount, "CryptoTransfer"),
+        getEstimatedFees(mockedAccount, "TokenAssociate"),
+      ]);
+
+      estimatedFees = { crypto, associate };
+    });
+
+    test("HBAR transfer, useAllAmount = true", async () => {
+      const mockedAccount = getMockedAccount();
+      const mockedTransaction = getMockedTransaction({ useAllAmount: true });
+
+      const amount = mockedAccount.balance.minus(estimatedFees.crypto);
+      const totalSpent = amount.plus(estimatedFees.crypto);
+
+      const result = await calculateAmount({
+        account: mockedAccount,
+        transaction: mockedTransaction,
+      });
+
+      expect(result).toEqual({ amount, totalSpent });
+    });
+
+    test("HBAR transfer, useAllAmount = false", async () => {
+      const mockedAccount = getMockedAccount();
+      const mockedTransaction = getMockedTransaction({
+        useAllAmount: false,
+        amount: new BigNumber(1000000),
+      });
+
+      const amount = mockedTransaction.amount;
+      const totalSpent = amount.plus(estimatedFees.crypto);
+
+      const result = await calculateAmount({
+        account: mockedAccount,
+        transaction: mockedTransaction,
+      });
+
+      expect(result).toEqual({ amount, totalSpent });
+    });
+
+    test("token transfer, useAllAmount = true", async () => {
+      const mockedTokenCurrency = getMockedTokenCurrency();
+      const mockedTokenAccount = getMockedTokenAccount(mockedTokenCurrency);
+      const mockedAccount = getMockedAccount({ subAccounts: [mockedTokenAccount] });
+      const mockedTransaction = getMockedTransaction({
+        useAllAmount: true,
+        subAccountId: mockedTokenAccount.id,
+      });
+
+      const amount = mockedTokenAccount.balance;
+      const totalSpent = amount;
+
+      const result = await calculateAmount({
+        account: mockedAccount,
+        transaction: mockedTransaction,
+      });
+
+      expect(result).toEqual({ amount, totalSpent });
+    });
+
+    test("token transfer, useAllAmount = false", async () => {
+      const mockedTokenCurrency = getMockedTokenCurrency();
+      const mockedTokenAccount = getMockedTokenAccount(mockedTokenCurrency);
+      const mockedAccount = getMockedAccount({ subAccounts: [mockedTokenAccount] });
+      const mockedTransaction = getMockedTransaction({
+        useAllAmount: false,
+        amount: new BigNumber(1),
+        subAccountId: mockedTokenAccount.id,
+      });
+
+      const amount = mockedTransaction.amount;
+      const totalSpent = amount;
+
+      const result = await calculateAmount({
+        account: mockedAccount,
+        transaction: mockedTransaction,
+      });
+
+      expect(result).toEqual({ amount, totalSpent });
+    });
+
+    test("token associate operation uses TokenAssociate fee", async () => {
+      const mockedTokenCurrency = getMockedTokenCurrency();
+      const mockedTokenAccount = getMockedTokenAccount(mockedTokenCurrency);
+      const mockedAccount = getMockedAccount({ subAccounts: [mockedTokenAccount] });
+      const mockedTransaction = getMockedTransaction({
+        useAllAmount: false,
+        amount: new BigNumber(1),
+        properties: {
+          name: "tokenAssociate",
+          token: mockedTokenCurrency,
+        },
+      });
+
+      const amount = mockedTransaction.amount;
+      const totalSpent = amount.plus(estimatedFees.associate);
+
+      const result = await calculateAmount({
+        account: mockedAccount,
+        transaction: mockedTransaction,
+      });
+
+      expect(result).toEqual({ amount, totalSpent });
+    });
+  });
+
+  describe("getEstimatedFees", () => {
+    const mockedAccount = getMockedAccount();
+
+    beforeEach(() => {
+      jest.clearAllMocks();
+      // reset LRU cache to make sure all tests receive correct mocks from mockedFetchLatest
+      getCurrencyToUSDRate.clear(mockedAccount.currency.ticker);
+    });
+
+    test("returns estimated fee based on USD rate for CryptoTransfer", async () => {
+      // 1 HBAR = 1 USD
+      const usdRate = 1;
+      mockedFetchLatest.mockResolvedValueOnce([usdRate]);
+
+      const result = await getEstimatedFees(mockedAccount, "CryptoTransfer");
+
+      const baseFeeTinybar = 0.0001 * 10 ** 8;
+      const expectedFee = new BigNumber(baseFeeTinybar)
+        .div(usdRate)
+        .integerValue(BigNumber.ROUND_CEIL)
+        .multipliedBy(2); // safety rate
+
+      expect(result.toFixed()).toBe(expectedFee.toFixed());
+    });
+
+    test("returns estimated fee based on USD rate for TokenTransfer", async () => {
+      // 1 HBAR = 0.5 USD
+      const usdRate = 0.5;
+      mockedFetchLatest.mockResolvedValueOnce([usdRate]);
+
+      const result = await getEstimatedFees(mockedAccount, "TokenTransfer");
+
+      const baseFeeTinybar = 0.001 * 10 ** 8;
+      const expectedFee = new BigNumber(baseFeeTinybar)
+        .div(usdRate)
+        .integerValue(BigNumber.ROUND_CEIL)
+        .multipliedBy(2);
+
+      expect(result.toFixed()).toBe(expectedFee.toFixed());
+    });
+
+    test("returns estimated fee based on USD rate for TokenAssociate", async () => {
+      // 1 HBAR = 2 USD
+      const usdRate = 2;
+      mockedFetchLatest.mockResolvedValueOnce([usdRate]);
+
+      const result = await getEstimatedFees(mockedAccount, "TokenAssociate");
+
+      const baseFeeTinybar = 0.05 * 10 ** 8;
+      const expectedFee = new BigNumber(baseFeeTinybar)
+        .div(usdRate)
+        .integerValue(BigNumber.ROUND_CEIL)
+        .multipliedBy(2);
+
+      expect(result.toFixed()).toBe(expectedFee.toFixed());
+    });
+
+    test("falls back to default estimate when cvs api returns null", async () => {
+      const usdRate = null;
+      mockedFetchLatest.mockResolvedValueOnce([usdRate]);
+
+      const result = await getEstimatedFees(mockedAccount, "CryptoTransfer");
+
+      const expected = new BigNumber("150200").multipliedBy(2);
+      expect(result.toFixed()).toBe(expected.toFixed());
+    });
+
+    test("falls back to default estimate on cvs api failure", async () => {
+      mockedFetchLatest.mockRejectedValueOnce(new Error("Network error"));
+
+      const result = await getEstimatedFees(mockedAccount, "CryptoTransfer");
+
+      const expected = new BigNumber("150200").multipliedBy(2);
+      expect(result.toFixed()).toBe(expected.toFixed());
+    });
+  });
+
+  describe("getSyncHash", () => {
+    const mockedCurrency = getMockedCurrency();
+
+    test("returns a consistent hash for same input", () => {
+      const hash1 = getSyncHash(mockedCurrency, []);
+      const hash2 = getSyncHash(mockedCurrency, []);
+
+      expect(hash2).toBe(hash1);
+    });
+
+    test("produces different hash if blacklistedTokenIds changes", () => {
+      const hash1 = getSyncHash(mockedCurrency, []);
+      const hash2 = getSyncHash(mockedCurrency, ["random_token"]);
 
-  beforeAll(async () => {
-    estimatedFees = await getEstimatedFees(account, "CryptoTransfer");
+      expect(hash1).not.toBe(hash2);
+    });
+  });
+
+  describe("getSubAccounts", () => {
+    test("returns sub account based on operations and mirror tokens", async () => {
+      const firstTokenCurrencyFromCAL = getTokenCurrencyFromCAL(0);
+      const secondTokenCurrencyFromCAL = getTokenCurrencyFromCAL(1);
+      const mockedAccount = getMockedAccount();
+      const mockedMirrorToken1 = getMockedMirrorToken({
+        token_id: firstTokenCurrencyFromCAL.contractAddress,
+        balance: 10,
+      });
+      const mockedMirrorToken2 = getMockedMirrorToken({
+        token_id: secondTokenCurrencyFromCAL.contractAddress,
+        balance: 0,
+      });
+
+      const mockedOperation1 = getMockedOperation({
+        accountId: encodeTokenAccountId(mockedAccount.id, firstTokenCurrencyFromCAL),
+      });
+      const mockedOperation2 = getMockedOperation({
+        accountId: encodeTokenAccountId(mockedAccount.id, secondTokenCurrencyFromCAL),
+      });
+
+      const result = await getSubAccounts(
+        mockedAccount.id,
+        [mockedOperation1, mockedOperation2],
+        [mockedMirrorToken1, mockedMirrorToken2],
+      );
+      const uniqueSubAccountIds = new Set(result.map(sa => sa.id));
+
+      expect(result).toHaveLength(2);
+      expect(result[0].token).toEqual(firstTokenCurrencyFromCAL);
+      expect(result[1].token).toEqual(secondTokenCurrencyFromCAL);
+      expect(result[0].balance).toEqual(new BigNumber(10));
+      expect(result[1].balance).toEqual(new BigNumber(0));
+      expect(result[0].operations).toEqual([mockedOperation1]);
+      expect(result[1].operations).toEqual([mockedOperation2]);
+      expect(uniqueSubAccountIds.size).toBe(result.length);
+    });
+
+    test("ignores operation if token is not listed in CAL", async () => {
+      const mockedTokenCurrency = getMockedTokenCurrency();
+      const mockedAccount = getMockedAccount();
+      const mockedOperation = getMockedOperation({
+        accountId: encodeTokenAccountId(mockedAccount.id, mockedTokenCurrency),
+      });
+
+      const result = await getSubAccounts(mockedAccount.id, [mockedOperation], []);
+
+      expect(result).toHaveLength(0);
+    });
+
+    test("returns sub account for mirror token with no operations yet (e.g. right after association)", async () => {
+      const tokenCurrencyFromCAL = getTokenCurrencyFromCAL(0);
+      const mockedAccount = getMockedAccount();
+      const mockedMirrorToken = getMockedMirrorToken({
+        token_id: tokenCurrencyFromCAL.contractAddress,
+        balance: 42,
+      });
+
+      const result = await getSubAccounts(mockedAccount.id, [], [mockedMirrorToken]);
+
+      expect(result).toHaveLength(1);
+      expect(result[0].token).toEqual(tokenCurrencyFromCAL);
+      expect(result[0].operations).toHaveLength(0);
+      expect(result[0].balance.toString()).toBe("42");
+    });
   });
 
-  test("calculateAmount transaction.useAllAmount = true", async () => {
-    transaction.useAllAmount = true;
+  describe("prepareOperations", () => {
+    const tokenCurrencyFromCAL = getTokenCurrencyFromCAL(0);
+
+    test("links token operation to existing coin operation with matching hash", () => {
+      const mockedTokenAccount = getMockedTokenAccount(tokenCurrencyFromCAL);
+      const mockedCoinOperation = getMockedOperation({ hash: "shared" });
+      const mockedTokenOperation = getMockedOperation({
+        hash: "shared",
+        accountId: encodeTokenAccountId(mockedTokenAccount.parentId, tokenCurrencyFromCAL),
+      });
 
-    const amount = account.balance.minus(estimatedFees);
-    const totalSpent = amount.plus(estimatedFees);
-    const data = {
-      amount,
-      totalSpent,
-    };
+      const result = prepareOperations([mockedCoinOperation], [mockedTokenOperation], []);
 
-    const result = await calculateAmount({
-      account,
-      transaction,
+      expect(result).toHaveLength(1);
+      expect(result[0].subOperations).toEqual([mockedTokenOperation]);
     });
 
-    expect(result).toEqual(data);
+    test("creates NONE coin operation as parent if no coin op with matching hash exists", () => {
+      const mockedTokenAccount = getMockedTokenAccount(tokenCurrencyFromCAL);
+      const mockedOrphanTokenOperation = getMockedOperation({
+        hash: "unknown-hash",
+        accountId: encodeTokenAccountId(mockedTokenAccount.parentId, tokenCurrencyFromCAL),
+      });
+
+      const result = prepareOperations([], [mockedOrphanTokenOperation], []);
+      const noneOp = result.find(op => op.type === "NONE");
+
+      expect(noneOp).toBeDefined();
+      expect(noneOp?.subOperations?.[0]).toEqual(mockedOrphanTokenOperation);
+      expect(noneOp?.hash).toBe("unknown-hash");
+    });
+
+    test("adds associatedTokenId to ASSOCIATE_TOKEN coin operation based on consensusTimestamp", () => {
+      const mockedCoinOperation = getMockedOperation({
+        type: "ASSOCIATE_TOKEN",
+        extra: { consensusTimestamp: "123" },
+      });
+      const mockedMirrorToken = getMockedMirrorToken({
+        token_id: "0.0.1001",
+        created_timestamp: "123",
+      });
+
+      const result = prepareOperations([mockedCoinOperation], [], [mockedMirrorToken]);
+      const extra = isValidExtra(result[0].extra) ? result[0].extra : null;
+
+      expect(extra).toBeDefined();
+      expect(extra?.associatedTokenId).toBe("0.0.1001");
+    });
+
+    test("ignores enrichment of ASSOCIATE_TOKEN operation if consensusTimestamp mismatches", () => {
+      const mockedCoinOperation = getMockedOperation({
+        type: "ASSOCIATE_TOKEN",
+        extra: { consensusTimestamp: "123" },
+      });
+      const mockedMirrorToken = getMockedMirrorToken({
+        token_id: "0.0.1001",
+        created_timestamp: "999",
+      });
+
+      const result = prepareOperations([mockedCoinOperation], [], [mockedMirrorToken]);
+      const extra = isValidExtra(result[0].extra) ? result[0].extra : null;
+
+      expect(extra).toBeDefined();
+      expect(extra?.associatedTokenId).toBeUndefined();
+    });
   });
 
-  test("calculateAmount transaction.useAllAmount = false", async () => {
-    transaction.useAllAmount = false;
+  describe("mergeSubAccounts", () => {
+    test("returns newSubAccounts if no initial account exists", () => {
+      const mockedTokenCurrency1 = getMockedTokenCurrency({ id: "token1" });
+      const mockedTokenCurrency2 = getMockedTokenCurrency({ id: "token2" });
+      const mockedTokenAccount1 = getMockedTokenAccount(mockedTokenCurrency1, { id: "ta1" });
+      const mockedTokenAccount2 = getMockedTokenAccount(mockedTokenCurrency2, { id: "ta2" });
+      const initialAccount = undefined;
+      const newSubAccounts = [mockedTokenAccount1, mockedTokenAccount2];
+
+      const result = mergeSubAccounts(initialAccount, newSubAccounts);
 
-    const amount = transaction.amount;
-    const totalSpent = amount.plus(estimatedFees);
-    const data = {
-      amount,
-      totalSpent,
-    };
+      expect(result).toEqual(newSubAccounts);
+    });
+
+    test("merges operations and updates only changed fields", () => {
+      const mockedTokenCurrency = getMockedTokenCurrency();
+      const existingOperation = getMockedOperation({ id: "op1" });
+      const newOperation = getMockedOperation({ id: "op2" });
+      const newPendingOperation = getMockedOperation({ id: "op3" });
+      const existingTokenAccount = getMockedTokenAccount(mockedTokenCurrency, {
+        id: "tokenaccount",
+        balance: new BigNumber(1000),
+        creationDate: new Date(),
+        operations: [existingOperation],
+        pendingOperations: [],
+      });
+      const updatedTokenAccount = getMockedTokenAccount(mockedTokenCurrency, {
+        id: "tokenaccount",
+        balance: new BigNumber(2000),
+        creationDate: new Date(Date.now() - 24 * 60 * 60 * 1000),
+        operations: [newOperation],
+        pendingOperations: [newPendingOperation],
+      });
+      const mockedAccount = getMockedAccount({ subAccounts: [existingTokenAccount] });
 
-    const result = await calculateAmount({
-      account,
-      transaction,
+      const result = mergeSubAccounts(mockedAccount, [updatedTokenAccount]);
+      const merged = result[0];
+
+      expect(result).toHaveLength(1);
+      expect(merged.creationDate).toEqual(existingTokenAccount.creationDate);
+      expect(merged.balance).toEqual(new BigNumber(2000));
+      expect(merged.pendingOperations.map(op => op.id)).toEqual(["op3"]);
+      expect(merged.operations.map(op => op.id)).toEqual(["op2", "op1"]);
+      expect(merged.operationsCount).toEqual(2);
     });
 
-    expect(result).toEqual(data);
+    test("adds new sub accounts that are not present in initial account", () => {
+      const existingToken = getMockedTokenCurrency({ id: "token1" });
+      const newToken = getMockedTokenCurrency({ id: "token2" });
+      const existingTokenAccount = getMockedTokenAccount(existingToken, { id: "ta1" });
+      const newTokenAccount = getMockedTokenAccount(newToken, { id: "ta2" });
+      const mockedAccount = getMockedAccount({ subAccounts: [existingTokenAccount] });
+
+      const result = mergeSubAccounts(mockedAccount, [existingTokenAccount, newTokenAccount]);
+
+      expect(result.map(sa => sa.id)).toEqual(["ta1", "ta2"]);
+    });
+  });
+
+  describe("applyPendingExtras", () => {
+    test("merges valid extras from pending operations", () => {
+      const opExtra1: HederaOperationExtra = { consensusTimestamp: "1.2.3.4" };
+      const pendingExtra1: HederaOperationExtra = { associatedTokenId: "0.0.1234" };
+
+      const mockedOperation1 = getMockedOperation({ hash: "op1", extra: opExtra1 });
+      const mockedPendingOperation1 = getMockedOperation({ hash: "op1", extra: pendingExtra1 });
+
+      const result = applyPendingExtras([mockedOperation1], [mockedPendingOperation1]);
+
+      expect(result[0].extra).toEqual({
+        ...mockedOperation1.extra,
+        ...mockedPendingOperation1.extra,
+      });
+    });
+
+    test("returns original operation if no matching pending is found", () => {
+      const opExtra: HederaOperationExtra = { consensusTimestamp: "1.2.3.4" };
+      const pendingExtra: HederaOperationExtra = { associatedTokenId: "0.0.1234" };
+
+      const mockedOperation = getMockedOperation({ hash: "unknown", extra: opExtra });
+      const mockedPendingOperation = getMockedOperation({ hash: "op1", extra: pendingExtra });
+
+      const result = applyPendingExtras([mockedOperation], [mockedPendingOperation]);
+      expect(result[0].extra).toEqual(mockedOperation.extra);
+    });
+  });
+
+  describe("patchOperationWithExtra", () => {
+    test("adds extra to operation and nested sub operations", () => {
+      const mockedOperation = getMockedOperation({
+        hash: "parent",
+        extra: {},
+        subOperations: [getMockedOperation({ hash: "sub1", extra: {} })],
+      });
+
+      const extra: HederaOperationExtra = {
+        consensusTimestamp: "12345",
+        associatedTokenId: "0.0.1001",
+      };
+
+      const patched = patchOperationWithExtra(mockedOperation, extra);
+
+      expect(patched.extra).toEqual(extra);
+      expect(patched.subOperations?.[0].extra).toEqual(extra);
+    });
+  });
+
+  describe("checkAccountTokenAssociationStatus", () => {
+    const accountId = "0.0.1234";
+    const tokenId = "0.0.5678";
+
+    beforeEach(() => {
+      jest.clearAllMocks();
+      // reset LRU cache to make sure all tests receive correct mocks from mockedGetAccount
+      checkAccountTokenAssociationStatus.clear(`${accountId}-${tokenId}`);
+    });
+
+    test("returns true if max_automatic_token_associations === -1", async () => {
+      mockedGetAccount.mockResolvedValueOnce({
+        account: accountId,
+        max_automatic_token_associations: -1,
+        balance: {
+          balance: 0,
+          timestamp: "",
+          tokens: [],
+        },
+      });
+
+      const result = await checkAccountTokenAssociationStatus(accountId, tokenId);
+      expect(result).toBe(true);
+    });
+
+    test("returns true if token is already associated", async () => {
+      mockedGetAccount.mockResolvedValueOnce({
+        account: accountId,
+        max_automatic_token_associations: 0,
+        balance: {
+          balance: 1,
+          timestamp: "",
+          tokens: [{ token_id: tokenId, balance: 1 }],
+        },
+      });
+
+      const result = await checkAccountTokenAssociationStatus(accountId, tokenId);
+      expect(result).toBe(true);
+    });
+
+    test("returns false if token is not associated", async () => {
+      mockedGetAccount.mockResolvedValueOnce({
+        account: accountId,
+        max_automatic_token_associations: 0,
+        balance: {
+          balance: 1,
+          timestamp: "",
+          tokens: [{ token_id: "0.0.9999", balance: 1 }],
+        },
+      });
+
+      const result = await checkAccountTokenAssociationStatus(accountId, tokenId);
+      expect(result).toBe(false);
+    });
   });
 });
diff --git a/libs/coin-modules/coin-hedera/src/bridge/utils.ts b/libs/coin-modules/coin-hedera/src/bridge/utils.ts
index a3a71656c66..0a7b714b482 100644
--- a/libs/coin-modules/coin-hedera/src/bridge/utils.ts
+++ b/libs/coin-modules/coin-hedera/src/bridge/utils.ts
@@ -21,14 +21,16 @@ import { mergeOps } from "@ledgerhq/coin-framework/bridge/jsHelpers";
 import { makeLRUCache, seconds } from "@ledgerhq/live-network/cache";
 import { estimateMaxSpendable } from "./estimateMaxSpendable";
 import type { HederaOperationType, HederaOperationExtra, Transaction } from "../types";
+import { getAccount } from "../api/mirror";
 import type { HederaMirrorToken } from "../api/types";
-import { isValidExtra } from "../logic";
+import { isTokenAssociateTransaction, isValidExtra } from "../logic";
 
 const ESTIMATED_FEE_SAFETY_RATE = 2;
 const TINYBAR_SCALE = 8;
 const BASE_USD_FEE_BY_OPERATION_TYPE: Record<HederaOperationType, number> = {
   CryptoTransfer: 0.0001 * 10 ** TINYBAR_SCALE,
   TokenTransfer: 0.001 * 10 ** TINYBAR_SCALE,
+  TokenAssociate: 0.05 * 10 ** TINYBAR_SCALE,
 } as const;
 
 // note: this is currently called frequently by getTransactionStatus; LRU cache prevents duplicated requests
@@ -133,7 +135,9 @@ export const calculateAmount = ({
     return calculateTokenAmount({ account, tokenAccount: subAccount, transaction });
   }
 
-  const operationType: HederaOperationType = "CryptoTransfer";
+  const operationType: HederaOperationType = isTokenAssociateTransaction(transaction)
+    ? "TokenAssociate"
+    : "CryptoTransfer";
 
   return calculateCoinAmount({ account, transaction, operationType });
 };
@@ -265,9 +269,11 @@ type CoinOperationForOrphanChild = Operation & Required<Pick<Operation, "subOper
 
 // this util handles:
 // - linking sub operations with coin operations, e.g. token transfer with fee payment
+// - if possible, assigning `extra.associatedTokenId = mirrorToken.tokenId` based on operation's consensus timestamp
 export const prepareOperations = (
   coinOperations: Operation[],
   tokenOperations: Operation[],
+  mirrorTokens: HederaMirrorToken[],
 ): Operation[] => {
   const preparedCoinOperations = coinOperations.map(op => ({ ...op }));
   const preparedTokenOperations = tokenOperations.map(op => ({ ...op }));
@@ -299,9 +305,25 @@ export const prepareOperations = (
   };
 
   // loop through coin operations to:
+  // - enrich ASSOCIATE_TOKEN operations with extra.associatedTokenId
   // - prepare a map of hash => operations
   const coinOperationsByHash: Record<string, CoinOperationForOrphanChild[]> = {};
   preparedCoinOperations.forEach(op => {
+    const extra = isValidExtra(op.extra) ? op.extra : null;
+
+    if (op.type === "ASSOCIATE_TOKEN" && extra?.consensusTimestamp) {
+      const relatedMirrorToken = mirrorTokens.find(t => {
+        return t.created_timestamp === extra.consensusTimestamp;
+      });
+
+      if (relatedMirrorToken) {
+        op.extra = {
+          ...extra,
+          associatedTokenId: relatedMirrorToken.token_id,
+        } satisfies HederaOperationExtra;
+      }
+    }
+
     if (!coinOperationsByHash[op.hash]) {
       coinOperationsByHash[op.hash] = [];
     }
@@ -432,3 +454,22 @@ export function patchOperationWithExtra(
     nftOperations: (operation.nftOperations ?? []).map(op => ({ ...op, extra })),
   };
 }
+
+export const checkAccountTokenAssociationStatus = makeLRUCache(
+  async (accountId: string, tokenId: string) => {
+    const mirrorAccount = await getAccount(accountId);
+
+    // auto association is enabled
+    if (mirrorAccount.max_automatic_token_associations === -1) {
+      return true;
+    }
+
+    const isTokenAssociated = mirrorAccount.balance.tokens.some(token => {
+      return token.token_id === tokenId;
+    });
+
+    return isTokenAssociated;
+  },
+  (accountId, tokenId) => `${accountId}-${tokenId}`,
+  seconds(30),
+);
diff --git a/libs/coin-modules/coin-hedera/src/deviceTransactionConfig.ts b/libs/coin-modules/coin-hedera/src/deviceTransactionConfig.ts
index d76217e5e7e..d1636a39a25 100644
--- a/libs/coin-modules/coin-hedera/src/deviceTransactionConfig.ts
+++ b/libs/coin-modules/coin-hedera/src/deviceTransactionConfig.ts
@@ -1,6 +1,7 @@
 import type { AccountLike, Account } from "@ledgerhq/types-live";
 import type { Transaction, TransactionStatus } from "./types";
 import type { CommonDeviceTransactionField as DeviceTransactionField } from "@ledgerhq/coin-framework/transaction/common";
+import { isTokenAssociateTransaction } from "./logic";
 
 function getDeviceTransactionConfig({
   transaction,
@@ -13,25 +14,25 @@ function getDeviceTransactionConfig({
 }): Array<DeviceTransactionField> {
   const fields: Array<DeviceTransactionField> = [];
 
-  if (transaction.useAllAmount) {
-    fields.push({
-      type: "text",
-      label: "Method",
-      value: "Transfer All",
-    });
-  } else {
-    fields.push({
-      type: "text",
-      label: "Method",
-      value: "Transfer",
-    });
-  }
+  const method = (() => {
+    if (isTokenAssociateTransaction(transaction)) return "Associate Token";
+    else if (transaction.useAllAmount) return "Transfer All";
+    else return "Transfer";
+  })();
 
   fields.push({
-    type: "amount",
-    label: "Amount",
+    type: "text",
+    label: "Method",
+    value: method,
   });
 
+  if (!isTokenAssociateTransaction(transaction)) {
+    fields.push({
+      type: "amount",
+      label: "Amount",
+    });
+  }
+
   if (!estimatedFees.isZero()) {
     fields.push({
       type: "fees",
diff --git a/libs/coin-modules/coin-hedera/src/logic.test.ts b/libs/coin-modules/coin-hedera/src/logic.test.ts
index 8123f97439d..8cb273ae8db 100644
--- a/libs/coin-modules/coin-hedera/src/logic.test.ts
+++ b/libs/coin-modules/coin-hedera/src/logic.test.ts
@@ -1,58 +1,139 @@
-import { BigNumber } from "bignumber.js";
-import { Operation } from "@ledgerhq/types-live";
 import { getCryptoCurrencyById } from "@ledgerhq/cryptoassets";
-import { getTransactionExplorer } from "./logic";
-
-describe("getTransactionExplorer", () => {
-  test("Tx explorer URL is converted from hash to consensus timestamp", async () => {
-    const explorerView = getCryptoCurrencyById("hedera").explorerViews[0];
-    expect(explorerView).toBeDefined();
-    expect(explorerView.tx).toBeDefined();
-
-    const mockOperation: Operation = {
-      extra: {
-        consensusTimestamp: "1.2.3.4",
-      },
-      id: "",
-      hash: "",
-      type: "IN",
-      value: new BigNumber(0),
-      fee: new BigNumber(0),
-      senders: [],
-      recipients: [],
-      blockHeight: undefined,
-      blockHash: undefined,
-      accountId: "",
-      date: new Date(),
-    };
-
-    const newUrl = getTransactionExplorer(explorerView, mockOperation);
-    expect(newUrl).toBe("https://hashscan.io/mainnet/transaction/1.2.3.4");
+import {
+  getTransactionExplorer,
+  isAutoTokenAssociationEnabled,
+  isTokenAssociateTransaction,
+  isTokenAssociationRequired,
+  isValidExtra,
+  sendRecipientCanNext,
+} from "./logic";
+import { getMockedAccount, getMockedTokenAccount } from "./test/fixtures/account";
+import { getMockedOperation } from "./test/fixtures/operation";
+import { getMockedTokenCurrency } from "./test/fixtures/currency";
+
+describe("logic", () => {
+  describe("getTransactionExplorer", () => {
+    test("Tx explorer URL is converted from hash to consensus timestamp", async () => {
+      const explorerView = getCryptoCurrencyById("hedera").explorerViews[0];
+      expect(explorerView).toBeDefined();
+      expect(explorerView.tx).toBeDefined();
+
+      const mockedOperation = getMockedOperation({
+        extra: { consensusTimestamp: "1.2.3.4" },
+      });
+
+      const newUrl = getTransactionExplorer(explorerView, mockedOperation);
+      expect(newUrl).toBe("https://hashscan.io/mainnet/transaction/1.2.3.4");
+    });
+
+    test("Tx explorer URL is based on transaction id if consensus timestamp is not available", async () => {
+      const explorerView = getCryptoCurrencyById("hedera").explorerViews[0];
+      expect(explorerView).toBeDefined();
+      expect(explorerView.tx).toBeDefined();
+
+      const mockedOperation = getMockedOperation({
+        extra: { transactionId: "0.0.1234567-123-123" },
+      });
+
+      const newUrl = getTransactionExplorer(explorerView, mockedOperation);
+      expect(newUrl).toBe("https://hashscan.io/mainnet/transaction/0.0.1234567-123-123");
+    });
+  });
+
+  describe("isTokenAssociateTransaction", () => {
+    test("returns correct value based on tx.properties", () => {
+      expect(isTokenAssociateTransaction({ properties: { name: "tokenAssociate" } } as any)).toBe(
+        true,
+      );
+      expect(isTokenAssociateTransaction({ properties: { name: "transfer" } } as any)).toBe(false);
+      expect(isTokenAssociateTransaction({} as any)).toBe(false);
+    });
+  });
+
+  describe("isAutoTokenAssociationEnabled", () => {
+    test("returns value based on isAutoTokenAssociationEnabled flag", () => {
+      expect(
+        isAutoTokenAssociationEnabled({
+          hederaResources: { isAutoTokenAssociationEnabled: true },
+        } as any),
+      ).toBe(true);
+
+      expect(
+        isAutoTokenAssociationEnabled({
+          hederaResources: { isAutoTokenAssociationEnabled: false },
+        } as any),
+      ).toBe(false);
+
+      expect(isAutoTokenAssociationEnabled({} as any)).toBe(false);
+    });
+  });
+
+  describe("isTokenAssociationRequired", () => {
+    test("should return false if token is already associated (token account exists)", () => {
+      const mockedTokenCurrency = getMockedTokenCurrency();
+      const mockedTokenAccount = getMockedTokenAccount(mockedTokenCurrency);
+      const mockedAccount = getMockedAccount({ subAccounts: [mockedTokenAccount] });
+
+      expect(isTokenAssociationRequired(mockedAccount, mockedTokenCurrency)).toBe(false);
+    });
+
+    test("should return false if auto token associations are enabled", () => {
+      const mockedTokenCurrency = getMockedTokenCurrency();
+      const mockedAccount = getMockedAccount({
+        subAccounts: [],
+        hederaResources: {
+          maxAutomaticTokenAssociations: -1,
+          isAutoTokenAssociationEnabled: true,
+        },
+      });
+
+      expect(isTokenAssociationRequired(mockedAccount, mockedTokenCurrency)).toBe(false);
+    });
+
+    test("should return true if token is not associated and auto associations are disabled", () => {
+      const mockedTokenCurrency = getMockedTokenCurrency();
+      const mockedAccount = getMockedAccount({ subAccounts: [] });
+
+      expect(isTokenAssociationRequired(mockedAccount, mockedTokenCurrency)).toBe(true);
+    });
+
+    test("should return false if token is undefined", () => {
+      const mockedAccount = getMockedAccount({ subAccounts: [] });
+
+      expect(isTokenAssociationRequired(mockedAccount, undefined)).toBe(false);
+    });
+
+    test("should return false for legacy accounts without subAccounts or hederaResources", () => {
+      const mockedTokenCurrency = getMockedTokenCurrency();
+      const mockedAccount = getMockedAccount();
+
+      delete mockedAccount.subAccounts;
+      delete mockedAccount.hederaResources;
+
+      expect(isTokenAssociationRequired(mockedAccount, mockedTokenCurrency)).toBe(true);
+    });
+  });
+
+  describe("isValidExtra", () => {
+    test("returns true for object and false for invalid types", () => {
+      expect(isValidExtra({ some: "value" })).toBe(true);
+      expect(isValidExtra(null)).toBe(false);
+      expect(isValidExtra(undefined)).toBe(false);
+      expect(isValidExtra("string")).toBe(false);
+      expect(isValidExtra(123)).toBe(false);
+      expect(isValidExtra([])).toBe(false);
+    });
   });
 
-  test("Tx explorer URL is based on transaction id if consensus timestamp is not available", async () => {
-    const explorerView = getCryptoCurrencyById("hedera").explorerViews[0];
-    expect(explorerView).toBeDefined();
-    expect(explorerView.tx).toBeDefined();
-
-    const mockOperation: Operation = {
-      extra: {
-        transactionId: "0.0.1234567-123-123",
-      },
-      id: "",
-      hash: "",
-      type: "IN",
-      value: new BigNumber(0),
-      fee: new BigNumber(0),
-      senders: [],
-      recipients: [],
-      blockHeight: undefined,
-      blockHash: undefined,
-      accountId: "",
-      date: new Date(),
-    };
-
-    const newUrl = getTransactionExplorer(explorerView, mockOperation);
-    expect(newUrl).toBe("https://hashscan.io/mainnet/transaction/0.0.1234567-123-123");
+  describe("sendRecipientCanNext", () => {
+    test("handles association warnings", () => {
+      expect(sendRecipientCanNext({ warnings: {} } as any)).toBe(true);
+      expect(sendRecipientCanNext({ warnings: { missingAssociation: new Error() } } as any)).toBe(
+        false,
+      );
+      expect(
+        sendRecipientCanNext({ warnings: { unverifiedAssociation: new Error() } } as any),
+      ).toBe(false);
+    });
   });
 });
diff --git a/libs/coin-modules/coin-hedera/src/logic.ts b/libs/coin-modules/coin-hedera/src/logic.ts
index c363a262690..63a79fe850b 100644
--- a/libs/coin-modules/coin-hedera/src/logic.ts
+++ b/libs/coin-modules/coin-hedera/src/logic.ts
@@ -1,6 +1,12 @@
-import type { ExplorerView } from "@ledgerhq/types-cryptoassets";
-import type { Operation } from "@ledgerhq/types-live";
-import type { HederaOperationExtra } from "./types";
+import type { ExplorerView, TokenCurrency } from "@ledgerhq/types-cryptoassets";
+import type { AccountLike, Operation } from "@ledgerhq/types-live";
+import type {
+  HederaAccount,
+  HederaOperationExtra,
+  TokenAssociateProperties,
+  Transaction,
+  TransactionStatus,
+} from "./types";
 
 const getTransactionExplorer = (
   explorerView: ExplorerView | null | undefined,
@@ -14,8 +20,43 @@ const getTransactionExplorer = (
   );
 };
 
+const isTokenAssociateTransaction = (
+  tx: Transaction,
+): tx is Extract<Required<Transaction>, { properties: TokenAssociateProperties }> => {
+  return tx.properties?.name === "tokenAssociate";
+};
+
+const isAutoTokenAssociationEnabled = (account: AccountLike) => {
+  const hederaAccount = "hederaResources" in account ? (account as HederaAccount) : null;
+
+  return hederaAccount?.hederaResources?.isAutoTokenAssociationEnabled ?? false;
+};
+
+const isTokenAssociationRequired = (
+  account: AccountLike,
+  token: TokenCurrency | null | undefined,
+) => {
+  const subAccounts = !!account && "subAccounts" in account ? account.subAccounts ?? [] : [];
+  const isTokenAssociated = subAccounts.some(item => item.token.id === token?.id);
+
+  return !!token && !isTokenAssociated && !isAutoTokenAssociationEnabled(account);
+};
+
 const isValidExtra = (extra: unknown): extra is HederaOperationExtra => {
   return !!extra && typeof extra === "object" && !Array.isArray(extra);
 };
 
-export { getTransactionExplorer, isValidExtra };
+const sendRecipientCanNext = (status: TransactionStatus) => {
+  const { missingAssociation, unverifiedAssociation } = status.warnings;
+
+  return !missingAssociation && !unverifiedAssociation;
+};
+
+export {
+  sendRecipientCanNext,
+  getTransactionExplorer,
+  isValidExtra,
+  isTokenAssociateTransaction,
+  isTokenAssociationRequired,
+  isAutoTokenAssociationEnabled,
+};
diff --git a/libs/coin-modules/coin-hedera/src/test/fixtures/account.ts b/libs/coin-modules/coin-hedera/src/test/fixtures/account.ts
new file mode 100644
index 00000000000..e479754e78e
--- /dev/null
+++ b/libs/coin-modules/coin-hedera/src/test/fixtures/account.ts
@@ -0,0 +1,123 @@
+import BigNumber from "bignumber.js";
+import type {
+  HederaAccount,
+  HederaAccountRaw,
+  HederaResources,
+  HederaResourcesRaw,
+} from "../../types";
+import type { TokenAccount } from "@ledgerhq/types-live";
+import { getMockedCurrency, getMockedTokenCurrency } from "./currency";
+import { TokenCurrency } from "@ledgerhq/types-cryptoassets";
+
+const defaultMockedCurrency = getMockedCurrency();
+const defaultMockedTokenCurrency = getMockedTokenCurrency();
+const defaultMockAccountId = "js:2:hedera:0.0.1234567:hederaBip44";
+const defaultMockTokenAccountId = `${defaultMockAccountId}+${defaultMockedTokenCurrency.id}`;
+const defaultBalance = new BigNumber(100000000);
+const defaultTokenBalance = new BigNumber(10);
+
+export const mockHederaResources: HederaResources = {
+  maxAutomaticTokenAssociations: 0,
+  isAutoTokenAssociationEnabled: false,
+};
+
+export const mockHederaResourcesRaw: HederaResourcesRaw = {
+  maxAutomaticTokenAssociations: 0,
+  isAutoTokenAssociationEnabled: false,
+};
+
+/**
+ * default settings:
+ * - account balance is 1 HBAR
+ * - auto token association is disabled
+ * - subAccounts array is empty (no tokens account are used)
+ */
+export const getMockedAccount = (overrides?: Partial<HederaAccount>): HederaAccount => {
+  return {
+    type: "Account",
+    id: defaultMockAccountId,
+    seedIdentifier: "",
+    derivationMode: "",
+    index: 0,
+    freshAddress: "0.0.12345",
+    freshAddressPath: "44/3030",
+    used: false,
+    balance: defaultBalance,
+    spendableBalance: defaultBalance,
+    creationDate: new Date(),
+    blockHeight: 0,
+    currency: defaultMockedCurrency,
+    operationsCount: 0,
+    operations: [],
+    pendingOperations: [],
+    lastSyncDate: new Date(),
+    balanceHistoryCache: {
+      HOUR: { latestDate: null, balances: [] },
+      DAY: { latestDate: null, balances: [] },
+      WEEK: { latestDate: null, balances: [] },
+    },
+    swapHistory: [],
+    subAccounts: [],
+    hederaResources: mockHederaResources,
+    ...overrides,
+  };
+};
+
+export const getMockedAccountRaw = (overrides?: Partial<HederaAccountRaw>): HederaAccountRaw => {
+  return {
+    id: defaultMockAccountId,
+    seedIdentifier: "",
+    derivationMode: "",
+    index: 0,
+    freshAddress: "0.0.12345",
+    freshAddressPath: "44/3030",
+    used: false,
+    balance: defaultBalance.toString(),
+    spendableBalance: defaultBalance.toString(),
+    creationDate: new Date().toISOString(),
+    blockHeight: 0,
+    currencyId: defaultMockedCurrency.id,
+    operationsCount: 0,
+    operations: [],
+    pendingOperations: [],
+    lastSyncDate: new Date().toISOString(),
+    balanceHistoryCache: {
+      HOUR: { latestDate: null, balances: [] },
+      DAY: { latestDate: null, balances: [] },
+      WEEK: { latestDate: null, balances: [] },
+    },
+    swapHistory: [],
+    subAccounts: [],
+    hederaResources: mockHederaResourcesRaw,
+    ...overrides,
+  };
+};
+
+/**
+ * default settings:
+ * - balance is 10
+ */
+export const getMockedTokenAccount = (
+  token: TokenCurrency,
+  overrides?: Partial<TokenAccount>,
+): TokenAccount => {
+  return {
+    type: "TokenAccount",
+    id: defaultMockTokenAccountId,
+    parentId: defaultMockAccountId,
+    token,
+    balance: defaultTokenBalance,
+    spendableBalance: defaultTokenBalance,
+    creationDate: new Date(),
+    operations: [],
+    operationsCount: 0,
+    pendingOperations: [],
+    swapHistory: [],
+    balanceHistoryCache: {
+      HOUR: { latestDate: null, balances: [] },
+      DAY: { latestDate: null, balances: [] },
+      WEEK: { latestDate: null, balances: [] },
+    },
+    ...overrides,
+  };
+};
diff --git a/libs/coin-modules/coin-hedera/src/test/fixtures/currency.ts b/libs/coin-modules/coin-hedera/src/test/fixtures/currency.ts
new file mode 100644
index 00000000000..74279e38d6f
--- /dev/null
+++ b/libs/coin-modules/coin-hedera/src/test/fixtures/currency.ts
@@ -0,0 +1,66 @@
+import { getCryptoCurrencyById, listTokensForCryptoCurrency } from "@ledgerhq/cryptoassets";
+import type { CryptoCurrency, TokenCurrency } from "@ledgerhq/types-cryptoassets";
+import invariant from "invariant";
+
+export const getMockedCurrency = (overrides?: Partial<CryptoCurrency>): CryptoCurrency => {
+  return {
+    type: "CryptoCurrency",
+    id: "hedera",
+    managerAppName: "Hedera",
+    coinType: 3030,
+    scheme: "hedera",
+    color: "#000",
+    family: "hedera",
+    explorerViews: [
+      {
+        tx: "https://hashscan.io/mainnet/transaction/$hash",
+        address: "https://hashscan.io/mainnet/account/$address",
+      },
+    ],
+    name: "Hedera",
+    ticker: "HBAR",
+    units: [
+      {
+        name: "HBAR",
+        code: "HBAR",
+        magnitude: 8,
+      },
+    ],
+    ...overrides,
+  };
+};
+
+export const getTokenCurrencyFromCAL = (
+  index: number,
+  overrides?: Partial<TokenCurrency>,
+): TokenCurrency => {
+  const hedera = getCryptoCurrencyById("hedera");
+  const token = listTokensForCryptoCurrency(hedera)[index];
+
+  invariant(token, `token not found in CAL list on ${index} position`);
+
+  return {
+    ...token,
+    ...overrides,
+  };
+};
+
+export const getMockedTokenCurrency = (overrides?: Partial<TokenCurrency>): TokenCurrency => {
+  return {
+    id: "hedera/hts/test_0.0.1234567",
+    contractAddress: "0.0.1001",
+    parentCurrency: getMockedCurrency(),
+    tokenType: "hts",
+    name: "Test token",
+    ticker: "TEST",
+    type: "TokenCurrency",
+    units: [
+      {
+        name: "Test",
+        code: "TEST",
+        magnitude: 8,
+      },
+    ],
+    ...overrides,
+  };
+};
diff --git a/libs/coin-modules/coin-hedera/src/test/fixtures/mirror.ts b/libs/coin-modules/coin-hedera/src/test/fixtures/mirror.ts
new file mode 100644
index 00000000000..ea5d87b0ef7
--- /dev/null
+++ b/libs/coin-modules/coin-hedera/src/test/fixtures/mirror.ts
@@ -0,0 +1,14 @@
+import { HederaMirrorToken } from "../../api/types";
+
+export const getMockedMirrorToken = (overrides?: Partial<HederaMirrorToken>): HederaMirrorToken => {
+  return {
+    token_id: "",
+    created_timestamp: "123",
+    automatic_association: false,
+    balance: 0,
+    decimals: 0,
+    freeze_status: "NOT_APPLICABLE",
+    kyc_status: "NOT_APPLICABLE",
+    ...overrides,
+  };
+};
diff --git a/libs/coin-modules/coin-hedera/src/test/fixtures/operation.ts b/libs/coin-modules/coin-hedera/src/test/fixtures/operation.ts
new file mode 100644
index 00000000000..45583f5e49d
--- /dev/null
+++ b/libs/coin-modules/coin-hedera/src/test/fixtures/operation.ts
@@ -0,0 +1,20 @@
+import BigNumber from "bignumber.js";
+import type { HederaOperation } from "../../types";
+
+export const getMockedOperation = (overrides?: Partial<HederaOperation>): HederaOperation => {
+  return {
+    id: "",
+    hash: "",
+    type: "IN",
+    value: new BigNumber(0),
+    fee: new BigNumber(0),
+    senders: [],
+    recipients: [],
+    blockHeight: undefined,
+    blockHash: undefined,
+    accountId: "",
+    date: new Date(),
+    extra: {},
+    ...overrides,
+  };
+};
diff --git a/libs/coin-modules/coin-hedera/src/test/fixtures/transaction.ts b/libs/coin-modules/coin-hedera/src/test/fixtures/transaction.ts
new file mode 100644
index 00000000000..d8a1effef5d
--- /dev/null
+++ b/libs/coin-modules/coin-hedera/src/test/fixtures/transaction.ts
@@ -0,0 +1,22 @@
+import BigNumber from "bignumber.js";
+import type { Transaction, TransactionRaw } from "../../types";
+
+export const getMockedTransaction = (overrides?: Partial<Transaction>): Transaction => {
+  return {
+    family: "hedera",
+    amount: new BigNumber(0),
+    recipient: "",
+    useAllAmount: false,
+    ...overrides,
+  };
+};
+
+export const getMockedTransactionRaw = (overrides?: Partial<TransactionRaw>): TransactionRaw => {
+  return {
+    family: "hedera",
+    amount: "0",
+    recipient: "",
+    useAllAmount: false,
+    ...overrides,
+  };
+};
diff --git a/libs/coin-modules/coin-hedera/src/types/bridge.ts b/libs/coin-modules/coin-hedera/src/types/bridge.ts
index 453b13b0d8e..7e25dcaa0c4 100644
--- a/libs/coin-modules/coin-hedera/src/types/bridge.ts
+++ b/libs/coin-modules/coin-hedera/src/types/bridge.ts
@@ -1,4 +1,7 @@
+import { TokenCurrency } from "@ledgerhq/types-cryptoassets";
 import type {
+  Account,
+  AccountRaw,
   Operation,
   TransactionCommon,
   TransactionCommonRaw,
@@ -14,25 +17,51 @@ export type NetworkInfoRaw = {
   family: "hedera";
 };
 
+export type TokenAssociateProperties = {
+  name: "tokenAssociate";
+  token: TokenCurrency;
+};
+
 export type Transaction = TransactionCommon & {
   family: "hedera";
   memo?: string | undefined;
+  properties?: TokenAssociateProperties;
 };
 
 export type TransactionRaw = TransactionCommonRaw & {
   family: "hedera";
   memo?: string | undefined;
+  properties?: TokenAssociateProperties;
 };
 
 export type TransactionStatus = TransactionStatusCommon;
 
 export type TransactionStatusRaw = TransactionStatusCommonRaw;
 
+export interface HederaResources {
+  maxAutomaticTokenAssociations: number;
+  isAutoTokenAssociationEnabled: boolean;
+}
+
+export interface HederaResourcesRaw {
+  maxAutomaticTokenAssociations: number;
+  isAutoTokenAssociationEnabled: boolean;
+}
+
+export type HederaAccount = Account & {
+  hederaResources?: HederaResources;
+};
+
+export type HederaAccountRaw = AccountRaw & {
+  hederaResources?: HederaResourcesRaw;
+};
+
 export type HederaOperationExtra = {
   consensusTimestamp?: string;
   transactionId?: string;
+  associatedTokenId?: string;
 };
 
-export type HederaOperationType = "CryptoTransfer" | "TokenTransfer";
+export type HederaOperationType = "CryptoTransfer" | "TokenTransfer" | "TokenAssociate";
 
 export type HederaOperation = Operation<HederaOperationExtra>;
diff --git a/libs/env/src/env.ts b/libs/env/src/env.ts
index 464a5330c81..b837754cda9 100644
--- a/libs/env/src/env.ts
+++ b/libs/env/src/env.ts
@@ -217,6 +217,11 @@ const envDefinitions = {
     parser: intParser,
     desc: "solana transaction broadcast confirmation timeout",
   },
+  HEDERA_TOKEN_ASSOCIATION_MIN_USD: {
+    def: 0.05,
+    parser: floatParser,
+    desc: "Minimum USD value an account must hold to perform a token association",
+  },
   API_HEDERA_MIRROR: {
     def: "https://hedera.coin.ledger.com",
     parser: stringParser,
diff --git a/libs/ledger-live-common/src/families/hedera/setup.ts b/libs/ledger-live-common/src/families/hedera/setup.ts
index 79a531c302d..9b5e9f19246 100644
--- a/libs/ledger-live-common/src/families/hedera/setup.ts
+++ b/libs/ledger-live-common/src/families/hedera/setup.ts
@@ -4,17 +4,21 @@ import { createBridges } from "@ledgerhq/coin-hedera/bridge/index";
 import Transport from "@ledgerhq/hw-transport";
 import Hedera from "@ledgerhq/hw-app-hedera";
 import hederaResolver from "@ledgerhq/coin-hedera/signer/index";
-import type { Account, Bridge } from "@ledgerhq/types-live";
+import type {
+  TransactionStatus,
+  Transaction,
+  HederaAccount,
+} from "@ledgerhq/coin-hedera/types/index";
+import type { Bridge } from "@ledgerhq/types-live";
 import makeCliTools from "@ledgerhq/coin-hedera/test/cli";
 import { CreateSigner, createResolver, executeWithSigner } from "../../bridge/setup";
 import { Resolver } from "../../hw/getAddress/types";
-import { TransactionStatus, Transaction } from "@ledgerhq/coin-hedera/types/index";
 
 const createSigner: CreateSigner<Hedera> = (transport: Transport) => {
   return new Hedera(transport);
 };
 
-const bridge: Bridge<Transaction, Account, TransactionStatus> = createBridges(
+const bridge: Bridge<Transaction, HederaAccount, TransactionStatus> = createBridges(
   executeWithSigner(createSigner),
 );
 
diff --git a/libs/ledgerjs/packages/errors/src/index.ts b/libs/ledgerjs/packages/errors/src/index.ts
index 992bce9e2d9..5bd8685485b 100644
--- a/libs/ledgerjs/packages/errors/src/index.ts
+++ b/libs/ledgerjs/packages/errors/src/index.ts
@@ -189,6 +189,17 @@ export const ReplacementTransactionUnderpriced = createCustomErrorClass(
 export const OpReturnDataSizeLimit = createCustomErrorClass("OpReturnSizeLimit");
 export const DustLimit = createCustomErrorClass("DustLimit");
 
+// Hedera family
+export const HederaInsufficientFundsForAssociation = createCustomErrorClass(
+  "HederaInsufficientFundsForAssociation",
+);
+export const HederaRecipientTokenAssociationRequired = createCustomErrorClass(
+  "HederaRecipientTokenAssociationRequired",
+);
+export const HederaRecipientTokenAssociationUnverified = createCustomErrorClass(
+  "HederaRecipientTokenAssociationUnverified",
+);
+
 // Language
 export const LanguageNotFound = createCustomErrorClass("LanguageNotFound");
 
diff --git a/libs/ledgerjs/packages/types-live/src/operation.ts b/libs/ledgerjs/packages/types-live/src/operation.ts
index 9663f1ee683..3fd9efe9742 100644
--- a/libs/ledgerjs/packages/types-live/src/operation.ts
+++ b/libs/ledgerjs/packages/types-live/src/operation.ts
@@ -55,7 +55,9 @@ export type OperationType =
   | "UNSTAKE"
   | "WITHDRAW_UNSTAKED"
   // SOLANA
-  | "BURN";
+  | "BURN"
+  // HEDERA
+  | "ASSOCIATE_TOKEN";
 
 export type OperationExtra = unknown;
 /**
